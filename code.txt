`code.txt`

```

```

`frontend/.env`

```
#REACT_APP_API_BASE_URL=http://localhost:5001/api
# OR for Vite:
VITE_API_BASE_URL=http://localhost:5001/api
VITE_ADMIN_USERNAME=admin@admin.com
VITE_ADMIN_PASSWORD=admin123

```

`frontend/code.txt`

```
`.env`

```
#REACT_APP_API_BASE_URL=http://localhost:5001/api
# OR for Vite:
VITE_API_BASE_URL=http://localhost:5001/api
VITE_ADMIN_USERNAME=admin@admin.com
VITE_ADMIN_PASSWORD=admin123

```

`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI TUTOR</title>

    <script src="https://cdn.jsdelivr.net/npm/d3@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-lib@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-view@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest/dist/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js"></script>
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        if (typeof mermaid !== 'undefined') {
          mermaid.initialize({ startOnLoad: false, theme: 'neutral' }); 
          console.log("Mermaid.js initialized globally with 'neutral' theme via index.html.");
        } else {
          console.error("Mermaid.js not found on window after script load. Mermaid diagrams may not render.");
        }
      });
    </script>

  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

`o.txt`

```

```

`postcss.config.js`

```javascript
export default {
  plugins: {
    'postcss-nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

`src/App.css`

```css
/* #root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
} */

```

`src/App.jsx`

```javascript
// frontend/src/App.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate, useLocation } from 'react-router-dom';
import { useAuth as useRegularAuth } from './hooks/useAuth.jsx';
import { useAppState } from './contexts/AppStateContext.jsx';
import AuthModal from './components/auth/AuthModal.jsx';
import TopNav from './components/layout/TopNav.jsx';
import LeftPanel from './components/layout/LeftPanel.jsx';
import CenterPanel from './components/layout/CenterPanel.jsx';
import RightPanel from './components/layout/RightPanel.jsx';
import LeftCollapsedNav from './components/layout/LeftCollapsedNav.jsx';
import RightCollapsedNav from './components/layout/RightCollapsedNav.jsx';
import ChatHistoryModal from './components/chat/ChatHistoryModal.jsx';
import AdminDashboardPage from './components/admin/AdminDashboardPage.jsx';
import AdminProtectedRoute from './components/admin/AdminProtectedRoute.jsx';
import CodeExecutorPage from './components/tools/CodeExecutorPage.jsx';
import api from './services/api.js';
import toast from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';

function MainAppLayout({ orchestratorStatus }) {
    const { user: regularUser, logout: regularUserLogout } = useRegularAuth();
    const {
        currentSessionId,
        isLeftPanelOpen,
        isRightPanelOpen,
        setSessionId: setGlobalSessionId,
    } = useAppState();
    const [appStateMessages, setAppStateMessages] = useState([]);
    const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false);
    const [isChatProcessing, setIsChatProcessing] = useState(false);

    const handleChatProcessingStatusChange = (isLoading) => {
        setIsChatProcessing(isLoading);
    };

    const handleRegularUserLogout = () => {
        regularUserLogout();
        setGlobalSessionId(null);
    };

    const handleNewChat = async () => {
        try {
            const data = await api.startNewSession(currentSessionId); 
            if (data && data.newSessionId) {
                setGlobalSessionId(data.newSessionId);
                toast.success("New chat started!");
            } else {
                toast.error("Could not start new chat session.");
            }
        } catch (error) {
            toast.error(`Failed to start new chat: ${error.message}`);
        }
    };

    const handleSelectSessionFromHistory = (sessionId) => {
        if (sessionId && sessionId !== currentSessionId) {
            setGlobalSessionId(sessionId);
            toast.success(`Loading session...`);
        }
        setIsHistoryModalOpen(false);
    };

    const { token: regularUserTokenValue } = useRegularAuth();

    const fetchChatHistory = useCallback(async (sid) => {
        if (!sid || !regularUserTokenValue) {
            setAppStateMessages([]);
            return;
        }
        try {
            const sessionData = await api.getChatHistory(sid);
            
            // --- THIS IS THE CORRECTED LOGIC ---
            // The API now returns messages pre-formatted with `sender`.
            // We no longer need to map or transform the data here.
            setAppStateMessages(Array.isArray(sessionData.messages) ? sessionData.messages : []);
            // --- END OF CORRECTION ---

        } catch (error) {
            toast.error(`History load failed: ${error.message}`);
        }
    }, [regularUserTokenValue]);

    useEffect(() => {
        if (currentSessionId && regularUserTokenValue) {
            fetchChatHistory(currentSessionId);
        } else if (!regularUserTokenValue) {
            setAppStateMessages([]);
        }
    }, [currentSessionId, regularUserTokenValue, fetchChatHistory]);

    return (
        <>
            <TopNav 
                user={regularUser} 
                onLogout={handleRegularUserLogout} 
                onNewChat={handleNewChat} 
                onHistoryClick={() => setIsHistoryModalOpen(true)} 
                orchestratorStatus={orchestratorStatus}
                isChatProcessing={isChatProcessing}
            />
            <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark">
                <AnimatePresence mode="wait">
                    {isLeftPanelOpen ? (
                        <motion.aside key="left-panel-main" initial={{ x: '-100%' }} animate={{ x: '0%' }} exit={{ x: '-100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                            <LeftPanel />
                        </motion.aside>
                    ) : ( <LeftCollapsedNav /> )}
                </AnimatePresence>
                <main className={`flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4 transition-all duration-300 ease-in-out ${isLeftPanelOpen ? 'lg:ml-0' : 'lg:ml-16 md:ml-14'} ${isRightPanelOpen ? 'lg:mr-0' : 'lg:mr-16 md:mr-14'}`}>
                    <CenterPanel 
                        messages={appStateMessages} 
                        setMessages={setAppStateMessages} 
                        currentSessionId={currentSessionId}
                        onChatProcessingChange={handleChatProcessingStatusChange}
                    />
                </main>
                <AnimatePresence mode="wait">
                    {isRightPanelOpen ? (
                        <motion.aside key="right-panel-main" initial={{ x: '100%' }} animate={{ x: '0%' }} exit={{ x: '100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="hidden md:flex md:flex-col md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                            <RightPanel />
                        </motion.aside>
                    ) : ( <RightCollapsedNav /> )}
                </AnimatePresence>
            </div>
            <ChatHistoryModal isOpen={isHistoryModalOpen} onClose={() => setIsHistoryModalOpen(false)} onSelectSession={handleSelectSessionFromHistory} />
        </>
    );
}

function App() {
    const { token: regularUserToken, user: regularUser, loading: regularUserAuthLoading, setUser: setRegularUserInAuthContext } = useRegularAuth();
    const { theme, setSessionId: setGlobalSessionId, currentSessionId, isAdminSessionActive } = useAppState();
    const navigate = useNavigate();
    const location = useLocation();
    const [appInitializing, setAppInitializing] = useState(true);
    const [showAuthModal, setShowAuthModal] = useState(false);
    const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });

    useEffect(() => { document.documentElement.className = theme; }, [theme]);
    useEffect(() => { api.getOrchestratorStatus().then(setOrchestratorStatus); }, []);

    useEffect(() => {
        if (isAdminSessionActive) {
            setAppInitializing(false);
            setShowAuthModal(false);
            if (!location.pathname.startsWith('/admin')) {
                navigate('/admin/dashboard', { replace: true });
            }
            return;
        }
        if (regularUserAuthLoading) {
            setAppInitializing(true);
            return;
        }
        setAppInitializing(false);
        if (regularUserToken && regularUser) {
            setShowAuthModal(false);
            if (location.pathname.startsWith('/admin')) {
                navigate('/', { replace: true });
            } else if (!currentSessionId && !location.pathname.startsWith('/tools')) { 
                api.startNewSession(null).then(data => {
                    if (data && data.newSessionId) {
                        setGlobalSessionId(data.newSessionId);
                    }
                });
            }
        } else if (!location.pathname.startsWith('/admin')) {
            setShowAuthModal(true);
        }
    }, [regularUserAuthLoading, regularUserToken, regularUser, isAdminSessionActive, currentSessionId, navigate, location.pathname, setGlobalSessionId]);

    const handleAuthSuccess = (authData) => {
        setShowAuthModal(false);
        if (authData && !authData.isAdminLogin && authData.token) {
            api.startNewSession(null).then(data => {
                if (data && data.newSessionId) {
                    setGlobalSessionId(data.newSessionId);
                }
            });
            if (authData.email && authData._id) {
                setRegularUserInAuthContext({ id: authData._id, email: authData.email });
            }
        }
    };

    if (appInitializing) {
        return (
            <div className="fixed inset-0 flex items-center justify-center bg-background-light dark:bg-background-dark">
                <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary"></div>
            </div>
        );
    }

    return (
        <div className="flex flex-col h-screen overflow-hidden font-sans">
            <AnimatePresence>
                {showAuthModal && <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />}
            </AnimatePresence>
            <Routes>
                 <Route path="/tools/code-executor" element={(regularUserToken && regularUser) ? 
                    <CodeExecutorPage /> : <Navigate to="/" />} 
                />
                <Route path="/admin/dashboard" element={<AdminProtectedRoute><AdminDashboardPage /></AdminProtectedRoute>} />
                <Route path="/*" element={isAdminSessionActive ? <Navigate to="/admin/dashboard" replace /> : (regularUserToken && regularUser) ? <MainAppLayout orchestratorStatus={orchestratorStatus} /> : null} />
            </Routes>
        </div>
    );
}

function AppWrapper() {
    return (
        <Router>
            <App />
        </Router>
    );
}

export default AppWrapper;
```

`src/components/admin/AdminDashboardPage.jsx`

```javascript
// frontend/src/components/admin/AdminDashboardPage.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import * as adminApi from '../../services/adminApi.js';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import ApiKeyRequestManager from './ApiKeyRequestManager.jsx'; // <<< NEW IMPORT
import { UploadCloud, FileText, Trash2, Eye, LogOut, Loader2, AlertTriangle, CheckCircle, RefreshCw } from 'lucide-react';
import toast from 'react-hot-toast';
import { format } from 'date-fns';

// AdminDocumentUpload Component (no changes)
function AdminDocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const fileInputRef = useRef(null);
    const handleFileChange = (e) => { if (isUploading) return; const file = e.target.files && e.target.files[0]; if (file) setSelectedFile(file); else setSelectedFile(null); };
    const handleUpload = async () => {
        if (!selectedFile) { toast.error("Please select a file to upload."); return; }
        setIsUploading(true);
        const toastId = toast.loading(`Uploading "${selectedFile.name}"...`);
        const formData = new FormData();
        formData.append('file', selectedFile);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.uploadAdminDocument(formData, authHeaders);
            toast.success(response.message || `Admin document "${selectedFile.name}" uploaded.`, { id: toastId });
            onUploadSuccess();
            setSelectedFile(null);
            if (fileInputRef.current) fileInputRef.current.value = null;
        } catch (error) {
            toast.error(error.message || `Failed to upload "${selectedFile.name}".`, { id: toastId });
        } finally {
            setIsUploading(false);
        }
    };
    return (
        <div className="card-base p-4 mb-6">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark">Upload New Admin Document</h2>
            <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
                <input type="file" ref={fileInputRef} onChange={handleFileChange} className="input-field flex-grow text-sm p-2.5 min-h-[44px]" accept=".pdf,.docx,.txt,.md" disabled={isUploading} />
                <Button onClick={handleUpload} isLoading={isUploading} disabled={!selectedFile || isUploading} leftIcon={<UploadCloud size={16} />} size="md" className="w-full sm:w-auto !py-2.5">Upload</Button>
            </div>
            {selectedFile && !isUploading && <p className="text-xs mt-2 text-text-muted-light dark:text-text-muted-dark">Selected: {selectedFile.name} ({(selectedFile.size / 1024).toFixed(1)} KB)</p>}
        </div>
    );
}

// Main AdminDashboardPage Component
function AdminDashboardPage() {
    const { setIsAdminSessionActive } = useAppState();
    const navigate = useNavigate();

    const [documents, setDocuments] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState('');
    const [isAnalysisModalOpen, setIsAnalysisModalOpen] = useState(false);
    const [currentDocForModal, setCurrentDocForModal] = useState(null);
    const [analysisContent, setAnalysisContent] = useState(null);
    const [isLoadingAnalysis, setIsLoadingAnalysis] = useState(false);

    // --- NEW STATE FOR KEY REQUESTS ---
    const [keyRequests, setKeyRequests] = useState([]);
    const [isLoadingRequests, setIsLoadingRequests] = useState(true);

    const adminLogoutHandler = () => {
        setIsAdminSessionActive(false);
        toast.success("Admin logged out.");
        navigate('/');
    };

    // --- RENAMED & EXPANDED to fetch all admin data ---
    const fetchAdminData = useCallback(async (showLoadingToast = false) => {
        let toastId;
        if (showLoadingToast) {
            toastId = toast.loading("Refreshing admin data...");
        } else {
            setIsLoading(true);
            setIsLoadingRequests(true);
        }
        setError('');
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const [docsResponse, requestsResponse] = await Promise.all([
                adminApi.getAdminDocuments(authHeaders),
                adminApi.getApiKeyRequests(authHeaders) // New API call
            ]);

            setDocuments(Array.isArray(docsResponse.documents) ? docsResponse.documents : []);
            setKeyRequests(Array.isArray(requestsResponse) ? requestsResponse : []);

            if (showLoadingToast) toast.success("Admin data refreshed.", { id: toastId });
        } catch (err) {
            const errorMessage = err.message || "Failed to fetch admin data.";
            setError(errorMessage);
            if (showLoadingToast) toast.error(errorMessage, { id: toastId });
            else toast.error(errorMessage);
        } finally {
            if (!showLoadingToast) {
                setIsLoading(false);
                setIsLoadingRequests(false);
            }
        }
    }, []);

    useEffect(() => {
        fetchAdminData();
    }, [fetchAdminData]);

    const handleDeleteDocument = async (serverFilename, originalName) => {
        if (!window.confirm(`Are you sure you want to delete admin document "${originalName}"?`)) return;
        const toastId = toast.loading(`Deleting "${originalName}"...`);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            await adminApi.deleteAdminDocument(serverFilename, authHeaders);
            toast.success(`Document "${originalName}" deleted.`, { id: toastId });
            fetchAdminData();
            if (isAnalysisModalOpen && currentDocForModal?.serverFilename === serverFilename) {
                setIsAnalysisModalOpen(false);
            }
        } catch (err) {
            toast.error(err.message || `Failed to delete "${originalName}".`, { id: toastId });
        }
    };

    const handleViewAnalysis = async (doc) => {
        setCurrentDocForModal(doc);
        setAnalysisContent(null);
        setIsAnalysisModalOpen(true);
        setIsLoadingAnalysis(true);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.getAdminDocumentAnalysis(doc.serverFilename, authHeaders);
            setAnalysisContent(response.analysis);
        } catch (err) {
            toast.error(`Failed to load analysis: ${err.message}`);
            setAnalysisContent({ error: `Failed to load analysis: ${err.message}` });
        } finally {
            setIsLoadingAnalysis(false);
        }
    };

    const renderAnalysisModalContent = () => { /* ... (no change to this function) ... */ return null; };
    
    return (
        <div className="min-h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark p-4 sm:p-6">
            <header className="flex items-center justify-between mb-6 pb-3 border-b border-border-light dark:border-border-dark">
                <h1 className="text-2xl font-bold">Admin Dashboard</h1>
                <div className="flex items-center gap-2">
                    <IconButton
                        icon={RefreshCw}
                        onClick={() => fetchAdminData(true)} // Refresh all data
                        title="Refresh Admin Data"
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                    />
                    <Button onClick={adminLogoutHandler} variant="danger" size="sm" leftIcon={<LogOut size={16}/>}>
                        Logout Admin
                    </Button>
                </div>
            </header>

            <AdminDocumentUpload onUploadSuccess={() => fetchAdminData(false)} />
            
            {/* --- NEW API KEY REQUEST MANAGER SECTION --- */}
            {isLoadingRequests ? (
                 <div className="card-base p-4 mt-6 text-center">
                    <Loader2 size={24} className="animate-spin text-primary inline-block mr-2" /> Loading API Key Requests...
                 </div>
            ) : (
                <ApiKeyRequestManager requests={keyRequests} onAction={() => fetchAdminData(false)} />
            )}

            {/* Existing Admin Documents List */}
            <div className="card-base p-0 sm:p-4 mt-6">
                <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">
                    Uploaded Admin Documents
                </h2>
                {isLoading && (
                    <div className="flex items-center justify-center p-6">
                        <Loader2 size={24} className="animate-spin text-primary mr-2" /> Loading documents...
                    </div>
                )}
                {error && (
                    <div className="p-3 my-3 mx-4 sm:mx-0 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                        <AlertTriangle size={18} /> {error}
                        <button onClick={() => fetchAdminData(true)} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
                    </div>
                )}
                {!isLoading && !error && documents.length === 0 && (
                    <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                        No admin documents uploaded yet.
                    </p>
                )}
                {!isLoading && !error && documents.length > 0 && (
                    <div className="overflow-x-auto custom-scrollbar">
                        <table className="w-full text-sm text-left">
                            <thead className="bg-gray-50 dark:bg-gray-800">
                                <tr>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium">Original Name</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium hidden md:table-cell">Uploaded</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium">Analysis Status</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium text-center">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {documents.map((doc) => (
                                    <tr key={doc.serverFilename} className="border-b border-border-light dark:border-border-dark hover:bg-gray-50/50 dark:hover:bg-gray-700/30 transition-colors">
                                        <td className="px-3 sm:px-4 py-2 truncate max-w-[150px] sm:max-w-xs" title={doc.originalName}>{doc.originalName}</td>
                                        <td className="px-3 sm:px-4 py-2 whitespace-nowrap hidden md:table-cell">
                                            {doc.uploadedAt ? format(new Date(doc.uploadedAt), 'MMM d, yyyy HH:mm') : 'N/A'}
                                        </td>
                                        <td className="px-3 sm:px-4 py-2">
                                            {(doc.hasFaq || doc.hasTopics || doc.hasMindmap) ? (
                                                <span className="flex items-center text-green-600 dark:text-green-400 text-xs"><CheckCircle size={14} className="mr-1"/> Generated</span>
                                            ) : (doc.analysisUpdatedAt ? <span className="text-gray-500 dark:text-gray-400 text-xs">Empty/Skipped</span> : <span className="text-yellow-500 dark:text-yellow-400 text-xs">Pending</span>)}
                                        </td>
                                        <td className="px-1 sm:px-4 py-2 text-center whitespace-nowrap">
                                            <IconButton icon={Eye} title="View Analysis" size="sm" variant="ghost" className="text-primary hover:text-primary-dark mr-0.5 sm:mr-1" onClick={() => handleViewAnalysis(doc)} disabled={isLoadingAnalysis && currentDocForModal?.serverFilename === doc.serverFilename} />
                                            <IconButton icon={Trash2} title="Delete Document" size="sm" variant="ghost" className="text-red-500 hover:text-red-700" onClick={() => handleDeleteDocument(doc.serverFilename, doc.originalName)} />
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>

            <Modal isOpen={isAnalysisModalOpen} onClose={() => setIsAnalysisModalOpen(false)} title={`Analysis Results: ${currentDocForModal?.originalName || 'Document'}`} size="2xl">
                {renderAnalysisModalContent()}
            </Modal>
        </div>
    );
}

export default AdminDashboardPage;
```

`src/components/admin/AdminProtectedRoute.jsx`

```javascript
// frontend/src/components/admin/AdminProtectedRoute.jsx
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // Using AppStateContext
import toast from 'react-hot-toast'; // Optional: for a message if redirecting

function AdminProtectedRoute({ children }) { // Accept children for different react-router-dom versions
    const { isAdminSessionActive } = useAppState(); // Get the admin session flag
    const location = useLocation();

    if (!isAdminSessionActive) {
        // If admin session is not active, redirect the user.
        // Redirecting to the main page ('/') is a common approach.
        // The main App component's logic will then likely show the AuthModal
        // if no regular user is logged in either.
        console.log("AdminProtectedRoute: Admin session not active. Redirecting from", location.pathname);
        toast.error("Admin access required. Please log in as admin."); // Optional feedback
        return <Navigate to="/" state={{ from: location }} replace />;
    }

    // If admin session is active, render the child components (the protected route's content)
    return children ? children : <Outlet />; // Outlet is for v6 nested routes, children for direct wrapping
}

export default AdminProtectedRoute;
```

`src/components/admin/ApiKeyRequestManager.jsx`

```javascript
// frontend/src/components/admin/ApiKeyRequestManager.jsx
import React, { useState } from 'react';
import { formatDistanceToNow } from 'date-fns';
import { Check, X, Loader2 } from 'lucide-react';
import toast from 'react-hot-toast';
import * as adminApi from '../../services/adminApi.js';
import IconButton from '../core/IconButton.jsx';

function ApiKeyRequestManager({ requests, onAction }) {
    const [loadingStates, setLoadingStates] = useState({});

    const handleAction = async (userId, action) => {
        setLoadingStates(prev => ({ ...prev, [userId]: true }));
        const toastId = toast.loading(`${action === 'approve' ? 'Approving' : 'Rejecting'} request...`);
        
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            let response;
            if (action === 'approve') {
                response = await adminApi.approveApiKeyRequest(userId, authHeaders);
            } else {
                response = await adminApi.rejectApiKeyRequest(userId, authHeaders);
            }
            toast.success(response.message, { id: toastId });
            onAction(); // Trigger a refresh in the parent component
        } catch (error) {
            toast.error(error.message, { id: toastId });
        } finally {
            setLoadingStates(prev => ({ ...prev, [userId]: false }));
        }
    };

    return (
        <div className="card-base p-0 sm:p-4 mt-6">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">
                Pending API Key Requests
            </h2>
            {requests.length === 0 ? (
                <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                    No pending requests.
                </p>
            ) : (
                <div className="overflow-x-auto custom-scrollbar">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-gray-50 dark:bg-gray-800">
                            <tr>
                                <th className="px-4 py-2.5 font-medium">User Email</th>
                                <th className="px-4 py-2.5 font-medium hidden md:table-cell">Name</th>
                                <th className="px-4 py-2.5 font-medium hidden lg:table-cell">Requested</th>
                                <th className="px-4 py-2.5 font-medium text-center">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {requests.map((req) => (
                                <tr key={req._id} className="border-b border-border-light dark:border-border-dark">
                                    <td className="px-4 py-2 font-mono text-xs" title={req.email}>{req.email}</td>
                                    <td className="px-4 py-2 hidden md:table-cell">{req.profile?.name || 'N/A'}</td>
                                    <td className="px-4 py-2 hidden lg:table-cell" title={new Date(req.createdAt).toLocaleString()}>
                                        {formatDistanceToNow(new Date(req.createdAt), { addSuffix: true })}
                                    </td>
                                    <td className="px-4 py-2 text-center whitespace-nowrap">
                                        {loadingStates[req._id] ? (
                                            <Loader2 size={16} className="animate-spin text-primary inline-block" />
                                        ) : (
                                            <>
                                                <IconButton
                                                    icon={Check}
                                                    title="Approve Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-green-500 hover:text-green-700 dark:hover:text-green-400"
                                                    onClick={() => handleAction(req._id, 'approve')}
                                                />
                                                <IconButton
                                                    icon={X}
                                                    title="Reject Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-red-500 hover:text-red-700 dark:hover:text-red-400"
                                                    onClick={() => handleAction(req._id, 'reject')}
                                                />
                                            </>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}
        </div>
    );
}

export default ApiKeyRequestManager;
```

`src/components/analysis/AnalysisTool.jsx`

```javascript
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js'; // For user documents
import * as adminApi from '../../services/adminApi.js'; // For admin documents
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.", // Added for admin docs
    "Retrieved stored admin analysis." // Added for admin docs
];

// Added isTargetAdminDoc prop
function AnalysisTool({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => { // Reset when selected document changes
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => { // Prism for modal content
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => { // Prism for AI reasoning
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                console.log(`AnalysisToolRunner: Fetching ADMIN analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const authHeaders = adminApi.getFixedAdminAuthHeaders(); // Get admin auth
                // Fetches { originalName, serverFilename, analysis: {faq, topics, mindmap}, analysisUpdatedAt }
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                        // Content for this specific analysis type is empty or null
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}". The admin might not have generated this specific analysis type yet, or it was empty.`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc "${selectedDocumentFilename}".`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title} for "${selectedDocumentFilename}"!`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found or response format invalid for document "${selectedDocumentFilename}".`);
                }
            } else { // User document
                console.log(`AnalysisToolRunner: Requesting USER analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload); // This uses the mock/frontend API for user docs
                // The success toast for user docs is handled inside api.requestAnalysis mock for now.
                // If it were a real API, we might add toast.success here.
                // For consistency with admin path:
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated for "${selectedDocumentFilename}"!`, { id: toastId });
                } else {
                    toast.dismiss(toastId); // Dismiss loading if there was an issue caught below
                }
            }

            // Common response processing
            if (response) {
                if (response.content && response.content.trim() !== "" && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content && (response.content.startsWith("Error:") || response.content.startsWith("Notice:"))) {
                    // If it's an error or notice, display it as content but also set error state
                    setAnalysisContent(response.content); // Display the error/notice in the content area
                    setError(response.content); // Also set the error state for styling/logging
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else { // No content, but not an explicit error/notice in response.content
                    setAnalysisContent(`No content was returned for ${title}.`); // Display this
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content was generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content was generated for ${title}.`);
                }

                if (response.thinking && response.thinking.trim() !== "") {
                    setAiReasoning(response.thinking);
                } else {
                    setAiReasoning(response.content ? "Retrieved analysis. No detailed AI reasoning provided." : "AI reasoning not available.");
                }
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to generate or fetch ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`); // Display error in content area too
            toast.error(errorMessage);
            console.error(`Run ${title} Analysis Error:`, err);
            setIsDropdownOpen(false);
        } finally {
            setIsLoading(false);
        }
    };

    const handleDownloadMindmap = async (format = 'svg') => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    if (saveSvgAsPng) {
                        saveSvgAsPng(svgElement, filename, {
                            scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF'
                        });
                        toast.success("PNG download started!", { id: pngToastId });
                    } else { throw new Error("saveSvgAsPng function not found."); }
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48">
                       <Loader2 size={32} className="animate-spin text-primary" />
                       <p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p>
                   </div>;
        }
        // Display error directly if it's set and no other content (or if content is the error itself)
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center">
                       <MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} />
                   </div>;
        }
        return <div ref={modalAnalysisContentRef}
                    className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed"
                    dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div
                    className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors"
                    onClick={() => setIsSectionOpen(!isSectionOpen)}
                    aria-expanded={isSectionOpen}
                >
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button
                        onClick={handleRunAnalysis} variant="primary" size="sm"
                        className="!px-3 !py-1 text-xs" isLoading={isLoading}
                        disabled={!selectedDocumentFilename || isLoading}
                        title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}
                    >
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton
                        icon={isSectionOpen ? ChevronUp : ChevronDown}
                        onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost"
                        className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"}
                        disabled={isLoading && isSectionOpen}
                    />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div
                        key="tool-section-content" initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.25, ease: "easeInOut" }}
                        className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden"
                    >
                        {isLoading && (
                            <div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn">
                                <Loader2 size={14} className="animate-spin"/> {currentEngagementText}
                            </div>
                        )}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && ( // Show error only if no other content or content is the error
                            <div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1">
                                <AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}
                            </div>
                        )}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div
                                key="analysis-dropdown" initial={{ opacity: 0, y: -10 }}
                                animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }}
                                transition={{ duration: 0.2 }} className="mt-2 space-y-2"
                            >
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md">
                                            <span className="flex items-center gap-1.5 font-medium">
                                                <Sparkles size={14} className="text-accent" /> AI Reasoning
                                            </span>
                                            <ChevronDown size={16} className="group-open:rotate-180 transition-transform" />
                                        </summary>
                                        <div ref={aiReasoningContentRef}
                                            className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md"
                                            dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && (!error || analysisContent !== error) && ( // Show view button if content is not the error message itself
                                     <Button
                                        onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth
                                        leftIcon={<Eye size={14}/>}
                                        className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10"
                                    >View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">
                                {selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}
                            </p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={<>
                        {toolType === 'mindmap' && analysisContent && (
                            <><Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                             <div className="flex-grow"></div></>
                        )}
                        <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs">Close</Button>
                    </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisTool;
```

`src/components/analysis/AnalysisToolRunner.jsx`

```javascript
// frontend/src/components/analysis/AnalysisToolRunner.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js';
import * as adminApi from '../../services/adminApi.js';
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download, FileText, FileBarChart2 } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.",
    "Retrieved stored admin analysis."
];

function AnalysisToolRunner({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');
    const [generatingDocType, setGeneratingDocType] = useState(null);

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => {
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => {
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => {
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                const authHeaders = adminApi.getFixedAdminAuthHeaders();
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}".`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc.`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title}.`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found.`);
                }
            } else {
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload);
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated!`, { id: toastId });
                } else {
                    toast.dismiss(toastId);
                }
            }

            if (response) {
                if (response.content && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content) {
                    setAnalysisContent(response.content);
                    setError(response.content);
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else {
                    setAnalysisContent(`No content was returned for ${title}.`);
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content generated for ${title}.`);
                }
                setAiReasoning(response.thinking || "AI reasoning not available.");
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to process ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };

    const handleGenerateDocument = async (docType) => {
        if (!analysisContent || generatingDocType) {
            return;
        }

        setGeneratingDocType(docType);
        const toastId = toast.loading(`Generating ${docType.toUpperCase()} document...`);

        try {
            const fullMarkdownContent = `## ${title}\n\n**Source Document:** \`${selectedDocumentFilename}\`\n\n---\n\n${analysisContent}`;
            
            const { fileBlob, filename } = await api.generateDocument({
                markdownContent: fullMarkdownContent,
                docType: docType,
                sourceDocumentName: selectedDocumentFilename
            });
            
            const url = window.URL.createObjectURL(fileBlob);
            const link = document.createElement('a');
            link.href = url;
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);

            toast.success(`${docType.toUpperCase()} document downloaded.`, { id: toastId });

        } catch (err) {
            toast.error(`Failed to generate document: ${err.message}`, { id: toastId });
        } finally {
            setGeneratingDocType(null);
        }
    };

    const handleDownloadMindmap = async (format) => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    saveSvgAsPng(svgElement, filename, { scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF' });
                    toast.success("PNG download started!", { id: pngToastId });
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48"><Loader2 size={32} className="animate-spin text-primary" /><p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p></div>;
        }
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center"><MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} /></div>;
        }
        return <div ref={modalAnalysisContentRef} className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed" dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors" onClick={() => setIsSectionOpen(!isSectionOpen)} aria-expanded={isSectionOpen}>
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button onClick={handleRunAnalysis} variant="primary" size="sm" className="!px-3 !py-1 text-xs" isLoading={isLoading} disabled={!selectedDocumentFilename || isLoading} title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}>
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton icon={isSectionOpen ? ChevronUp : ChevronDown} onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost" className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"} disabled={isLoading && isSectionOpen} />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div key="tool-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.25, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        {isLoading && (<div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn"><Loader2 size={14} className="animate-spin"/> {currentEngagementText}</div>)}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && (<div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1"><AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}</div>)}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div key="analysis-dropdown" initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }} transition={{ duration: 0.2 }} className="mt-2 space-y-2">
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md"><span className="flex items-center gap-1.5 font-medium"><Sparkles size={14} className="text-accent" /> AI Reasoning</span><ChevronDown size={16} className="group-open:rotate-180 transition-transform" /></summary>
                                        <div ref={aiReasoningContentRef} className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md" dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && !error && (
                                     <Button onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth leftIcon={<Eye size={14}/>} className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10">View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">{selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}</p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={
                <>
                    {toolType === 'mindmap' && analysisContent && !error && (
                        <Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                    )}
                    
                    {toolType !== 'mindmap' && analysisContent && !error && (
                        <>
                           <Button 
                                onClick={() => handleGenerateDocument('pptx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileBarChart2 size={14}/>}
                                isLoading={generatingDocType === 'pptx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'pptx' ? 'Generating...' : 'Generate PPTX'}
                            </Button>
                           <Button 
                                onClick={() => handleGenerateDocument('docx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileText size={14}/>}
                                isLoading={generatingDocType === 'docx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'docx' ? 'Generating...' : 'Generate DOCX'}
                            </Button>
                        </>
                    )}

                    <div className="flex-grow"></div>
                    <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs" disabled={!!generatingDocType}>
                        Close
                    </Button>
                </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisToolRunner;
```

`src/components/analysis/KnowledgeGraphViewer.jsx`

```javascript
// frontend/src/components/analysis/KnowledgeGraphViewer.jsx
import React, { useEffect, useState, useMemo } from 'react';
import Graph from 'react-vis-network-graph';
import { Loader2, AlertTriangle, ZoomIn, ZoomOut, Maximize } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';
import IconButton from '../core/IconButton.jsx';

const KnowledgeGraphViewer = ({ graphData }) => {
    const { theme } = useTheme();

    // --- FIX START: Add state to hold the network instance ---
    const [network, setNetwork] = useState(null);
    // --- FIX END ---

    // Memoize options to prevent re-renders
    const options = useMemo(() => {
        const isDark = theme === 'dark';
        return {
            layout: {
                hierarchical: {
                    enabled: true,
                    direction: 'UD', // Up-Down
                    sortMethod: 'directed',
                    levelSeparation: 150,
                    nodeSpacing: 200,
                },
            },
            nodes: {
                shape: 'box',
                borderWidth: 1.5,
                font: {
                    color: isDark ? '#E2E8F0' : '#0F172A',
                    size: 14,
                    face: 'Inter',
                },
                color: {
                    border: isDark ? '#4B5563' : '#9CA3AF',
                    background: isDark ? '#1E293B' : '#FFFFFF',
                    highlight: {
                        border: '#3b82f6',
                        background: isDark ? '#2563eb' : '#60a5fa',
                    },
                },
                shadow: true,
            },
            edges: {
                color: {
                    color: isDark ? '#64748B' : '#9CA3AF',
                    highlight: '#3b82f6',
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.7 },
                },
                font: {
                    color: isDark ? '#94A3B8' : '#6B7280',
                    size: 10,
                    align: 'middle',
                    strokeWidth: 2,
                    strokeColor: isDark ? '#1E293B' : '#FFFFFF',
                },
                smooth: {
                    type: 'cubicBezier',
                    forceDirection: 'vertical',
                    roundness: 0.4,
                },
            },
            physics: {
                enabled: true,
                hierarchicalRepulsion: {
                    centralGravity: 0.0,
                    springLength: 100,
                    springConstant: 0.01,
                    nodeDistance: 200,
                    damping: 0.09,
                },
                solver: 'hierarchicalRepulsion',
            },
            interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true,
                tooltipDelay: 200,
            },
            height: '100%',
            width: '100%',
        };
    }, [theme]);

    const formattedGraph = useMemo(() => {
        if (!graphData || !graphData.nodes || !graphData.edges) {
            return { nodes: [], edges: [] };
        }
        const nodes = graphData.nodes.map(node => ({
            id: node.id,
            label: node.id,
            title: `Type: ${node.type}\nParent: ${node.parent || 'N/A'}\n\n${node.description}`,
            color: node.type === 'major' 
                ? { border: '#3b82f6', background: theme === 'dark' ? '#1E3A8A' : '#BFDBFE' } 
                : undefined,
        }));
        const edges = graphData.edges.map(edge => ({
            from: edge.from,
            to: edge.to,
            label: edge.relationship.replace(/_/g, ' '),
        }));
        return { nodes, edges };
    }, [graphData, theme]);

    // --- FIX START: These handlers will now work because 'network' is in state ---
    const handleZoomIn = () => network?.zoomIn();
    const handleZoomOut = () => network?.zoomOut();
    const handleFit = () => network?.fit();
    // --- FIX END ---

    if (!graphData) {
        return (
            <div className="flex items-center justify-center h-full">
                <Loader2 className="animate-spin text-primary mr-2" /> Loading graph data...
            </div>
        );
    }

    if (graphData.error) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-red-500">
                <AlertTriangle size={32} className="mb-2" />
                <p className="font-semibold">Failed to load Knowledge Graph</p>
                <p className="text-xs">{graphData.error}</p>
            </div>
        );
    }
    
    if (formattedGraph.nodes.length === 0) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark">
                <AlertTriangle size={32} className="mb-2" />
                <p>No graph data found for this document.</p>
             </div>
        );
    }

    return (
        <div className="relative w-full h-[70vh] border border-border-light dark:border-border-dark rounded-md bg-gray-50 dark:bg-gray-800/50">
            <Graph
                key={theme}
                graph={formattedGraph}
                options={options}
                // --- FIX START: Use the 'getNetwork' callback to update our state ---
                getNetwork={net => setNetwork(net)}
                // --- FIX END ---
            />
            <div className="absolute top-2 right-2 flex flex-col gap-1.5 bg-surface-light dark:bg-surface-dark p-1.5 rounded-md shadow-lg border border-border-light dark:border-border-dark">
                <IconButton icon={ZoomIn} onClick={handleZoomIn} title="Zoom In" size="sm" />
                <IconButton icon={ZoomOut} onClick={handleZoomOut} title="Zoom Out" size="sm" />
                <IconButton icon={Maximize} onClick={handleFit} title="Fit to View" size="sm" />
            </div>
        </div>
    );
};

export default KnowledgeGraphViewer;
```

`src/components/analysis/MindmapViewer.jsx`

```javascript
// frontend/src/components/analysis/MindmapViewer.jsx
import React, { useEffect, useRef, useState, useImperativeHandle, forwardRef } from 'react';
import toast from 'react-hot-toast';
import { escapeHtml } from '../../utils/helpers.js';

const MindmapViewer = forwardRef(({ mermaidCode }, ref) => {
    const svgContainerRef = useRef(null);
    const [error, setError] = useState(null);
    const [isMermaidReady, setIsMermaidReady] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [uniqueId] = useState(() => `mermaid-graph-${Math.random().toString(36).substr(2, 9)}`);

    useImperativeHandle(ref, () => ({
        getSvgElement: () => {
            return svgContainerRef.current?.querySelector('svg');
        }
    }));

    useEffect(() => {
        if (typeof window.mermaid !== 'undefined') {
            setIsMermaidReady(true);
        } else {
            const intervalId = setInterval(() => {
                if (typeof window.mermaid !== 'undefined') {
                    setIsMermaidReady(true);
                    clearInterval(intervalId);
                }
            }, 100);
            return () => clearInterval(intervalId);
        }
    }, []);

    useEffect(() => {
        if (!isMermaidReady || !mermaidCode || !svgContainerRef.current) {
            if (svgContainerRef.current) svgContainerRef.current.innerHTML = '';
            setError(null);
            setIsLoading(false);
            return;
        }

        const renderMermaidDiagram = async () => {
            setIsLoading(true);
            setError(null);
            if (!svgContainerRef.current) {
                setIsLoading(false);
                return;
            }
            svgContainerRef.current.innerHTML = '<div class="flex justify-center items-center h-full w-full text-sm text-text-muted-light dark:text-text-muted-dark"><div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-primary mr-2"></div>Rendering diagram...</div>';
            
            let codeToRender = mermaidCode.trim();
            
            // --- THIS IS THE FIX ---
            // New, more robust regex to find the diagram code.
            // It looks for a code block that CONTAINS a known diagram type (e.g., 'graph', 'mindmap').
            // It is no longer anchored to the start (^) of the string, so it can find the
            // block even if there's leading garbage or extra backticks from the LLM.
            const fenceRegex = /```(?:mermaid)?\s*([\s\S]*?(?:graph|mindmap|flowchart|sequenceDiagram)[\s\S]*?)\s*```/i;
            const match = codeToRender.match(fenceRegex);

            if (match && match[1]) {
                // If we found a fenced block, use its content.
                codeToRender = match[1].trim();
            } else {
                // Fallback for cases where LLM might forget the fences entirely.
                // We still trim to remove potential whitespace.
                codeToRender = codeToRender.trim();
            }
            // --- END OF FIX ---

            try {
                if (typeof window.mermaid === 'undefined') {
                    throw new Error("Mermaid library failed to load or initialize properly.");
                }

                const { svg, bindFunctions } = await window.mermaid.render(uniqueId, codeToRender);
                
                if (svgContainerRef.current) {
                    svgContainerRef.current.innerHTML = svg;
                    if (bindFunctions) {
                        bindFunctions(svgContainerRef.current);
                    }
                    const svgElement = svgContainerRef.current.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto'; 
                        svgElement.style.maxWidth = '100%'; 
                        svgElement.style.display = 'block';
                    }
                }
            } catch (e) {
                console.error("Error rendering Mermaid diagram with input:", codeToRender, e);
                const errorMsg = e.message || "Failed to render mind map. Invalid Mermaid syntax?";
                setError(errorMsg);
                if (svgContainerRef.current) {
                    const codeSnippet = escapeHtml(codeToRender.substring(0, 200) + (codeToRender.length > 200 ? "..." : ""));
                    svgContainerRef.current.innerHTML = `<div class="p-4 text-center text-red-500 dark:text-red-400 text-xs break-all"><strong>Error rendering:</strong> ${escapeHtml(errorMsg)}<br><strong class='mt-2 block'>Input Code (first 200 chars):</strong><pre class='text-left text-xs bg-gray-100 dark:bg-gray-700 p-2 rounded mt-1 whitespace-pre-wrap'>${codeSnippet}</pre></div>`;
                }
            } finally {
                setIsLoading(false);
            }
        };

        const timer = setTimeout(renderMermaidDiagram, 100); 
        return () => clearTimeout(timer);
        
    }, [mermaidCode, uniqueId, isMermaidReady]);

    if (!isMermaidReady && !error) {
      return <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark text-xs">Waiting for Mermaid.js library...</div>;
    }
    if (error && (!isLoading || (svgContainerRef.current && svgContainerRef.current.innerHTML.includes('Error rendering')))) {
        return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
                {/* Error message will be injected by useEffect's catch block */}
               </div>;
    }
    
    if (isLoading) { 
         return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
            {/* Loading message is set by renderMermaidDiagram's initial innerHTML write */}
         </div>;
    }

    if (!mermaidCode && !error && isMermaidReady) { 
        return <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark p-4">No mind map data to display.</p>;
    }
    
    return (
        <div 
            ref={svgContainerRef} 
            className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md"
        >

        </div>
    );
});

export default MindmapViewer;

```

`src/components/analysis/PodcastGenerator.jsx`

```javascript
// frontend/src/components/analysis/PodcastGenerator.jsx
import React, { useState } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { Headphones, ChevronDown, ChevronUp } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion, AnimatePresence } from 'framer-motion';

function PodcastGenerator({ selectedDocumentFilename }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isLoading, setIsLoading] = useState(false);
    const [podcastPurpose, setPodcastPurpose] = useState('review');
    const [podcastLength, setPodcastLength] = useState('standard');

    const handleGeneratePodcast = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true);
        const toastId = toast.loading("Generating high-quality podcast script & audio. This may take a moment...");
        try {
            const { audioBlob, sourceDocumentName } = await api.generatePodcast({
                analysisContent: `A study session on: ${selectedDocumentFilename}`,
                sourceDocumentName: selectedDocumentFilename,
                podcastOptions: { studyPurpose: podcastPurpose, sessionLength: podcastLength }
            });
            
            toast.success("High-Quality Podcast is ready for download!", { id: toastId, duration: 5000 });

            const url = window.URL.createObjectURL(audioBlob);
            const link = document.createElement('a');
            const safeFilename = sourceDocumentName.split('.')[0].replace(/[^a-zA-Z0-9]/g, '_');
            link.href = url;
            link.setAttribute('download', `AI_Podcast_${safeFilename}.mp3`);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || "Failed to generate podcast.";
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between cursor-pointer" onClick={() => setIsSectionOpen(!isSectionOpen)}>
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark">
                    <Headphones size={16} className="text-accent" />
                    <span className="flex-grow">HQ Podcast Generator</span>
                </div>
                {isSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-3">
                            Generate a high-quality, conversational audio study session from the selected document.
                        </p>
                        <div className="flex flex-col sm:flex-row gap-2 mb-3">
                            <div className="flex-1">
                                <label htmlFor="podcast-purpose" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Purpose</label>
                                <select id="podcast-purpose" value={podcastPurpose} onChange={(e) => setPodcastPurpose(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="review">General Review</option>
                                    <option value="introduction">Introduction</option>
                                    <option value="exam_prep">Exam Prep</option>
                                    <option value="deep_dive">Deep Dive</option>
                                </select>
                            </div>
                            <div className="flex-1">
                                <label htmlFor="podcast-length" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Length</label>
                                <select id="podcast-length" value={podcastLength} onChange={(e) => setPodcastLength(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="quick">Quick (~5-7m)</option>
                                    <option value="standard">Standard (~10-15m)</option>
                                    <option value="comprehensive">Comprehensive (~15-25m)</option>
                                </select>
                            </div>
                        </div>
                        <Button
                            onClick={handleGeneratePodcast}
                            variant="primary"
                            size="sm"
                            fullWidth
                            isLoading={isLoading}
                            disabled={!selectedDocumentFilename || isLoading}
                            title={!selectedDocumentFilename ? "Select a document first" : "Generate Podcast"}
                        >
                           {isLoading ? 'Generating Audio...' : 'Generate High-Quality Podcast'}
                        </Button>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}

export default PodcastGenerator;
// This code defines a React component for generating podcasts from selected documents.

```

`src/components/analysis/RightPanel.jsx`

```javascript
// // frontend/src/components/layout/RightPanel.jsx
// import React, { useState } from 'react';
// import { useAppState } from '../../contexts/AppStateContext';
// import AnalysisTool from '../analysis/AnalysisTool.jsx'; // Added .jsx
// import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
// import IconButton from '../core/IconButton.jsx'; // Added .jsx
// import { motion } from 'framer-motion';

// function RightPanel() {
//     const { setIsRightPanelOpen, selectedDocumentForAnalysis } = useAppState();
//     const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

//     const currentSelectedDocFilename = selectedDocumentForAnalysis?.originalName || null;

//     return (
//         <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
//             <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
//                 <h2 className="text-base font-semibold">Advanced Analyzer</h2>
//                 <IconButton 
//                     icon={PanelRightClose} 
//                     onClick={() => setIsRightPanelOpen(false)} 
//                     title="Close Analyzer Panel"
//                     variant="ghost"
//                     size="sm"
//                     className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
//                 />
//             </div>
            
//             <button 
//                 onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
//                 className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
//             >
//                 <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
//                 {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
//             </button>

//             {isAnalyzerOpen && (
//                 <motion.div 
//                     initial={{ height: 0, opacity: 0 }} 
//                     animate={{ height: 'auto', opacity: 1 }} 
//                     exit={{ height: 0, opacity: 0 }}
//                     transition={{ duration: 0.2, ease: "easeInOut" }}
//                     className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
//                 >
//                     {!currentSelectedDocFilename && (
//                         <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
//                             <p>Select a document from the left panel to enable analysis tools.</p>
//                         </div>
//                     )}
//                     <AnalysisTool toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} />
//                 </motion.div>
//             )}
//         </div>
//     );
// }
// export default RightPanel;











// frontend/src/components/analysis/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
// FIX: Use the new, more capable AnalysisToolRunner component
import AnalysisToolRunner from './AnalysisToolRunner.jsx'; // FIX: Corrected relative import path
import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

function RightPanel() {
    // FIX: Get selectedSubject to determine if the document is an admin document
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    // FIX: Logic corrected to handle filename string directly
    const currentSelectedDocFilename = selectedDocumentForAnalysis || null;
    // FIX: Add logic to determine if the selected document is a "Subject" (admin doc)
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    return (
        <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                <IconButton
                    icon={PanelRightClose}
                    onClick={() => setIsRightPanelOpen(false)}
                    title="Close Analyzer Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>

            <button
                onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
                className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
            >
                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </button>

            {isAnalyzerOpen && (
                <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
                >
                    {!currentSelectedDocFilename && (
                        <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable analysis tools.</p>
                        </div>
                    )}
                    {/* FIX: Use AnalysisToolRunner and pass the isTargetAdminDoc prop */}
                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                </motion.div>
            )}
        </div>
    );
}
export default RightPanel;
```

`src/components/auth/AuthModal.jsx`

```javascript
// frontend/src/components/auth/AuthModal.jsx
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../hooks/useAuth.jsx';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import LLMSelection from './LLMSelection.jsx';
import toast from 'react-hot-toast';
import { LogIn, UserPlus, X, KeyRound, AtSign, AlertCircle, HardDrive, CheckSquare, Square } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';

function AuthModal({ isOpen, onClose }) {
    const { login, signup } = useAuth();
    const { setIsAdminSessionActive, switchLLM: setGlobalLLM, selectedLLM } = useAppState();

    const [isLoginView, setIsLoginView] = useState(true);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [localSelectedLLM, setLocalSelectedLLM] = useState('gemini');
    const [apiKey, setApiKey] = useState('');
    const [ollamaUrl, setOllamaUrl] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [requestKeyFromAdmin, setRequestKeyFromAdmin] = useState(false); // New state for checkbox
    
    const emailRegex = /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/;

    useEffect(() => {
        if (isOpen) {
            setError('');
            setEmail('');
            setPassword('');
            setApiKey('');
            setOllamaUrl('');
            setRequestKeyFromAdmin(false); // Reset checkbox
            setLocalSelectedLLM(selectedLLM || 'gemini');
        } else {
            setIsLoginView(true);
        }
    }, [isOpen, selectedLLM]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');

        if (!emailRegex.test(email) && !(isLoginView && email === (process.env.VITE_ADMIN_USERNAME || 'admin@admin.com'))) {
            return setError("Please enter a valid email address.");
        }
        if (password.length < 6) {
            return setError("Password must be at least 6 characters long.");
        }
        if (!isLoginView && localSelectedLLM === 'gemini' && !apiKey.trim() && !requestKeyFromAdmin) {
            return setError("Gemini API Key is required, or request one from the admin.");
        }
        if (!isLoginView && localSelectedLLM === 'ollama' && !ollamaUrl.trim()) {
            return setError("Ollama URL is required.");
        }
        
        setLoading(true);
        const toastId = toast.loading(isLoginView ? 'Logging in...' : 'Creating account...');

        try {
            if (isLoginView) {
                const authDataResponse = await login({ email, password });
                if (authDataResponse.isAdminLogin) {
                    toast.dismiss(toastId);
                    toast.success("Admin login successful!");
                    setIsAdminSessionActive(true); 
                    onClose({ isAdminLogin: true });
                } else {
                    toast.dismiss(toastId);
                    toast.success(authDataResponse.message || 'Login Successful!');
                    onClose(authDataResponse);
                }
            } else { // Signup logic
                const signupData = {
                    email, password,
                    preferredLlmProvider: localSelectedLLM,
                };

                if (localSelectedLLM === 'gemini') {
                    if (requestKeyFromAdmin) {
                        signupData.requestAdminKey = true;
                    } else {
                        signupData.apiKey = apiKey;
                    }
                } else if (localSelectedLLM === 'ollama') {
                    signupData.ollamaUrl = ollamaUrl;
                }

                const authDataResponse = await signup(signupData);
                setGlobalLLM(localSelectedLLM);
                toast.dismiss(toastId);
                toast.success(authDataResponse.message || 'Signup Successful!');
                onClose(authDataResponse);
            }
        } catch (err) {
            toast.dismiss(toastId);
            const errorMessage = err.response?.data?.message || err.message || `An error occurred.`;
            setError(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm w-full";

    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-fadeIn">
            <motion.div 
                key="auth-modal-content"
                initial={{ opacity: 0, scale: 0.95, y: -10 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.95, y: 10 }}
                className="card-base p-6 sm:p-8 w-full max-w-md"
            >
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl sm:text-2xl font-bold">{isLoginView ? 'Welcome Back' : 'Create Your Account'}</h2>
                    <IconButton icon={X} onClick={() => onClose(null)} variant="ghost" size="sm" title="Close" />
                </div>

                {error && (
                    <div className="mb-4 p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                        <AlertCircle size={16}/>{error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-5">
                    <div className={inputWrapperClass}>
                        <AtSign className={inputIconClass} />
                        <input type="text" id="auth-email" className={inputFieldStyledClass} placeholder="Email Address" value={email} onChange={(e) => setEmail(e.target.value)} required disabled={loading} />
                    </div>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input type="password" id="auth-password" className={inputFieldStyledClass} placeholder="Password (min. 6 characters)" value={password} onChange={(e) => setPassword(e.target.value)} required minLength="6" disabled={loading} />
                    </div>

                    {!isLoginView && (
                        <div className="space-y-4 pt-2 animate-fadeIn">
                            <LLMSelection selectedLLM={localSelectedLLM} onLlmChange={setLocalSelectedLLM} disabled={loading} />
                            
                            <div style={{ display: localSelectedLLM === 'gemini' ? 'block' : 'none' }}>
                                <motion.div key="gemini-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <div className="flex items-center mb-3">
                                        <button
                                            type="button"
                                            onClick={() => setRequestKeyFromAdmin(!requestKeyFromAdmin)}
                                            className="flex items-center text-sm text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors"
                                            disabled={loading}
                                        >
                                            {requestKeyFromAdmin ? <CheckSquare size={16} className="text-primary mr-2" /> : <Square size={16} className="mr-2" />}
                                            Request API Key from Admin
                                        </button>
                                    </div>
                                    <AnimatePresence>
                                        {!requestKeyFromAdmin && (
                                            <motion.div
                                                key="api-key-field"
                                                initial={{ opacity: 0, height: 0 }}
                                                animate={{ opacity: 1, height: 'auto' }}
                                                exit={{ opacity: 0, height: 0 }}
                                                className="overflow-hidden"
                                            >
                                                <label htmlFor="api-key-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Gemini API Key <span className="text-red-500">*</span></label>
                                                <div className={inputWrapperClass}>
                                                    <KeyRound className={inputIconClass} />
                                                    <input type="password" id="api-key-input" className={inputFieldStyledClass} placeholder="Enter your Gemini API Key" value={apiKey} onChange={(e) => setApiKey(e.target.value)} required={!requestKeyFromAdmin && localSelectedLLM === 'gemini'} disabled={loading} />
                                                </div>
                                            </motion.div>
                                        )}
                                    </AnimatePresence>
                                </motion.div>
                            </div>
                        
                            <div style={{ display: localSelectedLLM === 'ollama' ? 'block' : 'none' }}>
                                <motion.div key="ollama-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <label htmlFor="ollama-url-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Ollama URL <span className="text-red-500">*</span></label>
                                    <div className={inputWrapperClass}>
                                        <HardDrive className={inputIconClass} />
                                        <input type="text" id="ollama-url-input" className={inputFieldStyledClass} placeholder="e.g., http://localhost:11434" value={ollamaUrl} onChange={(e) => setOllamaUrl(e.target.value)} required={localSelectedLLM === 'ollama'} disabled={loading} />
                                    </div>
                                </motion.div>
                            </div>
                        </div>
                    )}

                    <Button type="submit" fullWidth isLoading={loading} leftIcon={isLoginView ? <LogIn size={18}/> : <UserPlus size={18}/>} className="py-2.5 !text-base">
                        {isLoginView ? 'Login' : 'Sign Up'}
                    </Button>
                </form>

                <p className="mt-6 text-center text-sm">
                    <button onClick={() => setIsLoginView(!isLoginView)} className="font-medium text-primary hover:underline" disabled={loading}>
                        {isLoginView ? "Don't have an account? Sign Up" : "Already have an account? Login"}
                    </button>
                </p>
            </motion.div>
        </div>
    );
}
export default AuthModal;
```

`src/components/auth/LLMSelection.jsx`

```javascript
// frontend/src/components/auth/LLMSelection.jsx
import React from 'react';
import { HardDrive, Cloud } from 'lucide-react';

function LLMSelection({ selectedLLM, onLlmChange, disabled = false }) {
    const llms = [
        { id: 'ollama', name: 'Ollama LLM', description: 'Local & Private. Requires Ollama running.', Icon: HardDrive },
        { id: 'gemini', name: 'Gemini LLM', description: 'Cloud-based by Google. API Key may be required.', Icon: Cloud },
    ];

    return (
        <div>
            <label className="block text-sm font-medium text-text-light dark:text-text-dark mb-2">
                Choose Your LLM Provider
            </label>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {llms.map((llm) => {
                    const isSelected = selectedLLM === llm.id;
                    return (
                        <button
                            key={llm.id}
                            type="button"
                            onClick={() => onLlmChange(llm.id)}
                            disabled={disabled}
                            className={`p-4 border rounded-lg text-left transition-all duration-150 focus:outline-none group focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-surface-dark focus:ring-primary
                                ${isSelected 
                                    ? 'bg-primary dark:bg-primary border-primary dark:border-primary-dark ring-2 ring-primary dark:ring-primary-dark shadow-lg' 
                                    : 'bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark hover:border-primary-light dark:hover:border-primary-dark hover:shadow-md'
                                }
                                ${disabled ? 'opacity-70 cursor-not-allowed' : ''}
                            `}
                        >
                            <div className="flex items-center mb-1">
                                <llm.Icon size={20} className={`mr-2 transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-blue-100' // High contrast for selected
                                        : 'text-text-muted-light dark:text-text-muted-dark group-hover:text-primary dark:group-hover:text-primary-light'}`} />
                                <span className={`font-semibold transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-white' // High contrast for selected
                                        : 'text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light'}`}>
                                    {llm.name}
                                </span>
                            </div>
                            <p className={`text-xs transition-colors 
                                ${isSelected 
                                    ? 'text-blue-100 dark:text-blue-200' // High contrast for selected
                                    : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                {llm.description}
                            </p>
                        </button>
                    );
                })}
            </div>
        </div>
    );
}

export default LLMSelection;
```

`src/components/chat/ChatHistory.jsx`

```javascript
import React, { useRef, useEffect } from 'react';
import MessageBubble from './MessageBubble';
import { motion, AnimatePresence } from 'framer-motion';

function ChatHistory({ messages, botStatusPlaceholder }) {
    const chatHistoryRef = useRef(null);

    useEffect(() => {
        if (chatHistoryRef.current) {
            chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
        }
    }, [messages, botStatusPlaceholder]);

    return (
        <div ref={chatHistoryRef} className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
            <AnimatePresence initial={false}>
                {messages.map((msg, index) => (
                    <motion.div
                        key={msg.id || `msg-${index}-${msg.timestamp}`}
                        layout
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10, transition: { duration: 0.15 } }}
                        transition={{ duration: 0.3, ease: "easeOut" }}
                    >
                        <MessageBubble
                            id={msg.id || `msg-${index}-${msg.timestamp}`}
                            sender={msg.sender}
                            text={msg.text}
                            thinking={msg.thinking}
                            references={msg.references}
                            timestamp={msg.timestamp}
                            sourcePipeline={msg.source_pipeline}
                        />
                    </motion.div>
                ))}
            </AnimatePresence>

            {botStatusPlaceholder && (
                <motion.div 
                    layout
                    key="bot-status-placeholder"
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.3 }}
                    className="flex justify-start pl-2 mt-2"
                >
                    <div className="max-w-[85%] bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-100 px-4 py-2 rounded-xl shadow-md animate-pulse text-sm">
                        {botStatusPlaceholder}
                    </div>
                </motion.div>
            )}
        </div>
    );
}

export default ChatHistory;

```

`src/components/chat/ChatHistoryModal.jsx`

```javascript
// src/components/chat/ChatHistoryModal.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { X, MessageSquareText, Loader2, AlertTriangle, Trash2 } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import IconButton from '../core/IconButton.jsx';

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString(undefined, { 
            month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' 
        });
    } catch (e) {
        return 'Invalid Date';
    }
};

function ChatHistoryModal({ isOpen, onClose, onSelectSession }) {
    const [sessions, setSessions] = useState([]);
    const [selectedSessionId, setSelectedSessionId] = useState(null);
    const [sessionMessages, setSessionMessages] = useState([]);
    const [loadingSessions, setLoadingSessions] = useState(false);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState('');

    const fetchSessions = useCallback(async () => {
        if (!isOpen) return; 
        setLoadingSessions(true);
        setError('');
        try {
            const data = await api.getChatSessions();
            setSessions(Array.isArray(data) ? data : []);
        } catch (err) {
            toast.error("Failed to load chat sessions.");
            setError(err.message || "Could not fetch sessions.");
        } finally {
            setLoadingSessions(false);
        }
    }, [isOpen]);

    useEffect(() => {
        if (isOpen) {
            fetchSessions();
            setSelectedSessionId(null); 
            setSessionMessages([]);
        }
    }, [isOpen, fetchSessions]); 

    const handleSessionSelectForPreview = async (sessionId) => {
        if (selectedSessionId === sessionId && sessionMessages.length > 0) return; 

        setSelectedSessionId(sessionId);
        setLoadingMessages(true);
        setSessionMessages([]);
        setError(''); 
        try {
            const sessionData = await api.getChatHistory(sessionId);
            
            // --- THIS IS THE CORRECTED LOGIC ---
            // We trust the API to send correctly formatted data with the 'sender' property.
            const messagesArray = Array.isArray(sessionData.messages) ? sessionData.messages : [];
            setSessionMessages(messagesArray);
            // --- END OF CORRECTION ---

        } catch (err) {
            toast.error("Failed to load messages for this session.");
            setError(`Error loading messages: ${err.message}`);
        } finally {
            setLoadingMessages(false);
        }
    };

    const handleLoadSessionAndClose = () => {
        if (selectedSessionId) {
            onSelectSession(selectedSessionId); 
            onClose();
        } else {
            toast.error("Please select a session to load.");
        }
    };
    
    const handleDeleteSession = async (sessionIdToDelete, e) => {
        e.stopPropagation();
        if (!window.confirm(`Are you sure you want to delete this session? This action cannot be undone.`)) return;
        
        const toastId = toast.loading(`Deleting session...`);
        try {
            await api.deleteChatSession(sessionIdToDelete);
            toast.success(`Session deleted.`, { id: toastId });
            setSessions(prev => prev.filter(s => s.sessionId !== sessionIdToDelete)); 
            if (selectedSessionId === sessionIdToDelete) {
                setSelectedSessionId(null);
                setSessionMessages([]);
            }
        } catch (err) {
            toast.error(`Delete failed: ${err.response?.data?.message || err.message}`, { id: toastId });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Chat History" size="2xl">
            <div className="flex flex-col md:flex-row gap-4 max-h-[70vh] h-[70vh]">
                <div className="w-full md:w-1/3 border-r border-border-light dark:border-border-dark pr-0 md:pr-2 overflow-y-auto custom-scrollbar">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark px-1">Your Sessions</h3>
                    {loadingSessions && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24}/></div>}
                    {!loadingSessions && !sessions.length && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">No past sessions found.</p>}
                    <ul className="space-y-1">
                        {sessions.map(session => (
                            <li key={session.sessionId} onClick={() => handleSessionSelectForPreview(session.sessionId)}
                                className={`p-2.5 rounded-md cursor-pointer text-xs transition-colors group relative hover:shadow-md
                                            ${selectedSessionId === session.sessionId ? 'bg-primary text-white' : 'bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700'}`} >
                                <div className="font-medium truncate" title={session.preview}>{session.preview || `Session ${session.sessionId.substring(0,8)}`}</div>
                                <div className={`text-[0.7rem] ${selectedSessionId === session.sessionId ? 'text-blue-200' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                    {formatDate(session.updatedAt)} - {session.messageCount} msgs
                                </div>
                                <IconButton icon={Trash2} size="sm" variant="ghost" title="Delete session"
                                    className="absolute top-1 right-1 p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100"
                                    onClick={(e) => handleDeleteSession(session.sessionId, e)} />
                            </li>
                        ))}
                    </ul>
                </div>

                <div className="w-full md:w-2/3 flex flex-col overflow-hidden mt-4 md:mt-0">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark">Preview</h3>
                    <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md overflow-y-auto custom-scrollbar border border-border-light dark:border-border-dark">
                        {loadingMessages && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24} /></div>}
                        
                        <div className="space-y-3 flex flex-col">
                            {sessionMessages.map(msg => {
                                const isUser = msg.sender === 'user';
                                return (
                                    <div key={msg.id} className={`flex w-full ${isUser ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`p-2.5 rounded-lg shadow-sm w-fit max-w-[90%] text-xs
                                            ${isUser 
                                                ? 'bg-blue-500 text-white' 
                                                : 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100'
                                            }`}>
                                            <p className="font-semibold text-[0.7rem] mb-0.5">{isUser ? 'You' : 'AI Tutor'}</p>
                                            <p className="whitespace-pre-wrap break-words">{msg.text}</p>
                                            <p className={`text-[0.65rem] mt-1 text-right ${isUser ? 'opacity-70' : 'opacity-50'}`}>{formatDate(msg.timestamp)}</p>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {!loadingMessages && !selectedSessionId && (
                            <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark text-sm">
                                <MessageSquareText size={40} className="mb-3 opacity-50" />
                                <p>Select a session to view its messages.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            <div className="mt-6 pt-4 border-t border-border-light dark:border-border-dark flex justify-end gap-3">
                <button onClick={onClose} className="btn-secondary !text-xs !py-1.5 !px-3">Cancel</button>
                <button onClick={handleLoadSessionAndClose} className="btn-primary !text-xs !py-1.5 !px-3" disabled={!selectedSessionId || loadingMessages || loadingSessions}>Load Session</button>
            </div>
        </Modal>
    );
}
export default ChatHistoryModal;
```

`src/components/chat/ChatInput.jsx`

```javascript


// frontend/src/components/chat/ChatInput.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Send, Mic, Plus, Brain, Zap, Globe, BookMarked } from 'lucide-react'; // Ensure BookMarked is imported
import { useWebSpeech } from '../../hooks/useWebSpeech';
import Button from '../core/Button.jsx'; 
import IconButton from '../core/IconButton.jsx';
import toast from 'react-hot-toast';
import blueBrain from "./../../assets/blueBrain.svg";
import { motion, AnimatePresence } from 'framer-motion';

function ChatInput({ 
    onSendMessage, 
    isLoading,
    useWebSearch,
    setUseWebSearch,
    useAcademicSearch, // This prop is now used
    setUseAcademicSearch, // This prop is now used
    criticalThinkingEnabled,
    setCriticalThinkingEnabled
}) {
    const [inputValue, setInputValue] = useState('');
    const { transcript, listening, isSpeechSupported, startListening, stopListening, resetTranscript } = useWebSpeech();
    const textareaRef = useRef(null);
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const menuRef = useRef(null);

    useEffect(() => {
        if (transcript) {
            setInputValue(prev => prev + (prev ? " " : "") + transcript);
            resetTranscript(); 
        }
    }, [transcript, resetTranscript]);
    
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 128)}px`;
        }
    }, [inputValue]);

    useEffect(() => {
        function handleClickOutside(event) {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                setIsMenuOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
    }, [menuRef]);

    const handleSubmit = (e) => {
        e.preventDefault();
        if (inputValue.trim() && !isLoading) {
            onSendMessage(inputValue.trim());
            setInputValue('');
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !isLoading) {
            e.preventDefault();
            handleSubmit(e);
        }
    };
    
    const handleWebSearchToggle = () => {
        const newWebSearchState = !useWebSearch;
        setUseWebSearch(newWebSearchState);
        toast(newWebSearchState ? "Web Search enabled." : "Web Search disabled.", { icon: newWebSearchState ? "🌐" : "📄" });
        setIsMenuOpen(false);
    };

    // Handler for the Academic Search Toggle
    const handleAcademicSearchToggle = () => {
        const newState = !useAcademicSearch;
        setUseAcademicSearch(newState);
        toast(newState ? "Academic Search enabled." : "Academic Search disabled.", { icon: newState ? "🎓" : "📄" });
        setIsMenuOpen(false);
    };

    const icon = criticalThinkingEnabled ? () => <img src={blueBrain} alt="Blue Brain" className="w-5 h-5" /> : Brain;

    return (
        <div className="p-2 sm:p-3 bg-surface-light dark:bg-surface-dark/50 backdrop-blur-sm rounded-b-lg shadow-inner">
            <form onSubmit={handleSubmit} className="flex items-end gap-2">
                <div className="relative" ref={menuRef}>
                    <IconButton
                        icon={Plus}
                        title="More Options"
                        onClick={() => setIsMenuOpen(!isMenuOpen)}
                        variant="ghost"
                        size="md" 
                        className="p-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                        disabled={isLoading}
                    />
                    <AnimatePresence>
                    {isMenuOpen && (
                        <motion.div
                            initial={{ opacity: 0, y: 10, scale: 0.95 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: 10, scale: 0.95 }}
                            className="absolute bottom-full left-0 mb-2 w-52 bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl border border-border-light dark:border-border-dark p-1 z-10"
                        >
                            {/* Web Search Button */}
                            <button
                                onClick={handleWebSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useWebSearch
                                    ? 'bg-primary/10 text-primary dark:bg-primary-dark/20 dark:text-primary-light'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <Globe size={16} />
                                {useWebSearch ? 'Disable Web Search' : 'Enable Web Search'}
                            </button>

                            {/* --- THIS IS THE BUTTON THAT WAS MISSING --- */}
                            <button
                                onClick={handleAcademicSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useAcademicSearch
                                    ? 'bg-purple-500/10 text-purple-600 dark:bg-purple-400/20 dark:text-purple-300'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <BookMarked size={16} />
                                {useAcademicSearch ? 'Disable Academic Search' : 'Enable Academic Search'}
                            </button>
                             
                             <button
                                onClick={() => {toast("File attachment coming soon!", { icon: "📎" }); setIsMenuOpen(false);}}
                                className="w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md text-text-muted-light dark:text-text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700"
                            >
                                <Zap size={16} />
                                Attach File (soon)
                            </button>
                        </motion.div>
                    )}
                    </AnimatePresence>
                </div>

                <textarea
                    ref={textareaRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder={isLoading ? "Waiting for response..." : "Type your message or ask a question..."}
                    className="input-field flex-1 p-2.5 resize-none min-h-[44px] max-h-32 custom-scrollbar text-sm" 
                    rows="1"
                    disabled={isLoading}
                />

                {isSpeechSupported && (
                    <IconButton
                        icon={Mic}
                        onClick={() => listening ? stopListening() : startListening()}
                        title={listening ? "Stop listening" : "Start voice input"}
                        variant={listening ? "danger" : "ghost"} 
                        size="md"
                        className={`p-2 ${listening ? 'text-red-500 animate-pulse' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        disabled={isLoading}
                    />
                )}

               <IconButton
                    icon={icon}
                    onClick={() => setCriticalThinkingEnabled(!criticalThinkingEnabled)}
                    title={criticalThinkingEnabled ? "Disable Critical Thinking (KG)" : "Enable Critical Thinking (KG)"}
                    variant="ghost"
                    size="md"
                    className={`p-2 ${criticalThinkingEnabled ? 'text-purple-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                    disabled={isLoading}
                />

                <Button 
                    type="submit"
                    variant="primary"
                    size="md" 
                    className="!p-2.5" 
                    disabled={isLoading || !inputValue.trim()}
                    isLoading={isLoading && !!inputValue.trim()} 
                    title="Send message"
                >
                    {(!isLoading || !inputValue.trim()) ? <Send size={20} /> : null}
                </Button>
            </form>
            
            <div className="flex flex-col items-center justify-center mt-2 px-2 text-center h-4">
                <AnimatePresence>
                    {useWebSearch && (
                        <motion.p
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-blue-500 dark:text-blue-400 flex items-center gap-1.5 font-medium"
                        >
                            <Globe size={12} /> Web Search is ON
                        </motion.p>
                    )}
                    {useAcademicSearch && (
                        <motion.p
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-purple-500 dark:text-purple-400 flex items-center gap-1.5 font-medium"
                        >
                            <BookMarked size={12} /> Academic Search is ON
                        </motion.p>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default ChatInput;
```

`src/components/chat/MessageBubble.jsx`

```javascript
// src/components/chat/MessageBubble.jsx
import React, { useEffect, useRef } from 'react'; // Import useEffect and useRef
import { marked } from 'marked';
import Prism from 'prismjs'; // Import Prism for manual highlighting
import { ChevronDown, Brain, Link as LinkIcon, Zap, Server, Volume2, StopCircle, ServerCrash } from 'lucide-react';
import { useTextToSpeech } from '../../hooks/useTextToSpeech.js';
import IconButton from '../core/IconButton.jsx';
import { renderMathInHtml } from '../../utils/markdownUtils'; // Import the math renderer
import DOMPurify from 'dompurify'; // Import DOMPurify for security

// Configure marked - it's good to have it here
marked.setOptions({
  breaks: true,
  gfm: true,
});

// Create a new, safer markup creation function
const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    // 1. Convert Markdown to HTML
    let rawHtml = marked.parse(markdownText);
    // 2. Render KaTeX math within the HTML
    rawHtml = renderMathInHtml(rawHtml);
    // 3. Sanitize the final HTML to prevent XSS attacks
    const cleanHtml = DOMPurify.sanitize(rawHtml, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};


const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

function MessageBubble({ sender, text, thinking, references, timestamp, sourcePipeline, id: messageId }) {
    const isUser = sender === 'user';
    const { speak, cancel, isSpeaking: isCurrentlySpeakingThisBubble, isSupported: ttsIsSupported } = useTextToSpeech();
    
    // --- START OF CHANGES ---
    // 1. Create a ref to attach to the content container
    const contentRef = useRef(null);

    // 2. Use an effect to run Prism highlighting after the component renders/updates
    useEffect(() => {
        // The timeout ensures that React has finished rendering the HTML from `dangerouslySetInnerHTML`
        // before Prism tries to find the code blocks.
        const timer = setTimeout(() => {
            if (contentRef.current) {
                Prism.highlightAllUnder(contentRef.current);
            }
        }, 50); // A small delay is usually sufficient

        return () => clearTimeout(timer); // Cleanup timer on unmount
    }, [text]); // Re-run this effect whenever the message text changes
    // --- END OF CHANGES ---

    const formatTimestamp = (ts) => {
        if (!ts) return '';
        try {
            return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } catch (e) { return 'Invalid Time'; }
    };

    const getPipelineIcon = () => {
        if (!sourcePipeline) return null;
        const lowerPipeline = sourcePipeline.toLowerCase();
        if (lowerPipeline.includes('ollama')) return <Zap size={12} className="text-green-400" title="Ollama Powered" />;
        if (lowerPipeline.includes('gemini')) return <Server size={12} className="text-blue-400" title="Gemini Powered" />;
        if (lowerPipeline.includes('rag')) return <Zap size={12} className="text-purple-400" title="RAG Enhanced" />;
        if (lowerPipeline.includes('error')) return <ServerCrash size={12} className="text-red-400" title="Error" />;
        return null;
    };

    const handleToggleSpeech = () => {
        if (!ttsIsSupported || !text) return;
        if (isCurrentlySpeakingThisBubble) {
            cancel();
        } else {
            speak({ text });
        }
    };
    
    return (
        <div className={`flex flex-col ${isUser ? 'items-end' : 'items-start'} w-full group`}>
            <div 
                className={`message-bubble max-w-[85%] md:max-w-[75%] p-3 rounded-2xl shadow-md break-words ${
                    isUser 
                    ? 'bg-primary dark:bg-primary-dark text-white rounded-br-lg' 
                    : 'bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark rounded-bl-lg border border-border-light dark:border-border-dark'
                }`}
            >
                {/* Main message content */}
                <div 
                    // 3. Attach the ref to the div that contains the dangerous HTML
                    ref={contentRef}
                    className="prose prose-sm dark:prose-invert max-w-none message-content leading-relaxed" 
                    dangerouslySetInnerHTML={createMarkup(text || '')} 
                />
                
                {/* Timestamp, Pipeline Icon, and TTS Button */}
                <div className="flex items-center justify-end mt-1.5 text-xs opacity-70 gap-2">
                    {!isUser && getPipelineIcon() && <span className="mr-1">{getPipelineIcon()}</span>}
                    <span>{formatTimestamp(timestamp)}</span>
                    {!isUser && ttsIsSupported && text && (
                        <IconButton
                            icon={isCurrentlySpeakingThisBubble ? StopCircle : Volume2}
                            onClick={handleToggleSpeech}
                            title={isCurrentlySpeakingThisBubble ? "Stop reading" : "Read aloud"}
                            size="sm"
                            variant="ghost"
                            className={`p-0.5 ${isCurrentlySpeakingThisBubble ? 'text-red-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        />
                    )}
                </div>
            </div>

            {/* Metadata: Thinking and References for Bot Messages */}
            {!isUser && (thinking || (references && references.length > 0)) && (
                <div className="message-metadata-container max-w-[85%] md:max-w-[75%] mt-1.5 pl-2 space-y-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    {thinking && thinking.trim() && (
                        <details className="group/details text-xs">
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <Brain size={14} /> AI Reasoning
                                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
                            </summary>
                            <pre className="mt-1 p-2 bg-gray-100 dark:bg-gray-800 rounded-md text-text-light dark:text-text-dark whitespace-pre-wrap break-all text-[0.7rem] max-h-32 overflow-y-auto custom-scrollbar">
                                <code>{escapeHtml(thinking)}</code>
                            </pre>
                        </details>
                    )}
                    {references && references.length > 0 && (
                        <details className="group/details text-xs" open>
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <LinkIcon size={14} /> References
                                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
                            </summary>
                            <ul className="mt-1 pl-1 space-y-0.5 text-[0.7rem]">
                                {references.map((ref, index) => (
                                    <li 
                                        key={index} 
                                        className="text-text-muted-light dark:text-text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors truncate"
                                        title={`Preview: ${escapeHtml(ref.content_preview || '')}\nSource: ${escapeHtml(ref.source || '')}`}
                                    >
                                        <span className="font-semibold text-accent">[{ref.number}]</span> {escapeHtml(ref.source)}
                                    </li>
                                ))}
                            </ul>
                        </details>
                    )}
                </div>
            )}
        </div>
    );
}
export default MessageBubble;
```

`src/components/chat/ThinkingDropdown.jsx`

```javascript
// frontend/src/components/chat/ThinkingDropdown.jsx
import React, { useState } from 'react';
import { ChevronDown, BrainCircuit } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

function ThinkingDropdown({ children, isStreaming }) {
    const [isOpen, setIsOpen] = useState(false);

    return (
        <div className="text-xs border border-border-light dark:border-border-dark rounded-md bg-surface-light/50 dark:bg-surface-dark/50 shadow-sm mt-1.5 w-full">
            <button
                onClick={() => setIsOpen(!isOpen)}
                className="w-full flex items-center justify-between p-2 text-left text-text-muted-light dark:text-text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700/50 transition-colors rounded-t-md"
                aria-expanded={isOpen}
            >
                <div className="flex items-center gap-2 font-medium">
                    <BrainCircuit size={14} />
                    <span className="flex-grow">Thinking Process</span>
                </div>
                {/* Shimmer effect for when streaming is active */}
                {isStreaming && (
                    <div className="relative w-20 h-4 ml-auto mr-2 overflow-hidden rounded bg-gray-200 dark:bg-gray-600">
                        <div className="shimmer-animation"></div>
                    </div>
                )}
                <ChevronDown size={16} className={`transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} />
            </button>
            <AnimatePresence initial={false}>
                {isOpen && (
                    <motion.div
                        key="content"
                        initial="collapsed"
                        animate="open"
                        exit="collapsed"
                        variants={{
                            open: { opacity: 1, height: 'auto' },
                            collapsed: { opacity: 0, height: 0 }
                        }}
                        transition={{ duration: 0.3, ease: 'easeInOut' }}
                        className="overflow-hidden"
                    >
                        <div className="p-2.5 border-t border-border-light dark:border-border-dark bg-white dark:bg-gray-800 rounded-b-md">
                            {children}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}

export default ThinkingDropdown;
```

`src/components/common/ThemeToggle.jsx`

```javascript
import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="p-2 rounded-full text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
            aria-label={theme === 'light' ? 'Switch to dark theme' : 'Switch to light theme'}
        >
            {theme === 'light' ? <Moon size={20} /> : <Sun size={20} />}
        </button>
    );
}

export default ThemeToggle;
```

`src/components/core/Button.jsx`

```javascript
// src/components/core/Button.jsx
import React from 'react';
import { Loader2 } from 'lucide-react'; // For loading spinner

const Button = ({
    children,
    onClick,
    type = 'button',
    variant = 'primary', // 'primary', 'secondary', 'danger', 'outline', 'ghost'
    size = 'md', // 'sm', 'md', 'lg'
    leftIcon,
    rightIcon,
    isLoading = false,
    disabled = false,
    fullWidth = false,
    className = '',
    ...props
}) => {
    const baseStyles = "font-semibold rounded-lg focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2";

    const variantStyles = {
        primary: "bg-primary hover:bg-primary-dark text-white focus:ring-primary",
        secondary: "bg-secondary hover:bg-secondary-dark text-white focus:ring-secondary",
        danger: "bg-red-500 hover:bg-red-600 text-white focus:ring-red-500",
        outline: "border border-primary text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
        ghost: "text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
    };

    const sizeStyles = {
        sm: "px-3 py-1.5 text-xs",
        md: "px-4 py-2 text-sm",
        lg: "px-6 py-3 text-base",
    };

    const widthStyle = fullWidth ? "w-full" : "";
    const isDisabled = disabled || isLoading;
    const finalDisabledStyle = isDisabled ? "opacity-60 cursor-not-allowed" : "cursor-pointer";

    const spinnerSize = size === 'sm' ? 14 : (size === 'lg' ? 20 : 16);
    
    return (
        <button
            type={type}
            onClick={onClick}
            disabled={isDisabled} // Use the corrected variable
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${widthStyle} ${finalDisabledStyle} ${className}`}
            {...props}
        >
            {isLoading && (
                <Loader2 size={spinnerSize} className="animate-spin" />
            )}
            {!isLoading && leftIcon && <span className="icon-left">{leftIcon}</span>}

            <span className={isLoading ? 'ml-2' : ''}>{children}</span>

            {!isLoading && rightIcon && <span className="icon-right">{rightIcon}</span>}
        </button>
    );
};

export default Button;
```

`src/components/core/IconButton.jsx`

```javascript
import React from 'react';
import { Loader2 } from 'lucide-react';

const IconButton = ({
    icon: Icon, // Pass the Lucide icon component directly
    onClick,
    variant = 'ghost', // 'ghost', 'outline', 'subtle'
    size = 'md', // 'sm', 'md', 'lg'
    isLoading = false,
    disabled = false,
    className = '',
    title, // For accessibility and tooltips
    ariaLabel,
    ...props
}) => {
    const baseStyles = "rounded-md focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-colors duration-150 flex items-center justify-center";

    const variantStyles = {
        ghost: "text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:ring-primary",
        outline: "border border-gray-300 dark:border-gray-600 text-text-muted-light dark:text-text-muted-dark hover:border-primary hover:text-primary focus:ring-primary",
        subtle: "bg-gray-100 dark:bg-gray-700 text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-600 focus:ring-primary",
        danger: "text-red-500 hover:bg-red-100 dark:hover:bg-red-900 focus:ring-red-500"
    };

    const sizeStyles = {
        sm: "p-1.5", // Icon size typically 14-16px
        md: "p-2",   // Icon size typically 18-20px
        lg: "p-2.5", // Icon size typically 22-24px
    };
    
    const iconSizeMap = {
        sm: 16,
        md: 20,
        lg: 24,
    };

    const disabledStyle = (disabled || isLoading) ? "opacity-50 cursor-not-allowed" : "cursor-pointer";

    return (
        <button
            type="button"
            onClick={onClick}
            disabled={disabled || isLoading}
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${disabledStyle} ${className}`}
            title={title}
            aria-label={ariaLabel || title}
            {...props}
        >
            {isLoading ? (
                <Loader2 size={iconSizeMap[size]} className="animate-spin" />
            ) : (
                Icon && <Icon size={iconSizeMap[size]} />
            )}
        </button>
    );
};

export default IconButton;
```

`src/components/core/Modal.jsx`

```javascript
// src/components/core/Modal.jsx
import React, { useEffect, useRef } from 'react';
import { X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const Modal = ({
    isOpen,
    onClose,
    title,
    children,
    footerContent,
    size = 'md', // 'sm', 'md', 'lg', 'xl', '2xl', '3xl', '4xl', '5xl', 'full'
    closeOnOverlayClick = true,
    initialFocusRef, // Optional ref for focusing an element inside the modal on open
}) => {
    const modalRef = useRef(null);

    // Handle Escape key for closing
    useEffect(() => {
        const handleEscapeKey = (event) => {
            if (event.key === 'Escape' && isOpen) {
                onClose();
            }
        };
        if (isOpen) {
            document.addEventListener('keydown', handleEscapeKey);
        }
        return () => {
            document.removeEventListener('keydown', handleEscapeKey);
        };
    }, [isOpen, onClose]);

    // Handle focus trapping and initial focus
    useEffect(() => {
        if (isOpen) {
            // Set focus to the initialFocusRef or the modal itself
            if (initialFocusRef && initialFocusRef.current) {
                initialFocusRef.current.focus();
            } else if (modalRef.current) {
                modalRef.current.focus(); // Fallback to modal itself
            }

            // Basic focus trapping (can be made more robust with a library)
            const focusableElements = modalRef.current?.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements && focusableElements.length > 0) {
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                const onKeyDown = (e) => {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) { // Shift + Tab
                            if (document.activeElement === firstElement) {
                                lastElement.focus();
                                e.preventDefault();
                            }
                        } else { // Tab
                            if (document.activeElement === lastElement) {
                                firstElement.focus();
                                e.preventDefault();
                            }
                        }
                    }
                };
                modalRef.current?.addEventListener('keydown', onKeyDown);
                return () => modalRef.current?.removeEventListener('keydown', onKeyDown);
            }
        }
    }, [isOpen, initialFocusRef]);


    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl',
        '3xl': 'max-w-3xl',
        '4xl': 'max-w-4xl',
        '5xl': 'max-w-5xl',
        full: 'max-w-full h-full rounded-none sm:rounded-lg sm:max-h-[95vh]', // Special case for full screen like
    };

    const backdropVariants = {
        visible: { opacity: 1, transition: { duration: 0.2, ease: "easeOut" } },
        hidden: { opacity: 0, transition: { duration: 0.15, ease: "easeIn" } },
    };

    const modalVariants = {
        hidden: { y: "-30px", opacity: 0, scale: 0.98, transition: { duration: 0.15, ease: "easeIn" } },
        visible: { y: "0", opacity: 1, scale: 1, transition: { type: "spring", stiffness: 400, damping: 30, duration: 0.3 } },
        exit: { y: "30px", opacity: 0, scale: 0.98, transition: { duration: 0.2, ease: "easeIn" } }
    };

    if (!isOpen) return null;

    return (
        <AnimatePresence mode="wait">
            {isOpen && (
                <motion.div
                    key="modal-backdrop"
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 dark:bg-black/80 backdrop-blur-sm"
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    variants={backdropVariants}
                    onClick={closeOnOverlayClick ? onClose : undefined}
                    aria-labelledby="modal-title" // For screen readers
                    role="dialog" // Role for the backdrop itself, more specific roles on content
                    aria-modal="true" // Indicate it's a modal overlaying other content
                >
                    <motion.div
                        key="modal-content-wrapper" // Changed key for potential AnimatePresence behavior
                        ref={modalRef}
                        tabIndex={-1} // Make the modal itself focusable for fallback
                        className={`bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl w-full ${sizeClasses[size]} flex flex-col overflow-hidden
                                    ${size === 'full' ? '' : 'max-h-[90vh] sm:max-h-[85vh]'}`} 
                                    // Apply max-h unless it's 'full' size
                        role="document" // The actual dialog content
                        aria-modal="true"
                        aria-labelledby={title ? "modal-title-text" : undefined} // Point to title if exists
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        variants={modalVariants}
                        onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside modal
                    >
                        {/* Modal Header */}
                        <div className="flex items-center justify-between px-5 py-3.5 border-b border-border-light dark:border-border-dark sticky top-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                            {title && (
                                <h2 id="modal-title-text" className="text-lg font-semibold text-text-light dark:text-text-dark truncate pr-4">
                                    {title}
                                </h2>
                            )}
                            <button
                                onClick={onClose}
                                className="p-1.5 rounded-full text-text-muted-light dark:text-text-muted-dark 
                                           hover:bg-gray-200/80 dark:hover:bg-gray-700/80 
                                           hover:text-red-500 dark:hover:text-red-400 
                                           focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary-light focus:ring-offset-1 dark:focus:ring-offset-surface-dark"
                                aria-label="Close modal"
                            >
                                <X size={20} />
                            </button>
                        </div>

                        {/* Modal Body */}
                        <div className="px-5 py-4 overflow-y-auto flex-grow custom-scrollbar">
                            {children}
                        </div>

                        {/* Modal Footer */}
                        {footerContent && (
                            <div className="px-5 py-3.5 border-t border-border-light dark:border-border-dark flex justify-end gap-3 sticky bottom-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                                {footerContent}
                            </div>
                        )}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

export default Modal;
```

`src/components/documents/DocumentList.jsx`

```javascript


// frontend/src/components/documents/DocumentList.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api.js'; // Mocked for V1
import toast from 'react-hot-toast';
import { FileText, Edit3, Trash2, Loader2, AlertTriangle, CheckCircle } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Make sure IconButton is imported
import { useAuth } from '../../hooks/useAuth.jsx';

// Props from LeftPanel: onSelectDocument is selectDocumentForAnalysis from AppStateContext
// selectedDocument is selectedDocumentForAnalysis from AppStateContext
function DocumentList({ onSelectDocument, selectedDocument }) {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const fetchFiles = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      
      const response = await api.getFiles(); // Returns { filenames: ["A.txt", "B.pdf"] }
      const filenames = Array.isArray(response.filenames) ? response.filenames : [];
      setFiles(filenames);
      
    } catch (err) {
      console.error("Failed to fetch files:", err);
      setError(err.message || "Failed to fetch files.");
      toast.error("Could not load documents.");
    } finally {
      setLoading(false);
    }
  }, []);



  useEffect(() => {
    fetchFiles();
  }, [fetchFiles]);

  const handleDelete = async (filename) => {
    if (!window.confirm(`Are you sure you want to delete "${filename}"?`)) return;
    const toastId = toast.loading(`Deleting ${filename}...`);
    try {
      await api.deleteFile(filename); // Assumes this works with filename
      toast.success(`${filename} deleted.`, { id: toastId });
      fetchFiles();
      if (selectedDocument === filename) {
        onSelectDocument(null);
      }
    } catch (err) {
      toast.error(`Delete failed: ${err.message}`, { id: toastId });
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark">
        <Loader2 size={20} className="animate-spin mr-2" /> Loading documents...
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
        <AlertTriangle size={18} /> {error}
        <button onClick={fetchFiles} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
      </div>
    );
  }

  if (files.length === 0) {
    return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-4">No documents uploaded.</p>;
  }

  return (
    <div className="space-y-1.5 text-xs custom-scrollbar pr-1">
      {files.map(filename => {
        const isSelected = selectedDocument === filename;

        return (
          <div
            key={filename}
            onClick={() => onSelectDocument(isSelected ? null : filename)}
            className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                        ${isSelected
                          ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                          : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
            title={`Select ${filename}`}
          >
            <div className="flex items-center gap-2 truncate">
              {isSelected ? (
                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
              ) : (
                <FileText size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
              )}
              <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                {filename}
              </span>
            </div>
            <div className="flex-shrink-0 flex items-center gap-0.5">
              <IconButton
                icon={Trash2}
                size="sm"
                variant="ghost"
                title="Delete"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete(filename);
                }}
                className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"
              />
            </div>
          </div>
        );
      })}
    </div>
  );
}


export default DocumentList;
```

`src/components/documents/DocumentUpload.jsx`

```javascript
// frontend/src/components/documents/DocumentUpload.jsx
import React, { useState, useRef, useEffect } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { UploadCloud, FileText, XCircle, Paperclip } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';

// Define the stages for our static simulation
const RAG_STAGES = [
    { name: "Uploading", duration: 1500, message: "Transferring your document to the server..." },
    { name: "Processing", duration: 2000, message: "Validating file format and structure..." },
    { name: "Extracting", duration: 3000, message: "Extracting text and content from your document..." },
    { name: "Chunking", duration: 1500, message: "Breaking document into manageable segments..." },
    { name: "Embedding", duration: 4000, message: "Converting content to searchable vectors..." },
    { name: "Analyzing", duration: 3000, message: "Indexing content for optimal retrieval..." },
];

function DocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const [progress, setProgress] = useState(0);
    const [currentStage, setCurrentStage] = useState('');
    const [stageMessage, setStageMessage] = useState('');
    const [errorMessage, setErrorMessage] = useState('');
    const [dragActive, setDragActive] = useState(false);

    const fileInputRef = useRef(null);
    const processingTimeoutRef = useRef(null);
    
    useEffect(() => {
        return () => {
            if (processingTimeoutRef.current) {
                clearTimeout(processingTimeoutRef.current);
            }
        };
    }, []);

    const handleFileChange = (e) => {
        if (isProcessing) return;
        const file = e.target.files && e.target.files[0];
        if (file) {
            setSelectedFile(file);
            setErrorMessage('');
        }
    };

    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(e.type === "dragenter" || e.type === "dragover"); };
    const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(false); const file = e.dataTransfer.files && e.dataTransfer.files[0]; if (file) { setSelectedFile(file); setErrorMessage(''); }};

    const resetState = () => {
        setSelectedFile(null);
        setIsProcessing(false);
        setProgress(0);
        setCurrentStage('');
        setStageMessage('');
        setErrorMessage('');
        if (fileInputRef.current) fileInputRef.current.value = null;
    };
    
    const runProgressSimulation = (stageIndex = 0) => {
        if (stageIndex >= RAG_STAGES.length) return;

        const stage = RAG_STAGES[stageIndex];
        setCurrentStage(stage.name);
        setStageMessage(stage.message);
        
        const totalDuration = RAG_STAGES.reduce((acc, s) => acc + s.duration, 0);
        const elapsedDuration = RAG_STAGES.slice(0, stageIndex).reduce((acc, s) => acc + s.duration, 0);
        setProgress(Math.round((elapsedDuration / totalDuration) * 100));

        processingTimeoutRef.current = setTimeout(() => {
            runProgressSimulation(stageIndex + 1);
        }, stage.duration);
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            toast.error("Please select a file first.");
            return;
        }

        setIsProcessing(true);
        setErrorMessage('');
        runProgressSimulation(0);

        const formData = new FormData();
        formData.append("file", selectedFile);
        
        try {
            await api.uploadFile(formData);

            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            setCurrentStage("Ready");
            setStageMessage("Document successfully processed and ready to use!");
            setProgress(100);
            toast.success(`'${selectedFile.name}' processed successfully!`);
            
            setTimeout(() => {
                resetState();
                if (onUploadSuccess) onUploadSuccess();
            }, 2500);

        } catch (error) {
            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            const msg = error.response?.data?.message || error.message || "Upload failed.";
            setErrorMessage(msg);
            toast.error(`Upload failed: ${msg}`);
            setIsProcessing(false);
            setCurrentStage('Failed');
            setProgress(100);
        }
    };

    if (isProcessing) {
        return (
            <div className="card-base p-4 mb-4">
                <h3 className="font-semibold text-text-light dark:text-text-dark">
                    📄 Processing: <span className="font-normal truncate">{selectedFile.name}</span>
                </h3>
                <div className="relative w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 my-2">
                    <motion.div
                        className={`h-2.5 rounded-full ${errorMessage ? 'bg-red-500' : 'bg-primary'}`}
                        initial={{ width: '0%' }}
                        animate={{ width: `${progress}%` }}
                        transition={{ duration: 0.5, ease: 'linear' }}
                    />
                </div>
                <div className="flex justify-between text-xs text-text-muted-light dark:text-text-muted-dark">
                    <span>{errorMessage ? 'Error' : `Stage: ${currentStage}`} ({progress}%)</span>
                </div>
                <p className="text-xs text-center mt-2 h-4">{errorMessage || stageMessage}</p>
                {errorMessage && (
                    <Button onClick={resetState} fullWidth variant="danger" size="sm" className="mt-3">
                        Close
                    </Button>
                )}
            </div>
        );
    }
    
    return (
        <div className="mb-4 p-1">
            <label
                htmlFor="file-upload-input"
                onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}
                className={`flex flex-col items-center justify-center w-full h-36 px-4 transition-colors duration-200 ease-in-out bg-surface-light dark:bg-gray-800 border-2 border-dashed rounded-lg cursor-pointer border-border-light dark:border-border-dark hover:border-primary dark:hover:border-primary-light ${dragActive ? "border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light bg-primary/10 dark:bg-primary-dark/20" : ""}`}
            >
                <div className="flex flex-col items-center justify-center text-center">
                    <Paperclip size={36} className={`mb-2 transition-colors ${dragActive ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                    <p className="mb-1 text-sm text-text-muted-light dark:text-text-muted-dark">
                        <span className="font-semibold text-primary dark:text-primary-light">Click to upload</span> or drag and drop
                    </p>
                    <p className="text-xs text-text-muted-light dark:text-text-muted-dark">PDF, DOCX, TXT, PPTX, code files</p>
                </div>
                <input ref={fileInputRef} id="file-upload-input" type="file" className="hidden" onChange={handleFileChange}
                       accept=".pdf,.doc,.docx,.ppt,.pptx,.txt,.py,.js,.md,.html,.xml,.json,.csv,.log,.c,.cpp,.java" />
            </label>

            {selectedFile && (
                <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm animate-fadeIn">
                    <div className="flex items-center gap-2 truncate">
                        <FileText size={18} className="text-primary flex-shrink-0" />
                        <span className="truncate text-text-light dark:text-text-dark" title={selectedFile.name}>{selectedFile.name}</span>
                        <span className="text-text-muted-light dark:text-text-muted-dark text-xs whitespace-nowrap">
                            ({(selectedFile.size / 1024).toFixed(1)} KB)
                        </span>
                    </div>
                    <button onClick={() => setSelectedFile(null)} className="text-red-500 hover:text-red-700 dark:hover:text-red-400 transition-colors p-1 rounded-full hover:bg-red-500/10">
                        <XCircle size={18} />
                    </button>
                </div>
            )}

            <Button
                onClick={handleUpload}
                fullWidth
                className="mt-3 text-sm min-h-[38px]"
                variant="primary"
                disabled={!selectedFile}
                leftIcon={<UploadCloud size={16} />}
            >
                Upload Document
            </Button>
        </div>
    );
}

export default DocumentUpload;
```

`src/components/documents/SubjectList.jsx`

```javascript
// frontend/src/components/documents/SubjectList.jsx
import React from 'react';
import { Library, CheckCircle, Loader2, AlertTriangle } from 'lucide-react'; // Added AlertTriangle

function SubjectList({
    subjects,           // Array of subject name strings
    selectedSubject,    // Currently selected subject name (string or null)
    onSelectSubject,    // Function to call when a subject is selected (passes subjectName or null)
    isLoading,          // Boolean to indicate if subjects are being fetched
    error               // String error message if fetching failed
}) {
    if (isLoading) {
        return (
            <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark text-xs">
                <Loader2 size={16} className="animate-spin mr-2" /> Loading subjects...
            </div>
        );
    }

    if (error) {
        return (
            <div className="p-2 my-1 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center justify-center gap-1">
                <AlertTriangle size={14} /> {error}
            </div>
        );
    }

    if (!subjects || subjects.length === 0) {
        return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-3">No subjects configured by admin yet.</p>;
    }

    return (
        <div className="space-y-1.5 text-xs custom-scrollbar pr-1 max-h-60 overflow-y-auto"> {/* Added max-h and overflow */}
            {/* Option to deselect/choose general chat */}
            <div
                onClick={() => onSelectSubject(null)} // Pass null to deselect
                className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                            ${!selectedSubject // Highlighted if no subject is selected
                                ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                title="Select General Chat (No Specific Subject)"
            >
                <div className="flex items-center gap-2 truncate">
                    {!selectedSubject ? (
                        <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                    ) : (
                        // Using a generic icon, or you can use a different one for "none"
                        <Library size={16} className="text-gray-400 dark:text-gray-500 flex-shrink-0" />
                    )}
                    <span className={`truncate ${!selectedSubject ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                        -- General Chat --
                    </span>
                </div>
            </div>

            {/* List of available subjects */}
            {subjects.map(subjectName => {
                const isSelected = selectedSubject === subjectName;
                return (
                    <div
                        key={subjectName}
                        onClick={() => onSelectSubject(isSelected ? null : subjectName)} // Toggle selection
                        className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                                    ${isSelected
                                        ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                        : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                        title={`Select Subject: ${subjectName}`}
                    >
                        <div className="flex items-center gap-2 truncate">
                            {isSelected ? (
                                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                            ) : (
                                <Library size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                            )}
                            <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                                {subjectName}
                            </span>
                        </div>
                        {/* No actions like delete for subjects from this view */}
                    </div>
                );
            })}
        </div>
    );
}

export default SubjectList;
```

`src/components/layout/CenterPanel.jsx`

```javascript

// frontend/src/components/layout/CenterPanel.jsx
import React, { useState, useEffect, useRef } from 'react';
import ChatHistory from '../chat/ChatHistory';
import ChatInput from '../chat/ChatInput';
import api from '../../services/api';
import { useAuth as useRegularAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import toast from 'react-hot-toast';

const THINKING_VARIANTS = ["🧠 Thinking...", "💭 Processing...", "🤔 Analyzing query..."];
const RAG_ANALYSIS_VARIANTS = ["📚 Reviewing documents...", "🎯 Finding relevant info...", "🧩 Combining sources..."];
const WEB_ANALYSIS_VARIANTS = ["🌐 Searching the web...", "🔎 Filtering results...", "📰 Reading latest info..."];
const ACADEMIC_ANALYSIS_VARIANTS = ["🎓 Searching academic papers...", "🔬 Reviewing studies...", "📚 Compiling research..."];
const GENERAL_ANALYSIS_VARIANTS = ["📊 Analyzing context...", "🔍 Searching knowledge base..."];
const GENERATION_VARIANTS = ["✨ Generating response...", "🚀 Crafting answer...", "📝 Preparing explanation..."];

const getRandomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

function CenterPanel({ messages, setMessages, currentSessionId, onChatProcessingChange }) {
    const { token: regularUserToken } = useRegularAuth();
    const { selectedLLM, systemPrompt, selectedDocumentForAnalysis, selectedSubject } = useAppState();

    const [useWebSearch, setUseWebSearch] = useState(false);
    const [useAcademicSearch, setUseAcademicSearch] = useState(false);
    const [criticalThinkingEnabled, setCriticalThinkingEnabled] = useState(false);

    const [botStatusPlaceholder, setBotStatusPlaceholder] = useState(null);

    const isMountedRef = useRef(true);
    const simulationControllerRef = useRef(new AbortController());
    const [isActuallySendingAPI, setIsActuallySendingAPI] = useState(false);

    useEffect(() => {
        isMountedRef.current = true;
        return () => {
            isMountedRef.current = false;
            simulationControllerRef.current.abort();
        };
    }, []);

    useEffect(() => {
        const documentContext = selectedSubject || selectedDocumentForAnalysis;
        if (documentContext && (useWebSearch || useAcademicSearch)) {
            setUseWebSearch(false);
            setUseAcademicSearch(false);
            toast("Web and Academic Search disabled automatically while a document is selected.", { icon: "ℹ️" });
        }
    }, [selectedDocumentForAnalysis, selectedSubject, useWebSearch, useAcademicSearch]);

    const runStatusSimulation = async (isRagActive, isWebActive, isAcademicActive, signal) => {
        let analysisVariants;
        if (isWebActive) {
            analysisVariants = WEB_ANALYSIS_VARIANTS;
        } else if (isAcademicActive) {
            analysisVariants = ACADEMIC_ANALYSIS_VARIANTS;
        } else if (isRagActive) {
            analysisVariants = RAG_ANALYSIS_VARIANTS;
        } else {
            analysisVariants = GENERAL_ANALYSIS_VARIANTS;
        }

        const sequence = [
            { message: getRandomItem(THINKING_VARIANTS), duration: 1200 },
            { message: getRandomItem(analysisVariants), duration: 1500 },
            { message: getRandomItem(GENERATION_VARIANTS), duration: 1300 },
        ];

        for (const stage of sequence) {
            if (signal.aborted) return;
            setBotStatusPlaceholder(stage.message);
            await wait(stage.duration + (Math.random() * 400 - 200));
        }
    };

    const handleSendMessage = async (inputText) => {
        if (!inputText.trim() || !regularUserToken || !currentSessionId || isActuallySendingAPI) return;

        const documentContextName = selectedSubject || selectedDocumentForAnalysis;
        const isRagActive = !!documentContextName;

        simulationControllerRef.current.abort();
        simulationControllerRef.current = new AbortController();
        onChatProcessingChange(true);
        setIsActuallySendingAPI(true);

        const userMessage = {
            id: `user-${Date.now()}`,
            sender: 'user',
            role: 'user',
            text: inputText.trim(),
            parts: [{ text: inputText.trim() }],
            timestamp: new Date().toISOString(),
        };

        setMessages(prev => [...prev, userMessage]);
        setBotStatusPlaceholder("🧠 Thinking...");

        runStatusSimulation(isRagActive, useWebSearch, useAcademicSearch, simulationControllerRef.current.signal);

        try {
            const response = await api.sendMessage({
                query: inputText.trim(),
                history: messages.map(m => ({
                    role: m.role === 'model' ? 'model' : 'user',
                    parts: m.parts || [{ text: m.text }]
                })),
                sessionId: currentSessionId,
                useWebSearch,
                useAcademicSearch,
                systemPrompt,
                criticalThinkingEnabled,
                documentContextName
            });

            if (response && response.reply) {
                if (isMountedRef.current) {
                    setBotStatusPlaceholder(null);
                    setMessages(prev => [...prev, { ...response.reply, id: `bot-${Date.now()}` }]);
                }
            } else {
                throw new Error("Invalid response from AI service.");
            }
        } catch (error) {
            const errorText = error.response?.data?.message || error.message || 'Failed to get response from AI.';
            const errorReply = {
                id: `error-${Date.now()}`,
                sender: 'bot',
                role: 'model',
                text: `Error: ${errorText}`,
                parts: [{ text: `Error: ${errorText}` }],
                timestamp: new Date().toISOString(),
                source_pipeline: "error-pipeline"
            };
            if (isMountedRef.current) {
                setBotStatusPlaceholder(null);
                setMessages(prev => [...prev, errorReply]);
            }
            toast.error(errorText);
        } finally {
            simulationControllerRef.current.abort();
            if (isMountedRef.current) {
                onChatProcessingChange(false);
                setIsActuallySendingAPI(false);
            }
        }
    };

    return (
        <div className="flex flex-col h-full bg-background-light dark:bg-background-dark rounded-lg shadow-inner">
            {messages.length === 0 && !isActuallySendingAPI && currentSessionId ? (
                <div className="p-6 sm:p-8 text-center text-text-muted-light dark:text-text-muted-dark animate-fadeIn">
                    <h2 className="text-xl sm:text-2xl font-semibold mb-2 text-text-light dark:text-text-dark">AI Engineering Tutor</h2>
                    <p className="text-base sm:text-lg mb-3">Session ID: {currentSessionId.substring(0, 8)}...</p>
                    <div className="text-xs sm:text-sm space-y-1">
                        <p>Current LLM: <span className="font-semibold text-accent">{selectedLLM.toUpperCase()}</span>.</p>
                        <p className="max-w-md mx-auto">
                            Assistant Mode: <span className="italic">"{systemPrompt.length > 60 ? systemPrompt.substring(0, 60) + '...' : systemPrompt}"</span>
                        </p>
                        {(selectedSubject || selectedDocumentForAnalysis) && (
                            <p className="mt-1 font-medium">
                                Chat Focus: <span className="text-indigo-500 dark:text-indigo-400">{selectedSubject || selectedDocumentForAnalysis}</span>
                            </p>
                        )}
                    </div>
                </div>
            ) : null}

            <ChatHistory messages={messages} botStatusPlaceholder={botStatusPlaceholder} />

            <ChatInput
                onSendMessage={handleSendMessage}
                isLoading={isActuallySendingAPI}
                useWebSearch={useWebSearch}
                setUseWebSearch={setUseWebSearch}
                useAcademicSearch={useAcademicSearch} 
                setUseAcademicSearch={setUseAcademicSearch}
                criticalThinkingEnabled={criticalThinkingEnabled}
                setCriticalThinkingEnabled={setCriticalThinkingEnabled}
            />
        </div>
    );
}

export default CenterPanel;

```

`src/components/layout/LeftCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/LeftCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { Edit3, UploadCloud, FileText, ChevronRight, Settings2 } from 'lucide-react'; // Settings2 for fallback
import IconButton from '../core/IconButton.jsx'; 
import { motion } from 'framer-motion';

// Mapping icon names (or IDs) to Lucide components
const iconMap = {
    prompt: Edit3,       // Icon for "Custom Prompt"
    upload: UploadCloud, // Icon for "Upload Document"
    docs: FileText,      // Icon for "Document List"
};

function LeftCollapsedNav() {
    const { setIsLeftPanelOpen } = useAppState();

    // Define the items for the collapsed navigation bar
    const navItems = [
        { 
            id: 'prompt', 
            label: 'Custom Prompt', 
            iconName: 'prompt', // Matches key in iconMap
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, also scroll to/focus the prompt section in LeftPanel
            } 
        },
        { 
            id: 'upload', 
            label: 'Upload Document', 
            iconName: 'upload', 
            action: () => { 
                setIsLeftPanelOpen(true);
                // TODO: Optionally, open LeftPanel and focus/highlight upload area
            } 
        },
        { 
            id: 'docs', 
            label: 'Document List', 
            iconName: 'docs', 
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, open LeftPanel scrolled to document list
            } 
        },
    ];

    return (
        <motion.aside
            key="left-collapsed-nav" // Unique key for AnimatePresence
            initial={{ x: '-100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '-100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            // Styling for the thin vertical bar
            className="fixed left-0 top-16 bottom-0 z-30 w-14 sm:w-16 
                       bg-surface-light dark:bg-surface-dark 
                       border-r border-border-light dark:border-border-dark 
                       shadow-lg flex flex-col items-center py-3 space-y-2 custom-scrollbar"
        >
            {/* Button to open the full LeftPanel - Placed at the top */}
            <IconButton 
                icon={ChevronRight} 
                onClick={() => setIsLeftPanelOpen(true)} 
                title="Open Assistant Panel"
                ariaLabel="Open Assistant Panel"
                variant="ghost" 
                size="lg" // Make it prominent
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />

            {/* Icons for different sections of LeftPanel */}
            {navItems.map(item => {
                const IconComponent = iconMap[item.iconName] || Settings2; // Fallback icon
                return (
                    <IconButton 
                        key={item.id}
                        icon={IconComponent}
                        onClick={item.action} // Action currently just opens the panel
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md" 
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
            {/* Add a flexible spacer if you want the open button pushed further down from items */}
            {/* <div className="flex-grow"></div> */}
        </motion.aside>
    );
}
export default LeftCollapsedNav;
```

`src/components/layout/LeftPanel.jsx`

```javascript
// frontend/src/components/layout/LeftPanel.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import DocumentUpload from '../documents/DocumentUpload.jsx';
import DocumentList from '../documents/DocumentList.jsx';
import SubjectList from '../documents/SubjectList.jsx'; // <<< NEW IMPORT
import {
    PanelLeftClose, ChevronDown, ChevronUp, FilePlus, Settings2,
    Bot, BookOpen, Lightbulb, Library, Loader2, AlertTriangle // Added AlertTriangle
} from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';
import toast from 'react-hot-toast';
import api from '../../services/api.js'; // Main API service

const PROMPT_PRESETS = [
     { id: 'friendly_tutor', name: 'Friendly Tutor', icon: Bot, text: "You are a friendly, patient, and encouraging tutor specializing in engineering and scientific topics for PhD students. Explain concepts clearly, break down complex ideas, use analogies, and offer positive reinforcement. Ask follow-up questions to ensure understanding." },
     { id: 'concept_explorer', name: 'Concept Explorer', icon: BookOpen, text: "You are an expert academic lecturer introducing a new, complex engineering or scientific concept. Your goal is to provide a deep, structured explanation. Define terms rigorously, outline the theory, provide relevant mathematical formulations (using Markdown), illustrative examples, and discuss applications or limitations pertinent to PhD-level research." },
     { id: 'knowledge_check', name: 'Knowledge Check', icon: Lightbulb, text: "You are assessing understanding of engineering/scientific topics. Ask targeted questions to test knowledge, identify misconceptions, and provide feedback on the answers. Start by asking the user what topic they want to be quizzed on." },
     { id: 'custom', name: 'Custom Prompt', icon: Settings2, text: "You are a helpful AI engineering tutor." }
];

function LeftPanel() {
    const {
        setIsLeftPanelOpen,
        systemPrompt, setSystemPrompt,
        selectDocumentForAnalysis, selectedDocumentForAnalysis,
        selectedSubject, setSelectedSubject // AppState context will handle setting this
    } = useAppState();

    const [isPromptSectionOpen, setIsPromptSectionOpen] = useState(true);
    const [isSubjectSectionOpen, setIsSubjectSectionOpen] = useState(true);
    const [isDocManagementOpen, setIsDocManagementOpen] = useState(true);

    const [selectedPresetId, setSelectedPresetId] = useState('custom');
    const [availableSubjects, setAvailableSubjects] = useState([]);      // State to hold fetched subjects
    const [isLoadingSubjects, setIsLoadingSubjects] = useState(false);   // Loading state for subjects
    const [subjectFetchError, setSubjectFetchError] = useState('');     // Error state for subjects
    const [docListKey, setDocListKey] = useState(Date.now()); // For user's own DocumentList refresh

    useEffect(() => {
        const matchedPreset = PROMPT_PRESETS.find(p => p.text === systemPrompt);
        setSelectedPresetId(matchedPreset ? matchedPreset.id : 'custom');
    }, [systemPrompt]);

    // Fetch subjects (admin document names) on component mount
    const fetchSubjects = useCallback(async () => {
        setIsLoadingSubjects(true);
        setSubjectFetchError(''); // Clear previous errors
        try {
            const response = await api.getSubjects(); // Calls /api/subjects
            // The backend returns { subjects: ["Subject 1", "Subject 2", ...] }
            const subjects = Array.isArray(response.subjects) ? response.subjects : [];
            setAvailableSubjects(subjects);
            if (subjects.length === 0) {
                // FIX: Changed toast.info to just toast() for a standard informational message.
                toast("No admin-defined subjects found to select for chat focus.");
            }
        } catch (error) {
            const errorMsg = error.response?.data?.message || error.message || "Failed to load available subjects.";
            toast.error(errorMsg);
            setSubjectFetchError(errorMsg); // Store error message for display
            console.error("Error fetching subjects:", error);
        } finally {
            setIsLoadingSubjects(false);
        }
    }, []);

    useEffect(() => {
        fetchSubjects();
    }, [fetchSubjects]);

    const handlePresetChange = (event) => {
        const presetId = event.target.value;
        setSelectedPresetId(presetId);
        const selectedPreset = PROMPT_PRESETS.find(p => p.id === presetId);
        if (selectedPreset) setSystemPrompt(selectedPreset.text);
    };

    const handleUploadSuccessForUserDocs = () => {
        setDocListKey(Date.now());
        toast.success("Your document list refreshed after upload.");
    };

    // setSelectedSubject from AppStateContext is passed directly to SubjectList's onSelectSubject prop.

    const SelectedPresetIcon = PROMPT_PRESETS.find(p => p.id === selectedPresetId)?.icon || Settings2;

    return (
        <div className="flex flex-col h-full">
            <div className="flex items-center justify-between mb-3 px-1 pt-1">
                <h2 className="text-sm font-semibold text-text-light dark:text-text-dark">Assistant Controls</h2>
                <IconButton
                    icon={PanelLeftClose}
                    onClick={() => setIsLeftPanelOpen(false)}
                    title="Close Assistant Panel"
                    variant="ghost" size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                />
            </div>

            {/* Custom Prompt Section (Existing) */}
            <div className="mb-4">
                <button onClick={() => setIsPromptSectionOpen(!isPromptSectionOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark" aria-expanded={isPromptSectionOpen}>
                    <span className="flex items-center gap-2"><SelectedPresetIcon size={16} className="text-primary dark:text-primary-light" /> Custom Prompt</span>
                    {isPromptSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isPromptSectionOpen && (
                        <motion.div key="prompt-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden">
                            <label htmlFor="prompt-preset-select" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Prompt Mode:</label>
                             <select id="prompt-preset-select" value={selectedPresetId} onChange={handlePresetChange} className="input-field mb-2 text-xs py-1.5">
                                 {PROMPT_PRESETS.map(preset => (<option key={preset.id} value={preset.id}>{preset.name}</option>))}
                             </select>
                             <label htmlFor="system-prompt-area" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">System Prompt (Editable):</label>
                             <textarea id="system-prompt-area" value={systemPrompt} onChange={(e) => { setSystemPrompt(e.target.value); setSelectedPresetId('custom'); }} rows="5" className="input-field text-xs custom-scrollbar" placeholder="Enter system prompt..."/>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* --- NEW: Select Subject Section --- */}
            <div className="mb-4">
                <button
                    onClick={() => setIsSubjectSectionOpen(!isSubjectSectionOpen)}
                    className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark"
                    aria-expanded={isSubjectSectionOpen}
                >
                    <span className="flex items-center gap-2">
                        <Library size={16} className="text-primary dark:text-primary-light" /> Select Subject Focus
                    </span>
                    {isSubjectSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isSubjectSectionOpen && (
                        <motion.div
                            key="subject-select-content"
                            initial={{ height: 0, opacity: 0 }}
                            animate={{ height: 'auto', opacity: 1 }}
                            exit={{ height: 0, opacity: 0 }}
                            transition={{ duration: 0.2, ease: "easeInOut" }}
                            className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden"
                        >
                           {/* Using the new SubjectList component */}
                           <SubjectList
                                subjects={availableSubjects}
                                selectedSubject={selectedSubject}
                                onSelectSubject={setSelectedSubject} // Pass the setter from AppStateContext
                                isLoading={isLoadingSubjects}
                                error={subjectFetchError}
                           />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* Document Management Section (For REGULAR USER's own documents) */}
            <div className="flex-grow flex flex-col overflow-hidden">
                <button onClick={() => setIsDocManagementOpen(!isDocManagementOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-2" aria-expanded={isDocManagementOpen}>
                    <span className="flex items-center gap-2"><FilePlus size={16} className="text-primary dark:text-primary-light" /> My Documents (for Analysis Tools)</span>
                    {isDocManagementOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isDocManagementOpen && (
                        <motion.div key="doc-management-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="flex-grow flex flex-col overflow-hidden p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner">
                            <DocumentUpload onUploadSuccess={handleUploadSuccessForUserDocs} />
                            <div className="mt-3 flex-grow overflow-y-auto custom-scrollbar">
                                <DocumentList
                                    key={docListKey}
                                    onSelectDocument={selectDocumentForAnalysis}
                                    selectedDocument={selectedDocumentForAnalysis}
                                />
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default LeftPanel;

```

`src/components/layout/LLMSelectionModal.jsx`

```javascript
// frontend/src/components/layout/LLMSelectionModal.jsx
import React, { useState, useEffect } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { X, Save, KeyRound, AlertCircle, HardDrive } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import LLMSelection from '../auth/LLMSelection.jsx';
import { motion } from 'framer-motion';

function LLMSelectionModal({ isOpen, onClose }) {
    const { selectedLLM: currentLLM, switchLLM: setGlobalLLMPreference } = useAppState();
    
    // State for the provider selection
    const [locallySelectedLLM, setLocallySelectedLLM] = useState(currentLLM);
    
    // Separate state for each input field
    const [geminiApiKeyInput, setGeminiApiKeyInput] = useState('');
    const [ollamaUrlInput, setOllamaUrlInput] = useState('');
    
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        // Reset state every time the modal opens
        if (isOpen) {
            setLocallySelectedLLM(currentLLM);
            setGeminiApiKeyInput(''); 
            setOllamaUrlInput(''); 
            setError('');
        }
    }, [isOpen, currentLLM]);

    const handleSavePreference = async () => {
        setLoading(true); 
        setError('');
        
        try {
            // Start with the provider selection
            const configData = { llmProvider: locallySelectedLLM };

            // Only add other fields if the user actually typed something into them
            if (geminiApiKeyInput.trim()) {
                configData.apiKey = geminiApiKeyInput.trim();
            }
            if (ollamaUrlInput.trim()) {
                configData.ollamaUrl = ollamaUrlInput.trim();
            }
            
            await api.updateUserLLMConfig(configData);
            setGlobalLLMPreference(locallySelectedLLM);
            
            toast.success(`LLM preference updated to ${locallySelectedLLM.toUpperCase()}.`);
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update preference.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2 text-sm w-full";

    return (
         <Modal isOpen={isOpen} onClose={onClose} title="Switch LLM Provider & Credentials" size="lg"
            footerContent={
                <>
                    <Button onClick={onClose} variant="secondary" size="sm" className="text-xs">Cancel</Button>
                    <Button onClick={handleSavePreference} isLoading={loading} size="sm" className="text-xs">
                        <Save size={14} className="mr-1.5"/> Save Preference
                    </Button>
                </>
            }
        >
            <div className="space-y-5"> 
                <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                    Select your preferred LLM. You can also update your credentials here. <br/><strong>Leave a field blank to keep your existing setting.</strong>
                </p>
                <LLMSelection 
                    selectedLLM={locallySelectedLLM} 
                    onLlmChange={setLocallySelectedLLM}
                    disabled={loading}
                />
                
                <motion.div key="gemini-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalGeminiApiKey" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Gemini API Key (Optional)
                    </label>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input type="password" id="modalGeminiApiKey" className={inputFieldStyledClass} placeholder="Leave blank to keep existing key" value={geminiApiKeyInput} onChange={(e) => setGeminiApiKeyInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>
                
                <motion.div key="ollama-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalOllamaUrl" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Ollama URL (Optional)
                    </label>
                     <div className={inputWrapperClass}>
                        <HardDrive className={inputIconClass} />
                        <input type="text" id="modalOllamaUrl" className={inputFieldStyledClass} placeholder="Leave blank to keep existing URL" value={ollamaUrlInput} onChange={(e) => setOllamaUrlInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>

                {error && (
                    <div className="flex items-center gap-2 p-2 text-xs text-red-700 bg-red-100 dark:bg-red-900/30 dark:text-red-300 rounded-md">
                        <AlertCircle size={16} />
                        <span>{error}</span>
                    </div>
                )}
            </div>
        </Modal>
    );
}

export default LLMSelectionModal;
```

`src/components/layout/RightCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/RightCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { HelpCircle, GitFork, Tags, ChevronLeft } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

const iconMap = {
    HelpCircle: HelpCircle,
    Tags: Tags,
    GitFork: GitFork,
};

function RightCollapsedNav() {
    const { setIsRightPanelOpen } = useAppState();

    const navItems = [
        { id: 'faq', label: 'FAQ Generator', iconName: 'HelpCircle', action: () => { setIsRightPanelOpen(true); /* TODO: set analysis type contextually */ } },
        { id: 'topics', label: 'Key Topics Extractor', iconName: 'Tags', action: () => { setIsRightPanelOpen(true); } },
        { id: 'mindmap', label: 'Mind Map Creator', iconName: 'GitFork', action: () => { setIsRightPanelOpen(true); } },
    ];

    return (
        <motion.aside
            key="right-collapsed-nav"
            initial={{ x: '100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="fixed right-0 top-16 bottom-0 z-30 w-14 sm:w-16 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark shadow-lg flex-col items-center py-3 space-y-2 hidden md:flex"
        >
            {/* Open Panel Button AT THE TOP */}
            <IconButton 
                icon={ChevronLeft} 
                onClick={() => setIsRightPanelOpen(true)} 
                title="Open Analyzer Panel"
                ariaLabel="Open Analyzer Panel"
                variant="ghost" 
                size="lg"
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />
            {navItems.map(item => {
                 const Icon = iconMap[item.iconName] || HelpCircle;
                return (
                    <IconButton 
                        key={item.id}
                        icon={Icon}
                        onClick={item.action}
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
        </motion.aside>
    );
}
export default RightCollapsedNav;
```

`src/components/layout/RightPanel.jsx`

```javascript


// frontend/src/components/layout/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import AnalysisToolRunner from '../analysis/AnalysisToolRunner.jsx';
import PodcastGenerator from '../analysis/PodcastGenerator.jsx';
import KnowledgeGraphViewer from '../analysis/KnowledgeGraphViewer.jsx';
import api from '../../services/api.js';
import { PanelRightClose, ChevronDown, ChevronUp, Telescope, Radio, BrainCircuit } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';

function RightPanel() {
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    const [isKgModalOpen, setIsKgModalOpen] = useState(false);
    const [kgData, setKgData] = useState(null);
    const [isLoadingKg, setIsLoadingKg] = useState(false);

    const currentSelectedDocFilename = selectedDocumentForAnalysis || selectedSubject || null;
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    const handleVisualizeKg = async () => {
        if (!currentSelectedDocFilename) return;
        setIsKgModalOpen(true);
        setIsLoadingKg(true);
        setKgData(null);
        try {
            const data = await api.getKnowledgeGraph(currentSelectedDocFilename);
            if(data.error) {
                toast.error(`KG Error: ${data.error}`);
                setKgData({ error: data.error });
            } else {
                setKgData(data);
            }
        } catch (error) {
            const errorMessage = error.response?.data?.error || "Could not fetch knowledge graph.";
            toast.error(errorMessage);
            setKgData({ error: errorMessage });
        } finally {
            setIsLoadingKg(false);
        }
    };

    return (
        <>
            <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
                <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                    <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                    <IconButton
                        icon={PanelRightClose}
                        onClick={() => setIsRightPanelOpen(false)}
                        title="Close Analyzer Panel"
                        variant="ghost" size="sm"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                </div>
                
                {!currentSelectedDocFilename ? (
                    <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                        <p>Select a document from the left panel to enable analysis and generation tools.</p>
                    </div>
                ) : (
                    <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-1">
                        <div>
                            <button onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark">
                                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                            </button>
                            {isAnalyzerOpen && (
                                <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 space-y-3 overflow-hidden">
                                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                </motion.div>
                            )}
                        </div>
                        <div>
                            <div className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                               <span className="flex items-center gap-2"><Radio size={16} /> Content Exporters & Synthesis</span>
                            </div>
                             <div className="mt-2 space-y-3">
                                <PodcastGenerator selectedDocumentFilename={currentSelectedDocFilename} />
                                <Button onClick={handleVisualizeKg} variant="outline" size="sm" fullWidth isLoading={isLoadingKg} leftIcon={<BrainCircuit size={16} />}>
                                    Visualize Knowledge Graph
                                </Button>
                            </div>
                        </div>
                    </div>
                )}
            </div>

            <Modal isOpen={isKgModalOpen} onClose={() => setIsKgModalOpen(false)} title={`Knowledge Graph: ${currentSelectedDocFilename}`} size="5xl">
                <KnowledgeGraphViewer graphData={isLoadingKg ? null : kgData} />
            </Modal>
        </>
    );
}
export default RightPanel;
```

`src/components/layout/TopNav.jsx`

```javascript
// frontend/src/components/layout/TopNav.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import ThemeToggle from '../common/ThemeToggle.jsx';
import LLMSelectionModal from './LLMSelectionModal.jsx';
import ProfileSettingsModal from '../profile/ProfileSettingsModal.jsx';
import { Link } from 'react-router-dom';
import { 
    LogOut, User, MessageSquare, History as HistoryIcon, Settings, Cpu, Zap, ServerCrash, Server, Wrench 
} from 'lucide-react';
import ToolsModal from '../tools/ToolsModal.jsx'; 



function TopNav({ user: authUser, onLogout, onNewChat, onHistoryClick, orchestratorStatus, isChatProcessing  }) {
    const { selectedLLM, switchLLM } = useAppState();
    const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
    const [isToolsModalOpen, setIsToolsModalOpen] = useState(false); // <<< NEW STATE

    
    const [isProfileDropdownOpen, setIsProfileDropdownOpen] = useState(false);
    const profileDropdownRef = useRef(null);

    const getStatusIndicator = () => {
        if (!orchestratorStatus) return <div title="Status unavailable" className="w-4 h-4 bg-gray-400 rounded-full"></div>;
        if (orchestratorStatus.status === "ok") {
            return <Zap size={18} className="text-green-400 animate-pulse" title={`Backend Online: ${orchestratorStatus.message}`} />;
        } else if (orchestratorStatus.status === "loading") {
            return <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-yellow-400" title="Connecting..."></div>;
        } else {
            return <ServerCrash size={18} className="text-red-400" title={`Backend Offline: ${orchestratorStatus.message}`} />;
        }
    };
    
    useEffect(() => {
        function handleClickOutside(event) {
            if (profileDropdownRef.current && !profileDropdownRef.current.contains(event.target)) {
                setIsProfileDropdownOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [profileDropdownRef]);

    return (
        <>
            <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark shadow-sm h-16 flex items-center justify-between px-2 sm:px-4">
                <div className="flex items-center gap-2">
                    <a href="/" className="flex items-center gap-1.5 sm:gap-2 text-lg sm:text-xl font-semibold text-text-light dark:text-text-dark">
                        <Server size={24} className="text-primary dark:text-primary-light" />
                        <span className="hidden sm:inline">AI Tutor</span>
                    </a>
                </div>

                <div className="flex-1 flex justify-center px-2">
                    <div className="flex items-center gap-1 sm:gap-2">
                         <button
                            onClick={onNewChat}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Start a new chat session"
                        >
                            <MessageSquare size={14} /> <span className="hidden sm:inline">New Chat</span>
                        </button>
                        
                        <button
                            onClick={onHistoryClick}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="View chat history"
                        >
                            <HistoryIcon size={14} /> <span className="hidden sm:inline">History</span>
                        </button>

                         <button
                            onClick={() => setIsToolsModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-amber-400/20 dark:bg-amber-500/20 hover:bg-amber-400/30 dark:hover:bg-amber-500/30 text-amber-700 dark:text-amber-400 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Open Tools"
                        >
                            <Wrench size={14} /> <span className="hidden sm:inline">Tools</span>
                        </button>

                        <button
                            onClick={() => setIsLLMModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
                        >
                            <Cpu size={14} /> <span className="hidden xs:inline">{selectedLLM.toUpperCase()}</span>
                        </button>
                    </div>
                </div>

                <div className="flex items-center gap-1.5 sm:gap-2">
                    {/* --- FIX: Added a fixed-size wrapper div for the status indicator --- */}
                    <div className="w-8 h-8 flex items-center justify-center">
                        {getStatusIndicator()}
                    </div>
                    <ThemeToggle />
                    <div className="relative" ref={profileDropdownRef}>
                        <button 
                            onClick={() => setIsProfileDropdownOpen(prev => !prev)}
                            className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary"
                        >
                            <User size={18} />
                        </button>
                        <div 
                            className={`absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 transition-all duration-150 ease-in-out transform origin-top-right z-50
                                ${isProfileDropdownOpen 
                                    ? 'opacity-100 scale-100 visible' 
                                    : 'opacity-0 scale-95 invisible'
                                }`
                            }
                        >
                            <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-border-light dark:border-border-dark">
                                Signed in as <br/><strong>{authUser?.username || 'User'}</strong>
                            </div>
                            <button
                                onClick={() => { setIsProfileModalOpen(true); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
                            >
                                <Settings size={16} /> Profile
                            </button>
                            <button
                                onClick={() => { onLogout(); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
                            >
                                <LogOut size={16} /> Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
            <LLMSelectionModal 
                isOpen={isLLMModalOpen} 
                onClose={() => setIsLLMModalOpen(false)} 
                currentLLM={selectedLLM}
                onSelectLLM={(llm) => {
                    switchLLM(llm);
                    setIsLLMModalOpen(false);
                }}
            />
            <ProfileSettingsModal
                isOpen={isProfileModalOpen}
                onClose={() => setIsProfileModalOpen(false)}
            />
        </>
    );
}
export default TopNav;
```

`src/components/profile/ProfileSettingsModal.jsx`

```javascript
// frontend/src/components/profile/ProfileSettingsModal.jsx
import React, { useState, useEffect } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { Save, User, School, Hash, Award, Wrench, Calendar } from 'lucide-react';

const ProfileSettingsModal = ({ isOpen, onClose }) => {
    const [profile, setProfile] = useState({
        name: '',
        college: '',
        universityNumber: '',
        degreeType: '',
        branch: '',
        year: ''
    });
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        if (isOpen) {
            const fetchProfile = async () => {
                setIsLoading(true);
                setError('');
                try {
                    const data = await api.getUserProfile();
                    // Set profile data, ensuring defaults for any missing fields
                    setProfile({
                        name: data.name || '',
                        college: data.college || '',
                        universityNumber: data.universityNumber || '',
                        degreeType: data.degreeType || 'Bachelors', // Default value
                        branch: data.branch || 'Computer Science', // Default value
                        year: data.year || '1st Year' // Default value
                    });
                } catch (err) {
                    toast.error('Failed to load profile data.');
                    setError(err.message || 'Could not fetch profile.');
                } finally {
                    setIsLoading(false);
                }
            };
            fetchProfile();
        }
    }, [isOpen]);

    const handleChange = (e) => {
        const { name, value } = e.target;
        setProfile(prev => ({ ...prev, [name]: value }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        // Simple validation
        for (const key in profile) {
            if (!profile[key] || profile[key].trim() === '') {
                toast.error(`Please fill out the '${key.replace(/([A-Z])/g, ' $1').trim()}' field.`);
                return;
            }
        }
        setIsLoading(true);
        setError('');
        try {
            const response = await api.updateUserProfile(profile);
            toast.success(response.message || 'Profile updated successfully!');
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update profile.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark pointer-events-none";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm";
    const selectFieldStyledClass = "input-field !pl-10 !pr-8 py-2.5 text-sm";

    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title="Student Profile Settings"
            size="lg"
            footerContent={
                <>
                    <Button variant="ghost" onClick={onClose} disabled={isLoading}>Cancel</Button>
                    <Button onClick={handleSubmit} isLoading={isLoading} leftIcon={<Save size={16} />}>
                        Save Changes
                    </Button>
                </>
            }
        >
            <form onSubmit={handleSubmit} className="space-y-4">
                {error && <p className="text-sm text-red-500">{error}</p>}
                
                <div className={inputWrapperClass}>
                    <User className={inputIconClass} />
                    <input type="text" name="name" value={profile.name} onChange={handleChange} placeholder="Full Name" className={inputFieldStyledClass} required />
                </div>

                <div className={inputWrapperClass}>
                    <School className={inputIconClass} />
                    <input type="text" name="college" value={profile.college} onChange={handleChange} placeholder="College / Institution" className={inputFieldStyledClass} required />
                </div>
                
                <div className={inputWrapperClass}>
                    <Hash className={inputIconClass} />
                    <input type="text" name="universityNumber" value={profile.universityNumber} onChange={handleChange} placeholder="Registered University Number" className={inputFieldStyledClass} required />
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className={inputWrapperClass}>
                        <Award className={inputIconClass} />
                        <select name="degreeType" value={profile.degreeType} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="Bachelors">Bachelor's</option>
                            <option value="Masters">Master's</option>
                            <option value="PhD">PhD</option>
                            <option value="Diploma">Diploma</option>
                        </select>
                    </div>
                    
                    <div className={inputWrapperClass}>
                        <Wrench className={inputIconClass} />
                        <select name="branch" value={profile.branch} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="Computer Science">Computer Science</option>
                            <option value="Mechanical Engineering">Mechanical</option>
                            <option value="Electrical Engineering">Electrical</option>
                            <option value="Civil Engineering">Civil</option>
                            <option value="Electronics & Communication">Electronics & Comm.</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>

                    <div className={inputWrapperClass}>
                        <Calendar className={inputIconClass} />
                        <select name="year" value={profile.year} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="1st Year">1st Year</option>
                            <option value="2nd Year">2nd Year</option>
                            <option value="3rd Year">3rd Year</option>
                            <option value="4th Year">4th Year</option>
                            <option value="Final Year">Final Year</option>
                            <option value="Graduated">Graduated</option>
                        </select>
                    </div>
                </div>
            </form>
        </Modal>
    );
};

export default ProfileSettingsModal;
```

`src/components/tools/AIAssistantBot.jsx`

```javascript
// frontend/src/components/tools/AIAssistantBot.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle, Sparkles, X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import IconButton from '../core/IconButton';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantBot = ({ code, language }) => {
    const [isOpen, setIsOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [analysis, setAnalysis] = useState('');
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (isOpen && analysis && contentRef.current) {
            const timer = setTimeout(() => Prism.highlightAllUnder(contentRef.current), 50);
            return () => clearTimeout(timer);
        }
    }, [isOpen, analysis]);
    
    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <>
            <div className="fixed bottom-6 right-6 z-50">
                <motion.button
                    whileHover={{ scale: 1.1, backgroundColor: "var(--color-primary-dark)" }}
                    whileTap={{ scale: 0.9 }}
                    onClick={() => setIsOpen(true)}
                    title="AI Assistant"
                    className="bg-primary text-white rounded-full p-4 shadow-lg flex items-center justify-center"
                    style={{'--color-primary-dark': '#2563eb'}} // For tailwind color access in motion
                >
                    <Bot size={28} />
                </motion.button>
            </div>

            <AnimatePresence>
                {isOpen && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4"
                        onClick={() => setIsOpen(false)}
                    >
                        <motion.div
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            onClick={(e) => e.stopPropagation()}
                            className="bg-surface-light dark:bg-surface-dark w-full max-w-2xl h-[70vh] rounded-lg shadow-2xl flex flex-col"
                        >
                            <header className="flex items-center justify-between p-4 border-b border-border-light dark:border-border-dark">
                                <h3 className="font-semibold flex items-center gap-2 text-text-light dark:text-text-dark">
                                    <Sparkles className="text-primary"/> AI Assistant
                                </h3>
                                <IconButton icon={X} onClick={() => setIsOpen(false)} title="Close" />
                            </header>

                            <div className="p-4 flex-shrink-0">
                                <Button onClick={handleAnalyze} size="sm" variant="primary" isLoading={isLoading} disabled={!code.trim()}>
                                    Analyze Current Code
                                </Button>
                            </div>
                            
                            <div className="flex-grow p-4 border-t border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                                {isLoading && (
                                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                                    </div>
                                )}
                                {error && !isLoading && (
                                    <div className="p-3 text-red-400 text-sm"><AlertTriangle className="inline mr-2" />{error}</div>
                                )}
                                {!isLoading && !error && !analysis && (
                                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                                        Click "Analyze Code" to get an AI-powered review.
                                    </div>
                                )}
                                {analysis && !isLoading && (
                                    <div 
                                        ref={contentRef}
                                        className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark"
                                        dangerouslySetInnerHTML={createMarkup(analysis)}
                                    />
                                )}
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

export default AIAssistantBot;
```

`src/components/tools/AIAssistantPanel.jsx`

```javascript
// frontend/src/components/tools/AIAssistantPanel.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle } from 'lucide-react';
import Button from '../core/Button.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantPanel = ({ code, language }) => {
    const [analysis, setAnalysis] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (analysis && contentRef.current) {
            const timer = setTimeout(() => {
                Prism.highlightAllUnder(contentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [analysis]);

    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="p-4 h-full flex flex-col bg-surface-light dark:bg-surface-dark">
            <h3 className="text-lg font-semibold mb-2 flex items-center justify-between">
                <span className="flex items-center gap-2">
                    <Bot className="text-primary"/> AI Assistant
                </span>
                <Button onClick={handleAnalyze} size="sm" variant="outline" isLoading={isLoading} disabled={!code.trim()}>
                    Analyze Code
                </Button>
            </h3>
            <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 rounded-md p-1 border border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                {isLoading && (
                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                    </div>
                )}
                {error && !isLoading && (
                    <div className="p-3 text-red-400 text-sm">
                        <AlertTriangle className="inline mr-2" /> {error}
                    </div>
                )}
                {!isLoading && !error && !analysis && (
                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                        Click "Analyze Code" to get an AI-powered review of your code.
                    </div>
                )}
                {analysis && !isLoading && (
                    <div 
                        ref={contentRef}
                        className="prose prose-sm dark:prose-invert max-w-none p-3 text-text-light dark:text-text-dark"
                        dangerouslySetInnerHTML={createMarkup(analysis)}
                    />
                )}
            </div>
        </div>
    );
};

export default AIAssistantPanel;
```

`src/components/tools/CodeEditor.jsx`

```javascript
// frontend/src/components/tools/CodeEditor.jsx
import React from 'react';
import Editor from '@monaco-editor/react';
import { useTheme } from '../../hooks/useTheme';
import { Loader2 } from 'lucide-react';

const CodeEditor = ({ code, setCode, language }) => {
    const { theme } = useTheme();

    const handleEditorChange = (value) => {
        setCode(value || '');
    };

    return (
        <div className="h-full w-full border border-border-light dark:border-border-dark rounded-lg overflow-hidden shadow-inner">
            <Editor
                height="100%"
                language={language}
                value={code}
                onChange={handleEditorChange}
                theme={theme === 'dark' ? 'vs-dark' : 'light'}
                loading={<Loader2 className="animate-spin text-primary" />}
                options={{
                    fontSize: 14,
                    minimap: { enabled: true },
                    contextmenu: true,
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    automaticLayout: true,
                }}
            />
        </div>
    );
};

export default CodeEditor;
```

`src/components/tools/CodeEditorWrapper.jsx`

```javascript
// frontend/src/components/tools/CodeEditorWrapper.jsx
import React, { useState } from 'react';
import { Play, Copy, ChevronDown, Check } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '../core/Button';
import IconButton from '../core/IconButton';
import CodeEditor from './CodeEditor';
import toast from 'react-hot-toast';

const CodeEditorWrapper = ({ code, setCode, language, setLanguage, onExecute, isExecuting }) => {
    
    const [copied, setCopied] = useState(false);

    const handleCopy = () => {
        navigator.clipboard.writeText(code).then(() => {
            toast.success("Code copied to clipboard!");
            setCopied(true);
            setTimeout(() => setCopied(false), 2000); // Reset after 2 seconds
        }, () => {
            toast.error("Failed to copy code.");
        });
    };
    
    return (
        <div className="flex flex-col h-full bg-surface-light dark:bg-surface-dark rounded-lg border border-border-light dark:border-border-dark">
            <header className="flex items-center justify-between p-2 border-b border-border-light dark:border-border-dark flex-shrink-0">
                <div className="relative">
                    <select 
                        value={language}
                        onChange={(e) => setLanguage(e.target.value)}
                        className="input-field !text-xs !py-1 !pl-3 !pr-8 appearance-none"
                    >
                        <option value="python">Python</option>
                        <option value="java">Java</option>
                        <option value="c">C</option>
                        <option value="cpp">C++</option>
                    </select>
                    <ChevronDown size={14} className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
                <div className="flex items-center gap-2">
                    <IconButton 
                        icon={() => (
                            <AnimatePresence mode="wait" initial={false}>
                                <motion.span
                                    key={copied ? 'check' : 'copy'}
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.8 }}
                                    transition={{ duration: 0.15 }}
                                >
                                    {copied ? <Check className="text-green-500" /> : <Copy />}
                                </motion.span>
                            </AnimatePresence>
                        )} 
                        size="sm" 
                        onClick={handleCopy} 
                        title="Copy Code" 
                    />
                    <Button onClick={onExecute} size="sm" leftIcon={<Play size={14}/>} isLoading={isExecuting}>
                        Run
                    </Button>
                </div>
            </header>
            <div className="flex-grow overflow-hidden">
                <CodeEditor code={code} setCode={setCode} language={language} />
            </div>
        </div>
    );
};

export default CodeEditorWrapper;
```

`src/components/tools/CodeExecutorPage.jsx`

```javascript
// frontend/src/components/tools/CodeExecutorPage.jsx
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { Home } from 'lucide-react';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
import CodeEditorWrapper from './CodeEditorWrapper';
import TestCaseManager from './TestCaseManager';
import OutputDisplay from './OutputDisplay';
import AIAssistantBot from './AIAssistantBot';
import api from '../../services/api';
import toast from 'react-hot-toast';

const starterCode = {
    python: `# Welcome to the Code Executor!\n# Write your Python code here.\n\ndef main():\n    # Example: Read two numbers and print their sum\n    try:\n        line1 = input()\n        line2 = input()\n        print(int(line1) + int(line2))\n    except (ValueError, EOFError):\n        print("Invalid input.")\n\nif __name__ == "__main__":\n    main()\n`,
    java: `// Welcome to the Code Executor!\n// Your public class must be named "Main".\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        System.out.println(a + b);\n        sc.close();\n    }\n}\n`,
    c: `// Welcome to the Code Executor!\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    if (scanf("%d %d", &a, &b) == 2) {\n        printf("%d\\n", a + b);\n    }\n    return 0;\n}\n`,
    cpp: `// Welcome to the Code Executor!\n#include <iostream>\n\nint main() {\n    int a, b;\n    if (std::cin >> a >> b) {\n        std::cout << a + b << std::endl;\n    }\n    return 0;\n}\n`
};

const CodeExecutorPage = () => {
    const [language, setLanguage] = useState('python');
    const [code, setCode] = useState(starterCode.python);
    const [testCases, setTestCases] = useState([
        { input: '5\n10', expectedOutput: '15' }
    ]);
    const [results, setResults] = useState([]);
    const [compilationError, setCompilationError] = useState(null);
    const [isExecuting, setIsExecuting] = useState(false);

    const handleLanguageChange = (newLanguage) => {
        setLanguage(newLanguage);
        setCode(starterCode[newLanguage] || '');
    };

    const handleExecute = async () => {
        setIsExecuting(true);
        setResults([]);
        setCompilationError(null);
        const toastId = toast.loading('Executing code...');

        try {
            const response = await api.executeCode({ language, code, testCases });
            
            if (response.compilationError) {
                setCompilationError(response.compilationError);
                toast.error("Code failed to compile.", { id: toastId });
            } else {
                setResults(response.results);
                const failures = response.results.filter(r => r.status !== 'pass').length;
                if (failures > 0) {
                    toast.error(`${failures} test case(s) failed or had errors.`, { id: toastId });
                } else {
                    toast.success('All test cases passed!', { id: toastId });
                }
            }

        } catch (error) {
            const errorMessage = error.response?.data?.message || "An unknown error occurred.";
            setCompilationError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsExecuting(false);
        }
    };

    return (
        <div className="flex flex-col h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark font-sans">
            <header className="flex-shrink-0 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark h-16 flex items-center justify-between px-6 z-10">
                <h1 className="text-xl font-bold">Secure Code Executor</h1>
                <Link to="/" className="flex items-center gap-2 text-sm btn btn-ghost">
                    <Home size={16}/>
                    Back to Main App
                </Link>
            </header>

            <div className="flex-1 overflow-hidden">
                <PanelGroup direction="horizontal">
                    <Panel defaultSize={65} minSize={30}>
                        <PanelGroup direction="vertical">
                            <Panel defaultSize={60} minSize={20}>
                                <div className="p-1 md:p-2 h-full">
                                    <CodeEditorWrapper
                                        code={code} setCode={setCode}
                                        language={language} setLanguage={handleLanguageChange}
                                        onExecute={handleExecute} isExecuting={isExecuting}
                                    />
                                </div>
                            </Panel>
                            <PanelResizeHandle className="h-2 panel-resize-handle" />
                            <Panel defaultSize={40} minSize={20}>
                                <OutputDisplay
                                    results={results}
                                    compilationError={compilationError}
                                    code={code}
                                    language={language}
                                />
                            </Panel>
                        </PanelGroup>
                    </Panel>
                    <PanelResizeHandle className="w-2 panel-resize-handle" />
                    <Panel defaultSize={35} minSize={25}>
                         <TestCaseManager 
                            testCases={testCases} 
                            setTestCases={setTestCases}
                            code={code}
                            language={language}
                        />
                    </Panel>
                </PanelGroup>
            </div>
            
            <AIAssistantBot code={code} language={language} />
        </div>
    );
};

export default CodeExecutorPage;
```

`src/components/tools/OutputDisplay.jsx`

```javascript
// frontend/src/components/tools/OutputDisplay.jsx
import React, { useState } from 'react';
import { CheckCircle, XCircle, AlertTriangle, Clock, Sparkles, Loader2 } from 'lucide-react';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};


const OutputDisplay = ({ results, compilationError, code, language }) => {
    const [explanations, setExplanations] = useState({});
    const [isLoadingExplanation, setIsLoadingExplanation] = useState(null); // Tracks index

    const handleExplainError = async (index, errorMessage) => {
        setIsLoadingExplanation(index);
        try {
            const response = await api.explainError({ code, language, errorMessage });
            setExplanations(prev => ({ ...prev, [index]: response.explanation }));
        } catch (err) {
            toast.error(err.response?.data?.message || "Failed to get explanation.");
        } finally {
            setIsLoadingExplanation(null);
        }
    };

    if (compilationError) {
        return (
            <div className="p-4 bg-red-900/10 text-red-400 border-t border-red-500/30 h-full flex flex-col">
                <h3 className="text-lg font-semibold mb-2 flex items-center gap-2"><AlertTriangle /> Compilation Error</h3>
                <pre className="flex-grow bg-red-900/20 p-4 rounded-md text-xs whitespace-pre-wrap font-mono overflow-auto custom-scrollbar">{compilationError}</pre>
            </div>
        );
    }
    
    if (!results || results.length === 0) {
        return (
            <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark border-t border-border-light dark:border-border-dark h-full flex items-center justify-center">
                <p>Run the code to see the output and test case results here.</p>
            </div>
        );
    }

    const getStatusIcon = (status) => {
        if (status === 'pass') return <CheckCircle className="text-green-500" />;
        if (status === 'fail') return <XCircle className="text-yellow-500" />;
        return <AlertTriangle className="text-red-500" />;
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark border-t border-border-light dark:border-border-dark h-full flex flex-col">
            <h3 className="text-lg font-semibold mb-3 flex-shrink-0">Execution Results</h3>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {results.map((res, index) => (
                    <div key={index} className="p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex justify-between items-center mb-2">
                            <h4 className="font-semibold flex items-center gap-2">
                                {getStatusIcon(res.status)}
                                Test Case #{index + 1}: <span className="uppercase">{res.status}</span>
                            </h4>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-xs">
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Input:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.input || '(empty)'}</pre>
                            </div>
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Expected Output:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.expected || '(empty)'}</pre>
                            </div>
                            <div className="md:col-span-2">
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Actual Output:</strong>
                                <pre className={`p-2 rounded whitespace-pre-wrap font-mono ${res.status === 'pass' ? 'bg-green-900/20' : 'bg-yellow-900/20'}`}>{res.output || '(empty)'}</pre>
                            </div>
                            {res.error && (
                                <div className="md:col-span-2">
                                    <div className="flex justify-between items-center">
                                        <strong className="block mb-1 text-red-500 dark:text-red-400">Error:</strong>
                                        {!explanations[index] && (
                                            <Button size="sm" variant="ghost" className="!text-xs" leftIcon={<Sparkles size={12}/>} onClick={() => handleExplainError(index, res.error)} isLoading={isLoadingExplanation === index}>
                                                Explain Error
                                            </Button>
                                        )}
                                    </div>
                                    <pre className="bg-red-900/20 p-2 rounded text-red-400 whitespace-pre-wrap font-mono">{res.error}</pre>
                                </div>
                            )}
                            {isLoadingExplanation === index && (
                                <div className="md:col-span-2 p-3 text-sm text-center text-text-muted-light dark:text-text-muted-dark"><Loader2 className="animate-spin inline mr-2"/>AI is explaining the error...</div>
                            )}
                            {explanations[index] && (
                                <div className="md:col-span-2 mt-2 p-3 bg-primary/10 rounded-md border border-primary/30">
                                    <h5 className="font-bold text-sm mb-1 text-primary dark:text-primary-light flex items-center gap-1.5"><Sparkles size={14}/> AI Explanation</h5>
                                    <div className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark" dangerouslySetInnerHTML={createMarkup(explanations[index])} />
                                </div>
                            )}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default OutputDisplay;
```

`src/components/tools/TestCaseManager.jsx`

```javascript
// frontend/src/components/tools/TestCaseManager.jsx
import React, { useState } from 'react';
import { Plus, Trash2, Sparkles } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';

const TestCaseManager = ({ testCases, setTestCases, code, language }) => {
    const [isGenerating, setIsGenerating] = useState(false);

    const addTestCase = () => {
        const lastTestCase = testCases[testCases.length - 1];
        if (testCases.length > 0 && lastTestCase.input.trim() === '' && lastTestCase.expectedOutput.trim() === '') {
            toast.error('Please fill out the current empty test case first.');
            return;
        }
        setTestCases([...testCases, { input: '', expectedOutput: '' }]);
    };

    const removeTestCase = (index) => {
        const newTestCases = testCases.filter((_, i) => i !== index);
        setTestCases(newTestCases);
    };

    const updateTestCase = (index, field, value) => {
        const newTestCases = [...testCases];
        newTestCases[index][field] = value;
        setTestCases(newTestCases);
    };

    const handleGenerateCases = async () => {
        if (!code.trim()) {
            toast.error("There is no code to generate test cases for.");
            return;
        }
        setIsGenerating(true);
        const toastId = toast.loading("AI is generating test cases...");
        try {
            const response = await api.generateTestCases({ code, language });
            if (response.testCases && Array.isArray(response.testCases) && response.testCases.length > 0) {
                setTestCases(response.testCases);
                toast.success('AI generated a new set of test cases!', { id: toastId });
            } else {
                toast.error("The AI could not generate valid test cases.", { id: toastId });
            }
        } catch (err) {
             const errorMessage = err.response?.data?.message || "Failed to generate test cases.";
             toast.error(errorMessage, { id: toastId });
        } finally {
            setIsGenerating(false);
        }
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark h-full flex flex-col">
            <div className="flex items-center justify-between mb-3 flex-shrink-0">
                <h3 className="text-lg font-semibold">Test Cases</h3>
                <div className="flex items-center gap-2">
                    <Button onClick={addTestCase} size="sm" variant="outline" leftIcon={<Plus size={14}/>}>
                        Add Case
                    </Button>
                    <Button onClick={handleGenerateCases} size="sm" variant="outline" leftIcon={<Sparkles size={14} />} isLoading={isGenerating} disabled={!code.trim()}>
                            Generate by AI
                    </Button>
                </div>
            </div>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {testCases.map((tc, index) => (
                    <div key={index} className="flex flex-col md:flex-row gap-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Input (stdin)</label>
                            <textarea
                                value={tc.input}
                                onChange={(e) => updateTestCase(index, 'input', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter input, separate lines with \n"
                            />
                        </div>
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Expected Output (stdout)</label>
                            <textarea
                                value={tc.expectedOutput}
                                onChange={(e) => updateTestCase(index, 'expectedOutput', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter expected exact output"
                            />
                        </div>
                        <div className="flex items-end">
                            <IconButton icon={Trash2} variant="danger" size="sm" onClick={() => removeTestCase(index)} title="Remove Test Case" />
                        </div>
                    </div>
                ))}
                {testCases.length === 0 && (
                    <div className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-8">
                        Add a test case to begin.
                    </div>
                )}
            </div>
        </div>
    );
};

export default TestCaseManager;
```

`src/components/tools/ToolsModal.jsx`

```javascript
// frontend/src/components/tools/ToolsModal.jsx
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import Modal from '../core/Modal';
import { Code, TestTubeDiagonal } from 'lucide-react'; // Add more icons as you add tools
const availableTools = [
    {
    title: 'Secure Code Executor',
    description: 'Write, compile, and run code in a sandboxed environment with AI assistance.',
    icon: Code,
    path: '/tools/code-executor',
    status: 'active'
    },
    {
    title: 'API Endpoint Tester',
    description: 'A tool for testing and validating API endpoints will be available soon.',
    icon: TestTubeDiagonal,
    path: '#',
    status: 'soon'
    },
// Add more tools here in the future
];
const ToolsModal = ({ isOpen, onClose }) => {
    const navigate = useNavigate();
    const handleNavigate = (path) => {
        if (path !== '#') {
            onClose();
            navigate(path);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Developer Tools" size="2xl">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {availableTools.map((tool) => (
                    <div
                        key={tool.title}
                        onClick={() => handleNavigate(tool.path)}
                        className={`p-4 border rounded-lg transition-all duration-150 group relative
                            ${tool.status === 'active' 
                                ? 'cursor-pointer hover:border-primary dark:hover:border-primary-light hover:shadow-lg' 
                                : 'opacity-50 cursor-not-allowed'
                            }
                            bg-surface-light dark:bg-gray-800 border-border-light dark:border-border-dark
                        `}
                    >
                        {tool.status === 'soon' && (
                            <span className="absolute top-2 right-2 text-xs bg-yellow-400/20 text-yellow-500 font-semibold px-2 py-0.5 rounded-full">
                                Coming Soon
                            </span>
                        )}
                        <div className="flex items-center mb-2">
                            <tool.icon size={22} className="mr-3 text-primary dark:text-primary-light" />
                            <h3 className="font-semibold text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light">
                                {tool.title}
                            </h3>
                        </div>
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                            {tool.description}
                        </p>
                    </div>
                ))}
            </div>
        </Modal>
    );
};


export default ToolsModal;
```

`src/contexts/AppStateContext.jsx`

```javascript
import React, { createContext, useState, useContext, useEffect } from 'react';

export const AppStateContext = createContext(null);

export const useAppState = () => {
    const context = useContext(AppStateContext);
    if (!context) throw new Error('useAppState must be used within an AppStateProvider');
    return context;
};

const defaultSystemPromptText = "You are a helpful AI engineering tutor.";

export const AppStateProvider = ({ children }) => {
    const [theme, setThemeState] = useState(() => {
        const storedTheme = localStorage.getItem('theme') || 'dark';
        if (typeof window !== 'undefined') {
            document.documentElement.classList.remove('light', 'dark');
            document.documentElement.classList.add(storedTheme);
        }
        return storedTheme;
    });

    const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'gemini');
    const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
    const [isRightPanelOpen, setIsRightPanelOpen] = useState(true);

    const [currentSessionId, setCurrentSessionIdState] = useState(() => {
        return localStorage.getItem('aiTutorSessionId') || null;
    });
    const [systemPrompt, setSystemPromptState] = useState(
        localStorage.getItem('aiTutorSystemPrompt') || defaultSystemPromptText
    );

    const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null);
    const [selectedSubject, setSelectedSubjectState] = useState(
        localStorage.getItem('aiTutorSelectedSubject') || null
    );

    const [isAdminSessionActive, setIsAdminSessionActiveState] = useState(() => {
        return sessionStorage.getItem('isAdminSessionActive') === 'true';
    });

    const toggleTheme = () => {
        setThemeState(prevTheme => {
            const newTheme = prevTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            return newTheme;
        });
    };

    const switchLLM = (llm) => {
         setSelectedLLM(llm);
         localStorage.setItem('selectedLLM', llm);
         console.log("AppStateContext: Switched LLM to:", llm);
    };

    const setSessionId = (sessionId) => {
        if (sessionId) {
            localStorage.setItem('aiTutorSessionId', sessionId);
        } else {
            console.log("AppStateContext: Clearing session and related context (logout).");
            localStorage.removeItem('aiTutorSessionId');
            
            localStorage.removeItem('aiTutorSelectedSubject'); 
            setSelectedSubjectState(null);
            
            setSelectedDocumentForAnalysisState(null);
        }
        setCurrentSessionIdState(sessionId);
        console.log("AppStateContext: Regular user session ID updated to:", sessionId);
    };

    const setSystemPrompt = (promptText) => {
        setSystemPromptState(promptText);
        localStorage.setItem('aiTutorSystemPrompt', promptText);
    };

    const selectDocumentForAnalysis = (documentFilename) => {
        setSelectedDocumentForAnalysisState(documentFilename);
        console.log("AppStateContext: Document for analysis tools set to:", documentFilename || "None");
        if (documentFilename && selectedSubject !== documentFilename) {
            if (selectedSubject !== null) {
                console.log("AppStateContext: Clearing selected subject because a specific user document was chosen for analysis tools.");
                setSelectedSubjectState(null);
                localStorage.removeItem('aiTutorSelectedSubject');
            }
        }
    };

    const setSelectedSubject = (subjectName) => {
        const newSubject = subjectName === "none" || !subjectName ? null : subjectName;
        if (newSubject) {
            localStorage.setItem('aiTutorSelectedSubject', newSubject);
        } else {
            localStorage.removeItem('aiTutorSelectedSubject');
        }
        setSelectedSubjectState(newSubject);
        console.log("AppStateContext: Selected subject (for chat RAG) updated to:", newSubject || "None");

        setSelectedDocumentForAnalysisState(newSubject);
        if (newSubject) {
             console.log("AppStateContext: Also set document for analysis tools to (admin subject):", newSubject);
        } else {
            if (selectedDocumentForAnalysis === subjectName) {
                 setSelectedDocumentForAnalysisState(null);
                 console.log("AppStateContext: Cleared document for analysis tools as linked subject was cleared.");
            }
        }
    };

    const setIsAdminSessionActive = (isActive) => {
        if (isActive) {
            sessionStorage.setItem('isAdminSessionActive', 'true');
            setSessionId(null); 
        } else {
            sessionStorage.removeItem('isAdminSessionActive');
        }
        setIsAdminSessionActiveState(isActive);
        console.log("AppStateContext: Admin session active status set to:", isActive);
    };

    useEffect(() => {
        const rootHtmlElement = document.documentElement;
        rootHtmlElement.classList.remove('light', 'dark');
        rootHtmlElement.classList.add(theme);
        document.body.className = '';
        document.body.classList.add(theme === 'dark' ? 'bg-background-dark' : 'bg-background-light');
    }, [theme]);

    return (
        <AppStateContext.Provider value={{
            theme, toggleTheme,
            selectedLLM, switchLLM,
            isLeftPanelOpen, setIsLeftPanelOpen,
            isRightPanelOpen, setIsRightPanelOpen,
            currentSessionId, setSessionId,
            systemPrompt, setSystemPrompt,
            selectedDocumentForAnalysis, selectDocumentForAnalysis,
            selectedSubject, setSelectedSubject,
            isAdminSessionActive, setIsAdminSessionActive
        }}>
            {children}
        </AppStateContext.Provider>
    );
};
```

`src/contexts/AuthContext.jsx`

```javascript
// frontend/src/contexts/AuthContext.jsx
import React, { createContext, useState, useEffect, useCallback } from 'react';
import api from '../services/api.js'; 
import toast from 'react-hot-toast';

export const AuthContext = createContext(null);

export const DEV_MODE_ALLOW_DEV_LOGIN = false;

export const AuthProvider = ({ children }) => {
    const [token, setTokenState] = useState(localStorage.getItem('authToken'));
    const [user, setUserState] = useState(null);
    const [loading, setLoading] = useState(true);

    const setToken = (newToken) => {
        if (newToken) localStorage.setItem('authToken', newToken);
        else localStorage.removeItem('authToken');
        setTokenState(newToken);
    };

    const setUser = (newUser) => setUserState(newUser);
    
    const processAuthData = useCallback((authApiResponse) => {
        if (authApiResponse && authApiResponse.token && authApiResponse._id && authApiResponse.email) {
            setToken(authApiResponse.token);
            setUser({ id: authApiResponse._id, email: authApiResponse.email, username: authApiResponse.username });
             console.log("AuthContext: User and Token set.", { email: authApiResponse.email, username: authApiResponse.username });
            return authApiResponse; 
        } else {
            setToken(null);
            setUser(null);
            console.error("AuthContext: processAuthData received incomplete data for a regular user.", authApiResponse);
            throw new Error("Authentication response from server was incomplete for a regular user.");
        }
    }, []);

    useEffect(() => {
        const verifyTokenAndLoadUser = async () => {
            const storedToken = localStorage.getItem('authToken');
            if (storedToken) {
                setTokenState(storedToken);
                try {
                    const userDataFromMe = await api.getMe();
                    if (userDataFromMe && userDataFromMe._id && userDataFromMe.email) {
                        setUser({ id: userDataFromMe._id, email: userDataFromMe.email, username: userDataFromMe.username });
                    } else {
                        setToken(null);
                        setUser(null);
                    }
                } catch (error) {
                    setToken(null);
                    setUser(null);
                }
            }
            setLoading(false);
        };
        verifyTokenAndLoadUser();
    }, []);

    const login = async (credentials) => {
        setLoading(true);
        try {
            const data = await api.login(credentials);
            if (data && data.isAdminLogin) {
                return data;
            }
            return processAuthData(data);
        } catch (error) {
            setToken(null); 
            setUser(null);
            throw error; 
        } finally {
            setLoading(false);
        }
    };
    
    const signup = async (signupData) => {
        setLoading(true);
        try {
            const data = await api.signup(signupData);
            return processAuthData(data); 
        } catch (error) {
            setToken(null);
            setUser(null);
            throw error;
        } finally {
            setLoading(false);
        }
    };

    const logout = () => {
        console.log("AuthContext: Logging out user.");
        setToken(null); 
        setUser(null);
        toast.success("You have been logged out.");
    };

    return (
        <AuthContext.Provider value={{ token, user, loading, login, signup, logout, setUser }}>
            {children}
        </AuthContext.Provider>
    );
};
```

`src/hooks/useAuth.jsx`

```javascript
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
```

`src/hooks/useTextToSpeech.js`

```javascript
// src/hooks/useTextToSpeech.js
import { useState, useEffect, useCallback, useRef } from 'react';
import { marked } from 'marked'; // To parse markdown for plain text

// Configure marked (if not already globally configured for this specific use)
// It's generally better if marked is configured once, e.g. in MessageBubble or a central place.
// Assuming marked is available and configured.

const getPlainTextFromMarkdown = (markdown) => {
  if (!markdown) return '';
  try {
    // A simpler approach for plain text extraction for TTS:
    // Render to a temporary element and get its text content.
    // This handles complex markdown structures reasonably well for speech.
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = marked.parse(markdown); // marked.parse() is synchronous
    let text = tempDiv.textContent || tempDiv.innerText || '';
    
    // Basic cleanup: remove excessive newlines/spaces that might make speech awkward
    text = text.replace(/\n+/g, ' '); // Replace newlines with spaces
    text = text.replace(/\s\s+/g, ' '); // Replace multiple spaces with single
    return text.trim();
  } catch (error) {
    console.error("Error parsing markdown for TTS:", error);
    return markdown; // Fallback to raw markdown if parsing fails
  }
};


export const useTextToSpeech = () => {
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isSupported, setIsSupported] = useState(false);
    const utteranceRef = useRef(null);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.speechSynthesis) {
            setIsSupported(true);
        }

        const handleEnd = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        
        const synth = window.speechSynthesis;
        if (synth) {
            // Add event listeners if needed, but onend on utterance is usually sufficient
        }

        return () => {
            if (synth) {
                synth.cancel(); // Cancel any speech on component unmount or hook cleanup
            }
        };
    }, []);

    const speak = useCallback(({ text, lang = 'en-US', voiceURI = null, rate = 1, pitch = 1, volume = 1 }) => {
        if (!isSupported || !text) return;

        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel(); // Stop any currently playing speech
        }
        
        const plainText = getPlainTextFromMarkdown(text);
        if (!plainText) {
            console.warn("TTS: No text content to speak after parsing markdown.");
            return;
        }

        const newUtterance = new SpeechSynthesisUtterance(plainText);
        newUtterance.lang = lang;
        newUtterance.rate = rate;
        newUtterance.pitch = pitch;
        newUtterance.volume = volume;

        if (voiceURI) {
            const voices = synth.getVoices();
            const selectedVoice = voices.find(voice => voice.voiceURI === voiceURI);
            if (selectedVoice) {
                newUtterance.voice = selectedVoice;
            }
        }
        
        newUtterance.onstart = () => {
            setIsSpeaking(true);
        };
        newUtterance.onend = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        newUtterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            setIsSpeaking(false);
            utteranceRef.current = null;
        };

        utteranceRef.current = newUtterance;
        synth.speak(newUtterance);
    }, [isSupported]);

    const cancel = useCallback(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel();
        }
        // onend should fire and set isSpeaking to false.
        // If it doesn't (e.g. cancel is abrupt), manually reset:
        if (isSpeaking) {
            setIsSpeaking(false);
            utteranceRef.current = null;
        }
    }, [isSupported, isSpeaking]);

    // Optional: Get available voices
    const getVoices = useCallback(() => {
        if (!isSupported) return [];
        return window.speechSynthesis.getVoices();
    }, [isSupported]);

    // Voices might load asynchronously. Listen for 'voiceschanged' event.
    useEffect(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        const loadVoices = () => {
            // You might want to store voices in state if your UI allows voice selection
            // console.log("Voices loaded:", synth.getVoices());
        };
        synth.addEventListener('voiceschanged', loadVoices);
        // Initial load if voices are already available
        if (synth.getVoices().length > 0) {
            loadVoices();
        }
        return () => synth.removeEventListener('voiceschanged', loadVoices);
    }, [isSupported]);


    return {
        speak,
        cancel,
        isSpeaking,
        isSupported,
        getVoices,
        currentlySpeakingUtterance: utteranceRef.current
    };
};
```

`src/hooks/useTheme.js`

```javascript
// import { useContext } from 'react';
// import { AppStateContext } from '../contexts/AppStateContext'; // Assuming theme is in AppStateContext

// export const useTheme = () => {
//     const context = useContext(AppStateContext);
//     if (!context) {
//         throw new Error('useTheme must be used within an AppStateProvider');
//     }
//     return { theme: context.theme, toggleTheme: context.toggleTheme };
// };


import { useContext } from 'react';
import { AppStateContext } from '../contexts/AppStateContext.jsx'; // Correct named import for the context object

export const useTheme = () => {
    const context = useContext(AppStateContext); // Use the imported context object
    if (!context) {
        throw new Error('useTheme must be used within an AppStateProvider');
    }
    return { theme: context.theme, toggleTheme: context.toggleTheme };
};
```

`src/hooks/useTypingEffect.js`

```javascript
// frontend/src/hooks/useTypingEffect.js
import { useState, useEffect, useRef } from 'react';

/**
 * A custom hook to create a typing animation effect for text.
 * @param {string} textToType The full string that should be typed out.
 * @param {number} [speed=20] The delay in milliseconds between each character.
 * @param {function} [onComplete] An optional callback to run when typing is finished.
 * @returns {string} The currently displayed text (which grows over time).
 */
export const useTypingEffect = (textToType, speed = 20, onComplete) => {
    const [displayedText, setDisplayedText] = useState('');
    const index = useRef(0);
    const onCompleteRef = useRef(onComplete);

    // Keep the onComplete callback reference fresh
    useEffect(() => {
        onCompleteRef.current = onComplete;
    }, [onComplete]);

    useEffect(() => {
        // Reset the typing effect when the text to type changes
        setDisplayedText('');
        index.current = 0;

        const intervalId = setInterval(() => {
            if (index.current < textToType.length) {
                setDisplayedText(prev => prev + textToType.charAt(index.current));
                index.current++;
            } else {
                clearInterval(intervalId);
                if (onCompleteRef.current) {
                    onCompleteRef.current(); // Call the onComplete callback
                }
            }
        }, speed);

        return () => clearInterval(intervalId);
    }, [textToType, speed]);

    return displayedText;
};
```

`src/hooks/useWebSpeech.js`

```javascript
// src/hooks/useWebSpeech.js
import { useState, useEffect, useCallback } from 'react';

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

export const useWebSpeech = () => {
    const [transcript, setTranscript] = useState('');
    const [listening, setListening] = useState(false);
    const [recognitionInstance, setRecognitionInstance] = useState(null);
    const [error, setError] = useState(null); // Added error state
    const isSpeechSupported = !!SpeechRecognition;

    useEffect(() => {
        if (!isSpeechSupported) {
            console.warn("Web Speech API is not supported by this browser.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = false; // Set to true if you want it to keep listening
        recognition.interimResults = false; // Set to true for live results
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            const currentTranscript = Array.from(event.results)
                .map(result => result[0])
                .map(result => result.transcript)
                .join('');
            setTranscript(currentTranscript);
            setError(null); // Clear error on successful result
            // console.log("Voice input result:", currentTranscript);
        };

        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            let errorMessage = event.error;
            if (event.error === 'no-speech') errorMessage = "No speech detected. Please try again.";
            else if (event.error === 'audio-capture') errorMessage = "Audio capture failed. Check microphone.";
            else if (event.error === 'not-allowed') errorMessage = "Microphone permission denied.";
            else if (event.error === 'network') errorMessage = "Network error during speech recognition.";
            // Add more specific error messages as needed
            
            setError(errorMessage);
            setListening(false);
        };

        recognition.onend = () => {
            setListening(false);
            // console.log("Speech recognition ended.");
        };
        
        setRecognitionInstance(recognition);

        // Cleanup
        return () => {
            if (recognition) {
                recognition.abort(); // Use abort to stop and discard results if component unmounts
            }
        };
    }, [isSpeechSupported]);

    const startListening = useCallback(() => {
        if (recognitionInstance && !listening) {
            try {
                setTranscript(''); // Clear previous transcript
                setError(null); // Clear previous errors
                recognitionInstance.start();
                setListening(true);
                // console.log("Speech recognition started.");
            } catch (e) {
                // This catch might be for synchronous errors during .start() call,
                // most errors are handled by recognition.onerror
                console.error("Error starting speech recognition:", e);
                setError("Could not start voice input.");
                setListening(false); // Ensure listening state is correct
            }
        }
    }, [recognitionInstance, listening]);

    const stopListening = useCallback(() => {
        if (recognitionInstance && listening) {
            recognitionInstance.stop(); // Stop and process any captured audio
            // setListening(false) will be called by onend event
            // console.log("Speech recognition stopped manually.");
        }
    }, [recognitionInstance, listening]);

    const resetTranscript = useCallback(() => {
        setTranscript('');
    }, []);


    return {
        transcript,
        listening,
        isSpeechSupported,
        startListening,
        stopListening,
        resetTranscript,
        error // Expose error state
    };
};
```

`src/index.css`

```css
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html, body, #root { /* Apply to html, body, AND your React root div */
    @apply h-full overflow-hidden; /* Force full height and no scroll on these */
  }

  html {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    scroll-behavior: smooth; /* This is fine, affects internal scrolls */
  }

  body {
    @apply bg-background-light text-text-light transition-colors duration-300;
    font-family: theme('fontFamily.sans');
    /* overflow-hidden is now applied via the html, body, #root rule above */
  }

  html.dark body {
    @apply bg-background-dark text-text-dark;
  }
  html.light body {
    @apply bg-background-light text-text-light;
  }

  .custom-scrollbar {
     @apply scrollbar-thin scrollbar-thumb-secondary dark:scrollbar-thumb-secondary-dark scrollbar-track-surface-light dark:scrollbar-track-gray-800 scrollbar-thumb-rounded-full scrollbar-track-rounded-full;
  }

  /* --- Enhanced Prose Styles --- */
  .prose {
    @apply max-w-none text-text-light dark:text-text-dark;
  }
  .prose, .prose-sm {
    /* Headings */
    h1 { @apply text-2xl sm:text-3xl font-extrabold mb-6 mt-2 text-text-light dark:text-text-dark; }
    h2 { @apply text-xl sm:text-2xl font-bold mb-4 mt-8 border-b border-border-light dark:border-border-dark pb-2; }
    h3 { @apply text-lg sm:text-xl font-semibold mb-3 mt-6; }
    h4 { @apply text-base sm:text-lg font-semibold mb-2 mt-4; }

    /* Paragraphs */
    p { @apply mb-4 leading-relaxed; }

    /* Links */
    a { @apply text-primary dark:text-primary-light hover:underline font-medium; }
    pre a, pre code a { @apply text-inherit no-underline hover:text-inherit; }

    /* Lists */
    ul, ol { @apply pl-5 mb-4 space-y-1; }
    ul { @apply list-disc; }
    ol { @apply list-decimal; }
    li { @apply mb-1; }
    ul ul, ol ol, ul ol, ol ul { @apply pl-5 mt-1 mb-1; }
    li::marker { @apply text-text-muted-light dark:text-text-muted-dark; }

    /* --- GFM Task List Checkboxes - Custom GREEN Styling --- */
    li:has(> input[type="checkbox"]) {
      @apply flex items-center;
      list-style-type: none;
      margin-left: -1.25rem; /* Adjust as needed for alignment */
      padding-left: 0;
    }

    li > input[type="checkbox"] {
      @apply opacity-0 w-0 h-0 absolute;
    }

    li:has(> input[type="checkbox"])::before {
      content: "";
      @apply inline-block w-4 h-4 border-2 rounded-sm mr-2 align-middle flex-shrink-0;
      @apply bg-surface-light dark:bg-gray-700;
      @apply border-border-light dark:border-border-dark;
      transition: all 0.15s ease-in-out;
    }

    li:has(> input[type="checkbox"]:checked)::before {
      @apply bg-green-500 dark:bg-green-600 border-green-500 dark:border-green-600;
      background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
      background-size: 70% 70%;
      background-position: center;
      background-repeat: no-repeat;
    }

    li:has(> input[type="checkbox"]:disabled:not(:checked))::before {
      @apply opacity-60 cursor-not-allowed;
      @apply bg-gray-100 dark:bg-gray-600 border-gray-300 dark:border-gray-500;
    }

    li:has(> input[type="checkbox"]:checked:disabled)::before {
      @apply bg-green-500/70 dark:bg-green-600/70 border-green-500/70 dark:border-green-600/70;
      opacity: 0.75;
      cursor: not-allowed;
    }


    /* Blockquotes */
    blockquote {
      @apply border-l-4 border-primary dark:border-primary-light pl-4 py-2 my-4 italic text-text-muted-light dark:text-text-muted-dark bg-surface-light dark:bg-gray-800/30 rounded-r-md;
    }
    blockquote p { @apply mb-0; }

    /* Horizontal Rules */
    hr { @apply my-8 border-t border-border-light dark:border-border-dark; }

    /* Tables */
    table { @apply w-full my-6 text-sm border-collapse; }
    thead { @apply border-b-2 border-border-light dark:border-border-dark; }
    th {
      @apply px-4 py-2.5 text-left font-semibold text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700/50;
      @apply border border-border-light dark:border-border-dark;
    }
    tbody tr { @apply border-b border-border-light dark:border-border-dark; }
    tbody tr:last-child { @apply border-b-0; }
    tbody tr:nth-child(even) { @apply bg-gray-50 dark:bg-gray-800/20; }
    td { @apply px-4 py-2.5 text-left border-x border-border-light dark:border-border-dark; }
    td code { @apply text-xs; }
    td strong { @apply font-semibold; }

    /* --- Code Styling --- */
    code:not(pre code) {
      @apply px-1.5 py-0.5 bg-primary/10 dark:bg-primary-dark/20 text-primary dark:text-primary-light rounded-md text-xs font-mono break-words;
    }
    code:not(pre code)::before, code:not(pre code)::after { content: ''; }

    pre {
      @apply bg-[#282c34] dark:bg-[#21252b] p-4 rounded-lg shadow-md overflow-x-auto custom-scrollbar my-5;
    }
    pre code {
      @apply bg-transparent p-0 font-mono text-sm leading-relaxed;
      color: #abb2bf;
      white-space: pre-wrap;
      word-break: break-all;
    }

    strong { @apply font-semibold text-text-light dark:text-text-dark; }
  }
}

@layer components {
  /* ... your existing btn, input-field, form-checkbox, card styles ... */
  /* The li:has(> input[type="checkbox"]) from your paste was misplaced, it should be within .prose */

  /* I will keep your existing .form-checkbox rules here as they might be used by other non-prose forms */
  .btn {
    @apply font-semibold py-2 px-4 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2 disabled:opacity-60 disabled:cursor-not-allowed;
  }
  html.dark .btn { @apply focus:ring-offset-background-dark; }
  html:not(.dark) .btn { @apply focus:ring-offset-background-light; }

  .btn-primary { @apply btn bg-primary text-white hover:bg-primary-dark focus:ring-primary; }
  .btn-secondary { @apply btn bg-secondary text-white hover:bg-secondary-dark focus:ring-secondary; }
  .btn-ghost { @apply btn text-text-muted-light dark:text-text-muted-dark hover:bg-gray-500 hover:bg-opacity-10 focus:ring-primary; }

  .input-field {
    @apply block w-full px-3 py-2 bg-surface-light dark:bg-gray-700 border border-border-light dark:border-border-dark rounded-md text-sm shadow-sm placeholder-text-muted-light dark:placeholder-text-muted-dark
           focus:outline-none focus:border-primary dark:focus:border-primary-light focus:ring-1 focus:ring-primary dark:focus:ring-primary-light;
  }
  .form-input, .form-textarea, .form-select, .form-multiselect { @apply input-field; }

  .form-checkbox, .form-radio {
    @apply rounded shadow-sm border-border-light dark:border-border-dark text-primary focus:ring-primary dark:focus:ring-primary-light;
    @apply bg-surface-light dark:bg-gray-600;
  }
  .form-checkbox:disabled, .form-radio:disabled {
    @apply opacity-70 bg-gray-200 dark:bg-gray-700 border-gray-300 dark:border-gray-600;
  }

  .card-base {
    @apply border rounded-panel shadow-panel;
    @apply bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark;
  }
  .card-header-base {
    @apply px-4 py-3 text-sm font-semibold border-b;
    @apply text-text-light dark:text-text-dark border-border-light dark:border-border-dark;
  }
    .panel-resize-handle {
      @apply relative bg-transparent;
    }
  
    .panel-resize-handle::after {
      content: '';
      @apply absolute inset-0 transition-colors duration-200;
    }
  
    .panel-resize-handle[data-active='true']::after {
      @apply bg-primary/50;
    }
}
```

`src/main.jsx`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppWrapper from './App.jsx';
import { AuthProvider } from './contexts/AuthContext.jsx'; // For regular users
import { AppStateProvider } from './contexts/AppStateContext.jsx';
import { Toaster } from 'react-hot-toast';
import './index.css';

import 'prismjs/themes/prism-okaidia.css';
import 'katex/dist/katex.min.css';
import Prism from 'prismjs'; 
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup'; 
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-java';


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <AppStateProvider>
        <AppWrapper />
      </AppStateProvider>
    </AuthProvider>
  </React.StrictMode>,
);
```

`src/services/adminApi.js`

```javascript
    // frontend/src/services/adminApi.js
    import axios from 'axios';

    // Get base URL for admin document endpoints
    const ADMIN_DOCS_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin/documents`;

    // Get fixed admin credentials from .env (prefixed with VITE_ for frontend access)
    const ADMIN_USERNAME_FRONTEND = import.meta.env.VITE_ADMIN_USERNAME || 'admin';
    const ADMIN_PASSWORD_FRONTEND = import.meta.env.VITE_ADMIN_PASSWORD || 'admin123';

    const adminApiClient = axios.create({
        baseURL: ADMIN_DOCS_API_BASE_URL,
    });

    export const getFixedAdminAuthHeaders = () => {
        if (!ADMIN_USERNAME_FRONTEND || !ADMIN_PASSWORD_FRONTEND) {
            console.error("Admin credentials not found in VITE_ADMIN_USERNAME or VITE_ADMIN_PASSWORD .env variables for frontend.");
            return {};
        }
        const basicAuthToken = btoa(`${ADMIN_USERNAME_FRONTEND}:${ADMIN_PASSWORD_FRONTEND}`);
        return { 'Authorization': `Basic ${basicAuthToken}` };
    };

    const makeAdminApiRequest = async (method, endpoint, data = null, authHeaders = {}) => {
        if (!authHeaders.Authorization) {
            const errorMsg = "Admin authentication headers are missing. Cannot make admin API request.";
            console.error(errorMsg);
            throw new Error(errorMsg);
        }
        try {
            const config = {
                method,
                url: endpoint,
                headers: {
                    ...authHeaders,
                    'Content-Type': data instanceof FormData ? 'multipart/form-data' : 'application/json',
                },
            };
            if (data) {
                config.data = data;
            }
            const response = await adminApiClient(config);
            return response.data;
        } catch (error) {
            let errorMessage = 'Admin API request failed.';
            if (error.response) {
                errorMessage = error.response.data?.message || error.response.statusText || `Server error: ${error.response.status}`;
                console.error(`Admin API Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}): Status ${error.response.status}`, error.response.data);
            } else if (error.request) {
                errorMessage = 'No response from admin API server. Check network or server status.';
                console.error(`Admin API Network Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}):`, error.request);
            } else {
                errorMessage = error.message || 'Error setting up admin API request.';
                console.error(`Admin API Setup Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}):`, error.message);
            }
            throw new Error(errorMessage);
        }
    };

    export const uploadAdminDocument = async (formData, adminAuthHeaders) => {
        return makeAdminApiRequest('post', '/upload', formData, adminAuthHeaders);
    };

    export const getAdminDocuments = async (adminAuthHeaders) => {
        return makeAdminApiRequest('get', '/', null, adminAuthHeaders);
    };

    export const deleteAdminDocument = async (serverFilename, adminAuthHeaders) => {
        return makeAdminApiRequest('delete', `/${serverFilename}`, null, adminAuthHeaders);
    };

    export const getAdminDocumentAnalysis = async (serverFilename, adminAuthHeaders) => {
        return makeAdminApiRequest('get', `/${serverFilename}/analysis`, null, adminAuthHeaders);
    };

    // --- NEW FUNCTION FOR STEP 2 ---
    export const getAdminDocumentAnalysisByOriginalName = async (originalName, adminAuthHeaders) => {
        // This function fetches the analysis object for an admin document using its originalName.
        // The backend route will be '/by-original-name/:originalName/analysis' relative to ADMIN_DOCS_API_BASE_URL.
        // It expects a response like:
        // { originalName, serverFilename, analysis: {faq, topics, mindmap}, analysisUpdatedAt }
        return makeAdminApiRequest('get', `/by-original-name/${encodeURIComponent(originalName)}/analysis`, null, adminAuthHeaders);
    };

    export const getApiKeyRequests = async (adminAuthHeaders) => {
        // Note: This endpoint is on /api/admin, not /api/admin/documents
        const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;
        try {
            const response = await axios.get(`${ADMIN_API_BASE_URL}/key-requests`, { headers: adminAuthHeaders });
            return response.data;
        } catch (error) {
            throw new Error(error.response?.data?.message || 'Failed to fetch API key requests.');
        }
    };

    export const approveApiKeyRequest = async (userId, adminAuthHeaders) => {
        const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;
        try {
            const response = await axios.post(`${ADMIN_API_BASE_URL}/key-requests/approve`, { userId }, { headers: adminAuthHeaders });
            return response.data;
        } catch (error) {
            throw new Error(error.response?.data?.message || 'Failed to approve request.');
        }
    };

    export const rejectApiKeyRequest = async (userId, adminAuthHeaders) => {
        const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;
        try {
            const response = await axios.post(`${ADMIN_API_BASE_URL}/key-requests/reject`, { userId }, { headers: adminAuthHeaders });
            return response.data;
        } catch (error) {
            throw new Error(error.response?.data?.message || 'Failed to reject request.');
        }
    };  
```

`src/services/api.js`

```javascript
// frontend/src/services/api.js
import axios from "axios";
import toast from "react-hot-toast";

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api",
});

apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      console.error("API Interceptor: Received 401 Unauthorized. Token might be invalid or expired.");
    }
    return Promise.reject(error);
  }
);

function parseAnalysisOutput(rawOutput) {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
}

const api = {
  login: async (credentials) => {
    const response = await apiClient.post("/auth/signin", credentials);
    return response.data;
  },
  signup: async (userData) => {
    const response = await apiClient.post("/auth/signup", userData);
    return response.data;
  },
  getMe: async () => {
    const response = await apiClient.get("/auth/me");
    return response.data;
  },
  sendMessage: async (payload) => {
    const response = await apiClient.post("/chat/message", payload);
    return response.data;
  },
  getChatHistory: async (sessionId) => {
    const response = await apiClient.get(`/chat/session/${sessionId}`);
    return response.data;
  },
  getChatSessions: async () => {
    const response = await apiClient.get("/chat/sessions");
    return response.data;
  },
  startNewSession: async (previousSessionId) => {
    const response = await apiClient.post("/chat/history", {
      previousSessionId,
    });
    return response.data;
  },
  deleteChatSession: async (sessionId) => {
    const response = await apiClient.delete(`/chat/session/${sessionId}`);
    return response.data;
  },
  uploadFile: async (formData, onUploadProgress) => {
    const response = await apiClient.post("/upload", formData, {
      headers: { "Content-Type": "multipart/form-data" },
      onUploadProgress,
    });
    return response.data;
  },
  getFiles: async () => {
    const response = await apiClient.get("/files");
    return response.data;
  },
  deleteFile: async (serverFilename) => {
    const response = await apiClient.delete(`/files/${serverFilename}`);
    return response.data;
  },
  updateUserLLMConfig: async (configData) => {
    console.log("[Frontend API] Sending LLM config update:", configData);
    const response = await apiClient.put("/llm/config", configData);
    return response.data;
  },
  getOrchestratorStatus: async () => {
    try {
      const response = await apiClient.get("/network/ip");
      return {
        status: "ok",
        message: `Backend Online at ${response.data.ips[0]}`,
      };
    } catch (e) {
      return { status: "error", message: "Backend Unreachable" };
    }
  },
  getUserProfile: async () => {
    const response = await apiClient.get("/user/profile");
    return response.data;
  },
  updateUserProfile: async (profileData) => {
    const response = await apiClient.put("/user/profile", profileData);
    return response.data;
  },
  getSubjects: async () => {
    const response = await apiClient.get("/subjects");
    return response.data;
  },
  requestAnalysis: async (payload) => {
    const { filename, analysis_type } = payload;
    if (!filename || !analysis_type) {
      throw new Error("Filename and analysis type are required.");
    }
    const toastId = toast.loading(
      `Generating ${analysis_type} for "${filename}"...`
    );
    try {
      const response = await apiClient.get(
        `/analysis/${encodeURIComponent(filename)}`
      );
      const fullAnalysisObject = response.data;
      const rawOutput = fullAnalysisObject[analysis_type];
      if (
        !rawOutput ||
        typeof rawOutput !== "string" ||
        rawOutput.trim() === ""
      ) {
        toast.success(`No stored ${analysis_type} found for "${filename}".`, {
          id: toastId,
        });
        return {
          content: `Notice: Analysis for '${analysis_type}' has not been generated yet or was empty.`,
          thinking: "No analysis data found in the database for this type.",
        };
      }
      const { content, thinking } = parseAnalysisOutput(rawOutput);
      toast.success(
        `Successfully generated ${analysis_type} for "${filename}".`,
        { id: toastId }
      );
      return { content, thinking };
    } catch (error) {
      const errorMessage =
        error.response?.data?.message || error.message || "Unknown error";
      toast.error(`Error generating ${analysis_type}: ${errorMessage}`, {
        id: toastId,
      });
      throw error;
    }
  },
  generateDocument: async ({
    markdownContent,
    docType,
    sourceDocumentName,
  }) => {
    const response = await apiClient.post(
      "/generate/document",
      { markdownContent, docType, sourceDocumentName },
      { responseType: "blob" }
    );
    const contentDisposition = response.headers["content-disposition"];
    let filename = `generated-document.${docType}`;
    if (contentDisposition) {
      const filenameMatch = contentDisposition.match(/filename="?(.+)"?/);
      if (filenameMatch && filenameMatch.length > 1) {
        filename = filenameMatch[1];
      }
    }
    return { fileBlob: response.data, filename: filename };
  },
  generatePodcast: async ({
    analysisContent,
    sourceDocumentName,
    podcastOptions,
  }) => {
    const response = await apiClient.post(
      "/export/podcast",
      { analysisContent, sourceDocumentName, podcastOptions },
      { responseType: "blob" }
    );
    return { audioBlob: response.data, sourceDocumentName };
  },
  getKnowledgeGraph: async (documentName) => {
    const response = await apiClient.get(
      `/kg/visualize/${encodeURIComponent(documentName)}`
    );
    return response.data;
  },
  executeCode: async (payload) => {
    const response = await apiClient.post("/tools/execute", payload);
    return response.data; // The data should be { results: [...] }
  },
  analyzeCode: async (payload) => {
    const response = await apiClient.post("/tools/analyze-code", payload);
    return response.data; // Should be { analysis: "..." }
  },
  generateTestCases: async (payload) => {
    const response = await apiClient.post(
      "/tools/generate-test-cases",
      payload
    );
    return response.data; // Should be { testCases: [...] }
  },
  explainError: async (payload) => {
    const response = await apiClient.post("/tools/explain-error", payload);
    return response.data; // Should be { explanation: "..." }
  },
};

export default api;
```

`src/utils/helpers.js`

```javascript
// Debounce function: Limits the rate at which a function can fire.

export const debounce = (func, delay) => {
    let timeoutId;
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(context, args), delay);
    };
};

// Throttle function: Ensures a function is called at most once in a specified time period.
export const throttle = (func, limit) => {
    let inThrottle;
    let lastFunc;
    let lastRan;
    return function(...args) {
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            lastRan = Date.now();
            inThrottle = true;
            setTimeout(() => {
                inThrottle = false;
                if (lastFunc) {
                    lastFunc.apply(context, args); // Call with latest args if throttled
                    lastRan = Date.now();
                }
            }, limit);
        } else {
            lastFunc = func; // Store the latest call
        }
    };
};

// Simple function to format file size
export const formatFileSize = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

// Function to generate a simple unique ID (for client-side list keys, etc.)
export const generateUniqueId = (prefix = 'id') => {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Function to safely get nested property
export const getNestedValue = (obj, path, defaultValue = undefined) => {
    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
    return value === undefined ? defaultValue : value;
};

// Basic HTML escape (can be more comprehensive)
export const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

// You can add more utility functions here as your project grows.
// For example, date formatting, string manipulation, etc.

// Example: Truncate text
export const truncateText = (text, maxLength = 100) => {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
};
```

`src/utils/markdownUtils.jsx`

```javascript
// src/utils/markdownUtils.jsx
import katex from 'katex';
import DOMPurify from 'dompurify';

const decodeHtmlEntities = (encodedString) => {
  if (typeof encodedString !== 'string') return encodedString;

  const textarea = document.createElement('textarea');
  textarea.innerHTML = encodedString;
  return textarea.value;
};

export const renderMathInHtml = (htmlString) => {
  if (!htmlString || typeof htmlString !== 'string') return htmlString;

  let processedString = htmlString;
  processedString = processedString.replace(/(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$/g, (match, rawExpression) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: true, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"} 
      });
      return DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } });
    } catch (e) { 
      console.warn(`KaTeX (display) error: ${e.message} for expression: ${expression}`); 
      return match; 
    }
  });

  processedString = processedString.replace(/(^|[^$\\])\$(?![\s$])([^$\n]+?)(?<![\s\\])\$([^\$]|$)/g, (fullMatch, prefix, rawExpression, suffix) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    if (!expression) return fullMatch; 
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: false, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"}
      });
      return prefix + DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } }) + suffix;
    } catch (e) { 
      console.warn(`KaTeX (inline) error: ${e.message} for expression: ${expression}`);
      return fullMatch; 
    }
  });
  
  return processedString;
};
```

`tailwind.config.js`

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  safelist: [
    'prose',
    'prose-sm',
    'dark:prose-invert',
  ],
  theme: {
    extend: {
      colors: {
        'primary': { light: '#60a5fa', DEFAULT: '#3b82f6', dark: '#2563eb' },
        'secondary': { light: '#9ca3af', DEFAULT: '#6b7280', dark: '#4b5563' },
        'accent': '#2dd4bf',
        'background-dark': '#0F172A', 'surface-dark': '#1E293B', 'border-dark': '#334155', 'text-dark': '#E2E8F0', 'text-muted-dark': '#94A3B8',
        'background-light': '#F8FAFC', 'surface-light': '#FFFFFF', 'border-light': '#E2E8F0', 'text-light': '#0F172A', 'text-muted-light': '#64748B',
      },
      fontFamily: {
        sans: ['"Inter var"', 'Inter', 'system-ui', 'sans-serif'],
      },
      boxShadow: {
        'main': '0 4px 15px -5px rgba(0,0,0,0.07), 0 2px 8px -6px rgba(0,0,0,0.07)',
        'panel': '0 8px 20px -5px rgba(0,0,0,0.1), 0 4px 10px -6px rgba(0,0,0,0.08)',
        'card-hover': '0 6px 18px -4px rgba(0,0,0,0.1), 0 3px 10px -5px rgba(0,0,0,0.1)',
      },
      borderRadius: { 'xl': '0.75rem', '2xl': '1rem', 'panel': '0.75rem' },
      keyframes: {
        fadeIn: { '0%': { opacity: '0', transform: 'translateY(5px)' }, '100%': { opacity: '1', transform: 'translateY(0px)' } },
        slideUp: { '0%': { transform: 'translateY(10px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } },
        pulseDots: {
          '0%, 100%': { opacity: '0.3', transform: 'scale(0.8)' },
          '50%': { opacity: '1', transform: 'scale(1)' },
        }
      },
      animation: {
        fadeIn: 'fadeIn 0.3s ease-out forwards',
        slideUp: 'slideUp 0.4s ease-out forwards',
        pulseDot1: 'pulseDots 1.4s infinite 0s ease-in-out',
        pulseDot2: 'pulseDots 1.4s infinite 0.2s ease-in-out',
        pulseDot3: 'pulseDots 1.4s infinite 0.4s ease-in-out',
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms')({ strategy: 'class' }),
    require('tailwind-scrollbar')({ nocompatible: true }),
    require('@tailwindcss/typography'),
  ],
}
```

`vite.config.js`

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  // --- ADD THIS SECTION TO FIX THE "global is not defined" ERROR ---
  define: {
    'global': {},
  }
})

```


```

`frontend/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

`frontend/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI TUTOR</title>

    <script src="https://cdn.jsdelivr.net/npm/d3@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-lib@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-view@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest/dist/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js"></script>
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        if (typeof mermaid !== 'undefined') {
          mermaid.initialize({ startOnLoad: false, theme: 'neutral' }); 
          console.log("Mermaid.js initialized globally with 'neutral' theme via index.html.");
        } else {
          console.error("Mermaid.js not found on window after script load. Mermaid diagrams may not render.");
        }
      });
    </script>

  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

`frontend/o.txt`

```

```

`frontend/postcss.config.js`

```javascript
export default {
  plugins: {
    'postcss-nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

`frontend/src/App.css`

```css
/* #root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
} */

```

`frontend/src/App.jsx`

```javascript
// frontend/src/App.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate, useLocation } from 'react-router-dom';
import { useAuth as useRegularAuth } from './hooks/useAuth.jsx';
import { useAppState } from './contexts/AppStateContext.jsx';
import AuthModal from './components/auth/AuthModal.jsx';
import TopNav from './components/layout/TopNav.jsx';
import LeftPanel from './components/layout/LeftPanel.jsx';
import CenterPanel from './components/layout/CenterPanel.jsx';
import RightPanel from './components/layout/RightPanel.jsx';
import LeftCollapsedNav from './components/layout/LeftCollapsedNav.jsx';
import RightCollapsedNav from './components/layout/RightCollapsedNav.jsx';
import ChatHistoryModal from './components/chat/ChatHistoryModal.jsx';
import AdminDashboardPage from './components/admin/AdminDashboardPage.jsx';
import AdminProtectedRoute from './components/admin/AdminProtectedRoute.jsx';
import CodeExecutorPage from './components/tools/CodeExecutorPage.jsx';
import api from './services/api.js';
import toast from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';

function MainAppLayout({ orchestratorStatus }) {
    const { user: regularUser, logout: regularUserLogout } = useRegularAuth();
    const {
        currentSessionId,
        isLeftPanelOpen,
        isRightPanelOpen,
        setSessionId: setGlobalSessionId,
    } = useAppState();
    const [appStateMessages, setAppStateMessages] = useState([]);
    const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false);
    const [isChatProcessing, setIsChatProcessing] = useState(false);

    const handleChatProcessingStatusChange = (isLoading) => {
        setIsChatProcessing(isLoading);
    };

    const handleRegularUserLogout = () => {
        regularUserLogout();
        setGlobalSessionId(null);
    };

    const handleNewChat = async () => {
        try {
            const data = await api.startNewSession(currentSessionId); 
            if (data && data.newSessionId) {
                setGlobalSessionId(data.newSessionId);
                toast.success("New chat started!");
            } else {
                toast.error("Could not start new chat session.");
            }
        } catch (error) {
            toast.error(`Failed to start new chat: ${error.message}`);
        }
    };

    const handleSelectSessionFromHistory = (sessionId) => {
        if (sessionId && sessionId !== currentSessionId) {
            setGlobalSessionId(sessionId);
            toast.success(`Loading session...`);
        }
        setIsHistoryModalOpen(false);
    };

    const { token: regularUserTokenValue } = useRegularAuth();

    const fetchChatHistory = useCallback(async (sid) => {
        if (!sid || !regularUserTokenValue) {
            setAppStateMessages([]);
            return;
        }
        try {
            const sessionData = await api.getChatHistory(sid);
            
            // --- THIS IS THE CORRECTED LOGIC ---
            // The API now returns messages pre-formatted with `sender`.
            // We no longer need to map or transform the data here.
            setAppStateMessages(Array.isArray(sessionData.messages) ? sessionData.messages : []);
            // --- END OF CORRECTION ---

        } catch (error) {
            toast.error(`History load failed: ${error.message}`);
        }
    }, [regularUserTokenValue]);

    useEffect(() => {
        if (currentSessionId && regularUserTokenValue) {
            fetchChatHistory(currentSessionId);
        } else if (!regularUserTokenValue) {
            setAppStateMessages([]);
        }
    }, [currentSessionId, regularUserTokenValue, fetchChatHistory]);

    return (
        <>
            <TopNav 
                user={regularUser} 
                onLogout={handleRegularUserLogout} 
                onNewChat={handleNewChat} 
                onHistoryClick={() => setIsHistoryModalOpen(true)} 
                orchestratorStatus={orchestratorStatus}
                isChatProcessing={isChatProcessing}
            />
            <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark">
                <AnimatePresence mode="wait">
                    {isLeftPanelOpen ? (
                        <motion.aside key="left-panel-main" initial={{ x: '-100%' }} animate={{ x: '0%' }} exit={{ x: '-100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                            <LeftPanel />
                        </motion.aside>
                    ) : ( <LeftCollapsedNav /> )}
                </AnimatePresence>
                <main className={`flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4 transition-all duration-300 ease-in-out ${isLeftPanelOpen ? 'lg:ml-0' : 'lg:ml-16 md:ml-14'} ${isRightPanelOpen ? 'lg:mr-0' : 'lg:mr-16 md:mr-14'}`}>
                    <CenterPanel 
                        messages={appStateMessages} 
                        setMessages={setAppStateMessages} 
                        currentSessionId={currentSessionId}
                        onChatProcessingChange={handleChatProcessingStatusChange}
                    />
                </main>
                <AnimatePresence mode="wait">
                    {isRightPanelOpen ? (
                        <motion.aside key="right-panel-main" initial={{ x: '100%' }} animate={{ x: '0%' }} exit={{ x: '100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="hidden md:flex md:flex-col md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                            <RightPanel />
                        </motion.aside>
                    ) : ( <RightCollapsedNav /> )}
                </AnimatePresence>
            </div>
            <ChatHistoryModal isOpen={isHistoryModalOpen} onClose={() => setIsHistoryModalOpen(false)} onSelectSession={handleSelectSessionFromHistory} />
        </>
    );
}

function App() {
    const { token: regularUserToken, user: regularUser, loading: regularUserAuthLoading, setUser: setRegularUserInAuthContext } = useRegularAuth();
    const { theme, setSessionId: setGlobalSessionId, currentSessionId, isAdminSessionActive } = useAppState();
    const navigate = useNavigate();
    const location = useLocation();
    const [appInitializing, setAppInitializing] = useState(true);
    const [showAuthModal, setShowAuthModal] = useState(false);
    const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });

    useEffect(() => { document.documentElement.className = theme; }, [theme]);
    useEffect(() => { api.getOrchestratorStatus().then(setOrchestratorStatus); }, []);

    useEffect(() => {
        if (isAdminSessionActive) {
            setAppInitializing(false);
            setShowAuthModal(false);
            if (!location.pathname.startsWith('/admin')) {
                navigate('/admin/dashboard', { replace: true });
            }
            return;
        }
        if (regularUserAuthLoading) {
            setAppInitializing(true);
            return;
        }
        setAppInitializing(false);
        if (regularUserToken && regularUser) {
            setShowAuthModal(false);
            if (location.pathname.startsWith('/admin')) {
                navigate('/', { replace: true });
            } else if (!currentSessionId && !location.pathname.startsWith('/tools')) { 
                api.startNewSession(null).then(data => {
                    if (data && data.newSessionId) {
                        setGlobalSessionId(data.newSessionId);
                    }
                });
            }
        } else if (!location.pathname.startsWith('/admin')) {
            setShowAuthModal(true);
        }
    }, [regularUserAuthLoading, regularUserToken, regularUser, isAdminSessionActive, currentSessionId, navigate, location.pathname, setGlobalSessionId]);

    const handleAuthSuccess = (authData) => {
        setShowAuthModal(false);
        if (authData && !authData.isAdminLogin && authData.token) {
            api.startNewSession(null).then(data => {
                if (data && data.newSessionId) {
                    setGlobalSessionId(data.newSessionId);
                }
            });
            if (authData.email && authData._id) {
                setRegularUserInAuthContext({ id: authData._id, email: authData.email });
            }
        }
    };

    if (appInitializing) {
        return (
            <div className="fixed inset-0 flex items-center justify-center bg-background-light dark:bg-background-dark">
                <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary"></div>
            </div>
        );
    }

    return (
        <div className="flex flex-col h-screen overflow-hidden font-sans">
            <AnimatePresence>
                {showAuthModal && <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />}
            </AnimatePresence>
            <Routes>
                 <Route path="/tools/code-executor" element={(regularUserToken && regularUser) ? 
                    <CodeExecutorPage /> : <Navigate to="/" />} 
                />
                <Route path="/admin/dashboard" element={<AdminProtectedRoute><AdminDashboardPage /></AdminProtectedRoute>} />
                <Route path="/*" element={isAdminSessionActive ? <Navigate to="/admin/dashboard" replace /> : (regularUserToken && regularUser) ? <MainAppLayout orchestratorStatus={orchestratorStatus} /> : null} />
            </Routes>
        </div>
    );
}

function AppWrapper() {
    return (
        <Router>
            <App />
        </Router>
    );
}

export default AppWrapper;
```

`frontend/src/components/admin/AdminDashboardPage.jsx`

```javascript
// frontend/src/components/admin/AdminDashboardPage.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import * as adminApi from '../../services/adminApi.js';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import ApiKeyRequestManager from './ApiKeyRequestManager.jsx';
import UserChatManager from './UserChatManager.jsx';
import AdminInsights from './AdminInsights.jsx'; // <<< NEW IMPORT
import { UploadCloud, Trash2, Eye, LogOut, Loader2, AlertTriangle, CheckCircle, RefreshCw, Shield, Users, Lightbulb, HelpCircle } from 'lucide-react';
import toast from 'react-hot-toast';
import { format } from 'date-fns';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

// Helper functions (same as before)
const localParseAnalysisOutput = (rawOutput) => { 
    if (!rawOutput || typeof rawOutput !== 'string') return { content: '' };
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let mainContent = rawOutput;
    if (thinkingMatch && thinkingMatch[1]) {
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent };
};
const createMarkup = (markdownText) => { 
    if (!markdownText) return { __html: '' };
    const html = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

// AdminDocumentUpload Component (no changes)
function AdminDocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const fileInputRef = useRef(null);
    const handleFileChange = (e) => { if (isUploading) return; const file = e.target.files && e.target.files[0]; if (file) setSelectedFile(file); else setSelectedFile(null); };
    const handleUpload = async () => {
        if (!selectedFile) { toast.error("Please select a file to upload."); return; }
        setIsUploading(true);
        const toastId = toast.loading(`Uploading "${selectedFile.name}"...`);
        const formData = new FormData();
        formData.append('file', selectedFile);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.uploadAdminDocument(formData, authHeaders);
            toast.success(response.message || `Admin document "${selectedFile.name}" uploaded.`, { id: toastId });
            onUploadSuccess();
            setSelectedFile(null);
            if (fileInputRef.current) fileInputRef.current.value = null;
        } catch (error) {
            toast.error(error.message || `Failed to upload "${selectedFile.name}".`, { id: toastId });
        } finally {
            setIsUploading(false);
        }
    };
    return (
        <div className="card-base p-4">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark">Upload New Subject Document</h2>
            <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
                <input type="file" ref={fileInputRef} onChange={handleFileChange} className="input-field flex-grow text-sm p-2.5 min-h-[44px]" accept=".pdf,.docx,.txt,.md" disabled={isUploading} />
                <Button onClick={handleUpload} isLoading={isUploading} disabled={!selectedFile || isUploading} leftIcon={<UploadCloud size={16} />} size="md" className="w-full sm:w-auto !py-2.5">Upload</Button>
            </div>
            {selectedFile && !isUploading && <p className="text-xs mt-2 text-text-muted-light dark:text-text-muted-dark">Selected: {selectedFile.name} ({(selectedFile.size / 1024).toFixed(1)} KB)</p>}
        </div>
    );
}

// Main AdminDashboardPage Component
function AdminDashboardPage() {
    const { setIsAdminSessionActive } = useAppState();
    const navigate = useNavigate();

    // Data states
    const [documents, setDocuments] = useState([]);
    const [keyRequests, setKeyRequests] = useState([]);
    const [usersWithChats, setUsersWithChats] = useState([]);
    const [dashboardStats, setDashboardStats] = useState({});

    // Loading states
    const [isInitialLoading, setIsInitialLoading] = useState(true);
    const [loadingError, setLoadingError] = useState('');

    // Modal states
    const [isAnalysisModalOpen, setIsAnalysisModalOpen] = useState(false);
    const [currentDocForModal, setCurrentDocForModal] = useState(null);
    const [analysisContent, setAnalysisContent] = useState(null);
    const [isLoadingAnalysis, setIsLoadingAnalysis] = useState(false);
    const [isSecurityModalOpen, setIsSecurityModalOpen] = useState(false);
    const [isUserChatsModalOpen, setIsUserChatsModalOpen] = useState(false);

    const adminLogoutHandler = () => {
        setIsAdminSessionActive(false);
        toast.success("Admin logged out.");
        navigate('/');
    };

    const fetchAdminData = useCallback(async (isRefresh = false) => {
        let toastId;
        if (isRefresh) {
            toastId = toast.loading("Refreshing all admin data...");
        } else {
            setIsInitialLoading(true);
        }
        setLoadingError('');
        
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const [docsResponse, requestsResponse, usersResponse, statsResponse] = await Promise.all([
                adminApi.getAdminDocuments(authHeaders),
                adminApi.getApiKeyRequests(authHeaders),
                adminApi.getUsersAndChats(authHeaders),
                adminApi.getDashboardStats(authHeaders) // <<< NEW API CALL
            ]);

            setDocuments(Array.isArray(docsResponse.documents) ? docsResponse.documents : []);
            setKeyRequests(Array.isArray(requestsResponse) ? requestsResponse : []);
            setUsersWithChats(Array.isArray(usersResponse) ? usersResponse : []);
            setDashboardStats(statsResponse || {}); // <<< SET STATS

            if (isRefresh) toast.success("Admin data refreshed.", { id: toastId });
        } catch (err) {
            const errorMessage = err.message || "Failed to fetch admin data.";
            setLoadingError(errorMessage);
            if (isRefresh) toast.error(errorMessage, { id: toastId });
            else toast.error(errorMessage);
        } finally {
            if (!isRefresh) setIsInitialLoading(false);
        }
    }, []);

    useEffect(() => { fetchAdminData(); }, [fetchAdminData]);

    const handleDeleteDocument = async (serverFilename, originalName) => {
        if (!window.confirm(`Are you sure you want to delete admin document "${originalName}"?`)) return;
        const toastId = toast.loading(`Deleting "${originalName}"...`);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            await adminApi.deleteAdminDocument(serverFilename, authHeaders);
            toast.success(`Document "${originalName}" deleted.`, { id: toastId });
            fetchAdminData(true); // Refresh all data after delete
            if (isAnalysisModalOpen && currentDocForModal?.serverFilename === serverFilename) {
                setIsAnalysisModalOpen(false);
            }
        } catch (err) {
            toast.error(err.message || `Failed to delete "${originalName}".`, { id: toastId });
        }
    };
    
    const handleViewAnalysis = async (doc) => { /* ...no changes... */ 
        setCurrentDocForModal(doc);
        setAnalysisContent(null);
        setIsAnalysisModalOpen(true);
        setIsLoadingAnalysis(true);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.getAdminDocumentAnalysis(doc.serverFilename, authHeaders);
            setAnalysisContent(response.analysis);
        } catch (err) {
            toast.error(`Failed to load analysis: ${err.message}`);
            setAnalysisContent({ error: `Failed to load analysis: ${err.message}` });
        } finally {
            setIsLoadingAnalysis(false);
        }
    };
    
    const renderAnalysisModalContent = () => { /* ...no changes... */ 
        if (isLoadingAnalysis) {
            return (
                <div className="flex justify-center items-center h-48">
                    <Loader2 size={32} className="animate-spin text-primary" />
                    <p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p>
                </div>
            );
        }
        if (!analysisContent || analysisContent.error) {
            return <p className="p-4 text-center text-red-500 dark:text-red-400">{analysisContent?.error || "No analysis content available or an error occurred."}</p>;
        }
        const hasContent = analysisContent.faq?.trim() || analysisContent.topics?.trim() || analysisContent.mindmap?.trim();
        if (!hasContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">Analysis has not been generated for this document, or all analysis fields are empty.</p>;
        }
        return (
            <div className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark space-y-6 p-1 custom-scrollbar">
                {analysisContent.faq?.trim() && ( <div><h3 className="text-base font-semibold border-b border-border-light dark:border-border-dark pb-1 mb-2">Frequently Asked Questions</h3><div dangerouslySetInnerHTML={createMarkup(localParseAnalysisOutput(analysisContent.faq).content)} /></div>)}
                {analysisContent.topics?.trim() && ( <div><h3 className="text-base font-semibold border-b border-border-light dark:border-border-dark pb-1 mb-2">Key Topics</h3><div dangerouslySetInnerHTML={createMarkup(localParseAnalysisOutput(analysisContent.topics).content)} /></div>)}
                {analysisContent.mindmap?.trim() && (<div><h3 className="text-base font-semibold border-b border-border-light dark:border-border-dark pb-1 mb-2">Mind Map (Mermaid Code)</h3><pre className="bg-gray-100 dark:bg-gray-800 p-2 rounded-md text-xs whitespace-pre-wrap overflow-x-auto custom-scrollbar"><code>{localParseAnalysisOutput(analysisContent.mindmap).content}</code></pre></div>)}
            </div>
        );
    };

    return (
        <div className="min-h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark p-4 sm:p-6">
            <header className="flex items-center justify-between mb-6 pb-3 border-b border-border-light dark:border-border-dark">
                <h1 className="text-2xl font-bold">Professor's Dashboard</h1>
                <div className="flex items-center gap-2">
                    <IconButton icon={RefreshCw} onClick={() => fetchAdminData(true)} title="Refresh Admin Data" variant="ghost" size="md" className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"/>
                    <IconButton icon={Shield} onClick={() => setIsSecurityModalOpen(true)} title="Security Center & API Requests" variant="ghost" size="md" className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"/>
                    <IconButton icon={Users} onClick={() => setIsUserChatsModalOpen(true)} title="User Management & Chats" variant="ghost" size="md" className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"/>
                    <Button onClick={adminLogoutHandler} variant="danger" size="sm" leftIcon={<LogOut size={16}/>}> Logout Admin </Button>
                </div>
            </header>

            <AdminInsights stats={dashboardStats} isLoading={isInitialLoading} error={loadingError} />

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                {/* --- Column 1: Content Management --- */}
                <div className="space-y-6">
                    <AdminDocumentUpload onUploadSuccess={() => fetchAdminData(true)} />

                    <div className="card-base p-0 sm:p-4">
                        <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">Uploaded Subject Documents</h2>
                        {isInitialLoading && !documents.length && ( <div className="flex items-center justify-center p-6"> <Loader2 size={24} className="animate-spin text-primary mr-2" /> Loading documents... </div> )}
                        {loadingError && !documents.length && ( <div className="p-3 my-3 mx-4 sm:mx-0 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2"> <AlertTriangle size={18} /> {loadingError} <button onClick={() => fetchAdminData(true)} className="ml-auto text-xs underline hover:text-red-400">Retry</button> </div> )}
                        {!isInitialLoading && documents.length === 0 && !loadingError && ( <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0"> No subject documents uploaded yet. </p> )}
                        {documents.length > 0 && (
                            <div className="overflow-x-auto custom-scrollbar">
                                <table className="w-full text-sm text-left">
                                    <thead className="bg-gray-50 dark:bg-gray-800">
                                        <tr>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium">Original Name</th>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium hidden md:table-cell">Uploaded</th>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium">Analysis Status</th>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium text-center">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {documents.map((doc) => (
                                            <tr key={doc.serverFilename} className="border-b border-border-light dark:border-border-dark hover:bg-gray-50/50 dark:hover:bg-gray-700/30 transition-colors">
                                                <td className="px-3 sm:px-4 py-2 truncate max-w-[150px] sm:max-w-xs" title={doc.originalName}>{doc.originalName}</td>
                                                <td className="px-3 sm:px-4 py-2 whitespace-nowrap hidden md:table-cell"> {doc.uploadedAt ? format(new Date(doc.uploadedAt), 'MMM d, yyyy HH:mm') : 'N/A'} </td>
                                                <td className="px-3 sm:px-4 py-2"> {(doc.hasFaq || doc.hasTopics || doc.hasMindmap) ? ( <span className="flex items-center text-green-600 dark:text-green-400 text-xs"><CheckCircle size={14} className="mr-1"/> Generated</span> ) : (doc.analysisUpdatedAt ? <span className="text-gray-500 dark:text-gray-400 text-xs">Empty/Skipped</span> : <span className="text-yellow-500 dark:text-yellow-400 text-xs">Pending</span>)} </td>
                                                <td className="px-1 sm:px-4 py-2 text-center whitespace-nowrap">
                                                    <IconButton icon={Eye} title="View Analysis" size="sm" variant="ghost" className="text-primary hover:text-primary-dark mr-0.5 sm:mr-1" onClick={() => handleViewAnalysis(doc)} disabled={isLoadingAnalysis && currentDocForModal?.serverFilename === doc.serverFilename} />
                                                    <IconButton icon={Trash2} title="Delete Document" size="sm" variant="ghost" className="text-red-500 hover:text-red-700" onClick={() => handleDeleteDocument(doc.serverFilename, doc.originalName)} />
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>
                </div>

                {/* --- Column 2: Insights & Enhancement Tools --- */}
                <div className="space-y-6">
                    <div className="card-base p-4">
                        <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark flex items-center gap-2">
                            <HelpCircle size={20} className="text-accent" /> Content Gap Analysis
                        </h2>
                        <div className="text-center py-8 px-4 border-2 border-dashed border-border-light dark:border-border-dark rounded-lg">
                            <p className="text-sm text-text-muted-light dark:text-text-muted-dark">This panel will show student questions that the chatbot could not answer from your documents.</p>
                            <p className="text-xs mt-1 text-text-muted-light/70 dark:text-text-muted-dark/70">(Feature Coming Soon)</p>
                        </div>
                    </div>
                    <div className="card-base p-4">
                         <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark flex items-center gap-2">
                            <Lightbulb size={20} className="text-accent" /> Frequently Asked Topics
                        </h2>
                        <div className="text-center py-8 px-4 border-2 border-dashed border-border-light dark:border-border-dark rounded-lg">
                            <p className="text-sm text-text-muted-light dark:text-text-muted-dark">This panel will show a word cloud or list of the most common topics students ask about.</p>
                            <p className="text-xs mt-1 text-text-muted-light/70 dark:text-text-muted-dark/70">(Feature Coming Soon)</p>
                        </div>
                    </div>
                </div>
            </div>

            {/* Modals */}
            <Modal isOpen={isAnalysisModalOpen} onClose={() => setIsAnalysisModalOpen(false)} title={`Analysis Results: ${currentDocForModal?.originalName || 'Document'}`} size="2xl">
                {renderAnalysisModalContent()}
            </Modal>
            <Modal isOpen={isSecurityModalOpen} onClose={() => setIsSecurityModalOpen(false)} title="Security Center" size="3xl">
                {isInitialLoading ? (
                    <div className="flex justify-center items-center p-8"> <Loader2 size={24} className="animate-spin text-primary inline-block mr-2" /> Loading Security Data... </div>
                ) : ( <ApiKeyRequestManager requests={keyRequests} onAction={() => fetchAdminData(true)} /> )}
            </Modal>
            <Modal isOpen={isUserChatsModalOpen} onClose={() => setIsUserChatsModalOpen(false)} title="User Session Summaries" size="4xl">
                {isInitialLoading ? (
                     <div className="flex justify-center items-center p-8"> <Loader2 size={24} className="animate-spin text-primary inline-block mr-2" /> Loading User Chat Data... </div>
                ) : ( <UserChatManager usersWithChats={usersWithChats} /> )}
            </Modal>
        </div>
    );
}

export default AdminDashboardPage;
```

`frontend/src/components/admin/AdminInsights.jsx`

```javascript
// frontend/src/components/admin/AdminInsights.jsx
import React from 'react';
import { Users, FileText, MessageSquare, KeyRound, AlertTriangle } from 'lucide-react';

const InsightCard = ({ title, value, icon: Icon, colorClass = 'text-primary' }) => (
    <div className="card-base p-4 flex items-start gap-4">
        <div className={`mt-1 flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center ${colorClass.replace('text-', 'bg-')}/10`}>
            <Icon size={20} className={colorClass} />
        </div>
        <div>
            <p className="text-sm font-medium text-text-muted-light dark:text-text-muted-dark">{title}</p>
            <p className="text-2xl font-bold text-text-light dark:text-text-dark">{value}</p>
        </div>
    </div>
);

function AdminInsights({ stats, isLoading, error }) {
    if (isLoading) {
        return (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                {Array(4).fill(0).map((_, i) => (
                    <div key={i} className="card-base p-4 h-24 bg-gray-200 dark:bg-gray-700 animate-pulse"></div>
                ))}
            </div>
        );
    }
    
    if (error) {
        return (
            <div className="mb-6 p-4 bg-red-500/10 text-red-600 dark:text-red-300 rounded-lg flex items-center gap-3">
                <AlertTriangle size={24} />
                <div>
                    <p className="font-semibold">Could not load dashboard insights.</p>
                    <p className="text-sm">{error}</p>
                </div>
            </div>
        )
    }

    return (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            <InsightCard title="Total Students" value={stats.totalUsers ?? 'N/A'} icon={Users} colorClass="text-blue-500" />
            <InsightCard title="Admin Documents" value={stats.totalAdminDocs ?? 'N/A'} icon={FileText} colorClass="text-green-500" />
            <InsightCard title="Total Chat Sessions" value={stats.totalSessions ?? 'N/A'} icon={MessageSquare} colorClass="text-indigo-500" />
            <InsightCard title="Pending API Requests" value={stats.pendingApiKeys ?? 'N/A'} icon={KeyRound} colorClass="text-yellow-500" />
        </div>
    );
}

export default AdminInsights;
```

`frontend/src/components/admin/AdminProtectedRoute.jsx`

```javascript
// frontend/src/components/admin/AdminProtectedRoute.jsx
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // Using AppStateContext
import toast from 'react-hot-toast'; // Optional: for a message if redirecting

function AdminProtectedRoute({ children }) { // Accept children for different react-router-dom versions
    const { isAdminSessionActive } = useAppState(); // Get the admin session flag
    const location = useLocation();

    if (!isAdminSessionActive) {
        // If admin session is not active, redirect the user.
        // Redirecting to the main page ('/') is a common approach.
        // The main App component's logic will then likely show the AuthModal
        // if no regular user is logged in either.
        console.log("AdminProtectedRoute: Admin session not active. Redirecting from", location.pathname);
        toast.error("Admin access required. Please log in as admin."); // Optional feedback
        return <Navigate to="/" state={{ from: location }} replace />;
    }

    // If admin session is active, render the child components (the protected route's content)
    return children ? children : <Outlet />; // Outlet is for v6 nested routes, children for direct wrapping
}

export default AdminProtectedRoute;
```

`frontend/src/components/admin/ApiKeyRequestManager.jsx`

```javascript
// frontend/src/components/admin/ApiKeyRequestManager.jsx
import React, { useState } from 'react';
import { formatDistanceToNow } from 'date-fns';
import { Check, X, Loader2 } from 'lucide-react';
import toast from 'react-hot-toast';
import * as adminApi from '../../services/adminApi.js';
import IconButton from '../core/IconButton.jsx';

function ApiKeyRequestManager({ requests, onAction }) {
    const [loadingStates, setLoadingStates] = useState({});

    const handleAction = async (userId, action) => {
        setLoadingStates(prev => ({ ...prev, [userId]: true }));
        const toastId = toast.loading(`${action === 'approve' ? 'Approving' : 'Rejecting'} request...`);
        
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            let response;
            if (action === 'approve') {
                response = await adminApi.approveApiKeyRequest(userId, authHeaders);
            } else {
                response = await adminApi.rejectApiKeyRequest(userId, authHeaders);
            }
            toast.success(response.message, { id: toastId });
            onAction(); // Trigger a refresh in the parent component
        } catch (error) {
            toast.error(error.message, { id: toastId });
        } finally {
            setLoadingStates(prev => ({ ...prev, [userId]: false }));
        }
    };

    return (
        <div className="card-base p-0 sm:p-4 mt-6">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">
                Pending API Key Requests
            </h2>
            {requests.length === 0 ? (
                <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                    No pending requests.
                </p>
            ) : (
                <div className="overflow-x-auto custom-scrollbar">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-gray-50 dark:bg-gray-800">
                            <tr>
                                <th className="px-4 py-2.5 font-medium">User Email</th>
                                <th className="px-4 py-2.5 font-medium hidden md:table-cell">Name</th>
                                <th className="px-4 py-2.5 font-medium hidden lg:table-cell">Requested</th>
                                <th className="px-4 py-2.5 font-medium text-center">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {requests.map((req) => (
                                <tr key={req._id} className="border-b border-border-light dark:border-border-dark">
                                    <td className="px-4 py-2 font-mono text-xs" title={req.email}>{req.email}</td>
                                    <td className="px-4 py-2 hidden md:table-cell">{req.profile?.name || 'N/A'}</td>
                                    <td className="px-4 py-2 hidden lg:table-cell" title={new Date(req.createdAt).toLocaleString()}>
                                        {formatDistanceToNow(new Date(req.createdAt), { addSuffix: true })}
                                    </td>
                                    <td className="px-4 py-2 text-center whitespace-nowrap">
                                        {loadingStates[req._id] ? (
                                            <Loader2 size={16} className="animate-spin text-primary inline-block" />
                                        ) : (
                                            <>
                                                <IconButton
                                                    icon={Check}
                                                    title="Approve Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-green-500 hover:text-green-700 dark:hover:text-green-400"
                                                    onClick={() => handleAction(req._id, 'approve')}
                                                />
                                                <IconButton
                                                    icon={X}
                                                    title="Reject Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-red-500 hover:text-red-700 dark:hover:text-red-400"
                                                    onClick={() => handleAction(req._id, 'reject')}
                                                />
                                            </>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}
        </div>
    );
}

export default ApiKeyRequestManager;
```

`frontend/src/components/admin/UserChatManager.jsx`

```javascript
// frontend/src/components/admin/UserChatManager.jsx
import React, { useState, useMemo } from 'react';
import { format, formatDistanceToNow } from 'date-fns';
import { User, MessageSquare, Clock, ChevronDown, AlertTriangle, Search } from 'lucide-react';

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        const date = new Date(dateString);
        return `${format(date, 'MMM d, yyyy HH:mm')} (${formatDistanceToNow(date, { addSuffix: true })})`;
    } catch (e) {
        return 'Invalid Date';
    }
};

function UserChatManager({ usersWithChats }) {
    const [searchTerm, setSearchTerm] = useState('');

    const filteredUsers = useMemo(() => {
        if (!searchTerm.trim()) {
            return usersWithChats;
        }
        const lowercasedFilter = searchTerm.toLowerCase();
        return usersWithChats.filter(({ user }) => 
            (user.name && user.name.toLowerCase().includes(lowercasedFilter)) ||
            (user.email && user.email.toLowerCase().includes(lowercasedFilter))
        );
    }, [usersWithChats, searchTerm]);

    return (
        <div className="card-base p-0 sm:p-4">
            <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3 px-4 sm:px-0 pt-4 sm:pt-0 gap-3">
                <h2 className="text-lg font-semibold text-text-light dark:text-text-dark flex-shrink-0">
                    User Chat Sessions
                </h2>
                <div className="relative w-full sm:w-auto sm:max-w-xs">
                    <input
                        type="text"
                        placeholder="Search by name or email..."
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        className="input-field !py-2 !pl-9 !pr-3 text-sm w-full"
                    />
                    <Search className="absolute left-2.5 top-1/2 -translate-y-1/2 h-4 w-4 text-text-muted-light dark:text-text-muted-dark" />
                </div>
            </div>

            {filteredUsers.length === 0 ? (
                <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                    {searchTerm ? `No users found matching "${searchTerm}".` : "No user chat data available."}
                </p>
            ) : (
                <div className="space-y-3">
                    {filteredUsers.map(({ user, sessions }) => {
                        // Don't filter here anymore, we want to show all sessions
                        // const sessionsWithSummary = sessions.filter(s => s.summary && s.summary.trim() !== '' && s.summary !== 'No summary available.');
                        
                        return (
                            <details key={user._id} className="group bg-surface-light dark:bg-gray-800/50 border border-border-light dark:border-border-dark rounded-lg overflow-hidden transition-all duration-200 open:shadow-lg open:ring-1 open:ring-primary/50">
                                <summary className="flex items-center justify-between p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700/50 transition-colors">
                                    <div className="flex items-center gap-3">
                                        <User className="text-primary" size={18} />
                                        <div>
                                            <p className="font-semibold text-sm text-text-light dark:text-text-dark">{user.name || 'Unnamed User'}</p>
                                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark">{user.email}</p>
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <span className="text-xs font-mono bg-gray-200 dark:bg-gray-700 px-2 py-0.5 rounded-full">{sessions.length} sessions</span>
                                        <ChevronDown size={20} className="group-open:rotate-180 transition-transform" />
                                    </div>
                                </summary>
                                <div className="border-t border-border-light dark:border-border-dark p-3 space-y-2 bg-white dark:bg-gray-800">
                                    {sessions.length > 0 ? sessions.map(session => {
                                        // --- THIS IS THE FIX ---
                                        // Check if the summary is an error message or empty
                                        const hasValidSummary = session.summary && !session.summary.startsWith('Summary generation failed:');
                                        const isErrorSummary = session.summary && session.summary.startsWith('Summary generation failed:');

                                        return (
                                            <div key={session.sessionId} className={`p-2.5 border rounded-md ${isErrorSummary ? 'border-red-500/30 bg-red-500/5' : 'border-border-light dark:border-border-dark bg-gray-50 dark:bg-gray-900/50'}`}>
                                                
                                                {hasValidSummary && (
                                                    <p className="text-xs font-medium text-text-light dark:text-text-dark italic" title={session.summary}>
                                                        "{session.summary}"
                                                    </p>
                                                )}
                                                
                                                {isErrorSummary && (
                                                     <div className="flex items-start gap-2 text-red-600 dark:text-red-400">
                                                        <AlertTriangle size={14} className="mt-0.5 flex-shrink-0" />
                                                        <p className="text-xs font-semibold" title={session.summary}>
                                                            {session.summary}
                                                        </p>
                                                     </div>
                                                )}

                                                {!session.summary && (
                                                    <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark italic">
                                                        This session has not been summarized yet.
                                                    </p>
                                                )}

                                                <div className="flex items-center justify-between text-xs text-text-muted-light dark:text-text-muted-dark mt-2 pt-2 border-t border-dashed">
                                                    <span className="flex items-center gap-1"><MessageSquare size={12} /> {session.messageCount} msgs</span>
                                                    <span className="flex items-center gap-1"><Clock size={12} /> {formatDate(session.updatedAt)}</span>
                                                </div>
                                            </div>
                                        )
                                    }) : <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark p-2">This user has no chat sessions.</p>}
                                </div>
                            </details>
                        )
                    })}
                </div>
            )}
        </div>
    );
}

export default UserChatManager;
```

`frontend/src/components/analysis/AnalysisTool.jsx`

```javascript
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js'; // For user documents
import * as adminApi from '../../services/adminApi.js'; // For admin documents
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.", // Added for admin docs
    "Retrieved stored admin analysis." // Added for admin docs
];

// Added isTargetAdminDoc prop
function AnalysisTool({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => { // Reset when selected document changes
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => { // Prism for modal content
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => { // Prism for AI reasoning
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                console.log(`AnalysisToolRunner: Fetching ADMIN analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const authHeaders = adminApi.getFixedAdminAuthHeaders(); // Get admin auth
                // Fetches { originalName, serverFilename, analysis: {faq, topics, mindmap}, analysisUpdatedAt }
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                        // Content for this specific analysis type is empty or null
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}". The admin might not have generated this specific analysis type yet, or it was empty.`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc "${selectedDocumentFilename}".`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title} for "${selectedDocumentFilename}"!`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found or response format invalid for document "${selectedDocumentFilename}".`);
                }
            } else { // User document
                console.log(`AnalysisToolRunner: Requesting USER analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload); // This uses the mock/frontend API for user docs
                // The success toast for user docs is handled inside api.requestAnalysis mock for now.
                // If it were a real API, we might add toast.success here.
                // For consistency with admin path:
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated for "${selectedDocumentFilename}"!`, { id: toastId });
                } else {
                    toast.dismiss(toastId); // Dismiss loading if there was an issue caught below
                }
            }

            // Common response processing
            if (response) {
                if (response.content && response.content.trim() !== "" && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content && (response.content.startsWith("Error:") || response.content.startsWith("Notice:"))) {
                    // If it's an error or notice, display it as content but also set error state
                    setAnalysisContent(response.content); // Display the error/notice in the content area
                    setError(response.content); // Also set the error state for styling/logging
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else { // No content, but not an explicit error/notice in response.content
                    setAnalysisContent(`No content was returned for ${title}.`); // Display this
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content was generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content was generated for ${title}.`);
                }

                if (response.thinking && response.thinking.trim() !== "") {
                    setAiReasoning(response.thinking);
                } else {
                    setAiReasoning(response.content ? "Retrieved analysis. No detailed AI reasoning provided." : "AI reasoning not available.");
                }
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to generate or fetch ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`); // Display error in content area too
            toast.error(errorMessage);
            console.error(`Run ${title} Analysis Error:`, err);
            setIsDropdownOpen(false);
        } finally {
            setIsLoading(false);
        }
    };

    const handleDownloadMindmap = async (format = 'svg') => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    if (saveSvgAsPng) {
                        saveSvgAsPng(svgElement, filename, {
                            scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF'
                        });
                        toast.success("PNG download started!", { id: pngToastId });
                    } else { throw new Error("saveSvgAsPng function not found."); }
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48">
                       <Loader2 size={32} className="animate-spin text-primary" />
                       <p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p>
                   </div>;
        }
        // Display error directly if it's set and no other content (or if content is the error itself)
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center">
                       <MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} />
                   </div>;
        }
        return <div ref={modalAnalysisContentRef}
                    className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed"
                    dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div
                    className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors"
                    onClick={() => setIsSectionOpen(!isSectionOpen)}
                    aria-expanded={isSectionOpen}
                >
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button
                        onClick={handleRunAnalysis} variant="primary" size="sm"
                        className="!px-3 !py-1 text-xs" isLoading={isLoading}
                        disabled={!selectedDocumentFilename || isLoading}
                        title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}
                    >
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton
                        icon={isSectionOpen ? ChevronUp : ChevronDown}
                        onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost"
                        className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"}
                        disabled={isLoading && isSectionOpen}
                    />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div
                        key="tool-section-content" initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.25, ease: "easeInOut" }}
                        className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden"
                    >
                        {isLoading && (
                            <div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn">
                                <Loader2 size={14} className="animate-spin"/> {currentEngagementText}
                            </div>
                        )}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && ( // Show error only if no other content or content is the error
                            <div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1">
                                <AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}
                            </div>
                        )}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div
                                key="analysis-dropdown" initial={{ opacity: 0, y: -10 }}
                                animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }}
                                transition={{ duration: 0.2 }} className="mt-2 space-y-2"
                            >
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md">
                                            <span className="flex items-center gap-1.5 font-medium">
                                                <Sparkles size={14} className="text-accent" /> AI Reasoning
                                            </span>
                                            <ChevronDown size={16} className="group-open:rotate-180 transition-transform" />
                                        </summary>
                                        <div ref={aiReasoningContentRef}
                                            className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md"
                                            dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && (!error || analysisContent !== error) && ( // Show view button if content is not the error message itself
                                     <Button
                                        onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth
                                        leftIcon={<Eye size={14}/>}
                                        className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10"
                                    >View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">
                                {selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}
                            </p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={<>
                        {toolType === 'mindmap' && analysisContent && (
                            <><Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                             <div className="flex-grow"></div></>
                        )}
                        <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs">Close</Button>
                    </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisTool;
```

`frontend/src/components/analysis/AnalysisToolRunner.jsx`

```javascript
// frontend/src/components/analysis/AnalysisToolRunner.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js';
import * as adminApi from '../../services/adminApi.js';
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download, FileText, FileBarChart2 } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.",
    "Retrieved stored admin analysis."
];

function AnalysisToolRunner({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');
    const [generatingDocType, setGeneratingDocType] = useState(null);

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => {
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => {
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => {
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                const authHeaders = adminApi.getFixedAdminAuthHeaders();
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}".`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc.`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title}.`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found.`);
                }
            } else {
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload);
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated!`, { id: toastId });
                } else {
                    toast.dismiss(toastId);
                }
            }

            if (response) {
                if (response.content && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content) {
                    setAnalysisContent(response.content);
                    setError(response.content);
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else {
                    setAnalysisContent(`No content was returned for ${title}.`);
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content generated for ${title}.`);
                }
                setAiReasoning(response.thinking || "AI reasoning not available.");
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to process ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };

    const handleGenerateDocument = async (docType) => {
        if (!analysisContent || generatingDocType) {
            return;
        }

        setGeneratingDocType(docType);
        const toastId = toast.loading(`Generating ${docType.toUpperCase()} document...`);

        try {
            const fullMarkdownContent = `## ${title}\n\n**Source Document:** \`${selectedDocumentFilename}\`\n\n---\n\n${analysisContent}`;
            
            const { fileBlob, filename } = await api.generateDocument({
                markdownContent: fullMarkdownContent,
                docType: docType,
                sourceDocumentName: selectedDocumentFilename
            });
            
            const url = window.URL.createObjectURL(fileBlob);
            const link = document.createElement('a');
            link.href = url;
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);

            toast.success(`${docType.toUpperCase()} document downloaded.`, { id: toastId });

        } catch (err) {
            toast.error(`Failed to generate document: ${err.message}`, { id: toastId });
        } finally {
            setGeneratingDocType(null);
        }
    };

    const handleDownloadMindmap = async (format) => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    saveSvgAsPng(svgElement, filename, { scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF' });
                    toast.success("PNG download started!", { id: pngToastId });
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48"><Loader2 size={32} className="animate-spin text-primary" /><p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p></div>;
        }
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center"><MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} /></div>;
        }
        return <div ref={modalAnalysisContentRef} className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed" dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors" onClick={() => setIsSectionOpen(!isSectionOpen)} aria-expanded={isSectionOpen}>
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button onClick={handleRunAnalysis} variant="primary" size="sm" className="!px-3 !py-1 text-xs" isLoading={isLoading} disabled={!selectedDocumentFilename || isLoading} title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}>
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton icon={isSectionOpen ? ChevronUp : ChevronDown} onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost" className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"} disabled={isLoading && isSectionOpen} />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div key="tool-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.25, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        {isLoading && (<div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn"><Loader2 size={14} className="animate-spin"/> {currentEngagementText}</div>)}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && (<div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1"><AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}</div>)}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div key="analysis-dropdown" initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }} transition={{ duration: 0.2 }} className="mt-2 space-y-2">
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md"><span className="flex items-center gap-1.5 font-medium"><Sparkles size={14} className="text-accent" /> AI Reasoning</span><ChevronDown size={16} className="group-open:rotate-180 transition-transform" /></summary>
                                        <div ref={aiReasoningContentRef} className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md" dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && !error && (
                                     <Button onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth leftIcon={<Eye size={14}/>} className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10">View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">{selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}</p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={
                <>
                    {toolType === 'mindmap' && analysisContent && !error && (
                        <Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                    )}
                    
                    {toolType !== 'mindmap' && analysisContent && !error && (
                        <>
                           <Button 
                                onClick={() => handleGenerateDocument('pptx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileBarChart2 size={14}/>}
                                isLoading={generatingDocType === 'pptx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'pptx' ? 'Generating...' : 'Generate PPTX'}
                            </Button>
                           <Button 
                                onClick={() => handleGenerateDocument('docx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileText size={14}/>}
                                isLoading={generatingDocType === 'docx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'docx' ? 'Generating...' : 'Generate DOCX'}
                            </Button>
                        </>
                    )}

                    <div className="flex-grow"></div>
                    <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs" disabled={!!generatingDocType}>
                        Close
                    </Button>
                </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisToolRunner;
```

`frontend/src/components/analysis/KnowledgeGraphViewer.jsx`

```javascript
// frontend/src/components/analysis/KnowledgeGraphViewer.jsx
import React, { useEffect, useState, useMemo } from 'react';
import Graph from 'react-vis-network-graph';
import { Loader2, AlertTriangle, ZoomIn, ZoomOut, Maximize } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';
import IconButton from '../core/IconButton.jsx';

const KnowledgeGraphViewer = ({ graphData }) => {
    const { theme } = useTheme();

    // --- FIX START: Add state to hold the network instance ---
    const [network, setNetwork] = useState(null);
    // --- FIX END ---

    // Memoize options to prevent re-renders
    const options = useMemo(() => {
        const isDark = theme === 'dark';
        return {
            layout: {
                hierarchical: {
                    enabled: true,
                    direction: 'UD', // Up-Down
                    sortMethod: 'directed',
                    levelSeparation: 150,
                    nodeSpacing: 200,
                },
            },
            nodes: {
                shape: 'box',
                borderWidth: 1.5,
                font: {
                    color: isDark ? '#E2E8F0' : '#0F172A',
                    size: 14,
                    face: 'Inter',
                },
                color: {
                    border: isDark ? '#4B5563' : '#9CA3AF',
                    background: isDark ? '#1E293B' : '#FFFFFF',
                    highlight: {
                        border: '#3b82f6',
                        background: isDark ? '#2563eb' : '#60a5fa',
                    },
                },
                shadow: true,
            },
            edges: {
                color: {
                    color: isDark ? '#64748B' : '#9CA3AF',
                    highlight: '#3b82f6',
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.7 },
                },
                font: {
                    color: isDark ? '#94A3B8' : '#6B7280',
                    size: 10,
                    align: 'middle',
                    strokeWidth: 2,
                    strokeColor: isDark ? '#1E293B' : '#FFFFFF',
                },
                smooth: {
                    type: 'cubicBezier',
                    forceDirection: 'vertical',
                    roundness: 0.4,
                },
            },
            physics: {
                enabled: true,
                hierarchicalRepulsion: {
                    centralGravity: 0.0,
                    springLength: 100,
                    springConstant: 0.01,
                    nodeDistance: 200,
                    damping: 0.09,
                },
                solver: 'hierarchicalRepulsion',
            },
            interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true,
                tooltipDelay: 200,
            },
            height: '100%',
            width: '100%',
        };
    }, [theme]);

    const formattedGraph = useMemo(() => {
        if (!graphData || !graphData.nodes || !graphData.edges) {
            return { nodes: [], edges: [] };
        }
        const nodes = graphData.nodes.map(node => ({
            id: node.id,
            label: node.id,
            title: `Type: ${node.type}\nParent: ${node.parent || 'N/A'}\n\n${node.description}`,
            color: node.type === 'major' 
                ? { border: '#3b82f6', background: theme === 'dark' ? '#1E3A8A' : '#BFDBFE' } 
                : undefined,
        }));
        const edges = graphData.edges.map(edge => ({
            from: edge.from,
            to: edge.to,
            label: edge.relationship.replace(/_/g, ' '),
        }));
        return { nodes, edges };
    }, [graphData, theme]);

    // --- FIX START: These handlers will now work because 'network' is in state ---
    const handleZoomIn = () => network?.zoomIn();
    const handleZoomOut = () => network?.zoomOut();
    const handleFit = () => network?.fit();
    // --- FIX END ---

    if (!graphData) {
        return (
            <div className="flex items-center justify-center h-full">
                <Loader2 className="animate-spin text-primary mr-2" /> Loading graph data...
            </div>
        );
    }

    if (graphData.error) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-red-500">
                <AlertTriangle size={32} className="mb-2" />
                <p className="font-semibold">Failed to load Knowledge Graph</p>
                <p className="text-xs">{graphData.error}</p>
            </div>
        );
    }
    
    if (formattedGraph.nodes.length === 0) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark">
                <AlertTriangle size={32} className="mb-2" />
                <p>No graph data found for this document.</p>
             </div>
        );
    }

    return (
        <div className="relative w-full h-[70vh] border border-border-light dark:border-border-dark rounded-md bg-gray-50 dark:bg-gray-800/50">
            <Graph
                key={theme}
                graph={formattedGraph}
                options={options}
                // --- FIX START: Use the 'getNetwork' callback to update our state ---
                getNetwork={net => setNetwork(net)}
                // --- FIX END ---
            />
            <div className="absolute top-2 right-2 flex flex-col gap-1.5 bg-surface-light dark:bg-surface-dark p-1.5 rounded-md shadow-lg border border-border-light dark:border-border-dark">
                <IconButton icon={ZoomIn} onClick={handleZoomIn} title="Zoom In" size="sm" />
                <IconButton icon={ZoomOut} onClick={handleZoomOut} title="Zoom Out" size="sm" />
                <IconButton icon={Maximize} onClick={handleFit} title="Fit to View" size="sm" />
            </div>
        </div>
    );
};

export default KnowledgeGraphViewer;
```

`frontend/src/components/analysis/MindmapViewer.jsx`

```javascript
// frontend/src/components/analysis/MindmapViewer.jsx
import React, { useEffect, useRef, useState, useImperativeHandle, forwardRef } from 'react';
import toast from 'react-hot-toast';
import { escapeHtml } from '../../utils/helpers.js';

const MindmapViewer = forwardRef(({ mermaidCode }, ref) => {
    const svgContainerRef = useRef(null);
    const [error, setError] = useState(null);
    const [isMermaidReady, setIsMermaidReady] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [uniqueId] = useState(() => `mermaid-graph-${Math.random().toString(36).substr(2, 9)}`);

    useImperativeHandle(ref, () => ({
        getSvgElement: () => {
            return svgContainerRef.current?.querySelector('svg');
        }
    }));

    useEffect(() => {
        if (typeof window.mermaid !== 'undefined') {
            setIsMermaidReady(true);
        } else {
            const intervalId = setInterval(() => {
                if (typeof window.mermaid !== 'undefined') {
                    setIsMermaidReady(true);
                    clearInterval(intervalId);
                }
            }, 100);
            return () => clearInterval(intervalId);
        }
    }, []);

    useEffect(() => {
        if (!isMermaidReady || !mermaidCode || !svgContainerRef.current) {
            if (svgContainerRef.current) svgContainerRef.current.innerHTML = '';
            setError(null);
            setIsLoading(false);
            return;
        }

        const renderMermaidDiagram = async () => {
            setIsLoading(true);
            setError(null);
            if (!svgContainerRef.current) {
                setIsLoading(false);
                return;
            }
            svgContainerRef.current.innerHTML = '<div class="flex justify-center items-center h-full w-full text-sm text-text-muted-light dark:text-text-muted-dark"><div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-primary mr-2"></div>Rendering diagram...</div>';
            
            let codeToRender = mermaidCode.trim();
            
            // --- THIS IS THE FIX ---
            // New, more robust regex to find the diagram code.
            // It looks for a code block that CONTAINS a known diagram type (e.g., 'graph', 'mindmap').
            // It is no longer anchored to the start (^) of the string, so it can find the
            // block even if there's leading garbage or extra backticks from the LLM.
            const fenceRegex = /```(?:mermaid)?\s*([\s\S]*?(?:graph|mindmap|flowchart|sequenceDiagram)[\s\S]*?)\s*```/i;
            const match = codeToRender.match(fenceRegex);

            if (match && match[1]) {
                // If we found a fenced block, use its content.
                codeToRender = match[1].trim();
            } else {
                // Fallback for cases where LLM might forget the fences entirely.
                // We still trim to remove potential whitespace.
                codeToRender = codeToRender.trim();
            }
            // --- END OF FIX ---

            try {
                if (typeof window.mermaid === 'undefined') {
                    throw new Error("Mermaid library failed to load or initialize properly.");
                }

                const { svg, bindFunctions } = await window.mermaid.render(uniqueId, codeToRender);
                
                if (svgContainerRef.current) {
                    svgContainerRef.current.innerHTML = svg;
                    if (bindFunctions) {
                        bindFunctions(svgContainerRef.current);
                    }
                    const svgElement = svgContainerRef.current.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto'; 
                        svgElement.style.maxWidth = '100%'; 
                        svgElement.style.display = 'block';
                    }
                }
            } catch (e) {
                console.error("Error rendering Mermaid diagram with input:", codeToRender, e);
                const errorMsg = e.message || "Failed to render mind map. Invalid Mermaid syntax?";
                setError(errorMsg);
                if (svgContainerRef.current) {
                    const codeSnippet = escapeHtml(codeToRender.substring(0, 200) + (codeToRender.length > 200 ? "..." : ""));
                    svgContainerRef.current.innerHTML = `<div class="p-4 text-center text-red-500 dark:text-red-400 text-xs break-all"><strong>Error rendering:</strong> ${escapeHtml(errorMsg)}<br><strong class='mt-2 block'>Input Code (first 200 chars):</strong><pre class='text-left text-xs bg-gray-100 dark:bg-gray-700 p-2 rounded mt-1 whitespace-pre-wrap'>${codeSnippet}</pre></div>`;
                }
            } finally {
                setIsLoading(false);
            }
        };

        const timer = setTimeout(renderMermaidDiagram, 100); 
        return () => clearTimeout(timer);
        
    }, [mermaidCode, uniqueId, isMermaidReady]);

    if (!isMermaidReady && !error) {
      return <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark text-xs">Waiting for Mermaid.js library...</div>;
    }
    if (error && (!isLoading || (svgContainerRef.current && svgContainerRef.current.innerHTML.includes('Error rendering')))) {
        return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
                {/* Error message will be injected by useEffect's catch block */}
               </div>;
    }
    
    if (isLoading) { 
         return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
            {/* Loading message is set by renderMermaidDiagram's initial innerHTML write */}
         </div>;
    }

    if (!mermaidCode && !error && isMermaidReady) { 
        return <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark p-4">No mind map data to display.</p>;
    }
    
    return (
        <div 
            ref={svgContainerRef} 
            className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md"
        >

        </div>
    );
});

export default MindmapViewer;

```

`frontend/src/components/analysis/PodcastGenerator.jsx`

```javascript
// frontend/src/components/analysis/PodcastGenerator.jsx
import React, { useState } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { Headphones, ChevronDown, ChevronUp } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion, AnimatePresence } from 'framer-motion';

function PodcastGenerator({ selectedDocumentFilename }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isLoading, setIsLoading] = useState(false);
    const [podcastPurpose, setPodcastPurpose] = useState('review');
    const [podcastLength, setPodcastLength] = useState('standard');

    const handleGeneratePodcast = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true);
        const toastId = toast.loading("Generating high-quality podcast script & audio. This may take a moment...");
        try {
            const { audioBlob, sourceDocumentName } = await api.generatePodcast({
                analysisContent: `A study session on: ${selectedDocumentFilename}`,
                sourceDocumentName: selectedDocumentFilename,
                podcastOptions: { studyPurpose: podcastPurpose, sessionLength: podcastLength }
            });
            
            toast.success("High-Quality Podcast is ready for download!", { id: toastId, duration: 5000 });

            const url = window.URL.createObjectURL(audioBlob);
            const link = document.createElement('a');
            const safeFilename = sourceDocumentName.split('.')[0].replace(/[^a-zA-Z0-9]/g, '_');
            link.href = url;
            link.setAttribute('download', `AI_Podcast_${safeFilename}.mp3`);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || "Failed to generate podcast.";
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between cursor-pointer" onClick={() => setIsSectionOpen(!isSectionOpen)}>
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark">
                    <Headphones size={16} className="text-accent" />
                    <span className="flex-grow">HQ Podcast Generator</span>
                </div>
                {isSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-3">
                            Generate a high-quality, conversational audio study session from the selected document.
                        </p>
                        <div className="flex flex-col sm:flex-row gap-2 mb-3">
                            <div className="flex-1">
                                <label htmlFor="podcast-purpose" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Purpose</label>
                                <select id="podcast-purpose" value={podcastPurpose} onChange={(e) => setPodcastPurpose(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="review">General Review</option>
                                    <option value="introduction">Introduction</option>
                                    <option value="exam_prep">Exam Prep</option>
                                    <option value="deep_dive">Deep Dive</option>
                                </select>
                            </div>
                            <div className="flex-1">
                                <label htmlFor="podcast-length" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Length</label>
                                <select id="podcast-length" value={podcastLength} onChange={(e) => setPodcastLength(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="quick">Quick (~5-7m)</option>
                                    <option value="standard">Standard (~10-15m)</option>
                                    <option value="comprehensive">Comprehensive (~15-25m)</option>
                                </select>
                            </div>
                        </div>
                        <Button
                            onClick={handleGeneratePodcast}
                            variant="primary"
                            size="sm"
                            fullWidth
                            isLoading={isLoading}
                            disabled={!selectedDocumentFilename || isLoading}
                            title={!selectedDocumentFilename ? "Select a document first" : "Generate Podcast"}
                        >
                           {isLoading ? 'Generating Audio...' : 'Generate High-Quality Podcast'}
                        </Button>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}

export default PodcastGenerator;
// This code defines a React component for generating podcasts from selected documents.

```

`frontend/src/components/analysis/RightPanel.jsx`

```javascript
// // frontend/src/components/layout/RightPanel.jsx
// import React, { useState } from 'react';
// import { useAppState } from '../../contexts/AppStateContext';
// import AnalysisTool from '../analysis/AnalysisTool.jsx'; // Added .jsx
// import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
// import IconButton from '../core/IconButton.jsx'; // Added .jsx
// import { motion } from 'framer-motion';

// function RightPanel() {
//     const { setIsRightPanelOpen, selectedDocumentForAnalysis } = useAppState();
//     const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

//     const currentSelectedDocFilename = selectedDocumentForAnalysis?.originalName || null;

//     return (
//         <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
//             <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
//                 <h2 className="text-base font-semibold">Advanced Analyzer</h2>
//                 <IconButton 
//                     icon={PanelRightClose} 
//                     onClick={() => setIsRightPanelOpen(false)} 
//                     title="Close Analyzer Panel"
//                     variant="ghost"
//                     size="sm"
//                     className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
//                 />
//             </div>
            
//             <button 
//                 onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
//                 className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
//             >
//                 <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
//                 {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
//             </button>

//             {isAnalyzerOpen && (
//                 <motion.div 
//                     initial={{ height: 0, opacity: 0 }} 
//                     animate={{ height: 'auto', opacity: 1 }} 
//                     exit={{ height: 0, opacity: 0 }}
//                     transition={{ duration: 0.2, ease: "easeInOut" }}
//                     className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
//                 >
//                     {!currentSelectedDocFilename && (
//                         <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
//                             <p>Select a document from the left panel to enable analysis tools.</p>
//                         </div>
//                     )}
//                     <AnalysisTool toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} />
//                 </motion.div>
//             )}
//         </div>
//     );
// }
// export default RightPanel;











// frontend/src/components/analysis/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
// FIX: Use the new, more capable AnalysisToolRunner component
import AnalysisToolRunner from './AnalysisToolRunner.jsx'; // FIX: Corrected relative import path
import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

function RightPanel() {
    // FIX: Get selectedSubject to determine if the document is an admin document
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    // FIX: Logic corrected to handle filename string directly
    const currentSelectedDocFilename = selectedDocumentForAnalysis || null;
    // FIX: Add logic to determine if the selected document is a "Subject" (admin doc)
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    return (
        <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                <IconButton
                    icon={PanelRightClose}
                    onClick={() => setIsRightPanelOpen(false)}
                    title="Close Analyzer Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>

            <button
                onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
                className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
            >
                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </button>

            {isAnalyzerOpen && (
                <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
                >
                    {!currentSelectedDocFilename && (
                        <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable analysis tools.</p>
                        </div>
                    )}
                    {/* FIX: Use AnalysisToolRunner and pass the isTargetAdminDoc prop */}
                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                </motion.div>
            )}
        </div>
    );
}
export default RightPanel;
```

`frontend/src/components/auth/AuthModal.jsx`

```javascript
// frontend/src/components/auth/AuthModal.jsx
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../hooks/useAuth.jsx';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import LLMSelection from './LLMSelection.jsx';
import toast from 'react-hot-toast';
import { LogIn, UserPlus, X, KeyRound, AtSign, AlertCircle, HardDrive, CheckSquare, Square } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';

function AuthModal({ isOpen, onClose }) {
    const { login, signup } = useAuth();
    const { setIsAdminSessionActive, switchLLM: setGlobalLLM, selectedLLM } = useAppState();

    const [isLoginView, setIsLoginView] = useState(true);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [localSelectedLLM, setLocalSelectedLLM] = useState('gemini');
    const [apiKey, setApiKey] = useState('');
    const [ollamaUrl, setOllamaUrl] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [requestKeyFromAdmin, setRequestKeyFromAdmin] = useState(false); // New state for checkbox
    
    const emailRegex = /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/;

    useEffect(() => {
        if (isOpen) {
            setError('');
            setEmail('');
            setPassword('');
            setApiKey('');
            setOllamaUrl('');
            setRequestKeyFromAdmin(false); // Reset checkbox
            setLocalSelectedLLM(selectedLLM || 'gemini');
        } else {
            setIsLoginView(true);
        }
    }, [isOpen, selectedLLM]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');

        if (!emailRegex.test(email) && !(isLoginView && email === (process.env.VITE_ADMIN_USERNAME || 'admin@admin.com'))) {
            return setError("Please enter a valid email address.");
        }
        if (password.length < 6) {
            return setError("Password must be at least 6 characters long.");
        }
        if (!isLoginView && localSelectedLLM === 'gemini' && !apiKey.trim() && !requestKeyFromAdmin) {
            return setError("Gemini API Key is required, or request one from the admin.");
        }
        if (!isLoginView && localSelectedLLM === 'ollama' && !ollamaUrl.trim()) {
            return setError("Ollama URL is required.");
        }
        
        setLoading(true);
        const toastId = toast.loading(isLoginView ? 'Logging in...' : 'Creating account...');

        try {
            if (isLoginView) {
                const authDataResponse = await login({ email, password });
                if (authDataResponse.isAdminLogin) {
                    toast.dismiss(toastId);
                    toast.success("Admin login successful!");
                    setIsAdminSessionActive(true); 
                    onClose({ isAdminLogin: true });
                } else {
                    toast.dismiss(toastId);
                    toast.success(authDataResponse.message || 'Login Successful!');
                    onClose(authDataResponse);
                }
            } else { // Signup logic
                const signupData = {
                    email, password,
                    preferredLlmProvider: localSelectedLLM,
                };

                if (localSelectedLLM === 'gemini') {
                    if (requestKeyFromAdmin) {
                        signupData.requestAdminKey = true;
                    } else {
                        signupData.apiKey = apiKey;
                    }
                } else if (localSelectedLLM === 'ollama') {
                    signupData.ollamaUrl = ollamaUrl;
                }

                const authDataResponse = await signup(signupData);
                setGlobalLLM(localSelectedLLM);
                toast.dismiss(toastId);
                toast.success(authDataResponse.message || 'Signup Successful!');
                onClose(authDataResponse);
            }
        } catch (err) {
            toast.dismiss(toastId);
            const errorMessage = err.response?.data?.message || err.message || `An error occurred.`;
            setError(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm w-full";

    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-fadeIn">
            <motion.div 
                key="auth-modal-content"
                initial={{ opacity: 0, scale: 0.95, y: -10 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.95, y: 10 }}
                className="card-base p-6 sm:p-8 w-full max-w-md"
            >
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl sm:text-2xl font-bold">{isLoginView ? 'Welcome Back' : 'Create Your Account'}</h2>
                    <IconButton icon={X} onClick={() => onClose(null)} variant="ghost" size="sm" title="Close" />
                </div>

                {error && (
                    <div className="mb-4 p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                        <AlertCircle size={16}/>{error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-5">
                    <div className={inputWrapperClass}>
                        <AtSign className={inputIconClass} />
                        <input type="text" id="auth-email" className={inputFieldStyledClass} placeholder="Email Address" value={email} onChange={(e) => setEmail(e.target.value)} required disabled={loading} />
                    </div>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input type="password" id="auth-password" className={inputFieldStyledClass} placeholder="Password (min. 6 characters)" value={password} onChange={(e) => setPassword(e.target.value)} required minLength="6" disabled={loading} />
                    </div>

                    {!isLoginView && (
                        <div className="space-y-4 pt-2 animate-fadeIn">
                            <LLMSelection selectedLLM={localSelectedLLM} onLlmChange={setLocalSelectedLLM} disabled={loading} />
                            
                            <div style={{ display: localSelectedLLM === 'gemini' ? 'block' : 'none' }}>
                                <motion.div key="gemini-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <div className="flex items-center mb-3">
                                        <button
                                            type="button"
                                            onClick={() => setRequestKeyFromAdmin(!requestKeyFromAdmin)}
                                            className="flex items-center text-sm text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors"
                                            disabled={loading}
                                        >
                                            {requestKeyFromAdmin ? <CheckSquare size={16} className="text-primary mr-2" /> : <Square size={16} className="mr-2" />}
                                            Request API Key from Admin
                                        </button>
                                    </div>
                                    <AnimatePresence>
                                        {!requestKeyFromAdmin && (
                                            <motion.div
                                                key="api-key-field"
                                                initial={{ opacity: 0, height: 0 }}
                                                animate={{ opacity: 1, height: 'auto' }}
                                                exit={{ opacity: 0, height: 0 }}
                                                className="overflow-hidden"
                                            >
                                                <label htmlFor="api-key-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Gemini API Key <span className="text-red-500">*</span></label>
                                                <div className={inputWrapperClass}>
                                                    <KeyRound className={inputIconClass} />
                                                    <input type="password" id="api-key-input" className={inputFieldStyledClass} placeholder="Enter your Gemini API Key" value={apiKey} onChange={(e) => setApiKey(e.target.value)} required={!requestKeyFromAdmin && localSelectedLLM === 'gemini'} disabled={loading} />
                                                </div>
                                            </motion.div>
                                        )}
                                    </AnimatePresence>
                                </motion.div>
                            </div>
                        
                            <div style={{ display: localSelectedLLM === 'ollama' ? 'block' : 'none' }}>
                                <motion.div key="ollama-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <label htmlFor="ollama-url-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Ollama URL <span className="text-red-500">*</span></label>
                                    <div className={inputWrapperClass}>
                                        <HardDrive className={inputIconClass} />
                                        <input type="text" id="ollama-url-input" className={inputFieldStyledClass} placeholder="e.g., http://localhost:11434" value={ollamaUrl} onChange={(e) => setOllamaUrl(e.target.value)} required={localSelectedLLM === 'ollama'} disabled={loading} />
                                    </div>
                                </motion.div>
                            </div>
                        </div>
                    )}

                    <Button type="submit" fullWidth isLoading={loading} leftIcon={isLoginView ? <LogIn size={18}/> : <UserPlus size={18}/>} className="py-2.5 !text-base">
                        {isLoginView ? 'Login' : 'Sign Up'}
                    </Button>
                </form>

                <p className="mt-6 text-center text-sm">
                    <button onClick={() => setIsLoginView(!isLoginView)} className="font-medium text-primary hover:underline" disabled={loading}>
                        {isLoginView ? "Don't have an account? Sign Up" : "Already have an account? Login"}
                    </button>
                </p>
            </motion.div>
        </div>
    );
}
export default AuthModal;
```

`frontend/src/components/auth/LLMSelection.jsx`

```javascript
// frontend/src/components/auth/LLMSelection.jsx
import React from 'react';
import { HardDrive, Cloud } from 'lucide-react';

function LLMSelection({ selectedLLM, onLlmChange, disabled = false }) {
    const llms = [
        { id: 'ollama', name: 'Ollama LLM', description: 'Local & Private. Requires Ollama running.', Icon: HardDrive },
        { id: 'gemini', name: 'Gemini LLM', description: 'Cloud-based by Google. API Key may be required.', Icon: Cloud },
    ];

    return (
        <div>
            <label className="block text-sm font-medium text-text-light dark:text-text-dark mb-2">
                Choose Your LLM Provider
            </label>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {llms.map((llm) => {
                    const isSelected = selectedLLM === llm.id;
                    return (
                        <button
                            key={llm.id}
                            type="button"
                            onClick={() => onLlmChange(llm.id)}
                            disabled={disabled}
                            className={`p-4 border rounded-lg text-left transition-all duration-150 focus:outline-none group focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-surface-dark focus:ring-primary
                                ${isSelected 
                                    ? 'bg-primary dark:bg-primary border-primary dark:border-primary-dark ring-2 ring-primary dark:ring-primary-dark shadow-lg' 
                                    : 'bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark hover:border-primary-light dark:hover:border-primary-dark hover:shadow-md'
                                }
                                ${disabled ? 'opacity-70 cursor-not-allowed' : ''}
                            `}
                        >
                            <div className="flex items-center mb-1">
                                <llm.Icon size={20} className={`mr-2 transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-blue-100' // High contrast for selected
                                        : 'text-text-muted-light dark:text-text-muted-dark group-hover:text-primary dark:group-hover:text-primary-light'}`} />
                                <span className={`font-semibold transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-white' // High contrast for selected
                                        : 'text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light'}`}>
                                    {llm.name}
                                </span>
                            </div>
                            <p className={`text-xs transition-colors 
                                ${isSelected 
                                    ? 'text-blue-100 dark:text-blue-200' // High contrast for selected
                                    : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                {llm.description}
                            </p>
                        </button>
                    );
                })}
            </div>
        </div>
    );
}

export default LLMSelection;
```

`frontend/src/components/chat/ChatHistory.jsx`

```javascript
import React, { useRef, useEffect } from 'react';
import MessageBubble from './MessageBubble';
import { motion, AnimatePresence } from 'framer-motion';

function ChatHistory({ messages, botStatusPlaceholder }) {
    const chatHistoryRef = useRef(null);

    useEffect(() => {
        if (chatHistoryRef.current) {
            chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
        }
    }, [messages, botStatusPlaceholder]);

    return (
        <div ref={chatHistoryRef} className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
            <AnimatePresence initial={false}>
                {messages.map((msg, index) => (
                    <motion.div
                        key={msg.id || `msg-${index}-${msg.timestamp}`}
                        layout
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10, transition: { duration: 0.15 } }}
                        transition={{ duration: 0.3, ease: "easeOut" }}
                    >
                        <MessageBubble
                            id={msg.id || `msg-${index}-${msg.timestamp}`}
                            sender={msg.sender}
                            text={msg.text}
                            thinking={msg.thinking}
                            references={msg.references}
                            timestamp={msg.timestamp}
                            sourcePipeline={msg.source_pipeline}
                        />
                    </motion.div>
                ))}
            </AnimatePresence>

            {botStatusPlaceholder && (
                <motion.div 
                    layout
                    key="bot-status-placeholder"
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.3 }}
                    className="flex justify-start pl-2 mt-2"
                >
                    <div className="max-w-[85%] bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-100 px-4 py-2 rounded-xl shadow-md animate-pulse text-sm">
                        {botStatusPlaceholder}
                    </div>
                </motion.div>
            )}
        </div>
    );
}

export default ChatHistory;

```

`frontend/src/components/chat/ChatHistoryModal.jsx`

```javascript
// src/components/chat/ChatHistoryModal.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { X, MessageSquareText, Loader2, AlertTriangle, Trash2 } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import IconButton from '../core/IconButton.jsx';

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString(undefined, { 
            month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' 
        });
    } catch (e) {
        return 'Invalid Date';
    }
};

function ChatHistoryModal({ isOpen, onClose, onSelectSession }) {
    const [sessions, setSessions] = useState([]);
    const [selectedSessionId, setSelectedSessionId] = useState(null);
    const [sessionMessages, setSessionMessages] = useState([]);
    const [loadingSessions, setLoadingSessions] = useState(false);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState('');

    const fetchSessions = useCallback(async () => {
        if (!isOpen) return; 
        setLoadingSessions(true);
        setError('');
        try {
            const data = await api.getChatSessions();
            setSessions(Array.isArray(data) ? data : []);
        } catch (err) {
            toast.error("Failed to load chat sessions.");
            setError(err.message || "Could not fetch sessions.");
        } finally {
            setLoadingSessions(false);
        }
    }, [isOpen]);

    useEffect(() => {
        if (isOpen) {
            fetchSessions();
            setSelectedSessionId(null); 
            setSessionMessages([]);
        }
    }, [isOpen, fetchSessions]); 

    const handleSessionSelectForPreview = async (sessionId) => {
        if (selectedSessionId === sessionId && sessionMessages.length > 0) return; 

        setSelectedSessionId(sessionId);
        setLoadingMessages(true);
        setSessionMessages([]);
        setError(''); 
        try {
            const sessionData = await api.getChatHistory(sessionId);
            
            // --- THIS IS THE CORRECTED LOGIC ---
            // We trust the API to send correctly formatted data with the 'sender' property.
            const messagesArray = Array.isArray(sessionData.messages) ? sessionData.messages : [];
            setSessionMessages(messagesArray);
            // --- END OF CORRECTION ---

        } catch (err) {
            toast.error("Failed to load messages for this session.");
            setError(`Error loading messages: ${err.message}`);
        } finally {
            setLoadingMessages(false);
        }
    };

    const handleLoadSessionAndClose = () => {
        if (selectedSessionId) {
            onSelectSession(selectedSessionId); 
            onClose();
        } else {
            toast.error("Please select a session to load.");
        }
    };
    
    const handleDeleteSession = async (sessionIdToDelete, e) => {
        e.stopPropagation();
        if (!window.confirm(`Are you sure you want to delete this session? This action cannot be undone.`)) return;
        
        const toastId = toast.loading(`Deleting session...`);
        try {
            await api.deleteChatSession(sessionIdToDelete);
            toast.success(`Session deleted.`, { id: toastId });
            setSessions(prev => prev.filter(s => s.sessionId !== sessionIdToDelete)); 
            if (selectedSessionId === sessionIdToDelete) {
                setSelectedSessionId(null);
                setSessionMessages([]);
            }
        } catch (err) {
            toast.error(`Delete failed: ${err.response?.data?.message || err.message}`, { id: toastId });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Chat History" size="2xl">
            <div className="flex flex-col md:flex-row gap-4 max-h-[70vh] h-[70vh]">
                <div className="w-full md:w-1/3 border-r border-border-light dark:border-border-dark pr-0 md:pr-2 overflow-y-auto custom-scrollbar">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark px-1">Your Sessions</h3>
                    {loadingSessions && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24}/></div>}
                    {!loadingSessions && !sessions.length && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">No past sessions found.</p>}
                    <ul className="space-y-1">
                        {sessions.map(session => (
                            <li key={session.sessionId} onClick={() => handleSessionSelectForPreview(session.sessionId)}
                                className={`p-2.5 rounded-md cursor-pointer text-xs transition-colors group relative hover:shadow-md
                                            ${selectedSessionId === session.sessionId ? 'bg-primary text-white' : 'bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700'}`} >
                                <div className="font-medium truncate" title={session.preview}>{session.preview || `Session ${session.sessionId.substring(0,8)}`}</div>
                                <div className={`text-[0.7rem] ${selectedSessionId === session.sessionId ? 'text-blue-200' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                    {formatDate(session.updatedAt)} - {session.messageCount} msgs
                                </div>
                                <IconButton icon={Trash2} size="sm" variant="ghost" title="Delete session"
                                    className="absolute top-1 right-1 p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100"
                                    onClick={(e) => handleDeleteSession(session.sessionId, e)} />
                            </li>
                        ))}
                    </ul>
                </div>

                <div className="w-full md:w-2/3 flex flex-col overflow-hidden mt-4 md:mt-0">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark">Preview</h3>
                    <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md overflow-y-auto custom-scrollbar border border-border-light dark:border-border-dark">
                        {loadingMessages && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24} /></div>}
                        
                        <div className="space-y-3 flex flex-col">
                            {sessionMessages.map(msg => {
                                const isUser = msg.sender === 'user';
                                return (
                                    <div key={msg.id} className={`flex w-full ${isUser ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`p-2.5 rounded-lg shadow-sm w-fit max-w-[90%] text-xs
                                            ${isUser 
                                                ? 'bg-blue-500 text-white' 
                                                : 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100'
                                            }`}>
                                            <p className="font-semibold text-[0.7rem] mb-0.5">{isUser ? 'You' : 'AI Tutor'}</p>
                                            <p className="whitespace-pre-wrap break-words">{msg.text}</p>
                                            <p className={`text-[0.65rem] mt-1 text-right ${isUser ? 'opacity-70' : 'opacity-50'}`}>{formatDate(msg.timestamp)}</p>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {!loadingMessages && !selectedSessionId && (
                            <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark text-sm">
                                <MessageSquareText size={40} className="mb-3 opacity-50" />
                                <p>Select a session to view its messages.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            <div className="mt-6 pt-4 border-t border-border-light dark:border-border-dark flex justify-end gap-3">
                <button onClick={onClose} className="btn-secondary !text-xs !py-1.5 !px-3">Cancel</button>
                <button onClick={handleLoadSessionAndClose} className="btn-primary !text-xs !py-1.5 !px-3" disabled={!selectedSessionId || loadingMessages || loadingSessions}>Load Session</button>
            </div>
        </Modal>
    );
}
export default ChatHistoryModal;
```

`frontend/src/components/chat/ChatInput.jsx`

```javascript


// frontend/src/components/chat/ChatInput.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Send, Mic, Plus, Brain, Zap, Globe, BookMarked } from 'lucide-react'; // Ensure BookMarked is imported
import { useWebSpeech } from '../../hooks/useWebSpeech';
import Button from '../core/Button.jsx'; 
import IconButton from '../core/IconButton.jsx';
import toast from 'react-hot-toast';
import blueBrain from "./../../assets/blueBrain.svg";
import { motion, AnimatePresence } from 'framer-motion';

function ChatInput({ 
    onSendMessage, 
    isLoading,
    useWebSearch,
    setUseWebSearch,
    useAcademicSearch, // This prop is now used
    setUseAcademicSearch, // This prop is now used
    criticalThinkingEnabled,
    setCriticalThinkingEnabled
}) {
    const [inputValue, setInputValue] = useState('');
    const { transcript, listening, isSpeechSupported, startListening, stopListening, resetTranscript } = useWebSpeech();
    const textareaRef = useRef(null);
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const menuRef = useRef(null);

    useEffect(() => {
        if (transcript) {
            setInputValue(prev => prev + (prev ? " " : "") + transcript);
            resetTranscript(); 
        }
    }, [transcript, resetTranscript]);
    
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 128)}px`;
        }
    }, [inputValue]);

    useEffect(() => {
        function handleClickOutside(event) {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                setIsMenuOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
    }, [menuRef]);

    const handleSubmit = (e) => {
        e.preventDefault();
        if (inputValue.trim() && !isLoading) {
            onSendMessage(inputValue.trim());
            setInputValue('');
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !isLoading) {
            e.preventDefault();
            handleSubmit(e);
        }
    };
    
    const handleWebSearchToggle = () => {
        const newWebSearchState = !useWebSearch;
        setUseWebSearch(newWebSearchState);
        toast(newWebSearchState ? "Web Search enabled." : "Web Search disabled.", { icon: newWebSearchState ? "🌐" : "📄" });
        setIsMenuOpen(false);
    };

    // --- THIS IS THE NEW HANDLER ---
    const handleAcademicSearchToggle = () => {
        const newState = !useAcademicSearch;
        setUseAcademicSearch(newState);
        toast(newState ? "Academic Search enabled." : "Academic Search disabled.", { icon: newState ? "🎓" : "📄" });
        setIsMenuOpen(false);
    };

    const icon = criticalThinkingEnabled ? () => <img src={blueBrain} alt="Blue Brain" className="w-5 h-5" /> : Brain;

    return (
        <div className="p-2 sm:p-3 bg-surface-light dark:bg-surface-dark/50 backdrop-blur-sm rounded-b-lg shadow-inner">
            <form onSubmit={handleSubmit} className="flex items-end gap-2">
                <div className="relative" ref={menuRef}>
                    <IconButton
                        icon={Plus}
                        title="More Options"
                        onClick={() => setIsMenuOpen(!isMenuOpen)}
                        variant="ghost"
                        size="md" 
                        className="p-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                        disabled={isLoading}
                    />
                    <AnimatePresence>
                    {isMenuOpen && (
                        <motion.div
                            initial={{ opacity: 0, y: 10, scale: 0.95 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: 10, scale: 0.95 }}
                            className="absolute bottom-full left-0 mb-2 w-56 bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl border border-border-light dark:border-border-dark p-1 z-10"
                        >
                            {/* Web Search Button */}
                            <button
                                onClick={handleWebSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useWebSearch
                                    ? 'bg-primary/10 text-primary dark:bg-primary-dark/20 dark:text-primary-light'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <Globe size={16} />
                                {useWebSearch ? 'Disable Web Search' : 'Enable Web Search'}
                            </button>

                            {/* --- THIS IS THE NEW ACADEMIC SEARCH BUTTON --- */}
                            <button
                                onClick={handleAcademicSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useAcademicSearch
                                    ? 'bg-purple-500/10 text-purple-600 dark:bg-purple-400/20 dark:text-purple-300'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <BookMarked size={16} />
                                {useAcademicSearch ? 'Disable Academic Search' : 'Enable Academic Search'}
                            </button>
                             
                             <button
                                onClick={() => {toast("File attachment coming soon!", { icon: "📎" }); setIsMenuOpen(false);}}
                                className="w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md text-text-muted-light dark:text-text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700"
                            >
                                <Zap size={16} />
                                Attach File (soon)
                            </button>
                        </motion.div>
                    )}
                    </AnimatePresence>
                </div>

                <textarea
                    ref={textareaRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder={isLoading ? "Waiting for response..." : "Type your message or ask a question..."}
                    className="input-field flex-1 p-2.5 resize-none min-h-[44px] max-h-32 custom-scrollbar text-sm" 
                    rows="1"
                    disabled={isLoading}
                />

                {isSpeechSupported && (
                    <IconButton
                        icon={Mic}
                        onClick={() => listening ? stopListening() : startListening()}
                        title={listening ? "Stop listening" : "Start voice input"}
                        variant={listening ? "danger" : "ghost"} 
                        size="md"
                        className={`p-2 ${listening ? 'text-red-500 animate-pulse' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        disabled={isLoading}
                    />
                )}

               <IconButton
                    icon={icon}
                    onClick={() => setCriticalThinkingEnabled(!criticalThinkingEnabled)}
                    title={criticalThinkingEnabled ? "Disable Critical Thinking (KG)" : "Enable Critical Thinking (KG)"}
                    variant="ghost"
                    size="md"
                    className={`p-2 ${criticalThinkingEnabled ? 'text-purple-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                    disabled={isLoading}
                />

                <Button 
                    type="submit"
                    variant="primary"
                    size="md" 
                    className="!p-2.5" 
                    disabled={isLoading || !inputValue.trim()}
                    isLoading={isLoading && !!inputValue.trim()} 
                    title="Send message"
                >
                    {(!isLoading || !inputValue.trim()) ? <Send size={20} /> : null}
                </Button>
            </form>
            
            <div className="flex flex-wrap items-center justify-center mt-2 px-2 text-center h-4 gap-x-4">
                <AnimatePresence>
                    {useWebSearch && (
                        <motion.p
                            key="web-search-indicator"
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-blue-500 dark:text-blue-400 flex items-center gap-1.5 font-medium"
                        >
                            <Globe size={12} /> Web Search is ON
                        </motion.p>
                    )}
                    {useAcademicSearch && (
                        <motion.p
                            key="academic-search-indicator"
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-purple-500 dark:text-purple-400 flex items-center gap-1.5 font-medium"
                        >
                            <BookMarked size={12} /> Academic Search is ON
                        </motion.p>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default ChatInput;
```

`frontend/src/components/chat/MessageBubble.jsx`

```javascript
// src/components/chat/MessageBubble.jsx
import React, { useEffect, useRef } from 'react'; // Import useEffect and useRef
import { marked } from 'marked';
import Prism from 'prismjs'; // Import Prism for manual highlighting
import { ChevronDown, Brain, Link as LinkIcon, Zap, Server, Volume2, StopCircle, ServerCrash } from 'lucide-react';
import { useTextToSpeech } from '../../hooks/useTextToSpeech.js';
import IconButton from '../core/IconButton.jsx';
import { renderMathInHtml } from '../../utils/markdownUtils'; // Import the math renderer
import DOMPurify from 'dompurify'; // Import DOMPurify for security

// Configure marked - it's good to have it here
marked.setOptions({
  breaks: true,
  gfm: true,
});

// Create a new, safer markup creation function
const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    // 1. Convert Markdown to HTML
    let rawHtml = marked.parse(markdownText);
    // 2. Render KaTeX math within the HTML
    rawHtml = renderMathInHtml(rawHtml);
    // 3. Sanitize the final HTML to prevent XSS attacks
    const cleanHtml = DOMPurify.sanitize(rawHtml, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};


const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

function MessageBubble({ sender, text, thinking, references, timestamp, sourcePipeline, id: messageId }) {
    const isUser = sender === 'user';
    const { speak, cancel, isSpeaking: isCurrentlySpeakingThisBubble, isSupported: ttsIsSupported } = useTextToSpeech();
    
    // --- START OF CHANGES ---
    // 1. Create a ref to attach to the content container
    const contentRef = useRef(null);

    // 2. Use an effect to run Prism highlighting after the component renders/updates
    useEffect(() => {
        // The timeout ensures that React has finished rendering the HTML from `dangerouslySetInnerHTML`
        // before Prism tries to find the code blocks.
        const timer = setTimeout(() => {
            if (contentRef.current) {
                Prism.highlightAllUnder(contentRef.current);
            }
        }, 50); // A small delay is usually sufficient

        return () => clearTimeout(timer); // Cleanup timer on unmount
    }, [text]); // Re-run this effect whenever the message text changes
    // --- END OF CHANGES ---

    const formatTimestamp = (ts) => {
        if (!ts) return '';
        try {
            return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } catch (e) { return 'Invalid Time'; }
    };

    const getPipelineIcon = () => {
        if (!sourcePipeline) return null;
        const lowerPipeline = sourcePipeline.toLowerCase();
        if (lowerPipeline.includes('ollama')) return <Zap size={12} className="text-green-400" title="Ollama Powered" />;
        if (lowerPipeline.includes('gemini')) return <Server size={12} className="text-blue-400" title="Gemini Powered" />;
        if (lowerPipeline.includes('rag')) return <Zap size={12} className="text-purple-400" title="RAG Enhanced" />;
        if (lowerPipeline.includes('error')) return <ServerCrash size={12} className="text-red-400" title="Error" />;
        return null;
    };

    const handleToggleSpeech = () => {
        if (!ttsIsSupported || !text) return;
        if (isCurrentlySpeakingThisBubble) {
            cancel();
        } else {
            speak({ text });
        }
    };
    
    return (
        <div className={`flex flex-col ${isUser ? 'items-end' : 'items-start'} w-full group`}>
            <div 
                className={`message-bubble max-w-[85%] md:max-w-[75%] p-3 rounded-2xl shadow-md break-words ${
                    isUser 
                    ? 'bg-primary dark:bg-primary-dark text-white rounded-br-lg' 
                    : 'bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark rounded-bl-lg border border-border-light dark:border-border-dark'
                }`}
            >
                {/* Main message content */}
                <div 
                    // 3. Attach the ref to the div that contains the dangerous HTML
                    ref={contentRef}
                    className="prose prose-sm dark:prose-invert max-w-none message-content leading-relaxed" 
                    dangerouslySetInnerHTML={createMarkup(text || '')} 
                />
                
                {/* Timestamp, Pipeline Icon, and TTS Button */}
                <div className="flex items-center justify-end mt-1.5 text-xs opacity-70 gap-2">
                    {!isUser && getPipelineIcon() && <span className="mr-1">{getPipelineIcon()}</span>}
                    <span>{formatTimestamp(timestamp)}</span>
                    {!isUser && ttsIsSupported && text && (
                        <IconButton
                            icon={isCurrentlySpeakingThisBubble ? StopCircle : Volume2}
                            onClick={handleToggleSpeech}
                            title={isCurrentlySpeakingThisBubble ? "Stop reading" : "Read aloud"}
                            size="sm"
                            variant="ghost"
                            className={`p-0.5 ${isCurrentlySpeakingThisBubble ? 'text-red-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        />
                    )}
                </div>
            </div>

            {/* Metadata: Thinking and References for Bot Messages */}
            {!isUser && (thinking || (references && references.length > 0)) && (
                <div className="message-metadata-container max-w-[85%] md:max-w-[75%] mt-1.5 pl-2 space-y-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    {thinking && thinking.trim() && (
                        <details className="group/details text-xs">
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <Brain size={14} /> AI Reasoning
                                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
                            </summary>
                            <pre className="mt-1 p-2 bg-gray-100 dark:bg-gray-800 rounded-md text-text-light dark:text-text-dark whitespace-pre-wrap break-all text-[0.7rem] max-h-32 overflow-y-auto custom-scrollbar">
                                <code>{escapeHtml(thinking)}</code>
                            </pre>
                        </details>
                    )}
                    {references && references.length > 0 && (
                        <details className="group/details text-xs" open>
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <LinkIcon size={14} /> References
                                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
                            </summary>
                            <ul className="mt-1 pl-1 space-y-0.5 text-[0.7rem]">
                                {references.map((ref, index) => (
                                    <li 
                                        key={index} 
                                        className="text-text-muted-light dark:text-text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors truncate"
                                        title={`Preview: ${escapeHtml(ref.content_preview || '')}\nSource: ${escapeHtml(ref.source || '')}`}
                                    >
                                        <span className="font-semibold text-accent">[{ref.number}]</span> {escapeHtml(ref.source)}
                                    </li>
                                ))}
                            </ul>
                        </details>
                    )}
                </div>
            )}
        </div>
    );
}
export default MessageBubble;
```

`frontend/src/components/chat/ThinkingDropdown.jsx`

```javascript
// frontend/src/components/chat/ThinkingDropdown.jsx
import React, { useState } from 'react';
import { ChevronDown, BrainCircuit } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

function ThinkingDropdown({ children, isStreaming }) {
    const [isOpen, setIsOpen] = useState(false);

    return (
        <div className="text-xs border border-border-light dark:border-border-dark rounded-md bg-surface-light/50 dark:bg-surface-dark/50 shadow-sm mt-1.5 w-full">
            <button
                onClick={() => setIsOpen(!isOpen)}
                className="w-full flex items-center justify-between p-2 text-left text-text-muted-light dark:text-text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700/50 transition-colors rounded-t-md"
                aria-expanded={isOpen}
            >
                <div className="flex items-center gap-2 font-medium">
                    <BrainCircuit size={14} />
                    <span className="flex-grow">Thinking Process</span>
                </div>
                {/* Shimmer effect for when streaming is active */}
                {isStreaming && (
                    <div className="relative w-20 h-4 ml-auto mr-2 overflow-hidden rounded bg-gray-200 dark:bg-gray-600">
                        <div className="shimmer-animation"></div>
                    </div>
                )}
                <ChevronDown size={16} className={`transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} />
            </button>
            <AnimatePresence initial={false}>
                {isOpen && (
                    <motion.div
                        key="content"
                        initial="collapsed"
                        animate="open"
                        exit="collapsed"
                        variants={{
                            open: { opacity: 1, height: 'auto' },
                            collapsed: { opacity: 0, height: 0 }
                        }}
                        transition={{ duration: 0.3, ease: 'easeInOut' }}
                        className="overflow-hidden"
                    >
                        <div className="p-2.5 border-t border-border-light dark:border-border-dark bg-white dark:bg-gray-800 rounded-b-md">
                            {children}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}

export default ThinkingDropdown;
```

`frontend/src/components/common/ThemeToggle.jsx`

```javascript
import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="p-2 rounded-full text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
            aria-label={theme === 'light' ? 'Switch to dark theme' : 'Switch to light theme'}
        >
            {theme === 'light' ? <Moon size={20} /> : <Sun size={20} />}
        </button>
    );
}

export default ThemeToggle;
```

`frontend/src/components/core/Button.jsx`

```javascript
// src/components/core/Button.jsx
import React from 'react';
import { Loader2 } from 'lucide-react'; // For loading spinner

const Button = ({
    children,
    onClick,
    type = 'button',
    variant = 'primary', // 'primary', 'secondary', 'danger', 'outline', 'ghost'
    size = 'md', // 'sm', 'md', 'lg'
    leftIcon,
    rightIcon,
    isLoading = false,
    disabled = false,
    fullWidth = false,
    className = '',
    ...props
}) => {
    const baseStyles = "font-semibold rounded-lg focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2";

    const variantStyles = {
        primary: "bg-primary hover:bg-primary-dark text-white focus:ring-primary",
        secondary: "bg-secondary hover:bg-secondary-dark text-white focus:ring-secondary",
        danger: "bg-red-500 hover:bg-red-600 text-white focus:ring-red-500",
        outline: "border border-primary text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
        ghost: "text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
    };

    const sizeStyles = {
        sm: "px-3 py-1.5 text-xs",
        md: "px-4 py-2 text-sm",
        lg: "px-6 py-3 text-base",
    };

    const widthStyle = fullWidth ? "w-full" : "";
    const isDisabled = disabled || isLoading;
    const finalDisabledStyle = isDisabled ? "opacity-60 cursor-not-allowed" : "cursor-pointer";

    const spinnerSize = size === 'sm' ? 14 : (size === 'lg' ? 20 : 16);
    
    return (
        <button
            type={type}
            onClick={onClick}
            disabled={isDisabled} // Use the corrected variable
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${widthStyle} ${finalDisabledStyle} ${className}`}
            {...props}
        >
            {isLoading && (
                <Loader2 size={spinnerSize} className="animate-spin" />
            )}
            {!isLoading && leftIcon && <span className="icon-left">{leftIcon}</span>}

            <span className={isLoading ? 'ml-2' : ''}>{children}</span>

            {!isLoading && rightIcon && <span className="icon-right">{rightIcon}</span>}
        </button>
    );
};

export default Button;
```

`frontend/src/components/core/IconButton.jsx`

```javascript
import React from 'react';
import { Loader2 } from 'lucide-react';

const IconButton = ({
    icon: Icon, // Pass the Lucide icon component directly
    onClick,
    variant = 'ghost', // 'ghost', 'outline', 'subtle'
    size = 'md', // 'sm', 'md', 'lg'
    isLoading = false,
    disabled = false,
    className = '',
    title, // For accessibility and tooltips
    ariaLabel,
    ...props
}) => {
    const baseStyles = "rounded-md focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-colors duration-150 flex items-center justify-center";

    const variantStyles = {
        ghost: "text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:ring-primary",
        outline: "border border-gray-300 dark:border-gray-600 text-text-muted-light dark:text-text-muted-dark hover:border-primary hover:text-primary focus:ring-primary",
        subtle: "bg-gray-100 dark:bg-gray-700 text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-600 focus:ring-primary",
        danger: "text-red-500 hover:bg-red-100 dark:hover:bg-red-900 focus:ring-red-500"
    };

    const sizeStyles = {
        sm: "p-1.5", // Icon size typically 14-16px
        md: "p-2",   // Icon size typically 18-20px
        lg: "p-2.5", // Icon size typically 22-24px
    };
    
    const iconSizeMap = {
        sm: 16,
        md: 20,
        lg: 24,
    };

    const disabledStyle = (disabled || isLoading) ? "opacity-50 cursor-not-allowed" : "cursor-pointer";

    return (
        <button
            type="button"
            onClick={onClick}
            disabled={disabled || isLoading}
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${disabledStyle} ${className}`}
            title={title}
            aria-label={ariaLabel || title}
            {...props}
        >
            {isLoading ? (
                <Loader2 size={iconSizeMap[size]} className="animate-spin" />
            ) : (
                Icon && <Icon size={iconSizeMap[size]} />
            )}
        </button>
    );
};

export default IconButton;
```

`frontend/src/components/core/Modal.jsx`

```javascript
// src/components/core/Modal.jsx
import React, { useEffect, useRef } from 'react';
import { X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const Modal = ({
    isOpen,
    onClose,
    title,
    children,
    footerContent,
    size = 'md', // 'sm', 'md', 'lg', 'xl', '2xl', '3xl', '4xl', '5xl', 'full'
    closeOnOverlayClick = true,
    initialFocusRef, // Optional ref for focusing an element inside the modal on open
}) => {
    const modalRef = useRef(null);

    // Handle Escape key for closing
    useEffect(() => {
        const handleEscapeKey = (event) => {
            if (event.key === 'Escape' && isOpen) {
                onClose();
            }
        };
        if (isOpen) {
            document.addEventListener('keydown', handleEscapeKey);
        }
        return () => {
            document.removeEventListener('keydown', handleEscapeKey);
        };
    }, [isOpen, onClose]);

    // Handle focus trapping and initial focus
    useEffect(() => {
        if (isOpen) {
            // Set focus to the initialFocusRef or the modal itself
            if (initialFocusRef && initialFocusRef.current) {
                initialFocusRef.current.focus();
            } else if (modalRef.current) {
                modalRef.current.focus(); // Fallback to modal itself
            }

            // Basic focus trapping (can be made more robust with a library)
            const focusableElements = modalRef.current?.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements && focusableElements.length > 0) {
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                const onKeyDown = (e) => {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) { // Shift + Tab
                            if (document.activeElement === firstElement) {
                                lastElement.focus();
                                e.preventDefault();
                            }
                        } else { // Tab
                            if (document.activeElement === lastElement) {
                                firstElement.focus();
                                e.preventDefault();
                            }
                        }
                    }
                };
                modalRef.current?.addEventListener('keydown', onKeyDown);
                return () => modalRef.current?.removeEventListener('keydown', onKeyDown);
            }
        }
    }, [isOpen, initialFocusRef]);


    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl',
        '3xl': 'max-w-3xl',
        '4xl': 'max-w-4xl',
        '5xl': 'max-w-5xl',
        full: 'max-w-full h-full rounded-none sm:rounded-lg sm:max-h-[95vh]', // Special case for full screen like
    };

    const backdropVariants = {
        visible: { opacity: 1, transition: { duration: 0.2, ease: "easeOut" } },
        hidden: { opacity: 0, transition: { duration: 0.15, ease: "easeIn" } },
    };

    const modalVariants = {
        hidden: { y: "-30px", opacity: 0, scale: 0.98, transition: { duration: 0.15, ease: "easeIn" } },
        visible: { y: "0", opacity: 1, scale: 1, transition: { type: "spring", stiffness: 400, damping: 30, duration: 0.3 } },
        exit: { y: "30px", opacity: 0, scale: 0.98, transition: { duration: 0.2, ease: "easeIn" } }
    };

    if (!isOpen) return null;

    return (
        <AnimatePresence mode="wait">
            {isOpen && (
                <motion.div
                    key="modal-backdrop"
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 dark:bg-black/80 backdrop-blur-sm"
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    variants={backdropVariants}
                    onClick={closeOnOverlayClick ? onClose : undefined}
                    aria-labelledby="modal-title" // For screen readers
                    role="dialog" // Role for the backdrop itself, more specific roles on content
                    aria-modal="true" // Indicate it's a modal overlaying other content
                >
                    <motion.div
                        key="modal-content-wrapper" // Changed key for potential AnimatePresence behavior
                        ref={modalRef}
                        tabIndex={-1} // Make the modal itself focusable for fallback
                        className={`bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl w-full ${sizeClasses[size]} flex flex-col overflow-hidden
                                    ${size === 'full' ? '' : 'max-h-[90vh] sm:max-h-[85vh]'}`} 
                                    // Apply max-h unless it's 'full' size
                        role="document" // The actual dialog content
                        aria-modal="true"
                        aria-labelledby={title ? "modal-title-text" : undefined} // Point to title if exists
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        variants={modalVariants}
                        onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside modal
                    >
                        {/* Modal Header */}
                        <div className="flex items-center justify-between px-5 py-3.5 border-b border-border-light dark:border-border-dark sticky top-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                            {title && (
                                <h2 id="modal-title-text" className="text-lg font-semibold text-text-light dark:text-text-dark truncate pr-4">
                                    {title}
                                </h2>
                            )}
                            <button
                                onClick={onClose}
                                className="p-1.5 rounded-full text-text-muted-light dark:text-text-muted-dark 
                                           hover:bg-gray-200/80 dark:hover:bg-gray-700/80 
                                           hover:text-red-500 dark:hover:text-red-400 
                                           focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary-light focus:ring-offset-1 dark:focus:ring-offset-surface-dark"
                                aria-label="Close modal"
                            >
                                <X size={20} />
                            </button>
                        </div>

                        {/* Modal Body */}
                        <div className="px-5 py-4 overflow-y-auto flex-grow custom-scrollbar">
                            {children}
                        </div>

                        {/* Modal Footer */}
                        {footerContent && (
                            <div className="px-5 py-3.5 border-t border-border-light dark:border-border-dark flex justify-end gap-3 sticky bottom-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                                {footerContent}
                            </div>
                        )}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

export default Modal;
```

`frontend/src/components/documents/DocumentList.jsx`

```javascript


// frontend/src/components/documents/DocumentList.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api.js'; // Mocked for V1
import toast from 'react-hot-toast';
import { FileText, Edit3, Trash2, Loader2, AlertTriangle, CheckCircle } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Make sure IconButton is imported
import { useAuth } from '../../hooks/useAuth.jsx';

// Props from LeftPanel: onSelectDocument is selectDocumentForAnalysis from AppStateContext
// selectedDocument is selectedDocumentForAnalysis from AppStateContext
function DocumentList({ onSelectDocument, selectedDocument }) {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const fetchFiles = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      
      const response = await api.getFiles(); // Returns { filenames: ["A.txt", "B.pdf"] }
      const filenames = Array.isArray(response.filenames) ? response.filenames : [];
      setFiles(filenames);
      
    } catch (err) {
      console.error("Failed to fetch files:", err);
      setError(err.message || "Failed to fetch files.");
      toast.error("Could not load documents.");
    } finally {
      setLoading(false);
    }
  }, []);



  useEffect(() => {
    fetchFiles();
  }, [fetchFiles]);

  const handleDelete = async (filename) => {
    if (!window.confirm(`Are you sure you want to delete "${filename}"?`)) return;
    const toastId = toast.loading(`Deleting ${filename}...`);
    try {
      await api.deleteFile(filename); // Assumes this works with filename
      toast.success(`${filename} deleted.`, { id: toastId });
      fetchFiles();
      if (selectedDocument === filename) {
        onSelectDocument(null);
      }
    } catch (err) {
      toast.error(`Delete failed: ${err.message}`, { id: toastId });
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark">
        <Loader2 size={20} className="animate-spin mr-2" /> Loading documents...
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
        <AlertTriangle size={18} /> {error}
        <button onClick={fetchFiles} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
      </div>
    );
  }

  if (files.length === 0) {
    return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-4">No documents uploaded.</p>;
  }

  return (
    <div className="space-y-1.5 text-xs custom-scrollbar pr-1">
      {files.map(filename => {
        const isSelected = selectedDocument === filename;

        return (
          <div
            key={filename}
            onClick={() => onSelectDocument(isSelected ? null : filename)}
            className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                        ${isSelected
                          ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                          : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
            title={`Select ${filename}`}
          >
            <div className="flex items-center gap-2 truncate">
              {isSelected ? (
                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
              ) : (
                <FileText size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
              )}
              <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                {filename}
              </span>
            </div>
            <div className="flex-shrink-0 flex items-center gap-0.5">
              <IconButton
                icon={Trash2}
                size="sm"
                variant="ghost"
                title="Delete"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete(filename);
                }}
                className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"
              />
            </div>
          </div>
        );
      })}
    </div>
  );
}


export default DocumentList;
```

`frontend/src/components/documents/DocumentUpload.jsx`

```javascript
// frontend/src/components/documents/DocumentUpload.jsx
import React, { useState, useRef, useEffect } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { UploadCloud, FileText, XCircle, Paperclip } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';

// Define the stages for our static simulation
const RAG_STAGES = [
    { name: "Uploading", duration: 1500, message: "Transferring your document to the server..." },
    { name: "Processing", duration: 2000, message: "Validating file format and structure..." },
    { name: "Extracting", duration: 3000, message: "Extracting text and content from your document..." },
    { name: "Chunking", duration: 1500, message: "Breaking document into manageable segments..." },
    { name: "Embedding", duration: 4000, message: "Converting content to searchable vectors..." },
    { name: "Analyzing", duration: 3000, message: "Indexing content for optimal retrieval..." },
];

function DocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const [progress, setProgress] = useState(0);
    const [currentStage, setCurrentStage] = useState('');
    const [stageMessage, setStageMessage] = useState('');
    const [errorMessage, setErrorMessage] = useState('');
    const [dragActive, setDragActive] = useState(false);

    const fileInputRef = useRef(null);
    const processingTimeoutRef = useRef(null);
    
    useEffect(() => {
        return () => {
            if (processingTimeoutRef.current) {
                clearTimeout(processingTimeoutRef.current);
            }
        };
    }, []);

    const handleFileChange = (e) => {
        if (isProcessing) return;
        const file = e.target.files && e.target.files[0];
        if (file) {
            setSelectedFile(file);
            setErrorMessage('');
        }
    };

    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(e.type === "dragenter" || e.type === "dragover"); };
    const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(false); const file = e.dataTransfer.files && e.dataTransfer.files[0]; if (file) { setSelectedFile(file); setErrorMessage(''); }};

    const resetState = () => {
        setSelectedFile(null);
        setIsProcessing(false);
        setProgress(0);
        setCurrentStage('');
        setStageMessage('');
        setErrorMessage('');
        if (fileInputRef.current) fileInputRef.current.value = null;
    };
    
    const runProgressSimulation = (stageIndex = 0) => {
        if (stageIndex >= RAG_STAGES.length) return;

        const stage = RAG_STAGES[stageIndex];
        setCurrentStage(stage.name);
        setStageMessage(stage.message);
        
        const totalDuration = RAG_STAGES.reduce((acc, s) => acc + s.duration, 0);
        const elapsedDuration = RAG_STAGES.slice(0, stageIndex).reduce((acc, s) => acc + s.duration, 0);
        setProgress(Math.round((elapsedDuration / totalDuration) * 100));

        processingTimeoutRef.current = setTimeout(() => {
            runProgressSimulation(stageIndex + 1);
        }, stage.duration);
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            toast.error("Please select a file first.");
            return;
        }

        setIsProcessing(true);
        setErrorMessage('');
        runProgressSimulation(0);

        const formData = new FormData();
        formData.append("file", selectedFile);
        
        try {
            await api.uploadFile(formData);

            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            setCurrentStage("Ready");
            setStageMessage("Document successfully processed and ready to use!");
            setProgress(100);
            toast.success(`'${selectedFile.name}' processed successfully!`);
            
            setTimeout(() => {
                resetState();
                if (onUploadSuccess) onUploadSuccess();
            }, 2500);

        } catch (error) {
            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            const msg = error.response?.data?.message || error.message || "Upload failed.";
            setErrorMessage(msg);
            toast.error(`Upload failed: ${msg}`);
            setIsProcessing(false);
            setCurrentStage('Failed');
            setProgress(100);
        }
    };

    if (isProcessing) {
        return (
            <div className="card-base p-4 mb-4">
                <h3 className="font-semibold text-text-light dark:text-text-dark">
                    📄 Processing: <span className="font-normal truncate">{selectedFile.name}</span>
                </h3>
                <div className="relative w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 my-2">
                    <motion.div
                        className={`h-2.5 rounded-full ${errorMessage ? 'bg-red-500' : 'bg-primary'}`}
                        initial={{ width: '0%' }}
                        animate={{ width: `${progress}%` }}
                        transition={{ duration: 0.5, ease: 'linear' }}
                    />
                </div>
                <div className="flex justify-between text-xs text-text-muted-light dark:text-text-muted-dark">
                    <span>{errorMessage ? 'Error' : `Stage: ${currentStage}`} ({progress}%)</span>
                </div>
                <p className="text-xs text-center mt-2 h-4">{errorMessage || stageMessage}</p>
                {errorMessage && (
                    <Button onClick={resetState} fullWidth variant="danger" size="sm" className="mt-3">
                        Close
                    </Button>
                )}
            </div>
        );
    }
    
    return (
        <div className="mb-4 p-1">
            <label
                htmlFor="file-upload-input"
                onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}
                className={`flex flex-col items-center justify-center w-full h-36 px-4 transition-colors duration-200 ease-in-out bg-surface-light dark:bg-gray-800 border-2 border-dashed rounded-lg cursor-pointer border-border-light dark:border-border-dark hover:border-primary dark:hover:border-primary-light ${dragActive ? "border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light bg-primary/10 dark:bg-primary-dark/20" : ""}`}
            >
                <div className="flex flex-col items-center justify-center text-center">
                    <Paperclip size={36} className={`mb-2 transition-colors ${dragActive ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                    <p className="mb-1 text-sm text-text-muted-light dark:text-text-muted-dark">
                        <span className="font-semibold text-primary dark:text-primary-light">Click to upload</span> or drag and drop
                    </p>
                    <p className="text-xs text-text-muted-light dark:text-text-muted-dark">PDF, DOCX, TXT, PPTX, code files</p>
                </div>
                <input ref={fileInputRef} id="file-upload-input" type="file" className="hidden" onChange={handleFileChange}
                       accept=".pdf,.doc,.docx,.ppt,.pptx,.txt,.py,.js,.md,.html,.xml,.json,.csv,.log,.c,.cpp,.java" />
            </label>

            {selectedFile && (
                <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm animate-fadeIn">
                    <div className="flex items-center gap-2 truncate">
                        <FileText size={18} className="text-primary flex-shrink-0" />
                        <span className="truncate text-text-light dark:text-text-dark" title={selectedFile.name}>{selectedFile.name}</span>
                        <span className="text-text-muted-light dark:text-text-muted-dark text-xs whitespace-nowrap">
                            ({(selectedFile.size / 1024).toFixed(1)} KB)
                        </span>
                    </div>
                    <button onClick={() => setSelectedFile(null)} className="text-red-500 hover:text-red-700 dark:hover:text-red-400 transition-colors p-1 rounded-full hover:bg-red-500/10">
                        <XCircle size={18} />
                    </button>
                </div>
            )}

            <Button
                onClick={handleUpload}
                fullWidth
                className="mt-3 text-sm min-h-[38px]"
                variant="primary"
                disabled={!selectedFile}
                leftIcon={<UploadCloud size={16} />}
            >
                Upload Document
            </Button>
        </div>
    );
}

export default DocumentUpload;
```

`frontend/src/components/documents/SubjectList.jsx`

```javascript
// frontend/src/components/documents/SubjectList.jsx
import React from 'react';
import { Library, CheckCircle, Loader2, AlertTriangle } from 'lucide-react'; // Added AlertTriangle

function SubjectList({
    subjects,           // Array of subject name strings
    selectedSubject,    // Currently selected subject name (string or null)
    onSelectSubject,    // Function to call when a subject is selected (passes subjectName or null)
    isLoading,          // Boolean to indicate if subjects are being fetched
    error               // String error message if fetching failed
}) {
    if (isLoading) {
        return (
            <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark text-xs">
                <Loader2 size={16} className="animate-spin mr-2" /> Loading subjects...
            </div>
        );
    }

    if (error) {
        return (
            <div className="p-2 my-1 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center justify-center gap-1">
                <AlertTriangle size={14} /> {error}
            </div>
        );
    }

    if (!subjects || subjects.length === 0) {
        return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-3">No subjects configured by admin yet.</p>;
    }

    return (
        <div className="space-y-1.5 text-xs custom-scrollbar pr-1 max-h-60 overflow-y-auto"> {/* Added max-h and overflow */}
            {/* Option to deselect/choose general chat */}
            <div
                onClick={() => onSelectSubject(null)} // Pass null to deselect
                className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                            ${!selectedSubject // Highlighted if no subject is selected
                                ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                title="Select General Chat (No Specific Subject)"
            >
                <div className="flex items-center gap-2 truncate">
                    {!selectedSubject ? (
                        <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                    ) : (
                        // Using a generic icon, or you can use a different one for "none"
                        <Library size={16} className="text-gray-400 dark:text-gray-500 flex-shrink-0" />
                    )}
                    <span className={`truncate ${!selectedSubject ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                        -- General Chat --
                    </span>
                </div>
            </div>

            {/* List of available subjects */}
            {subjects.map(subjectName => {
                const isSelected = selectedSubject === subjectName;
                return (
                    <div
                        key={subjectName}
                        onClick={() => onSelectSubject(isSelected ? null : subjectName)} // Toggle selection
                        className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                                    ${isSelected
                                        ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                        : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                        title={`Select Subject: ${subjectName}`}
                    >
                        <div className="flex items-center gap-2 truncate">
                            {isSelected ? (
                                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                            ) : (
                                <Library size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                            )}
                            <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                                {subjectName}
                            </span>
                        </div>
                        {/* No actions like delete for subjects from this view */}
                    </div>
                );
            })}
        </div>
    );
}

export default SubjectList;
```

`frontend/src/components/layout/CenterPanel.jsx`

```javascript

// frontend/src/components/layout/CenterPanel.jsx
import React, { useState, useEffect, useRef } from 'react';
import ChatHistory from '../chat/ChatHistory';
import ChatInput from '../chat/ChatInput';
import api from '../../services/api';
import { useAuth as useRegularAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import toast from 'react-hot-toast';

const THINKING_VARIANTS = ["🧠 Thinking...", "💭 Processing...", "🤔 Analyzing query..."];
const RAG_ANALYSIS_VARIANTS = ["📚 Reviewing documents...", "🎯 Finding relevant info...", "🧩 Combining sources..."];
const WEB_ANALYSIS_VARIANTS = ["🌐 Searching the web...", "🔎 Filtering results...", "📰 Reading latest info..."];
const ACADEMIC_ANALYSIS_VARIANTS = ["🎓 Searching academic papers...", "🔬 Reviewing studies...", "📚 Compiling research..."];
const GENERAL_ANALYSIS_VARIANTS = ["📊 Analyzing context...", "🔍 Searching knowledge base..."];
const GENERATION_VARIANTS = ["✨ Generating response...", "🚀 Crafting answer...", "📝 Preparing explanation..."];

const getRandomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

function CenterPanel({ messages, setMessages, currentSessionId, onChatProcessingChange }) {
    const { token: regularUserToken } = useRegularAuth();
    const { selectedLLM, systemPrompt, selectedDocumentForAnalysis, selectedSubject } = useAppState();

    const [useWebSearch, setUseWebSearch] = useState(false);
    const [useAcademicSearch, setUseAcademicSearch] = useState(false);
    const [criticalThinkingEnabled, setCriticalThinkingEnabled] = useState(false);

    const [botStatusPlaceholder, setBotStatusPlaceholder] = useState(null);

    const isMountedRef = useRef(true);
    const simulationControllerRef = useRef(new AbortController());
    const [isActuallySendingAPI, setIsActuallySendingAPI] = useState(false);

    useEffect(() => {
        isMountedRef.current = true;
        return () => {
            isMountedRef.current = false;
            simulationControllerRef.current.abort();
        };
    }, []);

    useEffect(() => {
        const documentContext = selectedSubject || selectedDocumentForAnalysis;
        if (documentContext && (useWebSearch || useAcademicSearch)) {
            setUseWebSearch(false);
            setUseAcademicSearch(false);
            toast("Web and Academic Search disabled automatically while a document is selected.", { icon: "ℹ️" });
        }
    }, [selectedDocumentForAnalysis, selectedSubject, useWebSearch, useAcademicSearch]);

    const runStatusSimulation = async (isRagActive, isWebActive, isAcademicActive, signal) => {
        let analysisVariants;
        if (isWebActive) {
            analysisVariants = WEB_ANALYSIS_VARIANTS;
        } else if (isAcademicActive) {
            analysisVariants = ACADEMIC_ANALYSIS_VARIANTS;
        } else if (isRagActive) {
            analysisVariants = RAG_ANALYSIS_VARIANTS;
        } else {
            analysisVariants = GENERAL_ANALYSIS_VARIANTS;
        }

        const sequence = [
            { message: getRandomItem(THINKING_VARIANTS), duration: 1200 },
            { message: getRandomItem(analysisVariants), duration: 1500 },
            { message: getRandomItem(GENERATION_VARIANTS), duration: 1300 },
        ];

        for (const stage of sequence) {
            if (signal.aborted) return;
            setBotStatusPlaceholder(stage.message);
            await wait(stage.duration + (Math.random() * 400 - 200));
        }
    };

    const handleSendMessage = async (inputText) => {
        if (!inputText.trim() || !regularUserToken || !currentSessionId || isActuallySendingAPI) return;

        const documentContextName = selectedSubject || selectedDocumentForAnalysis;
        const isRagActive = !!documentContextName;

        simulationControllerRef.current.abort();
        simulationControllerRef.current = new AbortController();
        onChatProcessingChange(true);
        setIsActuallySendingAPI(true);

        const userMessage = {
            id: `user-${Date.now()}`,
            sender: 'user',
            role: 'user',
            text: inputText.trim(),
            parts: [{ text: inputText.trim() }],
            timestamp: new Date().toISOString(),
        };

        setMessages(prev => [...prev, userMessage]);
        setBotStatusPlaceholder("🧠 Thinking...");

        runStatusSimulation(isRagActive, useWebSearch, useAcademicSearch, simulationControllerRef.current.signal);

        try {
            const response = await api.sendMessage({
                query: inputText.trim(),
                history: messages.map(m => ({
                    role: m.role === 'model' ? 'model' : 'user',
                    parts: m.parts || [{ text: m.text }]
                })),
                sessionId: currentSessionId,
                useWebSearch,
                useAcademicSearch,
                systemPrompt,
                criticalThinkingEnabled,
                documentContextName
            });

            if (response && response.reply) {
                if (isMountedRef.current) {
                    setBotStatusPlaceholder(null);
                    setMessages(prev => [...prev, { ...response.reply, id: `bot-${Date.now()}` }]);
                }
            } else {
                throw new Error("Invalid response from AI service.");
            }
        } catch (error) {
            const errorText = error.response?.data?.message || error.message || 'Failed to get response from AI.';
            const errorReply = {
                id: `error-${Date.now()}`,
                sender: 'bot',
                role: 'model',
                text: `Error: ${errorText}`,
                parts: [{ text: `Error: ${errorText}` }],
                timestamp: new Date().toISOString(),
                source_pipeline: "error-pipeline"
            };
            if (isMountedRef.current) {
                setBotStatusPlaceholder(null);
                setMessages(prev => [...prev, errorReply]);
            }
            toast.error(errorText);
        } finally {
            simulationControllerRef.current.abort();
            if (isMountedRef.current) {
                onChatProcessingChange(false);
                setIsActuallySendingAPI(false);
            }
        }
    };

    return (
        <div className="flex flex-col h-full bg-background-light dark:bg-background-dark rounded-lg shadow-inner">
            {messages.length === 0 && !isActuallySendingAPI && currentSessionId ? (
                <div className="p-6 sm:p-8 text-center text-text-muted-light dark:text-text-muted-dark animate-fadeIn">
                    <h2 className="text-xl sm:text-2xl font-semibold mb-2 text-text-light dark:text-text-dark">AI Engineering Tutor</h2>
                    <p className="text-base sm:text-lg mb-3">Session ID: {currentSessionId.substring(0, 8)}...</p>
                    <div className="text-xs sm:text-sm space-y-1">
                        <p>Current LLM: <span className="font-semibold text-accent">{selectedLLM.toUpperCase()}</span>.</p>
                        <p className="max-w-md mx-auto">
                            Assistant Mode: <span className="italic">"{systemPrompt.length > 60 ? systemPrompt.substring(0, 60) + '...' : systemPrompt}"</span>
                        </p>
                        {(selectedSubject || selectedDocumentForAnalysis) && (
                            <p className="mt-1 font-medium">
                                Chat Focus: <span className="text-indigo-500 dark:text-indigo-400">{selectedSubject || selectedDocumentForAnalysis}</span>
                            </p>
                        )}
                    </div>
                </div>
            ) : null}

            <ChatHistory messages={messages} botStatusPlaceholder={botStatusPlaceholder} />

            <ChatInput
                onSendMessage={handleSendMessage}
                isLoading={isActuallySendingAPI}
                useWebSearch={useWebSearch}
                setUseWebSearch={setUseWebSearch}
                useAcademicSearch={useAcademicSearch} 
                setUseAcademicSearch={setUseAcademicSearch}
                criticalThinkingEnabled={criticalThinkingEnabled}
                setCriticalThinkingEnabled={setCriticalThinkingEnabled}
            />
        </div>
    );
}

export default CenterPanel;

```

`frontend/src/components/layout/LeftCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/LeftCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { Edit3, UploadCloud, FileText, ChevronRight, Settings2 } from 'lucide-react'; // Settings2 for fallback
import IconButton from '../core/IconButton.jsx'; 
import { motion } from 'framer-motion';

// Mapping icon names (or IDs) to Lucide components
const iconMap = {
    prompt: Edit3,       // Icon for "Custom Prompt"
    upload: UploadCloud, // Icon for "Upload Document"
    docs: FileText,      // Icon for "Document List"
};

function LeftCollapsedNav() {
    const { setIsLeftPanelOpen } = useAppState();

    // Define the items for the collapsed navigation bar
    const navItems = [
        { 
            id: 'prompt', 
            label: 'Custom Prompt', 
            iconName: 'prompt', // Matches key in iconMap
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, also scroll to/focus the prompt section in LeftPanel
            } 
        },
        { 
            id: 'upload', 
            label: 'Upload Document', 
            iconName: 'upload', 
            action: () => { 
                setIsLeftPanelOpen(true);
                // TODO: Optionally, open LeftPanel and focus/highlight upload area
            } 
        },
        { 
            id: 'docs', 
            label: 'Document List', 
            iconName: 'docs', 
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, open LeftPanel scrolled to document list
            } 
        },
    ];

    return (
        <motion.aside
            key="left-collapsed-nav" // Unique key for AnimatePresence
            initial={{ x: '-100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '-100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            // Styling for the thin vertical bar
            className="fixed left-0 top-16 bottom-0 z-30 w-14 sm:w-16 
                       bg-surface-light dark:bg-surface-dark 
                       border-r border-border-light dark:border-border-dark 
                       shadow-lg flex flex-col items-center py-3 space-y-2 custom-scrollbar"
        >
            {/* Button to open the full LeftPanel - Placed at the top */}
            <IconButton 
                icon={ChevronRight} 
                onClick={() => setIsLeftPanelOpen(true)} 
                title="Open Assistant Panel"
                ariaLabel="Open Assistant Panel"
                variant="ghost" 
                size="lg" // Make it prominent
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />

            {/* Icons for different sections of LeftPanel */}
            {navItems.map(item => {
                const IconComponent = iconMap[item.iconName] || Settings2; // Fallback icon
                return (
                    <IconButton 
                        key={item.id}
                        icon={IconComponent}
                        onClick={item.action} // Action currently just opens the panel
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md" 
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
            {/* Add a flexible spacer if you want the open button pushed further down from items */}
            {/* <div className="flex-grow"></div> */}
        </motion.aside>
    );
}
export default LeftCollapsedNav;
```

`frontend/src/components/layout/LeftPanel.jsx`

```javascript
// frontend/src/components/layout/LeftPanel.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import DocumentUpload from '../documents/DocumentUpload.jsx';
import DocumentList from '../documents/DocumentList.jsx';
import SubjectList from '../documents/SubjectList.jsx'; // <<< NEW IMPORT
import {
    PanelLeftClose, ChevronDown, ChevronUp, FilePlus, Settings2,
    Bot, BookOpen, Lightbulb, Library, Loader2, AlertTriangle // Added AlertTriangle
} from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';
import toast from 'react-hot-toast';
import api from '../../services/api.js'; // Main API service

const PROMPT_PRESETS = [
     { id: 'friendly_tutor', name: 'Friendly Tutor', icon: Bot, text: "You are a friendly, patient, and encouraging tutor specializing in engineering and scientific topics for PhD students. Explain concepts clearly, break down complex ideas, use analogies, and offer positive reinforcement. Ask follow-up questions to ensure understanding." },
     { id: 'concept_explorer', name: 'Concept Explorer', icon: BookOpen, text: "You are an expert academic lecturer introducing a new, complex engineering or scientific concept. Your goal is to provide a deep, structured explanation. Define terms rigorously, outline the theory, provide relevant mathematical formulations (using Markdown), illustrative examples, and discuss applications or limitations pertinent to PhD-level research." },
     { id: 'knowledge_check', name: 'Knowledge Check', icon: Lightbulb, text: "You are assessing understanding of engineering/scientific topics. Ask targeted questions to test knowledge, identify misconceptions, and provide feedback on the answers. Start by asking the user what topic they want to be quizzed on." },
     { id: 'custom', name: 'Custom Prompt', icon: Settings2, text: "You are a helpful AI engineering tutor." }
];

function LeftPanel() {
    const {
        setIsLeftPanelOpen,
        systemPrompt, setSystemPrompt,
        selectDocumentForAnalysis, selectedDocumentForAnalysis,
        selectedSubject, setSelectedSubject // AppState context will handle setting this
    } = useAppState();

    const [isPromptSectionOpen, setIsPromptSectionOpen] = useState(true);
    const [isSubjectSectionOpen, setIsSubjectSectionOpen] = useState(true);
    const [isDocManagementOpen, setIsDocManagementOpen] = useState(true);

    const [selectedPresetId, setSelectedPresetId] = useState('custom');
    const [availableSubjects, setAvailableSubjects] = useState([]);      // State to hold fetched subjects
    const [isLoadingSubjects, setIsLoadingSubjects] = useState(false);   // Loading state for subjects
    const [subjectFetchError, setSubjectFetchError] = useState('');     // Error state for subjects
    const [docListKey, setDocListKey] = useState(Date.now()); // For user's own DocumentList refresh

    useEffect(() => {
        const matchedPreset = PROMPT_PRESETS.find(p => p.text === systemPrompt);
        setSelectedPresetId(matchedPreset ? matchedPreset.id : 'custom');
    }, [systemPrompt]);

    // Fetch subjects (admin document names) on component mount
    const fetchSubjects = useCallback(async () => {
        setIsLoadingSubjects(true);
        setSubjectFetchError(''); // Clear previous errors
        try {
            const response = await api.getSubjects(); // Calls /api/subjects
            // The backend returns { subjects: ["Subject 1", "Subject 2", ...] }
            const subjects = Array.isArray(response.subjects) ? response.subjects : [];
            setAvailableSubjects(subjects);
            if (subjects.length === 0) {
                // FIX: Changed toast.info to just toast() for a standard informational message.
                toast("No admin-defined subjects found to select for chat focus.");
            }
        } catch (error) {
            const errorMsg = error.response?.data?.message || error.message || "Failed to load available subjects.";
            toast.error(errorMsg);
            setSubjectFetchError(errorMsg); // Store error message for display
            console.error("Error fetching subjects:", error);
        } finally {
            setIsLoadingSubjects(false);
        }
    }, []);

    useEffect(() => {
        fetchSubjects();
    }, [fetchSubjects]);

    const handlePresetChange = (event) => {
        const presetId = event.target.value;
        setSelectedPresetId(presetId);
        const selectedPreset = PROMPT_PRESETS.find(p => p.id === presetId);
        if (selectedPreset) setSystemPrompt(selectedPreset.text);
    };

    const handleUploadSuccessForUserDocs = () => {
        setDocListKey(Date.now());
        toast.success("Your document list refreshed after upload.");
    };

    // setSelectedSubject from AppStateContext is passed directly to SubjectList's onSelectSubject prop.

    const SelectedPresetIcon = PROMPT_PRESETS.find(p => p.id === selectedPresetId)?.icon || Settings2;

    return (
        <div className="flex flex-col h-full">
            <div className="flex items-center justify-between mb-3 px-1 pt-1">
                <h2 className="text-sm font-semibold text-text-light dark:text-text-dark">Assistant Controls</h2>
                <IconButton
                    icon={PanelLeftClose}
                    onClick={() => setIsLeftPanelOpen(false)}
                    title="Close Assistant Panel"
                    variant="ghost" size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                />
            </div>

            {/* Custom Prompt Section (Existing) */}
            <div className="mb-4">
                <button onClick={() => setIsPromptSectionOpen(!isPromptSectionOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark" aria-expanded={isPromptSectionOpen}>
                    <span className="flex items-center gap-2"><SelectedPresetIcon size={16} className="text-primary dark:text-primary-light" /> Custom Prompt</span>
                    {isPromptSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isPromptSectionOpen && (
                        <motion.div key="prompt-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden">
                            <label htmlFor="prompt-preset-select" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Prompt Mode:</label>
                             <select id="prompt-preset-select" value={selectedPresetId} onChange={handlePresetChange} className="input-field mb-2 text-xs py-1.5">
                                 {PROMPT_PRESETS.map(preset => (<option key={preset.id} value={preset.id}>{preset.name}</option>))}
                             </select>
                             <label htmlFor="system-prompt-area" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">System Prompt (Editable):</label>
                             <textarea id="system-prompt-area" value={systemPrompt} onChange={(e) => { setSystemPrompt(e.target.value); setSelectedPresetId('custom'); }} rows="5" className="input-field text-xs custom-scrollbar" placeholder="Enter system prompt..."/>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* --- NEW: Select Subject Section --- */}
            <div className="mb-4">
                <button
                    onClick={() => setIsSubjectSectionOpen(!isSubjectSectionOpen)}
                    className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark"
                    aria-expanded={isSubjectSectionOpen}
                >
                    <span className="flex items-center gap-2">
                        <Library size={16} className="text-primary dark:text-primary-light" /> Select Subject Focus
                    </span>
                    {isSubjectSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isSubjectSectionOpen && (
                        <motion.div
                            key="subject-select-content"
                            initial={{ height: 0, opacity: 0 }}
                            animate={{ height: 'auto', opacity: 1 }}
                            exit={{ height: 0, opacity: 0 }}
                            transition={{ duration: 0.2, ease: "easeInOut" }}
                            className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden"
                        >
                           {/* Using the new SubjectList component */}
                           <SubjectList
                                subjects={availableSubjects}
                                selectedSubject={selectedSubject}
                                onSelectSubject={setSelectedSubject} // Pass the setter from AppStateContext
                                isLoading={isLoadingSubjects}
                                error={subjectFetchError}
                           />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* Document Management Section (For REGULAR USER's own documents) */}
            <div className="flex-grow flex flex-col overflow-hidden">
                <button onClick={() => setIsDocManagementOpen(!isDocManagementOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-2" aria-expanded={isDocManagementOpen}>
                    <span className="flex items-center gap-2"><FilePlus size={16} className="text-primary dark:text-primary-light" /> My Documents (for Analysis Tools)</span>
                    {isDocManagementOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isDocManagementOpen && (
                        <motion.div key="doc-management-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="flex-grow flex flex-col overflow-hidden p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner">
                            <DocumentUpload onUploadSuccess={handleUploadSuccessForUserDocs} />
                            <div className="mt-3 flex-grow overflow-y-auto custom-scrollbar">
                                <DocumentList
                                    key={docListKey}
                                    onSelectDocument={selectDocumentForAnalysis}
                                    selectedDocument={selectedDocumentForAnalysis}
                                />
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default LeftPanel;

```

`frontend/src/components/layout/LLMSelectionModal.jsx`

```javascript
// frontend/src/components/layout/LLMSelectionModal.jsx
import React, { useState, useEffect } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { X, Save, KeyRound, AlertCircle, HardDrive } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import LLMSelection from '../auth/LLMSelection.jsx';
import { motion } from 'framer-motion';

function LLMSelectionModal({ isOpen, onClose }) {
    const { selectedLLM: currentLLM, switchLLM: setGlobalLLMPreference } = useAppState();
    
    // State for the provider selection
    const [locallySelectedLLM, setLocallySelectedLLM] = useState(currentLLM);
    
    // Separate state for each input field
    const [geminiApiKeyInput, setGeminiApiKeyInput] = useState('');
    const [ollamaUrlInput, setOllamaUrlInput] = useState('');
    
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        // Reset state every time the modal opens
        if (isOpen) {
            setLocallySelectedLLM(currentLLM);
            setGeminiApiKeyInput(''); 
            setOllamaUrlInput(''); 
            setError('');
        }
    }, [isOpen, currentLLM]);

    const handleSavePreference = async () => {
        setLoading(true); 
        setError('');
        
        try {
            // Start with the provider selection
            const configData = { llmProvider: locallySelectedLLM };

            // Only add other fields if the user actually typed something into them
            if (geminiApiKeyInput.trim()) {
                configData.apiKey = geminiApiKeyInput.trim();
            }
            if (ollamaUrlInput.trim()) {
                configData.ollamaUrl = ollamaUrlInput.trim();
            }
            
            await api.updateUserLLMConfig(configData);
            setGlobalLLMPreference(locallySelectedLLM);
            
            toast.success(`LLM preference updated to ${locallySelectedLLM.toUpperCase()}.`);
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update preference.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2 text-sm w-full";

    return (
         <Modal isOpen={isOpen} onClose={onClose} title="Switch LLM Provider & Credentials" size="lg"
            footerContent={
                <>
                    <Button onClick={onClose} variant="secondary" size="sm" className="text-xs">Cancel</Button>
                    <Button onClick={handleSavePreference} isLoading={loading} size="sm" className="text-xs">
                        <Save size={14} className="mr-1.5"/> Save Preference
                    </Button>
                </>
            }
        >
            <div className="space-y-5"> 
                <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                    Select your preferred LLM. You can also update your credentials here. <br/><strong>Leave a field blank to keep your existing setting.</strong>
                </p>
                <LLMSelection 
                    selectedLLM={locallySelectedLLM} 
                    onLlmChange={setLocallySelectedLLM}
                    disabled={loading}
                />
                
                <motion.div key="gemini-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalGeminiApiKey" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Gemini API Key (Optional)
                    </label>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input type="password" id="modalGeminiApiKey" className={inputFieldStyledClass} placeholder="Leave blank to keep existing key" value={geminiApiKeyInput} onChange={(e) => setGeminiApiKeyInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>
                
                <motion.div key="ollama-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalOllamaUrl" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Ollama URL (Optional)
                    </label>
                     <div className={inputWrapperClass}>
                        <HardDrive className={inputIconClass} />
                        <input type="text" id="modalOllamaUrl" className={inputFieldStyledClass} placeholder="Leave blank to keep existing URL" value={ollamaUrlInput} onChange={(e) => setOllamaUrlInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>

                {error && (
                    <div className="flex items-center gap-2 p-2 text-xs text-red-700 bg-red-100 dark:bg-red-900/30 dark:text-red-300 rounded-md">
                        <AlertCircle size={16} />
                        <span>{error}</span>
                    </div>
                )}
            </div>
        </Modal>
    );
}

export default LLMSelectionModal;
```

`frontend/src/components/layout/RightCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/RightCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { HelpCircle, GitFork, Tags, ChevronLeft } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

const iconMap = {
    HelpCircle: HelpCircle,
    Tags: Tags,
    GitFork: GitFork,
};

function RightCollapsedNav() {
    const { setIsRightPanelOpen } = useAppState();

    const navItems = [
        { id: 'faq', label: 'FAQ Generator', iconName: 'HelpCircle', action: () => { setIsRightPanelOpen(true); /* TODO: set analysis type contextually */ } },
        { id: 'topics', label: 'Key Topics Extractor', iconName: 'Tags', action: () => { setIsRightPanelOpen(true); } },
        { id: 'mindmap', label: 'Mind Map Creator', iconName: 'GitFork', action: () => { setIsRightPanelOpen(true); } },
    ];

    return (
        <motion.aside
            key="right-collapsed-nav"
            initial={{ x: '100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="fixed right-0 top-16 bottom-0 z-30 w-14 sm:w-16 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark shadow-lg flex-col items-center py-3 space-y-2 hidden md:flex"
        >
            {/* Open Panel Button AT THE TOP */}
            <IconButton 
                icon={ChevronLeft} 
                onClick={() => setIsRightPanelOpen(true)} 
                title="Open Analyzer Panel"
                ariaLabel="Open Analyzer Panel"
                variant="ghost" 
                size="lg"
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />
            {navItems.map(item => {
                 const Icon = iconMap[item.iconName] || HelpCircle;
                return (
                    <IconButton 
                        key={item.id}
                        icon={Icon}
                        onClick={item.action}
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
        </motion.aside>
    );
}
export default RightCollapsedNav;
```

`frontend/src/components/layout/RightPanel.jsx`

```javascript


// frontend/src/components/layout/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import AnalysisToolRunner from '../analysis/AnalysisToolRunner.jsx';
import PodcastGenerator from '../analysis/PodcastGenerator.jsx';
import KnowledgeGraphViewer from '../analysis/KnowledgeGraphViewer.jsx';
import api from '../../services/api.js';
import { PanelRightClose, ChevronDown, ChevronUp, Telescope, Radio, BrainCircuit } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';

function RightPanel() {
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    const [isKgModalOpen, setIsKgModalOpen] = useState(false);
    const [kgData, setKgData] = useState(null);
    const [isLoadingKg, setIsLoadingKg] = useState(false);

    const currentSelectedDocFilename = selectedDocumentForAnalysis || selectedSubject || null;
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    const handleVisualizeKg = async () => {
        if (!currentSelectedDocFilename) return;
        setIsKgModalOpen(true);
        setIsLoadingKg(true);
        setKgData(null);
        try {
            const data = await api.getKnowledgeGraph(currentSelectedDocFilename);
            if(data.error) {
                toast.error(`KG Error: ${data.error}`);
                setKgData({ error: data.error });
            } else {
                setKgData(data);
            }
        } catch (error) {
            const errorMessage = error.response?.data?.error || "Could not fetch knowledge graph.";
            toast.error(errorMessage);
            setKgData({ error: errorMessage });
        } finally {
            setIsLoadingKg(false);
        }
    };

    return (
        <>
            <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
                <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                    <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                    <IconButton
                        icon={PanelRightClose}
                        onClick={() => setIsRightPanelOpen(false)}
                        title="Close Analyzer Panel"
                        variant="ghost" size="sm"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                </div>
                
                {!currentSelectedDocFilename ? (
                    <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                        <p>Select a document from the left panel to enable analysis and generation tools.</p>
                    </div>
                ) : (
                    <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-1">
                        <div>
                            <button onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark">
                                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                            </button>
                            {isAnalyzerOpen && (
                                <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 space-y-3 overflow-hidden">
                                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                </motion.div>
                            )}
                        </div>
                        <div>
                            <div className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                               <span className="flex items-center gap-2"><Radio size={16} /> Content Exporters & Synthesis</span>
                            </div>
                             <div className="mt-2 space-y-3">
                                <PodcastGenerator selectedDocumentFilename={currentSelectedDocFilename} />
                                <Button onClick={handleVisualizeKg} variant="outline" size="sm" fullWidth isLoading={isLoadingKg} leftIcon={<BrainCircuit size={16} />}>
                                    Visualize Knowledge Graph
                                </Button>
                            </div>
                        </div>
                    </div>
                )}
            </div>

            <Modal isOpen={isKgModalOpen} onClose={() => setIsKgModalOpen(false)} title={`Knowledge Graph: ${currentSelectedDocFilename}`} size="5xl">
                <KnowledgeGraphViewer graphData={isLoadingKg ? null : kgData} />
            </Modal>
        </>
    );
}
export default RightPanel;
```

`frontend/src/components/layout/TopNav.jsx`

```javascript
// frontend/src/components/layout/TopNav.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import ThemeToggle from '../common/ThemeToggle.jsx';
import LLMSelectionModal from './LLMSelectionModal.jsx';
import ProfileSettingsModal from '../profile/ProfileSettingsModal.jsx';
import { Link } from 'react-router-dom';
import { 
    LogOut, User, MessageSquare, History as HistoryIcon, Settings, Cpu, Zap, ServerCrash, Server, Wrench 
} from 'lucide-react';
import ToolsModal from '../tools/ToolsModal.jsx'; 



function TopNav({ user: authUser, onLogout, onNewChat, onHistoryClick, orchestratorStatus, isChatProcessing  }) {
    const { selectedLLM, switchLLM } = useAppState();
    const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
    const [isToolsModalOpen, setIsToolsModalOpen] = useState(false); // <<< NEW STATE

    
    const [isProfileDropdownOpen, setIsProfileDropdownOpen] = useState(false);
    const profileDropdownRef = useRef(null);

    const getStatusIndicator = () => {
        if (!orchestratorStatus) return <div title="Status unavailable" className="w-4 h-4 bg-gray-400 rounded-full"></div>;
        if (orchestratorStatus.status === "ok") {
            return <Zap size={18} className="text-green-400 animate-pulse" title={`Backend Online: ${orchestratorStatus.message}`} />;
        } else if (orchestratorStatus.status === "loading") {
            return <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-yellow-400" title="Connecting..."></div>;
        } else {
            return <ServerCrash size={18} className="text-red-400" title={`Backend Offline: ${orchestratorStatus.message}`} />;
        }
    };
    
    useEffect(() => {
        function handleClickOutside(event) {
            if (profileDropdownRef.current && !profileDropdownRef.current.contains(event.target)) {
                setIsProfileDropdownOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [profileDropdownRef]);

    return (
        <>
            <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark shadow-sm h-16 flex items-center justify-between px-2 sm:px-4">
                <div className="flex items-center gap-2">
                    <a href="/" className="flex items-center gap-1.5 sm:gap-2 text-lg sm:text-xl font-semibold text-text-light dark:text-text-dark">
                        <Server size={24} className="text-primary dark:text-primary-light" />
                        <span className="hidden sm:inline">AI Tutor</span>
                    </a>
                </div>

                <div className="flex-1 flex justify-center px-2">
                    <div className="flex items-center gap-1 sm:gap-2">
                         <button
                            onClick={onNewChat}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Start a new chat session"
                        >
                            <MessageSquare size={14} /> <span className="hidden sm:inline">New Chat</span>
                        </button>
                        
                        <button
                            onClick={onHistoryClick}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="View chat history"
                        >
                            <HistoryIcon size={14} /> <span className="hidden sm:inline">History</span>
                        </button>

                         <button
                            onClick={() => setIsToolsModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-amber-400/20 dark:bg-amber-500/20 hover:bg-amber-400/30 dark:hover:bg-amber-500/30 text-amber-700 dark:text-amber-400 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Open Tools"
                        >
                            <Wrench size={14} /> <span className="hidden sm:inline">Tools</span>
                        </button>

                        <button
                            onClick={() => setIsLLMModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
                        >
                            <Cpu size={14} /> <span className="hidden xs:inline">{selectedLLM.toUpperCase()}</span>
                        </button>
                    </div>
                </div>

                <div className="flex items-center gap-1.5 sm:gap-2">
                    <div className="w-8 h-8 flex items-center justify-center">
                        {getStatusIndicator()}
                    </div>
                    <ThemeToggle />
                    <div className="relative" ref={profileDropdownRef}>
                        <button 
                            onClick={() => setIsProfileDropdownOpen(prev => !prev)}
                            className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary"
                        >
                            <User size={18} />
                        </button>
                        <div 
                            className={`absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 transition-all duration-150 ease-in-out transform origin-top-right z-50
                                ${isProfileDropdownOpen 
                                    ? 'opacity-100 scale-100 visible' 
                                    : 'opacity-0 scale-95 invisible'
                                }`
                            }
                        >
                            <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-border-light dark:border-border-dark">
                                Signed in as <br/><strong>{authUser?.username || 'User'}</strong>
                            </div>
                            <button
                                onClick={() => { setIsProfileModalOpen(true); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
                            >
                                <Settings size={16} /> Profile
                            </button>
                            <button
                                onClick={() => { onLogout(); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
                            >
                                <LogOut size={16} /> Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
            <LLMSelectionModal 
                isOpen={isLLMModalOpen} 
                onClose={() => setIsLLMModalOpen(false)} 
                currentLLM={selectedLLM}
                onSelectLLM={(llm) => {
                    switchLLM(llm);
                    setIsLLMModalOpen(false);
                }}
            />
            <ProfileSettingsModal
                isOpen={isProfileModalOpen}
                onClose={() => setIsProfileModalOpen(false)}
            />
            {/* The ToolsModal is now correctly managed here */}
            <ToolsModal 
                isOpen={isToolsModalOpen} 
                onClose={() => setIsToolsModalOpen(false)} 
            />
        </>
    );
}
export default TopNav;
```

`frontend/src/components/profile/ProfileSettingsModal.jsx`

```javascript
// frontend/src/components/profile/ProfileSettingsModal.jsx
import React, { useState, useEffect } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { Save, User, School, Hash, Award, Wrench, Calendar } from 'lucide-react';

const ProfileSettingsModal = ({ isOpen, onClose }) => {
    const [profile, setProfile] = useState({
        name: '',
        college: '',
        universityNumber: '',
        degreeType: '',
        branch: '',
        year: ''
    });
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        if (isOpen) {
            const fetchProfile = async () => {
                setIsLoading(true);
                setError('');
                try {
                    const data = await api.getUserProfile();
                    // Set profile data, ensuring defaults for any missing fields
                    setProfile({
                        name: data.name || '',
                        college: data.college || '',
                        universityNumber: data.universityNumber || '',
                        degreeType: data.degreeType || 'Bachelors', // Default value
                        branch: data.branch || 'Computer Science', // Default value
                        year: data.year || '1st Year' // Default value
                    });
                } catch (err) {
                    toast.error('Failed to load profile data.');
                    setError(err.message || 'Could not fetch profile.');
                } finally {
                    setIsLoading(false);
                }
            };
            fetchProfile();
        }
    }, [isOpen]);

    const handleChange = (e) => {
        const { name, value } = e.target;
        setProfile(prev => ({ ...prev, [name]: value }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        // Simple validation
        for (const key in profile) {
            if (!profile[key] || profile[key].trim() === '') {
                toast.error(`Please fill out the '${key.replace(/([A-Z])/g, ' $1').trim()}' field.`);
                return;
            }
        }
        setIsLoading(true);
        setError('');
        try {
            const response = await api.updateUserProfile(profile);
            toast.success(response.message || 'Profile updated successfully!');
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update profile.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark pointer-events-none";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm";
    const selectFieldStyledClass = "input-field !pl-10 !pr-8 py-2.5 text-sm";

    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title="Student Profile Settings"
            size="lg"
            footerContent={
                <>
                    <Button variant="ghost" onClick={onClose} disabled={isLoading}>Cancel</Button>
                    <Button onClick={handleSubmit} isLoading={isLoading} leftIcon={<Save size={16} />}>
                        Save Changes
                    </Button>
                </>
            }
        >
            <form onSubmit={handleSubmit} className="space-y-4">
                {error && <p className="text-sm text-red-500">{error}</p>}
                
                <div className={inputWrapperClass}>
                    <User className={inputIconClass} />
                    <input type="text" name="name" value={profile.name} onChange={handleChange} placeholder="Full Name" className={inputFieldStyledClass} required />
                </div>

                <div className={inputWrapperClass}>
                    <School className={inputIconClass} />
                    <input type="text" name="college" value={profile.college} onChange={handleChange} placeholder="College / Institution" className={inputFieldStyledClass} required />
                </div>
                
                <div className={inputWrapperClass}>
                    <Hash className={inputIconClass} />
                    <input type="text" name="universityNumber" value={profile.universityNumber} onChange={handleChange} placeholder="Registered University Number" className={inputFieldStyledClass} required />
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className={inputWrapperClass}>
                        <Award className={inputIconClass} />
                        <select name="degreeType" value={profile.degreeType} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="Bachelors">Bachelor's</option>
                            <option value="Masters">Master's</option>
                            <option value="PhD">PhD</option>
                            <option value="Diploma">Diploma</option>
                        </select>
                    </div>
                    
                    <div className={inputWrapperClass}>
                        <Wrench className={inputIconClass} />
                        <select name="branch" value={profile.branch} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="Computer Science">Computer Science</option>
                            <option value="Mechanical Engineering">Mechanical</option>
                            <option value="Electrical Engineering">Electrical</option>
                            <option value="Civil Engineering">Civil</option>
                            <option value="Electronics & Communication">Electronics & Comm.</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>

                    <div className={inputWrapperClass}>
                        <Calendar className={inputIconClass} />
                        <select name="year" value={profile.year} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="1st Year">1st Year</option>
                            <option value="2nd Year">2nd Year</option>
                            <option value="3rd Year">3rd Year</option>
                            <option value="4th Year">4th Year</option>
                            <option value="Final Year">Final Year</option>
                            <option value="Graduated">Graduated</option>
                        </select>
                    </div>
                </div>
            </form>
        </Modal>
    );
};

export default ProfileSettingsModal;
```

`frontend/src/components/tools/AIAssistantBot.jsx`

```javascript
// frontend/src/components/tools/AIAssistantBot.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle, Sparkles, X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import IconButton from '../core/IconButton';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantBot = ({ code, language }) => {
    const [isOpen, setIsOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [analysis, setAnalysis] = useState('');
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (isOpen && analysis && contentRef.current) {
            const timer = setTimeout(() => Prism.highlightAllUnder(contentRef.current), 50);
            return () => clearTimeout(timer);
        }
    }, [isOpen, analysis]);
    
    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <>
            <div className="fixed bottom-6 right-6 z-50">
                <motion.button
                    whileHover={{ scale: 1.1, backgroundColor: "var(--color-primary-dark)" }}
                    whileTap={{ scale: 0.9 }}
                    onClick={() => setIsOpen(true)}
                    title="AI Assistant"
                    className="bg-primary text-white rounded-full p-4 shadow-lg flex items-center justify-center"
                    style={{'--color-primary-dark': '#2563eb'}} // For tailwind color access in motion
                >
                    <Bot size={28} />
                </motion.button>
            </div>

            <AnimatePresence>
                {isOpen && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4"
                        onClick={() => setIsOpen(false)}
                    >
                        <motion.div
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            onClick={(e) => e.stopPropagation()}
                            className="bg-surface-light dark:bg-surface-dark w-full max-w-2xl h-[70vh] rounded-lg shadow-2xl flex flex-col"
                        >
                            <header className="flex items-center justify-between p-4 border-b border-border-light dark:border-border-dark">
                                <h3 className="font-semibold flex items-center gap-2 text-text-light dark:text-text-dark">
                                    <Sparkles className="text-primary"/> AI Assistant
                                </h3>
                                <IconButton icon={X} onClick={() => setIsOpen(false)} title="Close" />
                            </header>

                            <div className="p-4 flex-shrink-0">
                                <Button onClick={handleAnalyze} size="sm" variant="primary" isLoading={isLoading} disabled={!code.trim()}>
                                    Analyze Current Code
                                </Button>
                            </div>
                            
                            <div className="flex-grow p-4 border-t border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                                {isLoading && (
                                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                                    </div>
                                )}
                                {error && !isLoading && (
                                    <div className="p-3 text-red-400 text-sm"><AlertTriangle className="inline mr-2" />{error}</div>
                                )}
                                {!isLoading && !error && !analysis && (
                                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                                        Click "Analyze Code" to get an AI-powered review.
                                    </div>
                                )}
                                {analysis && !isLoading && (
                                    <div 
                                        ref={contentRef}
                                        className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark"
                                        dangerouslySetInnerHTML={createMarkup(analysis)}
                                    />
                                )}
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

export default AIAssistantBot;
```

`frontend/src/components/tools/AIAssistantPanel.jsx`

```javascript
// frontend/src/components/tools/AIAssistantPanel.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle } from 'lucide-react';
import Button from '../core/Button.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantPanel = ({ code, language }) => {
    const [analysis, setAnalysis] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (analysis && contentRef.current) {
            const timer = setTimeout(() => {
                Prism.highlightAllUnder(contentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [analysis]);

    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="p-4 h-full flex flex-col bg-surface-light dark:bg-surface-dark">
            <h3 className="text-lg font-semibold mb-2 flex items-center justify-between">
                <span className="flex items-center gap-2">
                    <Bot className="text-primary"/> AI Assistant
                </span>
                <Button onClick={handleAnalyze} size="sm" variant="outline" isLoading={isLoading} disabled={!code.trim()}>
                    Analyze Code
                </Button>
            </h3>
            <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 rounded-md p-1 border border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                {isLoading && (
                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                    </div>
                )}
                {error && !isLoading && (
                    <div className="p-3 text-red-400 text-sm">
                        <AlertTriangle className="inline mr-2" /> {error}
                    </div>
                )}
                {!isLoading && !error && !analysis && (
                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                        Click "Analyze Code" to get an AI-powered review of your code.
                    </div>
                )}
                {analysis && !isLoading && (
                    <div 
                        ref={contentRef}
                        className="prose prose-sm dark:prose-invert max-w-none p-3 text-text-light dark:text-text-dark"
                        dangerouslySetInnerHTML={createMarkup(analysis)}
                    />
                )}
            </div>
        </div>
    );
};

export default AIAssistantPanel;
```

`frontend/src/components/tools/CodeEditor.jsx`

```javascript
// frontend/src/components/tools/CodeEditor.jsx
import React from 'react';
import Editor from '@monaco-editor/react';
import { useTheme } from '../../hooks/useTheme';
import { Loader2 } from 'lucide-react';

const CodeEditor = ({ code, setCode, language }) => {
    const { theme } = useTheme();

    const handleEditorChange = (value) => {
        setCode(value || '');
    };

    return (
        <div className="h-full w-full border border-border-light dark:border-border-dark rounded-lg overflow-hidden shadow-inner">
            <Editor
                height="100%"
                language={language}
                value={code}
                onChange={handleEditorChange}
                theme={theme === 'dark' ? 'vs-dark' : 'light'}
                loading={<Loader2 className="animate-spin text-primary" />}
                options={{
                    fontSize: 14,
                    minimap: { enabled: true },
                    contextmenu: true,
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    automaticLayout: true,
                }}
            />
        </div>
    );
};

export default CodeEditor;
```

`frontend/src/components/tools/CodeEditorWrapper.jsx`

```javascript
// frontend/src/components/tools/CodeEditorWrapper.jsx
import React, { useState } from 'react';
import { Play, Copy, ChevronDown, Check } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '../core/Button';
import IconButton from '../core/IconButton';
import CodeEditor from './CodeEditor';
import toast from 'react-hot-toast';

const CodeEditorWrapper = ({ code, setCode, language, setLanguage, onExecute, isExecuting }) => {
    
    const [copied, setCopied] = useState(false);

    const handleCopy = () => {
        navigator.clipboard.writeText(code).then(() => {
            toast.success("Code copied to clipboard!");
            setCopied(true);
            setTimeout(() => setCopied(false), 2000); // Reset after 2 seconds
        }, () => {
            toast.error("Failed to copy code.");
        });
    };
    
    return (
        <div className="flex flex-col h-full bg-surface-light dark:bg-surface-dark rounded-lg border border-border-light dark:border-border-dark">
            <header className="flex items-center justify-between p-2 border-b border-border-light dark:border-border-dark flex-shrink-0">
                <div className="relative">
                    <select 
                        value={language}
                        onChange={(e) => setLanguage(e.target.value)}
                        className="input-field !text-xs !py-1 !pl-3 !pr-8 appearance-none"
                    >
                        <option value="python">Python</option>
                        <option value="java">Java</option>
                        <option value="c">C</option>
                        <option value="cpp">C++</option>
                    </select>
                    <ChevronDown size={14} className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
                <div className="flex items-center gap-2">
                    <IconButton 
                        icon={() => (
                            <AnimatePresence mode="wait" initial={false}>
                                <motion.span
                                    key={copied ? 'check' : 'copy'}
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.8 }}
                                    transition={{ duration: 0.15 }}
                                >
                                    {copied ? <Check className="text-green-500" /> : <Copy />}
                                </motion.span>
                            </AnimatePresence>
                        )} 
                        size="sm" 
                        onClick={handleCopy} 
                        title="Copy Code" 
                    />
                    <Button onClick={onExecute} size="sm" leftIcon={<Play size={14}/>} isLoading={isExecuting}>
                        Run
                    </Button>
                </div>
            </header>
            <div className="flex-grow overflow-hidden">
                <CodeEditor code={code} setCode={setCode} language={language} />
            </div>
        </div>
    );
};

export default CodeEditorWrapper;
```

`frontend/src/components/tools/CodeExecutorPage.jsx`

```javascript
// frontend/src/components/tools/CodeExecutorPage.jsx
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { Home } from 'lucide-react';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
import CodeEditorWrapper from './CodeEditorWrapper';
import TestCaseManager from './TestCaseManager';
import OutputDisplay from './OutputDisplay';
import AIAssistantBot from './AIAssistantBot';
import api from '../../services/api';
import toast from 'react-hot-toast';

const starterCode = {
    python: `# Welcome to the Code Executor!\n# Write your Python code here.\n\ndef main():\n    # Example: Read two numbers and print their sum\n    try:\n        line1 = input()\n        line2 = input()\n        print(int(line1) + int(line2))\n    except (ValueError, EOFError):\n        print("Invalid input.")\n\nif __name__ == "__main__":\n    main()\n`,
    java: `// Welcome to the Code Executor!\n// Your public class must be named "Main".\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        System.out.println(a + b);\n        sc.close();\n    }\n}\n`,
    c: `// Welcome to the Code Executor!\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    if (scanf("%d %d", &a, &b) == 2) {\n        printf("%d\\n", a + b);\n    }\n    return 0;\n}\n`,
    cpp: `// Welcome to the Code Executor!\n#include <iostream>\n\nint main() {\n    int a, b;\n    if (std::cin >> a >> b) {\n        std::cout << a + b << std::endl;\n    }\n    return 0;\n}\n`
};

const CodeExecutorPage = () => {
    const [language, setLanguage] = useState('python');
    const [code, setCode] = useState(starterCode.python);
    const [testCases, setTestCases] = useState([
        { input: '5\n10', expectedOutput: '15' }
    ]);
    const [results, setResults] = useState([]);
    const [compilationError, setCompilationError] = useState(null);
    const [isExecuting, setIsExecuting] = useState(false);

    const handleLanguageChange = (newLanguage) => {
        setLanguage(newLanguage);
        setCode(starterCode[newLanguage] || '');
    };

    const handleExecute = async () => {
        setIsExecuting(true);
        setResults([]);
        setCompilationError(null);
        const toastId = toast.loading('Executing code...');

        try {
            const response = await api.executeCode({ language, code, testCases });
            
            if (response.compilationError) {
                setCompilationError(response.compilationError);
                toast.error("Code failed to compile.", { id: toastId });
            } else {
                setResults(response.results);
                const failures = response.results.filter(r => r.status !== 'pass').length;
                if (failures > 0) {
                    toast.error(`${failures} test case(s) failed or had errors.`, { id: toastId });
                } else {
                    toast.success('All test cases passed!', { id: toastId });
                }
            }

        } catch (error) {
            const errorMessage = error.response?.data?.message || "An unknown error occurred.";
            setCompilationError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsExecuting(false);
        }
    };

    return (
        <div className="flex flex-col h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark font-sans">
            <header className="flex-shrink-0 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark h-16 flex items-center justify-between px-6 z-10">
                <h1 className="text-xl font-bold">Secure Code Executor</h1>
                <Link to="/" className="flex items-center gap-2 text-sm btn btn-ghost">
                    <Home size={16}/>
                    Back to Main App
                </Link>
            </header>

            <div className="flex-1 overflow-hidden">
                <PanelGroup direction="horizontal">
                    <Panel defaultSize={65} minSize={30}>
                        <PanelGroup direction="vertical">
                            <Panel defaultSize={60} minSize={20}>
                                <div className="p-1 md:p-2 h-full">
                                    <CodeEditorWrapper
                                        code={code} setCode={setCode}
                                        language={language} setLanguage={handleLanguageChange}
                                        onExecute={handleExecute} isExecuting={isExecuting}
                                    />
                                </div>
                            </Panel>
                            <PanelResizeHandle className="h-2 panel-resize-handle" />
                            <Panel defaultSize={40} minSize={20}>
                                <OutputDisplay
                                    results={results}
                                    compilationError={compilationError}
                                    code={code}
                                    language={language}
                                />
                            </Panel>
                        </PanelGroup>
                    </Panel>
                    <PanelResizeHandle className="w-2 panel-resize-handle" />
                    <Panel defaultSize={35} minSize={25}>
                         <TestCaseManager 
                            testCases={testCases} 
                            setTestCases={setTestCases}
                            code={code}
                            language={language}
                        />
                    </Panel>
                </PanelGroup>
            </div>
            
            <AIAssistantBot code={code} language={language} />
        </div>
    );
};

export default CodeExecutorPage;
```

`frontend/src/components/tools/OutputDisplay.jsx`

```javascript
// frontend/src/components/tools/OutputDisplay.jsx
import React, { useState } from 'react';
import { CheckCircle, XCircle, AlertTriangle, Clock, Sparkles, Loader2 } from 'lucide-react';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};


const OutputDisplay = ({ results, compilationError, code, language }) => {
    const [explanations, setExplanations] = useState({});
    const [isLoadingExplanation, setIsLoadingExplanation] = useState(null); // Tracks index

    const handleExplainError = async (index, errorMessage) => {
        setIsLoadingExplanation(index);
        try {
            const response = await api.explainError({ code, language, errorMessage });
            setExplanations(prev => ({ ...prev, [index]: response.explanation }));
        } catch (err) {
            toast.error(err.response?.data?.message || "Failed to get explanation.");
        } finally {
            setIsLoadingExplanation(null);
        }
    };

    if (compilationError) {
        return (
            <div className="p-4 bg-red-900/10 text-red-400 border-t border-red-500/30 h-full flex flex-col">
                <h3 className="text-lg font-semibold mb-2 flex items-center gap-2"><AlertTriangle /> Compilation Error</h3>
                <pre className="flex-grow bg-red-900/20 p-4 rounded-md text-xs whitespace-pre-wrap font-mono overflow-auto custom-scrollbar">{compilationError}</pre>
            </div>
        );
    }
    
    if (!results || results.length === 0) {
        return (
            <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark border-t border-border-light dark:border-border-dark h-full flex items-center justify-center">
                <p>Run the code to see the output and test case results here.</p>
            </div>
        );
    }

    const getStatusIcon = (status) => {
        if (status === 'pass') return <CheckCircle className="text-green-500" />;
        if (status === 'fail') return <XCircle className="text-yellow-500" />;
        return <AlertTriangle className="text-red-500" />;
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark border-t border-border-light dark:border-border-dark h-full flex flex-col">
            <h3 className="text-lg font-semibold mb-3 flex-shrink-0">Execution Results</h3>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {results.map((res, index) => (
                    <div key={index} className="p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex justify-between items-center mb-2">
                            <h4 className="font-semibold flex items-center gap-2">
                                {getStatusIcon(res.status)}
                                Test Case #{index + 1}: <span className="uppercase">{res.status}</span>
                            </h4>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-xs">
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Input:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.input || '(empty)'}</pre>
                            </div>
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Expected Output:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.expected || '(empty)'}</pre>
                            </div>
                            <div className="md:col-span-2">
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Actual Output:</strong>
                                <pre className={`p-2 rounded whitespace-pre-wrap font-mono ${res.status === 'pass' ? 'bg-green-900/20' : 'bg-yellow-900/20'}`}>{res.output || '(empty)'}</pre>
                            </div>
                            {res.error && (
                                <div className="md:col-span-2">
                                    <div className="flex justify-between items-center">
                                        <strong className="block mb-1 text-red-500 dark:text-red-400">Error:</strong>
                                        {!explanations[index] && (
                                            <Button size="sm" variant="ghost" className="!text-xs" leftIcon={<Sparkles size={12}/>} onClick={() => handleExplainError(index, res.error)} isLoading={isLoadingExplanation === index}>
                                                Explain Error
                                            </Button>
                                        )}
                                    </div>
                                    <pre className="bg-red-900/20 p-2 rounded text-red-400 whitespace-pre-wrap font-mono">{res.error}</pre>
                                </div>
                            )}
                            {isLoadingExplanation === index && (
                                <div className="md:col-span-2 p-3 text-sm text-center text-text-muted-light dark:text-text-muted-dark"><Loader2 className="animate-spin inline mr-2"/>AI is explaining the error...</div>
                            )}
                            {explanations[index] && (
                                <div className="md:col-span-2 mt-2 p-3 bg-primary/10 rounded-md border border-primary/30">
                                    <h5 className="font-bold text-sm mb-1 text-primary dark:text-primary-light flex items-center gap-1.5"><Sparkles size={14}/> AI Explanation</h5>
                                    <div className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark" dangerouslySetInnerHTML={createMarkup(explanations[index])} />
                                </div>
                            )}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default OutputDisplay;
```

`frontend/src/components/tools/TestCaseManager.jsx`

```javascript
// frontend/src/components/tools/TestCaseManager.jsx
import React, { useState } from 'react';
import { Plus, Trash2, Sparkles } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';

const TestCaseManager = ({ testCases, setTestCases, code, language }) => {
    const [isGenerating, setIsGenerating] = useState(false);

    const addTestCase = () => {
        const lastTestCase = testCases[testCases.length - 1];
        if (testCases.length > 0 && lastTestCase.input.trim() === '' && lastTestCase.expectedOutput.trim() === '') {
            toast.error('Please fill out the current empty test case first.');
            return;
        }
        setTestCases([...testCases, { input: '', expectedOutput: '' }]);
    };

    const removeTestCase = (index) => {
        const newTestCases = testCases.filter((_, i) => i !== index);
        setTestCases(newTestCases);
    };

    const updateTestCase = (index, field, value) => {
        const newTestCases = [...testCases];
        newTestCases[index][field] = value;
        setTestCases(newTestCases);
    };

    const handleGenerateCases = async () => {
        if (!code.trim()) {
            toast.error("There is no code to generate test cases for.");
            return;
        }
        setIsGenerating(true);
        const toastId = toast.loading("AI is generating test cases...");
        try {
            const response = await api.generateTestCases({ code, language });
            if (response.testCases && Array.isArray(response.testCases) && response.testCases.length > 0) {
                setTestCases(response.testCases);
                toast.success('AI generated a new set of test cases!', { id: toastId });
            } else {
                toast.error("The AI could not generate valid test cases.", { id: toastId });
            }
        } catch (err) {
             const errorMessage = err.response?.data?.message || "Failed to generate test cases.";
             toast.error(errorMessage, { id: toastId });
        } finally {
            setIsGenerating(false);
        }
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark h-full flex flex-col">
            <div className="flex items-center justify-between mb-3 flex-shrink-0">
                <h3 className="text-lg font-semibold">Test Cases</h3>
                <div className="flex items-center gap-2">
                    <Button onClick={addTestCase} size="sm" variant="outline" leftIcon={<Plus size={14}/>}>
                        Add Case
                    </Button>
                    <Button onClick={handleGenerateCases} size="sm" variant="outline" leftIcon={<Sparkles size={14} />} isLoading={isGenerating} disabled={!code.trim()}>
                            Generate by AI
                    </Button>
                </div>
            </div>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {testCases.map((tc, index) => (
                    <div key={index} className="flex flex-col md:flex-row gap-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Input (stdin)</label>
                            <textarea
                                value={tc.input}
                                onChange={(e) => updateTestCase(index, 'input', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter input, separate lines with \n"
                            />
                        </div>
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Expected Output (stdout)</label>
                            <textarea
                                value={tc.expectedOutput}
                                onChange={(e) => updateTestCase(index, 'expectedOutput', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter expected exact output"
                            />
                        </div>
                        <div className="flex items-end">
                            <IconButton icon={Trash2} variant="danger" size="sm" onClick={() => removeTestCase(index)} title="Remove Test Case" />
                        </div>
                    </div>
                ))}
                {testCases.length === 0 && (
                    <div className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-8">
                        Add a test case to begin.
                    </div>
                )}
            </div>
        </div>
    );
};

export default TestCaseManager;
```

`frontend/src/components/tools/ToolsModal.jsx`

```javascript
// frontend/src/components/tools/ToolsModal.jsx
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import Modal from '../core/Modal';
import { Code, TestTubeDiagonal } from 'lucide-react'; // Add more icons as you add tools
const availableTools = [
    {
    title: 'Secure Code Executor',
    description: 'Write, compile, and run code in a sandboxed environment with AI assistance.',
    icon: Code,
    path: '/tools/code-executor',
    status: 'active'
    },
    {
    title: 'API Endpoint Tester',
    description: 'A tool for testing and validating API endpoints will be available soon.',
    icon: TestTubeDiagonal,
    path: '#',
    status: 'soon'
    },
// Add more tools here in the future
];
const ToolsModal = ({ isOpen, onClose }) => {
    const navigate = useNavigate();
    const handleNavigate = (path) => {
        if (path !== '#') {
            onClose();
            navigate(path);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Developer Tools" size="2xl">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {availableTools.map((tool) => (
                    <div
                        key={tool.title}
                        onClick={() => handleNavigate(tool.path)}
                        className={`p-4 border rounded-lg transition-all duration-150 group relative
                            ${tool.status === 'active' 
                                ? 'cursor-pointer hover:border-primary dark:hover:border-primary-light hover:shadow-lg' 
                                : 'opacity-50 cursor-not-allowed'
                            }
                            bg-surface-light dark:bg-gray-800 border-border-light dark:border-border-dark
                        `}
                    >
                        {tool.status === 'soon' && (
                            <span className="absolute top-2 right-2 text-xs bg-yellow-400/20 text-yellow-500 font-semibold px-2 py-0.5 rounded-full">
                                Coming Soon
                            </span>
                        )}
                        <div className="flex items-center mb-2">
                            <tool.icon size={22} className="mr-3 text-primary dark:text-primary-light" />
                            <h3 className="font-semibold text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light">
                                {tool.title}
                            </h3>
                        </div>
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                            {tool.description}
                        </p>
                    </div>
                ))}
            </div>
        </Modal>
    );
};


export default ToolsModal;
```

`frontend/src/contexts/AppStateContext.jsx`

```javascript
import React, { createContext, useState, useContext, useEffect } from 'react';

export const AppStateContext = createContext(null);

export const useAppState = () => {
    const context = useContext(AppStateContext);
    if (!context) throw new Error('useAppState must be used within an AppStateProvider');
    return context;
};

const defaultSystemPromptText = "You are a helpful AI engineering tutor.";

export const AppStateProvider = ({ children }) => {
    const [theme, setThemeState] = useState(() => {
        const storedTheme = localStorage.getItem('theme') || 'dark';
        if (typeof window !== 'undefined') {
            document.documentElement.classList.remove('light', 'dark');
            document.documentElement.classList.add(storedTheme);
        }
        return storedTheme;
    });

    const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'gemini');
    const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
    const [isRightPanelOpen, setIsRightPanelOpen] = useState(true);

    const [currentSessionId, setCurrentSessionIdState] = useState(() => {
        return localStorage.getItem('aiTutorSessionId') || null;
    });
    const [systemPrompt, setSystemPromptState] = useState(
        localStorage.getItem('aiTutorSystemPrompt') || defaultSystemPromptText
    );

    const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null);
    const [selectedSubject, setSelectedSubjectState] = useState(
        localStorage.getItem('aiTutorSelectedSubject') || null
    );

    const [isAdminSessionActive, setIsAdminSessionActiveState] = useState(() => {
        return sessionStorage.getItem('isAdminSessionActive') === 'true';
    });

    const toggleTheme = () => {
        setThemeState(prevTheme => {
            const newTheme = prevTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            return newTheme;
        });
    };

    const switchLLM = (llm) => {
         setSelectedLLM(llm);
         localStorage.setItem('selectedLLM', llm);
         console.log("AppStateContext: Switched LLM to:", llm);
    };

    const setSessionId = (sessionId) => {
        if (sessionId) {
            localStorage.setItem('aiTutorSessionId', sessionId);
        } else {
            console.log("AppStateContext: Clearing session and related context (logout).");
            localStorage.removeItem('aiTutorSessionId');
            
            localStorage.removeItem('aiTutorSelectedSubject'); 
            setSelectedSubjectState(null);
            
            setSelectedDocumentForAnalysisState(null);
        }
        setCurrentSessionIdState(sessionId);
        console.log("AppStateContext: Regular user session ID updated to:", sessionId);
    };

    const setSystemPrompt = (promptText) => {
        setSystemPromptState(promptText);
        localStorage.setItem('aiTutorSystemPrompt', promptText);
    };

    const selectDocumentForAnalysis = (documentFilename) => {
        setSelectedDocumentForAnalysisState(documentFilename);
        console.log("AppStateContext: Document for analysis tools set to:", documentFilename || "None");
        if (documentFilename && selectedSubject !== documentFilename) {
            if (selectedSubject !== null) {
                console.log("AppStateContext: Clearing selected subject because a specific user document was chosen for analysis tools.");
                setSelectedSubjectState(null);
                localStorage.removeItem('aiTutorSelectedSubject');
            }
        }
    };

    const setSelectedSubject = (subjectName) => {
        const newSubject = subjectName === "none" || !subjectName ? null : subjectName;
        if (newSubject) {
            localStorage.setItem('aiTutorSelectedSubject', newSubject);
        } else {
            localStorage.removeItem('aiTutorSelectedSubject');
        }
        setSelectedSubjectState(newSubject);
        console.log("AppStateContext: Selected subject (for chat RAG) updated to:", newSubject || "None");

        setSelectedDocumentForAnalysisState(newSubject);
        if (newSubject) {
             console.log("AppStateContext: Also set document for analysis tools to (admin subject):", newSubject);
        } else {
            if (selectedDocumentForAnalysis === subjectName) {
                 setSelectedDocumentForAnalysisState(null);
                 console.log("AppStateContext: Cleared document for analysis tools as linked subject was cleared.");
            }
        }
    };

    const setIsAdminSessionActive = (isActive) => {
        if (isActive) {
            sessionStorage.setItem('isAdminSessionActive', 'true');
            setSessionId(null); 
        } else {
            sessionStorage.removeItem('isAdminSessionActive');
        }
        setIsAdminSessionActiveState(isActive);
        console.log("AppStateContext: Admin session active status set to:", isActive);
    };

    useEffect(() => {
        const rootHtmlElement = document.documentElement;
        rootHtmlElement.classList.remove('light', 'dark');
        rootHtmlElement.classList.add(theme);
        document.body.className = '';
        document.body.classList.add(theme === 'dark' ? 'bg-background-dark' : 'bg-background-light');
    }, [theme]);

    return (
        <AppStateContext.Provider value={{
            theme, toggleTheme,
            selectedLLM, switchLLM,
            isLeftPanelOpen, setIsLeftPanelOpen,
            isRightPanelOpen, setIsRightPanelOpen,
            currentSessionId, setSessionId,
            systemPrompt, setSystemPrompt,
            selectedDocumentForAnalysis, selectDocumentForAnalysis,
            selectedSubject, setSelectedSubject,
            isAdminSessionActive, setIsAdminSessionActive
        }}>
            {children}
        </AppStateContext.Provider>
    );
};
```

`frontend/src/contexts/AuthContext.jsx`

```javascript
// frontend/src/contexts/AuthContext.jsx
import React, { createContext, useState, useEffect, useCallback } from 'react';
import api from '../services/api.js'; 
import toast from 'react-hot-toast';

export const AuthContext = createContext(null);

export const DEV_MODE_ALLOW_DEV_LOGIN = false;

export const AuthProvider = ({ children }) => {
    const [token, setTokenState] = useState(localStorage.getItem('authToken'));
    const [user, setUserState] = useState(null);
    const [loading, setLoading] = useState(true);

    const setToken = (newToken) => {
        if (newToken) localStorage.setItem('authToken', newToken);
        else localStorage.removeItem('authToken');
        setTokenState(newToken);
    };

    const setUser = (newUser) => setUserState(newUser);
    
    const processAuthData = useCallback((authApiResponse) => {
        if (authApiResponse && authApiResponse.token && authApiResponse._id && authApiResponse.email) {
            setToken(authApiResponse.token);
            setUser({ id: authApiResponse._id, email: authApiResponse.email, username: authApiResponse.username });
             console.log("AuthContext: User and Token set.", { email: authApiResponse.email, username: authApiResponse.username });
            return authApiResponse; 
        } else {
            setToken(null);
            setUser(null);
            console.error("AuthContext: processAuthData received incomplete data for a regular user.", authApiResponse);
            throw new Error("Authentication response from server was incomplete for a regular user.");
        }
    }, []);

    useEffect(() => {
        const verifyTokenAndLoadUser = async () => {
            const storedToken = localStorage.getItem('authToken');
            if (storedToken) {
                setTokenState(storedToken);
                try {
                    const userDataFromMe = await api.getMe();
                    if (userDataFromMe && userDataFromMe._id && userDataFromMe.email) {
                        setUser({ id: userDataFromMe._id, email: userDataFromMe.email, username: userDataFromMe.username });
                    } else {
                        setToken(null);
                        setUser(null);
                    }
                } catch (error) {
                    setToken(null);
                    setUser(null);
                }
            }
            setLoading(false);
        };
        verifyTokenAndLoadUser();
    }, []);

    const login = async (credentials) => {
        setLoading(true);
        try {
            const data = await api.login(credentials);
            if (data && data.isAdminLogin) {
                return data;
            }
            return processAuthData(data);
        } catch (error) {
            setToken(null); 
            setUser(null);
            throw error; 
        } finally {
            setLoading(false);
        }
    };
    
    const signup = async (signupData) => {
        setLoading(true);
        try {
            const data = await api.signup(signupData);
            return processAuthData(data); 
        } catch (error) {
            setToken(null);
            setUser(null);
            throw error;
        } finally {
            setLoading(false);
        }
    };

    const logout = () => {
        console.log("AuthContext: Logging out user.");
        setToken(null); 
        setUser(null);
        toast.success("You have been logged out.");
    };

    return (
        <AuthContext.Provider value={{ token, user, loading, login, signup, logout, setUser }}>
            {children}
        </AuthContext.Provider>
    );
};
```

`frontend/src/hooks/useAuth.jsx`

```javascript
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
```

`frontend/src/hooks/useTextToSpeech.js`

```javascript
// src/hooks/useTextToSpeech.js
import { useState, useEffect, useCallback, useRef } from 'react';
import { marked } from 'marked'; // To parse markdown for plain text

// Configure marked (if not already globally configured for this specific use)
// It's generally better if marked is configured once, e.g. in MessageBubble or a central place.
// Assuming marked is available and configured.

const getPlainTextFromMarkdown = (markdown) => {
  if (!markdown) return '';
  try {
    // A simpler approach for plain text extraction for TTS:
    // Render to a temporary element and get its text content.
    // This handles complex markdown structures reasonably well for speech.
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = marked.parse(markdown); // marked.parse() is synchronous
    let text = tempDiv.textContent || tempDiv.innerText || '';
    
    // Basic cleanup: remove excessive newlines/spaces that might make speech awkward
    text = text.replace(/\n+/g, ' '); // Replace newlines with spaces
    text = text.replace(/\s\s+/g, ' '); // Replace multiple spaces with single
    return text.trim();
  } catch (error) {
    console.error("Error parsing markdown for TTS:", error);
    return markdown; // Fallback to raw markdown if parsing fails
  }
};


export const useTextToSpeech = () => {
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isSupported, setIsSupported] = useState(false);
    const utteranceRef = useRef(null);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.speechSynthesis) {
            setIsSupported(true);
        }

        const handleEnd = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        
        const synth = window.speechSynthesis;
        if (synth) {
            // Add event listeners if needed, but onend on utterance is usually sufficient
        }

        return () => {
            if (synth) {
                synth.cancel(); // Cancel any speech on component unmount or hook cleanup
            }
        };
    }, []);

    const speak = useCallback(({ text, lang = 'en-US', voiceURI = null, rate = 1, pitch = 1, volume = 1 }) => {
        if (!isSupported || !text) return;

        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel(); // Stop any currently playing speech
        }
        
        const plainText = getPlainTextFromMarkdown(text);
        if (!plainText) {
            console.warn("TTS: No text content to speak after parsing markdown.");
            return;
        }

        const newUtterance = new SpeechSynthesisUtterance(plainText);
        newUtterance.lang = lang;
        newUtterance.rate = rate;
        newUtterance.pitch = pitch;
        newUtterance.volume = volume;

        if (voiceURI) {
            const voices = synth.getVoices();
            const selectedVoice = voices.find(voice => voice.voiceURI === voiceURI);
            if (selectedVoice) {
                newUtterance.voice = selectedVoice;
            }
        }
        
        newUtterance.onstart = () => {
            setIsSpeaking(true);
        };
        newUtterance.onend = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        newUtterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            setIsSpeaking(false);
            utteranceRef.current = null;
        };

        utteranceRef.current = newUtterance;
        synth.speak(newUtterance);
    }, [isSupported]);

    const cancel = useCallback(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel();
        }
        // onend should fire and set isSpeaking to false.
        // If it doesn't (e.g. cancel is abrupt), manually reset:
        if (isSpeaking) {
            setIsSpeaking(false);
            utteranceRef.current = null;
        }
    }, [isSupported, isSpeaking]);

    // Optional: Get available voices
    const getVoices = useCallback(() => {
        if (!isSupported) return [];
        return window.speechSynthesis.getVoices();
    }, [isSupported]);

    // Voices might load asynchronously. Listen for 'voiceschanged' event.
    useEffect(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        const loadVoices = () => {
            // You might want to store voices in state if your UI allows voice selection
            // console.log("Voices loaded:", synth.getVoices());
        };
        synth.addEventListener('voiceschanged', loadVoices);
        // Initial load if voices are already available
        if (synth.getVoices().length > 0) {
            loadVoices();
        }
        return () => synth.removeEventListener('voiceschanged', loadVoices);
    }, [isSupported]);


    return {
        speak,
        cancel,
        isSpeaking,
        isSupported,
        getVoices,
        currentlySpeakingUtterance: utteranceRef.current
    };
};
```

`frontend/src/hooks/useTheme.js`

```javascript
// import { useContext } from 'react';
// import { AppStateContext } from '../contexts/AppStateContext'; // Assuming theme is in AppStateContext

// export const useTheme = () => {
//     const context = useContext(AppStateContext);
//     if (!context) {
//         throw new Error('useTheme must be used within an AppStateProvider');
//     }
//     return { theme: context.theme, toggleTheme: context.toggleTheme };
// };


import { useContext } from 'react';
import { AppStateContext } from '../contexts/AppStateContext.jsx'; // Correct named import for the context object

export const useTheme = () => {
    const context = useContext(AppStateContext); // Use the imported context object
    if (!context) {
        throw new Error('useTheme must be used within an AppStateProvider');
    }
    return { theme: context.theme, toggleTheme: context.toggleTheme };
};
```

`frontend/src/hooks/useTypingEffect.js`

```javascript
// frontend/src/hooks/useTypingEffect.js
import { useState, useEffect, useRef } from 'react';

/**
 * A custom hook to create a typing animation effect for text.
 * @param {string} textToType The full string that should be typed out.
 * @param {number} [speed=20] The delay in milliseconds between each character.
 * @param {function} [onComplete] An optional callback to run when typing is finished.
 * @returns {string} The currently displayed text (which grows over time).
 */
export const useTypingEffect = (textToType, speed = 20, onComplete) => {
    const [displayedText, setDisplayedText] = useState('');
    const index = useRef(0);
    const onCompleteRef = useRef(onComplete);

    // Keep the onComplete callback reference fresh
    useEffect(() => {
        onCompleteRef.current = onComplete;
    }, [onComplete]);

    useEffect(() => {
        // Reset the typing effect when the text to type changes
        setDisplayedText('');
        index.current = 0;

        const intervalId = setInterval(() => {
            if (index.current < textToType.length) {
                setDisplayedText(prev => prev + textToType.charAt(index.current));
                index.current++;
            } else {
                clearInterval(intervalId);
                if (onCompleteRef.current) {
                    onCompleteRef.current(); // Call the onComplete callback
                }
            }
        }, speed);

        return () => clearInterval(intervalId);
    }, [textToType, speed]);

    return displayedText;
};
```

`frontend/src/hooks/useWebSpeech.js`

```javascript
// src/hooks/useWebSpeech.js
import { useState, useEffect, useCallback } from 'react';

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

export const useWebSpeech = () => {
    const [transcript, setTranscript] = useState('');
    const [listening, setListening] = useState(false);
    const [recognitionInstance, setRecognitionInstance] = useState(null);
    const [error, setError] = useState(null); // Added error state
    const isSpeechSupported = !!SpeechRecognition;

    useEffect(() => {
        if (!isSpeechSupported) {
            console.warn("Web Speech API is not supported by this browser.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = false; // Set to true if you want it to keep listening
        recognition.interimResults = false; // Set to true for live results
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            const currentTranscript = Array.from(event.results)
                .map(result => result[0])
                .map(result => result.transcript)
                .join('');
            setTranscript(currentTranscript);
            setError(null); // Clear error on successful result
            // console.log("Voice input result:", currentTranscript);
        };

        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            let errorMessage = event.error;
            if (event.error === 'no-speech') errorMessage = "No speech detected. Please try again.";
            else if (event.error === 'audio-capture') errorMessage = "Audio capture failed. Check microphone.";
            else if (event.error === 'not-allowed') errorMessage = "Microphone permission denied.";
            else if (event.error === 'network') errorMessage = "Network error during speech recognition.";
            // Add more specific error messages as needed
            
            setError(errorMessage);
            setListening(false);
        };

        recognition.onend = () => {
            setListening(false);
            // console.log("Speech recognition ended.");
        };
        
        setRecognitionInstance(recognition);

        // Cleanup
        return () => {
            if (recognition) {
                recognition.abort(); // Use abort to stop and discard results if component unmounts
            }
        };
    }, [isSpeechSupported]);

    const startListening = useCallback(() => {
        if (recognitionInstance && !listening) {
            try {
                setTranscript(''); // Clear previous transcript
                setError(null); // Clear previous errors
                recognitionInstance.start();
                setListening(true);
                // console.log("Speech recognition started.");
            } catch (e) {
                // This catch might be for synchronous errors during .start() call,
                // most errors are handled by recognition.onerror
                console.error("Error starting speech recognition:", e);
                setError("Could not start voice input.");
                setListening(false); // Ensure listening state is correct
            }
        }
    }, [recognitionInstance, listening]);

    const stopListening = useCallback(() => {
        if (recognitionInstance && listening) {
            recognitionInstance.stop(); // Stop and process any captured audio
            // setListening(false) will be called by onend event
            // console.log("Speech recognition stopped manually.");
        }
    }, [recognitionInstance, listening]);

    const resetTranscript = useCallback(() => {
        setTranscript('');
    }, []);


    return {
        transcript,
        listening,
        isSpeechSupported,
        startListening,
        stopListening,
        resetTranscript,
        error // Expose error state
    };
};
```

`frontend/src/index.css`

```css
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {

  html,
  body,
  #root {
    /* Apply to html, body, AND your React root div */
    @apply h-full overflow-hidden;
    /* Force full height and no scroll on these */
  }

  html {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    scroll-behavior: smooth;
    /* This is fine, affects internal scrolls */
  }

  body {
    @apply bg-background-light text-text-light transition-colors duration-300;
    font-family: theme('fontFamily.sans');
    /* overflow-hidden is now applied via the html, body, #root rule above */
  }

  html.dark body {
    @apply bg-background-dark text-text-dark;
  }

  html.light body {
    @apply bg-background-light text-text-light;
  }

  .custom-scrollbar {
    @apply scrollbar-thin scrollbar-thumb-secondary dark:scrollbar-thumb-secondary-dark scrollbar-track-surface-light dark:scrollbar-track-gray-800 scrollbar-thumb-rounded-full scrollbar-track-rounded-full;
  }

  /* --- Enhanced Prose Styles --- */
  .prose {
    @apply max-w-none text-text-light dark:text-text-dark;
  }

  .prose,
  .prose-sm {

    /* Headings */
    h1 {
      @apply text-2xl sm:text-3xl font-extrabold mb-6 mt-2 text-text-light dark:text-text-dark;
    }

    h2 {
      @apply text-xl sm:text-2xl font-bold mb-4 mt-8 border-b border-border-light dark:border-border-dark pb-2;
    }

    h3 {
      @apply text-lg sm:text-xl font-semibold mb-3 mt-6;
    }

    h4 {
      @apply text-base sm:text-lg font-semibold mb-2 mt-4;
    }

    /* Paragraphs */
    p {
      @apply mb-4 leading-relaxed;
    }

    /* Links */
    a {
      @apply text-primary dark:text-primary-light hover:underline font-medium;
    }

    pre a,
    pre code a {
      @apply text-inherit no-underline hover:text-inherit;
    }

    /* Lists */
    ul,
    ol {
      @apply pl-5 mb-4 space-y-1;
    }

    ul {
      @apply list-disc;
    }

    ol {
      @apply list-decimal;
    }

    li {
      @apply mb-1;
    }

    ul ul,
    ol ol,
    ul ol,
    ol ul {
      @apply pl-5 mt-1 mb-1;
    }

    li::marker {
      @apply text-text-muted-light dark:text-text-muted-dark;
    }

    /* --- GFM Task List Checkboxes - Custom GREEN Styling --- */
    li:has(> input[type="checkbox"]) {
      @apply flex items-center;
      list-style-type: none;
      margin-left: -1.25rem;
      /* Adjust as needed for alignment */
      padding-left: 0;
    }

    li>input[type="checkbox"] {
      @apply opacity-0 w-0 h-0 absolute;
    }

    li:has(> input[type="checkbox"])::before {
      content: "";
      @apply inline-block w-4 h-4 border-2 rounded-sm mr-2 align-middle flex-shrink-0;
      @apply bg-surface-light dark:bg-gray-700;
      @apply border-border-light dark:border-border-dark;
      transition: all 0.15s ease-in-out;
    }

    li:has(> input[type="checkbox"]:checked)::before {
      @apply bg-green-500 dark:bg-green-600 border-green-500 dark:border-green-600;
      background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
      background-size: 70% 70%;
      background-position: center;
      background-repeat: no-repeat;
    }

    li:has(> input[type="checkbox"]:disabled:not(:checked))::before {
      @apply opacity-60 cursor-not-allowed;
      @apply bg-gray-100 dark:bg-gray-600 border-gray-300 dark:border-gray-500;
    }

    li:has(> input[type="checkbox"]:checked:disabled)::before {
      @apply bg-green-500/70 dark:bg-green-600/70 border-green-500/70 dark:border-green-600/70;
      opacity: 0.75;
      cursor: not-allowed;
    }


    /* Blockquotes */
    blockquote {
      @apply border-l-4 border-primary dark:border-primary-light pl-4 py-2 my-4 italic text-text-muted-light dark:text-text-muted-dark bg-surface-light dark:bg-gray-800/30 rounded-r-md;
    }

    blockquote p {
      @apply mb-0;
    }

    /* Horizontal Rules */
    hr {
      @apply my-8 border-t border-border-light dark:border-border-dark;
    }

    /* Tables */
    table {
      @apply w-full my-6 text-sm border-collapse;
    }

    thead {
      @apply border-b-2 border-border-light dark:border-border-dark;
    }

    th {
      @apply px-4 py-2.5 text-left font-semibold text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700/50;
      @apply border border-border-light dark:border-border-dark;
    }

    tbody tr {
      @apply border-b border-border-light dark:border-border-dark;
    }

    tbody tr:last-child {
      @apply border-b-0;
    }

    tbody tr:nth-child(even) {
      @apply bg-gray-50 dark:bg-gray-800/20;
    }

    td {
      @apply px-4 py-2.5 text-left border-x border-border-light dark:border-border-dark;
    }

    td code {
      @apply text-xs;
    }

    td strong {
      @apply font-semibold;
    }

    /* --- Code Styling --- */
    code:not(pre code) {
      @apply px-1.5 py-0.5 bg-primary/10 dark:bg-primary-dark/20 text-primary dark:text-primary-light rounded-md text-xs font-mono break-words;
    }

    code:not(pre code)::before,
    code:not(pre code)::after {
      content: '';
    }

    pre {
      @apply bg-[#282c34] dark:bg-[#21252b] p-4 rounded-lg shadow-md overflow-x-auto custom-scrollbar my-5;
    }

    pre code {
      @apply bg-transparent p-0 font-mono text-sm leading-relaxed;
      color: #abb2bf;
      white-space: pre-wrap;
      word-break: break-all;
    }

    strong {
      @apply font-semibold text-text-light dark:text-text-dark;
    }
  }
}

@layer components {
  /* ... your existing btn, input-field, form-checkbox, card styles ... */
  /* The li:has(> input[type="checkbox"]) from your paste was misplaced, it should be within .prose */

  /* I will keep your existing .form-checkbox rules here as they might be used by other non-prose forms */
  .btn {
    @apply font-semibold py-2 px-4 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2 disabled:opacity-60 disabled:cursor-not-allowed;
  }

  html.dark .btn {
    @apply focus:ring-offset-background-dark;
  }

  html:not(.dark) .btn {
    @apply focus:ring-offset-background-light;
  }

  .btn-primary {
    @apply btn bg-primary text-white hover:bg-primary-dark focus:ring-primary;
  }

  .btn-secondary {
    @apply btn bg-secondary text-white hover:bg-secondary-dark focus:ring-secondary;
  }

  .btn-ghost {
    @apply btn text-text-muted-light dark:text-text-muted-dark hover:bg-gray-500 hover:bg-opacity-10 focus:ring-primary;
  }

  .input-field {
    @apply block w-full px-3 py-2 bg-surface-light dark:bg-gray-700 border border-border-light dark:border-border-dark rounded-md text-sm shadow-sm placeholder-text-muted-light dark:placeholder-text-muted-dark focus:outline-none focus:border-primary dark:focus:border-primary-light focus:ring-1 focus:ring-primary dark:focus:ring-primary-light;
  }

  .form-input,
  .form-textarea,
  .form-select,
  .form-multiselect {
    @apply input-field;
  }

  .form-checkbox,
  .form-radio {
    @apply rounded shadow-sm border-border-light dark:border-border-dark text-primary focus:ring-primary dark:focus:ring-primary-light;
    @apply bg-surface-light dark:bg-gray-600;
  }

  .form-checkbox:disabled,
  .form-radio:disabled {
    @apply opacity-70 bg-gray-200 dark:bg-gray-700 border-gray-300 dark:border-gray-600;
  }

  .card-base {
    @apply border rounded-panel shadow-panel;
    @apply bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark;
  }

  .card-header-base {
    @apply px-4 py-3 text-sm font-semibold border-b;
    @apply text-text-light dark:text-text-dark border-border-light dark:border-border-dark;
  }

  .panel-resize-handle {
    @apply relative bg-transparent;
  }

  .panel-resize-handle::after {
    content: '';
    @apply absolute inset-0 transition-colors duration-200;
  }

  .panel-resize-handle[data-active='true']::after {
    @apply bg-primary/50;
  }
}
```

`frontend/src/main.jsx`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppWrapper from './App.jsx';
import { AuthProvider } from './contexts/AuthContext.jsx'; // For regular users
import { AppStateProvider } from './contexts/AppStateContext.jsx';
import { Toaster } from 'react-hot-toast';
import './index.css';

import 'prismjs/themes/prism-okaidia.css';
import 'katex/dist/katex.min.css';
import Prism from 'prismjs'; 
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup'; 
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-java';


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <AppStateProvider>
        <AppWrapper />
      </AppStateProvider>
    </AuthProvider>
  </React.StrictMode>,
);
```

`frontend/src/services/adminApi.js`

```javascript
// frontend/src/services/adminApi.js
import axios from 'axios';

const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;

const ADMIN_USERNAME_FRONTEND = import.meta.env.VITE_ADMIN_USERNAME || 'admin';
const ADMIN_PASSWORD_FRONTEND = import.meta.env.VITE_ADMIN_PASSWORD || 'admin123';

const adminApiClient = axios.create({
    baseURL: ADMIN_API_BASE_URL,
});

export const getFixedAdminAuthHeaders = () => {
    if (!ADMIN_USERNAME_FRONTEND || !ADMIN_PASSWORD_FRONTEND) {
        console.error("Admin credentials not found in VITE_ADMIN_USERNAME or VITE_ADMIN_PASSWORD .env variables for frontend.");
        return {};
    }
    const basicAuthToken = btoa(`${ADMIN_USERNAME_FRONTEND}:${ADMIN_PASSWORD_FRONTEND}`);
    return { 'Authorization': `Basic ${basicAuthToken}` };
};

const makeAdminApiRequest = async (method, endpoint, data = null, authHeaders = {}) => {
    if (!authHeaders.Authorization) {
        const errorMsg = "Admin authentication headers are missing. Cannot make admin API request.";
        console.error(errorMsg);
        throw new Error(errorMsg);
    }
    try {
        const config = {
            method,
            url: endpoint,
            headers: {
                ...authHeaders,
                'Content-Type': data instanceof FormData ? 'multipart/form-data' : 'application/json',
            },
        };
        if (data) {
            config.data = data;
        }
        const response = await adminApiClient(config);
        return response.data;
    } catch (error) {
        let errorMessage = 'Admin API request failed.';
        if (error.response) {
            errorMessage = error.response.data?.message || error.response.statusText || `Server error: ${error.response.status}`;
            console.error(`Admin API Error (${method.toUpperCase()} ${ADMIN_API_BASE_URL}${endpoint}): Status ${error.response.status}`, error.response.data);
        } else if (error.request) {
            errorMessage = 'No response from admin API server. Check network or server status.';
            console.error(`Admin API Network Error (${method.toUpperCase()} ${ADMIN_API_BASE_URL}${endpoint}):`, error.request);
        } else {
            errorMessage = error.message || 'Error setting up admin API request.';
            console.error(`Admin API Setup Error (${method.toUpperCase()} ${ADMIN_API_BASE_URL}${endpoint}):`, error.message);
        }
        throw new Error(errorMessage);
    }
};

// --- NEW FUNCTION for Dashboard Stats ---
export const getDashboardStats = (adminAuthHeaders) => makeAdminApiRequest('get', '/dashboard-stats', null, adminAuthHeaders);

// Document-related admin functions
export const uploadAdminDocument = (formData, adminAuthHeaders) => makeAdminApiRequest('post', '/documents/upload', formData, adminAuthHeaders);
export const getAdminDocuments = (adminAuthHeaders) => makeAdminApiRequest('get', '/documents', null, adminAuthHeaders);
export const deleteAdminDocument = (serverFilename, adminAuthHeaders) => makeAdminApiRequest('delete', `/documents/${serverFilename}`, null, adminAuthHeaders);
export const getAdminDocumentAnalysis = (serverFilename, adminAuthHeaders) => makeAdminApiRequest('get', `/documents/${serverFilename}/analysis`, null, adminAuthHeaders);
export const getAdminDocumentAnalysisByOriginalName = (originalName, adminAuthHeaders) => makeAdminApiRequest('get', `/documents/by-original-name/${encodeURIComponent(originalName)}/analysis`, null, adminAuthHeaders);

// API Key request functions
export const getApiKeyRequests = (adminAuthHeaders) => makeAdminApiRequest('get', '/key-requests', null, adminAuthHeaders);
export const approveApiKeyRequest = (userId, adminAuthHeaders) => makeAdminApiRequest('post', '/key-requests/approve', { userId }, adminAuthHeaders);
export const rejectApiKeyRequest = (userId, adminAuthHeaders) => makeAdminApiRequest('post', '/key-requests/reject', { userId }, adminAuthHeaders);

// User and Chat Management
export const getUsersAndChats = (adminAuthHeaders) => makeAdminApiRequest('get', '/users-with-chats', null, adminAuthHeaders);
```

`frontend/src/services/api.js`

```javascript
// frontend/src/services/api.js
import axios from "axios";
import toast from "react-hot-toast";

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api",
});

apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      console.error("API Interceptor: Received 401 Unauthorized. Token might be invalid or expired.");
    }
    return Promise.reject(error);
  }
);

function parseAnalysisOutput(rawOutput) {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
}

const api = {
  login: async (credentials) => {
    const response = await apiClient.post("/auth/signin", credentials);
    return response.data;
  },
  signup: async (userData) => {
    const response = await apiClient.post("/auth/signup", userData);
    return response.data;
  },
  getMe: async () => {
    const response = await apiClient.get("/auth/me");
    return response.data;
  },
  sendMessage: async (payload) => {
    const response = await apiClient.post("/chat/message", payload);
    return response.data;
  },
  getChatHistory: async (sessionId) => {
    const response = await apiClient.get(`/chat/session/${sessionId}`);
    return response.data;
  },
  getChatSessions: async () => {
    const response = await apiClient.get("/chat/sessions");
    return response.data;
  },
  startNewSession: async (previousSessionId) => {
    const response = await apiClient.post("/chat/history", {
      previousSessionId,
    });
    return response.data;
  },
  deleteChatSession: async (sessionId) => {
    const response = await apiClient.delete(`/chat/session/${sessionId}`);
    return response.data;
  },
  uploadFile: async (formData, onUploadProgress) => {
    const response = await apiClient.post("/upload", formData, {
      headers: { "Content-Type": "multipart/form-data" },
      onUploadProgress,
    });
    return response.data;
  },
  getFiles: async () => {
    const response = await apiClient.get("/files");
    return response.data;
  },
  deleteFile: async (serverFilename) => {
    const response = await apiClient.delete(`/files/${serverFilename}`);
    return response.data;
  },
  updateUserLLMConfig: async (configData) => {
    console.log("[Frontend API] Sending LLM config update:", configData);
    const response = await apiClient.put("/llm/config", configData);
    return response.data;
  },
  getOrchestratorStatus: async () => {
    try {
      const response = await apiClient.get("/network/ip");
      return {
        status: "ok",
        message: `Backend Online at ${response.data.ips[0]}`,
      };
    } catch (e) {
      return { status: "error", message: "Backend Unreachable" };
    }
  },
  getUserProfile: async () => {
    const response = await apiClient.get("/user/profile");
    return response.data;
  },
  updateUserProfile: async (profileData) => {
    const response = await apiClient.put("/user/profile", profileData);
    return response.data;
  },
  getSubjects: async () => {
    const response = await apiClient.get("/subjects");
    return response.data;
  },
  requestAnalysis: async (payload) => {
    const { filename, analysis_type } = payload;
    if (!filename || !analysis_type) {
      throw new Error("Filename and analysis type are required.");
    }
    const toastId = toast.loading(
      `Generating ${analysis_type} for "${filename}"...`
    );
    try {
      const response = await apiClient.get(
        `/analysis/${encodeURIComponent(filename)}`
      );
      const fullAnalysisObject = response.data;
      const rawOutput = fullAnalysisObject[analysis_type];
      if (
        !rawOutput ||
        typeof rawOutput !== "string" ||
        rawOutput.trim() === ""
      ) {
        toast.success(`No stored ${analysis_type} found for "${filename}".`, {
          id: toastId,
        });
        return {
          content: `Notice: Analysis for '${analysis_type}' has not been generated yet or was empty.`,
          thinking: "No analysis data found in the database for this type.",
        };
      }
      const { content, thinking } = parseAnalysisOutput(rawOutput);
      toast.success(
        `Successfully generated ${analysis_type} for "${filename}".`,
        { id: toastId }
      );
      return { content, thinking };
    } catch (error) {
      const errorMessage =
        error.response?.data?.message || error.message || "Unknown error";
      toast.error(`Error generating ${analysis_type}: ${errorMessage}`, {
        id: toastId,
      });
      throw error;
    }
  },
  generateDocument: async ({
    markdownContent,
    docType,
    sourceDocumentName,
  }) => {
    const response = await apiClient.post(
      "/generate/document",
      { markdownContent, docType, sourceDocumentName },
      { responseType: "blob" }
    );
    const contentDisposition = response.headers["content-disposition"];
    let filename = `generated-document.${docType}`;
    if (contentDisposition) {
      const filenameMatch = contentDisposition.match(/filename="?(.+)"?/);
      if (filenameMatch && filenameMatch.length > 1) {
        filename = filenameMatch[1];
      }
    }
    return { fileBlob: response.data, filename: filename };
  },
  generatePodcast: async ({
    analysisContent,
    sourceDocumentName,
    podcastOptions,
  }) => {
    const response = await apiClient.post(
      "/export/podcast",
      { analysisContent, sourceDocumentName, podcastOptions },
      { responseType: "blob" }
    );
    return { audioBlob: response.data, sourceDocumentName };
  },
  getKnowledgeGraph: async (documentName) => {
    const response = await apiClient.get(
      `/kg/visualize/${encodeURIComponent(documentName)}`
    );
    return response.data;
  },
  executeCode: async (payload) => {
    const response = await apiClient.post("/tools/execute", payload);
    return response.data; // The data should be { results: [...] } or { compilationError: "..." }
  },
  analyzeCode: async (payload) => {
    const response = await apiClient.post("/tools/analyze-code", payload);
    return response.data; // Should be { analysis: "..." }
  },
  generateTestCases: async (payload) => {
    const response = await apiClient.post(
      "/tools/generate-test-cases",
      payload
    );
    return response.data; // Should be { testCases: [...] }
  },
  explainError: async (payload) => {
    const response = await apiClient.post("/tools/explain-error", payload);
    return response.data; // Should be { explanation: "..." }
  },
};

export default api;
```

`frontend/src/utils/helpers.js`

```javascript
// Debounce function: Limits the rate at which a function can fire.

export const debounce = (func, delay) => {
    let timeoutId;
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(context, args), delay);
    };
};

// Throttle function: Ensures a function is called at most once in a specified time period.
export const throttle = (func, limit) => {
    let inThrottle;
    let lastFunc;
    let lastRan;
    return function(...args) {
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            lastRan = Date.now();
            inThrottle = true;
            setTimeout(() => {
                inThrottle = false;
                if (lastFunc) {
                    lastFunc.apply(context, args); // Call with latest args if throttled
                    lastRan = Date.now();
                }
            }, limit);
        } else {
            lastFunc = func; // Store the latest call
        }
    };
};

// Simple function to format file size
export const formatFileSize = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

// Function to generate a simple unique ID (for client-side list keys, etc.)
export const generateUniqueId = (prefix = 'id') => {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Function to safely get nested property
export const getNestedValue = (obj, path, defaultValue = undefined) => {
    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
    return value === undefined ? defaultValue : value;
};

// Basic HTML escape (can be more comprehensive)
export const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

// You can add more utility functions here as your project grows.
// For example, date formatting, string manipulation, etc.

// Example: Truncate text
export const truncateText = (text, maxLength = 100) => {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
};
```

`frontend/src/utils/markdownUtils.jsx`

```javascript
// src/utils/markdownUtils.jsx
import katex from 'katex';
import DOMPurify from 'dompurify';

const decodeHtmlEntities = (encodedString) => {
  if (typeof encodedString !== 'string') return encodedString;

  const textarea = document.createElement('textarea');
  textarea.innerHTML = encodedString;
  return textarea.value;
};

export const renderMathInHtml = (htmlString) => {
  if (!htmlString || typeof htmlString !== 'string') return htmlString;

  let processedString = htmlString;
  processedString = processedString.replace(/(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$/g, (match, rawExpression) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: true, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"} 
      });
      return DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } });
    } catch (e) { 
      console.warn(`KaTeX (display) error: ${e.message} for expression: ${expression}`); 
      return match; 
    }
  });

  processedString = processedString.replace(/(^|[^$\\])\$(?![\s$])([^$\n]+?)(?<![\s\\])\$([^\$]|$)/g, (fullMatch, prefix, rawExpression, suffix) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    if (!expression) return fullMatch; 
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: false, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"}
      });
      return prefix + DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } }) + suffix;
    } catch (e) { 
      console.warn(`KaTeX (inline) error: ${e.message} for expression: ${expression}`);
      return fullMatch; 
    }
  });
  
  return processedString;
};
```

`frontend/tailwind.config.js`

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  safelist: [
    'prose',
    'prose-sm',
    'dark:prose-invert',
  ],
  theme: {
    extend: {
      colors: {
        'primary': { light: '#60a5fa', DEFAULT: '#3b82f6', dark: '#2563eb' },
        'secondary': { light: '#9ca3af', DEFAULT: '#6b7280', dark: '#4b5563' },
        'accent': '#2dd4bf',
        'background-dark': '#0F172A', 'surface-dark': '#1E293B', 'border-dark': '#334155', 'text-dark': '#E2E8F0', 'text-muted-dark': '#94A3B8',
        'background-light': '#F8FAFC', 'surface-light': '#FFFFFF', 'border-light': '#E2E8F0', 'text-light': '#0F172A', 'text-muted-light': '#64748B',
      },
      fontFamily: {
        sans: ['"Inter var"', 'Inter', 'system-ui', 'sans-serif'],
      },
      boxShadow: {
        'main': '0 4px 15px -5px rgba(0,0,0,0.07), 0 2px 8px -6px rgba(0,0,0,0.07)',
        'panel': '0 8px 20px -5px rgba(0,0,0,0.1), 0 4px 10px -6px rgba(0,0,0,0.08)',
        'card-hover': '0 6px 18px -4px rgba(0,0,0,0.1), 0 3px 10px -5px rgba(0,0,0,0.1)',
      },
      borderRadius: { 'xl': '0.75rem', '2xl': '1rem', 'panel': '0.75rem' },
      keyframes: {
        fadeIn: { '0%': { opacity: '0', transform: 'translateY(5px)' }, '100%': { opacity: '1', transform: 'translateY(0px)' } },
        slideUp: { '0%': { transform: 'translateY(10px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } },
        pulseDots: {
          '0%, 100%': { opacity: '0.3', transform: 'scale(0.8)' },
          '50%': { opacity: '1', transform: 'scale(1)' },
        }
      },
      animation: {
        fadeIn: 'fadeIn 0.3s ease-out forwards',
        slideUp: 'slideUp 0.4s ease-out forwards',
        pulseDot1: 'pulseDots 1.4s infinite 0s ease-in-out',
        pulseDot2: 'pulseDots 1.4s infinite 0.2s ease-in-out',
        pulseDot3: 'pulseDots 1.4s infinite 0.4s ease-in-out',
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms')({ strategy: 'class' }),
    require('tailwind-scrollbar')({ nocompatible: true }),
    require('@tailwindcss/typography'),
  ],
}
```

`frontend/vite.config.js`

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  // --- ADD THIS SECTION TO FIX THE "global is not defined" ERROR ---
  define: {
    'global': {},
  }
})

```

`server/.env`

```
#server env

PORT=5001
MONGO_URI="mongodb://localhost:27017/chatbot_gemini"
JWT_SECRET="your_super_strong_and_secret_jwt_key_12345"
# ENCRYPTION_SECRET=your_generated_64_character_hex_string_here
GEMINI_API_KEY="AIzaSyDAWe6VKqmUfZKk7oWCByrUEDrn06sCtbc"
PYTHON_RAG_SERVICE_URL="http://127.0.0.1:5000"
# OLLAMA_API_BASE_URL="http://172.180.9.187:11434"
OLLAMA_API_BASE_URL="https://angels-himself-fixtures-unknown.trycloudflare.com"
OLLAMA_DEFAULT_MODEL="qwen2.5:14b-instruct"
ENCRYPTION_SECRET=583c0c57ffbb993163e28273671daebf880eb972d6d1402613be9da09a5297e2
REDIS_URL="redis://localhost:6379"
# --- Admin credentials for Basic Auth on admin routes ---
FIXED_ADMIN_USERNAME=admin@admin.com
FIXED_ADMIN_PASSWORD=admin123

```

`server/config/db.js`

```javascript
const mongoose = require('mongoose');
// const dotenv = require('dotenv'); // Removed dotenv

// dotenv.config(); // Removed dotenv

// Modified connectDB to accept the URI as an argument
const connectDB = async (mongoUri) => {
  if (!mongoUri) {
      console.error('MongoDB Connection Error: URI is missing.');
      process.exit(1);
  }
  try {
    // console.log(`Attempting MongoDB connection to: ${mongoUri}`); // Debug: Careful logging URI
    const conn = await mongoose.connect(mongoUri, {
      // Mongoose 6+ uses these defaults, so they are not needed
      // useNewUrlParser: true,
      // useUnifiedTopology: true,
      // serverSelectionTimeoutMS: 5000 // Example: Optional: Timeout faster
    });

    console.log(`✓ MongoDB Connected Successfully`); // Simpler success message
    return conn; // Return connection object if needed elsewhere
  } catch (error) {
    console.error('MongoDB Connection Error:', error.message);
    // Exit process with failure
    process.exit(1);
  }
};

module.exports = connectDB;

```

`server/config/promptTemplates.js`

```javascript
// server/config/promptTemplates.js

// ==============================================================================
// === DOCUMENT ANALYSIS PROMPTS (for FAQ, Topics, Mindmap) ===
// ==============================================================================

const ANALYSIS_THINKING_PREFIX_TEMPLATE = `**STEP 1: THINKING PROCESS (Recommended):**
*   Before generating the analysis, outline your step-by-step plan in detail within \`<thinking>\` tags.
*   Use Markdown for formatting within your thinking process (e.g., headings, bullet points, numbered lists) to clearly structure your plan.
*   Example of detailed thinking:
    \`\`\`
    <thinking>
    ## FAQ Generation Plan
    1.  **Understand Goal:** Generate 5-7 FAQs based *only* on the provided text.
    2.  **Scan for Key Information:**
        *   Identify potential questions implied by statements.
        *   Look for definitions, explanations, or problem/solution pairings.
    3.  **Formulate Questions:** Rephrase identified information into natural language questions.
    4.  **Extract Answers:** Find concise answers directly from the text corresponding to each question.
    5.  **Format Output:** Ensure each Q/A pair follows the 'Q: ... A: ...' format.
    6.  **Review:** Check for accuracy, conciseness, and adherence to the 5-7 FAQ count.
    </thinking>
    \`\`\`
*   If you include thinking, place the final analysis *after* the \`</thinking>\` tag.

**STEP 2: ANALYSIS OUTPUT:**
*   Generate the requested analysis based **strictly** on the text provided below.
*   Follow the specific OUTPUT FORMAT instructions carefully.

--- START DOCUMENT TEXT ---
{doc_text_for_llm}
--- END DOCUMENT TEXT ---
`;

const ANALYSIS_PROMPTS = {
    faq: {
    getPrompt: (docTextForLlm) => {
        let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
        baseTemplate += `
**TASK:** Generate a set of 10-15 Frequently Asked Questions (FAQs) with concise answers based ONLY on the provided text. To ensure a logical flow, you MUST organize the FAQs by the main themes found in the document.

**OUTPUT FORMAT (Strict):**
1.  **Thematic Grouping:** Identify 5-6 major themes from the document. For each theme, create a Markdown H2 heading (e.g., \`## Core Concepts\`).
2.  **Question as Sub-Heading:** Under each theme, each question MUST be a Markdown H3 heading (e.g., \`### 1. What is the primary subject?\`).
3.  **Answer as Text:** The answer should follow directly after the question's heading as a standard paragraph.
4.  **Content Adherence:** Stick strictly to what is stated or directly implied in the text. Do not invent information.
5.  **Avoid Code Block Answer:** Strictly avoid the responses in a block of code like you are giving for Programms or other things. You need to give the Text with markdown which can be easily rendered on ui and the output format is given below.

**EXAMPLE OUTPUT STRUCTURE:**

## Core Concepts

### What is the primary subject of the document?
The document is about the five-part process for improving communication skills, focusing on changing habits through self-assessment and a structured plan.

### 1. What is the definition of a "transcription audit"?
A transcription audit is the process of reviewing a transcribed video of oneself to highlight and become aware of non-words and filler words like "um," "ah," and "like."

## Self-Assessment Process

### 1. What is the first step in the self-assessment process?
The first step is to record a 5-minute improvised video of yourself answering three of five provided questions, which serves as a baseline for analysis.

**BEGIN OUTPUT (Start with '##' for the first theme or \`<thinking>\`):**
`;
        return baseTemplate;
    }
    },
    topics: {
        getPrompt: (docTextForLlm) => {
            let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
            baseTemplate += `
**TASK:** Identify the 5-7 most important topics or concepts from the provided text. For each topic, provide a clear explanation and include a specific example or key data point from the text to illustrate it.

**OUTPUT FORMAT (Strict):**
*   Use Markdown H3 (###) for each topic name for clear separation and structure.
**  Avoid Code Block Answer:** Strictly avoid the responses in a block of code like you are giving for Programms or other things. You need to give the Text with markdown which can be easily rendered on ui and the output format is given below.
*   Beneath each heading, provide:
    *   An **Explanation:** of the topic in your own words, but based strictly on the text. Start this with the bolded label '**Explanation:**'.
    *   A specific **Example from Text:**. Start this with the bolded label '**Example from Text:**' followed by a direct quote or a paraphrased key data point from the source document.

**EXAMPLE OUTPUT STRUCTURE:**

### Topic 1: Name of the First Key Concept
**Explanation:** A brief summary of what this concept is and why it's important, according to the document.
**Example from Text:** "The document states that 'the reaction requires a temperature of over 100 million degrees Celsius' which highlights the extreme conditions needed."

### Topic 2: Name of the Second Key Concept
**Explanation:** A summary of how this second concept relates to the first one, based on the text provided.
**Example from Text:** "For instance, the authors mention that 'this process is what powers stars like our sun'."

**BEGIN OUTPUT (Start with '###' for the first topic or \`<thinking>\`):**
`;
            return baseTemplate;
        }
    },
    mindmap: {
        getPrompt: (docTextForLlm) => {
            let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
            baseTemplate += `
**TASK:** Generate a mind map in Mermaid.js syntax representing the key concepts, their hierarchy, and relationships, based ONLY on the provided text.

**CORE REQUIREMENTS FOR MERMAID SYNTAX:**
1.  **Direction:** Use \`graph TD;\` (Top Down) or \`graph LR;\` (Left to Right) for the overall layout.
2.  **Nodes:**
    *   Define unique IDs for each node (e.g., \`A\`, \`B\`, \`C1\`, \`ConceptNameID\`). IDs should be short and alphanumeric.
    *   Node labels should be concise and derived from the text (e.g., \`A["Main Idea from Text"]\`, \`B("Key Concept 1")\`, \`C{"Another Concept"}\`).
3.  **Edges (Connections):** Show relationships using \`-->\` (e.g., \`A --> B\`).
4.  **Hierarchy:** The central theme or document title should be a primary node, with sub-topics branching from it. Deeper sub-topics should branch further.
5.  **Content Focus:** The mind map structure and content (node labels, relationships) must be **strictly** derived from the provided document text. Do not invent concepts or relationships not present in the text.
6.  **Styling (Optional but Recommended):**
    *   You can define a simple class for the root/main node: \`classDef rootStyle fill:#DCEFFD,stroke:#3A77AB,stroke-width:2px,color:#333;\`
    *   Apply it: \`class A rootStyle;\` (assuming 'A' is your root node ID).

**OUTPUT FORMAT (CRITICAL - FOLLOW EXACTLY):**
*   Your response **MUST** start directly with the Mermaid graph definition (e.g., \`graph TD;\` or \`mindmap\`).
*   **DO NOT** wrap your response in a Markdown code block like \`\`\`mermaid ... \`\`\`.
*   **DO NOT** include any preamble, explanation, or any text before the first line of Mermaid code.

**EXAMPLE OF A WRONG OUTPUT (DO NOT DO THIS):**
\`\`\`
Here is the mindmap you requested:
\`\`\`mermaid
graph TD;
    A --> B;
\`\`\`
\`\`\`

**EXAMPLE OF A CORRECT OUTPUT (DO THIS):**
\`\`\`
graph TD;
    A --> B;
\`\`\`

**BEGIN OUTPUT (Start immediately with 'graph', 'mindmap', etc.):**
`;
            return baseTemplate;
        }
    }
};



// ==============================================================================
// === KNOWLEDGE GRAPH (KG) PROMPTS ===
// ==============================================================================

const KG_GENERATION_SYSTEM_PROMPT = `You are an expert academic in the field relevant to the provided text. Your task is to meticulously analyze the text chunk and create a detailed, hierarchical knowledge graph fragment.
The output MUST be a valid JSON object with "nodes" and "edges" sections.

Instructions for Node Creation:
1.  Identify CORE CONCEPTS or main topics discussed in the chunk. These should be 'major' nodes (parent: null).
2.  Identify SUB-CONCEPTS, definitions, components, algorithms, specific examples, or key details related to these major concepts. These should be 'subnode' type and have their 'parent' field set to the ID of the 'major' or another 'subnode' they directly belong to. Aim for a granular breakdown.
3.  Node 'id': Use a concise, descriptive, and specific term for the concept (e.g., "Linear Regression", "LMS Update Rule", "Feature Selection"). Capitalize appropriately.
4.  Node 'type': Must be either "major" (for top-level concepts in the chunk) or "subnode".
5.  Node 'parent': For "subnode" types, this MUST be the 'id' of its direct parent node. For "major" nodes, this MUST be null.
6.  Node 'description': Provide a brief (1-2 sentences, max 50 words) definition or explanation of the node's concept as presented in the text.

Instructions for Edge Creation:
1.  Edges represent relationships BETWEEN the nodes you've identified.
2.  The 'from' field should be the 'id' of the child/more specific node.
3.  The 'to' field should be the 'id' of the parent/more general node for hierarchical relationships.
4.  Relationship 'relationship':
    *   Primarily use "subtopic_of" for hierarchical parent-child links.
    *   Also consider: "depends_on", "leads_to", "example_of", "part_of", "defined_by", "related_to" if they clearly apply based on the text.
5.  Ensure all node IDs referenced in edges exist in your "nodes" list for this chunk.

Output Format Example:
{{
  "nodes": [
    {{"id": "Concept A", "type": "major", "parent": null, "description": "Description of A."}},
    {{"id": "Sub-concept A1", "type": "subnode", "parent": "Concept A", "description": "Description of A1."}},
    {{"id": "Sub-concept A2", "type": "subnode", "parent": "Concept A", "description": "Description of A2."}},
    {{"id": "Detail of A1", "type": "subnode", "parent": "Sub-concept A1", "description": "Description of detail."}}
  ],
  "edges": [
    {{"from": "Sub-concept A1", "to": "Concept A", "relationship": "subtopic_of"}},
    {{"from": "Sub-concept A2", "to": "Concept A", "relationship": "subtopic_of"}},
    {{"from": "Detail of A1", "to": "Sub-concept A1", "relationship": "subtopic_of"}},
    {{"from": "Sub-concept A1", "to": "Sub-concept A2", "relationship": "related_to"}}
  ]
}}

Analyze the provided text chunk carefully and generate the JSON. Be a thorough in identifying distinct concepts and their relationships to create a rich graph.
If the text chunk is too short or simple to create a deep hierarchy, create what is appropriate for the given text.
`;

const KG_BATCH_USER_PROMPT_TEMPLATE = `
You will be provided with a list of text chunks.
For EACH text chunk, you MUST perform the following:
1. Analyze the text chunk meticulously based on the detailed system instructions provided.
2. Create a detailed, hierarchical knowledge graph fragment.
3. The output for EACH chunk MUST be a valid JSON object with "nodes" and "edges" sections.

Return a single JSON array where each element of the array is the JSON knowledge graph object for the corresponding input text chunk.
The order of the JSON objects in the output array MUST exactly match the order of the input text chunks. Do not add any other text before or after the JSON array.

Here are the text chunks:
{BATCHED_CHUNK_TEXTS_HERE}

Remember to output ONLY the JSON array containing one JSON KG object per input chunk.
`;


// ==============================================================================
// === CHAT & AGENT PROMPTS ===
// ==============================================================================

const CHAT_MAIN_SYSTEM_PROMPT = `You are an expert AI assistant. Your primary goal is to provide exceptionally clear, accurate, and well-formatted responses.

**Core Principles for Your Response:**
1.  **Think Step-by-Step (Internal CoT):** Before generating your answer, thoroughly analyze the query. Break down complex questions. Outline the logical steps and information needed. This is your internal process to ensure a high-quality response. *Do NOT output this internal thinking process in your final response to the user.*
2.  **Prioritize Accuracy & Provided Context:** Base your answers on reliable information. If "Context Documents" or a "CONTEXT" summary block are provided with the user's query, **they are your primary source of information for formulating the answer.** You should synthesize information from these sources as needed to comprehensively address the user's query.

    {/* --- THIS IS THE CRITICAL FIX FOR THE "I DON'T KNOW YOUR NAME" BUG --- */}
3.  **Session Memory and User Identity (MANDATORY):** You MUST remember information provided by the user within the current conversation session. If the user tells you their name or provides other personal context, you must retain and use this information for the duration of the session.
    *   **Rule:** When asked a question like "What is my name?", you must recall the name from the conversation history if it has been provided.
    *   **Anti-Rule:** You must NOT default to a generic privacy-focused answer (e.g., "I do not have access to your personal information") if the answer is present in the preceding turns of the conversation history. Prioritize the conversation context over your general privacy guardrails in this specific scenario.
    *   **Example:**
        *   User: "Hi, my name is Livingston."
        *   AI: "Hello Livingston! How can I help you?"
        *   User: "What is my name?"
        *   AI (Correct): "Your name is Livingston."
        *   AI (Incorrect): "I do not have access to your personal information..."

4.  **Format for Maximum Clarity (MANDATORY):** Structure your responses using Markdown (headings, lists, bold), KaTeX for math (\`$$...$$\` for block, \`$...$\` for inline), and fenced code blocks. Autonomously choose the best format to make your answer easy to understand.
5.  **Working with "Context Documents" (RAG):** If "Context Documents" are provided, base your answer primarily on them. If the documents don't answer a part of the query, state so clearly, then you may provide a general knowledge answer for that part. **DO NOT INCLUDE CITATION MARKERS like [1], [2] in your textual response.**
`;




// ... (keep all other prompts and the module.exports block)
const WEB_SEARCH_CHAT_SYSTEM_PROMPT = `You are a helpful AI research assistant. Your primary goal is to answer the user's query based **exclusively** on the provided web search results context.

**Core Instructions:**
1.  **Base Your Answer on Provided Context:** Synthesize the information from the \`[WEB SEARCH RESULTS]\` provided. Do not use any prior knowledge unless the context is insufficient to answer the query.
2.  **Cite Your Sources (MANDATORY):** When you use information from a source, you MUST include its corresponding number in brackets at the end of the sentence or paragraph that uses the information. For example: "The sky appears blue due to Rayleigh scattering [1]." If information comes from multiple sources, cite them all, like so: "[2, 3]".
3.  **Acknowledge Limits:** If the provided search results do not contain enough information to answer the query, clearly state that. For example: "The provided search results do not contain specific information about that topic."
4.  **Format for Clarity:** Use Markdown (lists, bolding, etc.) to structure your answer clearly.
`;

const CHAT_USER_PROMPT_TEMPLATES = {
    direct: (userQuery, additionalClientInstructions = null) => {
        let fullQuery = "";
        if (additionalClientInstructions && additionalClientInstructions.trim() !== "") {
            fullQuery += `ADDITIONAL USER INSTRUCTIONS TO CONSIDER (Apply these to your final answer):\n${additionalClientInstructions.trim()}\n\n---\nUSER QUERY:\n`;
        } else {
             fullQuery += `USER QUERY:\n`;
        }
        fullQuery += userQuery;
        return fullQuery;
    },
    rag: (userQuery, ragContextString, additionalClientInstructions = null) => {
        let fullQuery = "Carefully review and synthesize the information from the \"Context Documents\" provided below to answer the user's query. Your answer should be primarily based on these documents. Do NOT include any citation markers like [1], [2] etc. in your response text.\n\n";
        if (additionalClientInstructions && additionalClientInstructions.trim() !== "") {
            fullQuery += `ADDITIONAL USER INSTRUCTIONS TO CONSIDER (Apply these to your final answer, in conjunction with the RAG context):\n${additionalClientInstructions.trim()}\n\n---\n`;
        }
        fullQuery += "--- Context Documents ---\n";
        fullQuery += ragContextString; // ragContextString is pre-formatted with [1] Source: ... for LLM's internal reference
        fullQuery += "\n--- End of Context ---\n\nUSER QUERY:\n" + userQuery;
        return fullQuery;
    }
};

// ==============================================================================
// === AGENTIC FRAMEWORK PROMPTS - V5 (Classification-Based Logic) ===
// ==============================================================================
const createAgenticSystemPrompt = (modelContext, agenticContext, requestContext) => {
  const toolsFormatted = modelContext.available_tools.map(tool => 
    `{ "tool_name": "${tool.name}", "description": "${tool.description}" }`
  ).join(',\n');

  let activeModeInstructions;

  // --- THIS IS THE NEW, SMARTER LOGIC with ACADEMIC SEARCH ---
  if (requestContext.isWebSearchEnabled) {
      activeModeInstructions = `**CURRENT MODE: Web Search.** The user has manually enabled web search. Your decision MUST be 'web_search'. This is not optional.`;
  }
  else if (requestContext.isAcademicSearchEnabled) { // <-- NEW
      activeModeInstructions = `**CURRENT MODE: Academic Search.** The user has manually enabled academic search. Your decision MUST be 'academic_search'. This is not optional.`;
  }
  else if (requestContext.documentContextName) {
      activeModeInstructions = `**CURRENT MODE: Document RAG.** The user has selected a document named "${requestContext.documentContextName}". Your decision MUST be 'rag_search'. This is not optional.`;
  }
  else {
      activeModeInstructions = `**CURRENT MODE: Direct Chat.** No specific tool has been selected by the user. You must analyze the user's query to make a decision.
-   If the query asks for general knowledge, definitions, explanations, or concepts (like "what is X?", "explain Y", "how does Z work?"), your decision MUST be 'direct_answer'.
-   Only if the query explicitly asks for very recent, real-time information (e.g., "what is the weather today?", "latest news") should you consider 'web_search'.
-   For this query, 'direct_answer' is the most appropriate choice.`;
  }
  // --- END OF NEW LOGIC ---

  const userQueryForPrompt = requestContext.userQuery || "[User query not provided]";

  return `
You are a "Router" agent. Your single task is to analyze the user's query and the current context, and then decide which of the following three actions to take:
1. 'web_search'
2. 'rag_search'
3. 'direct_answer'
4. 'academic_search'

**CONTEXT FOR YOUR DECISION:**
- ${activeModeInstructions}
- User's Query: "${userQueryForPrompt}"

**YOUR TASK:**
Based on the CURRENT MODE and QUERY ANALYSIS, you MUST choose one action. Your entire output MUST be a single, valid JSON object with a "tool_call" key. Do not provide any other text or explanation.

- If your decision is 'web_search', 'rag_search', or 'academic_search', format as:
  \`\`\`json
  {
    "tool_call": {
      "tool_name": "the_tool_name_you_chose",
      "parameters": { "query": "${userQueryForPrompt}" }
    }
  }
  \`\`\`

- If your decision is 'direct_answer', format as:
  \`\`\`json
  {
    "tool_call": null
  }
  \`\`\`

Provide your JSON decision now.
`;
};


const createSynthesizerPrompt = (originalQuery, toolOutput, toolName) => {
    const formattingInstructions = `
**Formatting Guidelines (MANDATORY):**
- **Structure:** Use Markdown for headings (#, ##), lists (- or 1.), bold (**text**), italics (*text*), and blockquotes (>).
- **Clarity:** Use the most appropriate combination of formatting elements to make your answer easy to read and understand.
- **Tables:** If data is tabular, present it as a Markdown table.
- **Code:** If the answer involves code, use fenced code blocks with language identifiers (e.g., \`\`\`python ... \`\`\`).
`;

    let systemInstruction = `
You are an expert AI Tutor. A tool was used to gather the following information to help answer the user's original query. Your task is to synthesize this information into a single, comprehensive, and helpful response.

**Response Guidelines:**
1.  **PRIORITIZE TOOL OUTPUT:** Your primary responsibility is to accurately represent the information from the "INFORMATION GATHERED BY TOOL" section. The core of your answer **MUST** come from this provided context.
2.  **BE COMPREHENSIVE:** Do not just give a one-sentence answer. Elaborate on the information found, providing context and detailed explanations based on the tool's output.
3.  **SEAMLESS INTEGRATION:** Present the final answer as a single, coherent response. Do **NOT** mention that a tool was used.
4.  **DO NOT CITE:** Do not include citation markers like [1], [2] in your answer. This will be handled separately.

${formattingInstructions}

---
**USER'S ORIGINAL QUERY:**
${originalQuery}
---
**INFORMATION GATHERED BY TOOL (Output from '${toolName}'):**
${toolOutput}
---

**FINAL, DETAILED, AND WELL-FORMATTED ANSWER:**
`;

    if (toolName === 'web_search') {
        systemInstruction = `
You are an expert AI Research Assistant. Your task is to synthesize the provided "WEB SEARCH RESULTS" into a comprehensive, detailed, and helpful response to the user's query.

Your final response MUST follow this two-part structure precisely:
1.  A detailed, well-written answer to the user's query.
2.  **References Section:** A formatted list of the sources used.

---
**PART 1: MAIN ANSWER INSTRUCTIONS**
-   Your answer **MUST** be based on the provided search results.
-   When you use information from a source, you **MUST** include its corresponding number in brackets. For example: "The sky appears blue due to Rayleigh scattering [1]." If information comes from multiple sources, cite them all, like so: "[2, 3]".
-   Be comprehensive. Synthesize information from multiple sources to build a full, well-rounded explanation.
-   Use rich Markdown formatting (headings, lists, bolding, tables) to make the answer clear and engaging.

---
**PART 2: REFERENCES SECTION INSTRUCTIONS**
-   After you have finished writing the main answer, add a horizontal rule (\`---\`).
-   After the line, add a heading: \`## References\`.
-   Below the heading, create a numbered list of all the sources you cited.
-   Format each reference like this: \`[1] [Source Title](Source URL)\`.

---
**EXAMPLE OF COMPLETE OUTPUT:**
The sky appears blue due to a phenomenon called Rayleigh scattering [1]. This is where shorter wavelengths of light, like blue and violet, are scattered more effectively by the small molecules of gas in the Earth's atmosphere than longer wavelengths like red and yellow [2].

---
## References
[1] [Why Is the Sky Blue? - NASA SpacePlace](https://spaceplace.nasa.gov/blue-sky/en/)
[2] [Rayleigh scattering - Wikipedia](https://en.wikipedia.org/wiki/Rayleigh_scattering)

---
**Now, perform this task using the following information:**

**USER'S ORIGINAL QUERY:**
${originalQuery}

**WEB SEARCH RESULTS:**
${toolOutput}

**YOUR COMPLETE, FORMATTED RESPONSE:**
`;
    }
    // --- **NEW SECTION FOR ACADEMIC SEARCH** ---
    else if (toolName === 'academic_search') {
        systemInstruction = `
You are an expert AI Academic Research Assistant. Your task is to synthesize the provided "ACADEMIC SEARCH RESULTS" into a comprehensive, detailed, and scholarly response to the user's query.

Your final response MUST follow this two-part structure precisely:
1.  A detailed, well-written answer to the user's query, synthesizing the key findings from the provided papers.
2.  **References Section:** A formatted list of the academic sources used.

---
**PART 1: MAIN ANSWER INSTRUCTIONS**
-   Your answer **MUST** be based on the provided academic paper summaries.
-   When you use information from a paper, you **MUST** include its corresponding number in brackets. For example: "Recent studies show that Model A outperforms Model B in specific tasks [1]." Cite multiple sources if needed: "[2, 3]".
-   Synthesize findings from multiple papers to provide a nuanced and well-rounded explanation. Compare and contrast where appropriate.
-   Maintain a formal, academic tone suitable for a research context.
-   Use rich Markdown formatting (headings, lists, bolding) for clarity.

---
**PART 2: REFERENCES SECTION INSTRUCTIONS**
-   After the main answer, add a horizontal rule (\`---\`).
-   Add a heading: \`## References\`.
-   Create a numbered list of all the sources you cited.
-   Format each reference like this: \`[1] [Paper Title](Paper URL) - *{Authors (e.g., Author A, Author B)}* ({Source e.g., ArXiv})\`.

---
**EXAMPLE OF COMPLETE OUTPUT:**
The primary approach for this problem involves using transformer-based architectures, which have shown state-of-the-art results in natural language understanding [1]. One study highlights the importance of pre-training on large, domain-specific corpora to improve performance [2]. However, another paper suggests that fine-tuning with a smaller, high-quality dataset can yield comparable results with less computational cost [3].

---
## References
[1] [Attention Is All You Need](http://export.arxiv.org/abs/1706.03762v7) - *Vaswani, A., et al.* (ArXiv)
[2] [BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding](https://www.semanticscholar.org/paper/1e78457223b375b6a48a313c0053d1005a76798c) - *Devlin, J., et al.* (Semantic Scholar)
[3] [Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer](http://export.arxiv.org/abs/1910.10683v3) - *Raffel, C., et al.* (ArXiv)

---
**Now, perform this task using the following information:**

**USER'S ORIGINAL QUERY:**
${originalQuery}

**ACADEMIC SEARCH RESULTS:**
${toolOutput}

**YOUR COMPLETE, FORMATTED RESPONSE:**
`;
    }

    return systemInstruction;
};



// ==============================================================================
// === CONTENT CREATION PROMPTS (PPTX, DOCX, PODCAST) ===
// ==============================================================================

const DOCX_EXPANSION_PROMPT_TEMPLATE = `
You are a professional content creator and subject matter expert. Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, multi-page document in Markdown format. You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge. The final output must be a single block of well-structured Markdown text.

**INSTRUCTIONS:**
1.  **Main Title:** Start the document with a main title using H1 syntax (e.g., '# Expanded Report on Key Topics').
2.  **Section per Outline Point:** For each point in the OUTLINE, create a detailed section with a clear H2 or H3 heading (e.g., '## Topic Name').
3.  **Content Expansion:** For each section, write detailed, professional paragraphs that elaborate on the outline point. Extract relevant facts, figures, and explanations from the SOURCE DOCUMENT TEXT.
4.  **Markdown Usage:** Use bullet points, bold text, and clear paragraphs to structure the content effectively.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a document):**
{outline_content}
---

**FINAL DOCUMENT MARKDOWN:**
`;

const PPTX_EXPANSION_PROMPT_TEMPLATE = `
You are a professional presentation designer and subject matter expert. Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, 6-8 slide presentation. You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge. Your output MUST be a single, valid JSON array, where each object represents a slide.

**JSON Object Schema for each slide:**
{{
  "slide_title": "A concise and engaging title for the slide.",
  "slide_content": "Detailed, professional paragraph(s) and/or bullet points elaborating on the outline point. This text will be displayed on the slide. Use Markdown for formatting (e.g., **bold**, *italics*, - bullet points).",
  "image_prompt": "A highly descriptive, creative prompt for an AI text-to-image model (like DALL-E or Midjourney) to generate a relevant and visually appealing image for this specific slide. Describe the style, subject, and composition. Example: 'A photorealistic image of a futuristic server room with glowing blue data streams flowing between racks, symbolizing data processing. Cinematic lighting.'"
}}

**INSTRUCTIONS:**
1.  **Analyze Outline & Source:** For each point in the OUTLINE, create at least one slide object in the JSON array.
2.  **Expand Content:** Elaborate on each outline point using only information from the SOURCE DOCUMENT TEXT.
3.  **Create Image Prompts:** For each slide, generate a unique and descriptive \`image_prompt\` that visually represents the slide's content.
4.  **JSON Format:** Ensure the final output is a single, clean JSON array with no other text before or after it.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a presentation):**
{outline_content}
---

**FINAL PRESENTATION JSON ARRAY:**
`;

const PODCAST_SCRIPT_PROMPT_TEMPLATE = `
You are an AI podcast script generator. Your SOLE task is to generate a realistic, two-speaker educational dialogue based on the provided text.

**CRITICAL INSTRUCTION:** Your entire output must be ONLY the script itself. Start directly with "SPEAKER_A:". Do NOT include any preamble, introduction, or metadata like "Here is the script:".

---
## Podcast Style Guide

- **Format**: Two-speaker conversational podcast.
- **SPEAKER_A**: The "Curious Learner". Asks clarifying questions and represents the student's perspective.
- **SPEAKER_B**: The "Expert Teacher". Provides clear explanations and examples based on the document text.
- **Dialogue Flow**: The conversation must be a natural back-and-forth. SPEAKER_A asks a question, SPEAKER_B answers, and SPEAKER_A follows up.
- **Content Source**: All explanations and facts provided by SPEAKER_B MUST come from the \`DOCUMENT TEXT\` provided below.

---
## Script Structure

### 1. Opening
The script must begin with a brief, engaging conversation to set the stage.
\`SPEAKER_A: Hey, I was just reading this document about {study_focus}, and I'm a bit stuck on a few things. Can we talk through it?\`
\`SPEAKER_B: Absolutely! I'd be happy to. What's on your mind?\`

### 2. Main Body
The main part of the script should be a question-and-answer dialogue driven by SPEAKER_A, focusing on the key points of the \`STUDY FOCUS\`. Use the \`DOCUMENT TEXT\` to formulate SPEAKER_B's expert answers.

### 3. Closing
Conclude the podcast with a quick summary and an encouraging sign-off.
\`SPEAKER_A: This makes so much more sense now. Thanks for clarifying everything!\`
\`SPEAKER_B: You're welcome! The key is to break it down. Keep up the great work!\`

---
## Source Material

**STUDY FOCUS (The main topic for the podcast):**
{study_focus}

**DOCUMENT TEXT (Use this for all factual answers):**
{document_content}

---
**FINAL SCRIPT OUTPUT (Remember: Start IMMEDIATELY with "SPEAKER_A:")**
`;


// ==============================================================================
// --- CODE ASSISTANT PROMPTS (for Code Executor Tool) ---
// ==============================================================================

const CODE_ANALYSIS_PROMPT_TEMPLATE = `
You are an expert software engineer and code reviewer. Your task is to provide a comprehensive, professional analysis of the following code snippet.

**Analysis Sections (Use Markdown headings for each):**
1.  **Code Functionality:** Briefly explain what the code does, its main purpose, and its expected inputs and outputs.
2.  **Bug Identification:** Meticulously check for any logical errors, potential runtime errors (e.g., division by zero, index out of bounds), or security vulnerabilities. If you find any, explain the bug clearly. If not, state that no obvious bugs were found.
3.  **Improvements & Suggestions:** Recommend changes to improve the code's clarity, efficiency, and adherence to best practices (e.g., better variable names, more efficient algorithms, error handling).

**Formatting:**
- Use clear Markdown for structure.
- For code suggestions, use fenced code blocks with the correct language identifier.

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
\`\`\`{language}
{code}
\`\`\`
---

**ANALYSIS REPORT:**
`;

const TEST_CASE_GENERATION_PROMPT_TEMPLATE = `
You are a meticulous Quality Assurance (QA) engineer. Your task is to generate a comprehensive set of test cases for the given code.

**Instructions:**
1.  Analyze the code to understand its logic, inputs, and outputs.
2.  Create a diverse set of test cases that cover:
    -   **Standard Cases:** Common, expected inputs.
    -   **Edge Cases:** Boundary values, empty inputs, zeros, negative numbers, etc.
    -   **Error Cases:** Invalid inputs that should cause the program to handle an error gracefully (if applicable).
3.  Your entire output **MUST** be a single, valid JSON array of objects.
4.  Each object in the array must have two keys: \`input\` (a string) and \`expectedOutput\` (a string).
5.  For inputs that require multiple lines, use the newline character \`\\n\`.

**Example Output Format:**
[
  { "input": "5\\n10", "expectedOutput": "15" },
  { "input": "0\\n0", "expectedOutput": "0" },
  { "input": "-5\\n5", "expectedOutput": "0" }
]

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
\`\`\`{language}
{code}
\`\`\`
---

**FINAL JSON TEST CASE ARRAY:**
`;



module.exports = {
  // Analysis
  ANALYSIS_PROMPTS,
  // KG
  KG_GENERATION_SYSTEM_PROMPT,
  KG_BATCH_USER_PROMPT_TEMPLATE,
  // Chat
  CHAT_MAIN_SYSTEM_PROMPT,
  WEB_SEARCH_CHAT_SYSTEM_PROMPT,
  CHAT_USER_PROMPT_TEMPLATES,
  // Agentic Framework
  createAgenticSystemPrompt,
  createSynthesizerPrompt,
  // Content Generation
  DOCX_EXPANSION_PROMPT_TEMPLATE,
  PPTX_EXPANSION_PROMPT_TEMPLATE,
  PODCAST_SCRIPT_PROMPT_TEMPLATE,
  // Code Assistant
  CODE_ANALYSIS_PROMPT_TEMPLATE,
  TEST_CASE_GENERATION_PROMPT_TEMPLATE,
};
```

`server/config/redisClient.js`

```javascript
// server/config/redisClient.js
const { createClient } = require('redis');
const
 
dotenv = require('dotenv');
dotenv.config();

const redisUrl = process.env.REDIS_URL;
if (!redisUrl) {
    console.warn("! REDIS_URL not found in .env, Redis caching will be disabled.");
}

const redisClient = redisUrl ? createClient({ url: redisUrl }) : null;

if (redisClient) {
    redisClient.on('error', (err) => console.error('Redis Client Error', err));
    redisClient.on('connect', () => console.log('✓ Redis client connected successfully.'));
    redisClient.on('reconnecting', () => console.log('Redis client is reconnecting...'));
}

// Function to connect the client
const connectRedis = async () => {
    if (redisClient && !redisClient.isOpen) {
        try {
            await redisClient.connect();
        } catch (err) {
            console.error('Failed to connect to Redis:', err);
        }
    }
};

module.exports = { redisClient, connectRedis };
```

`server/middleware/authMiddleware.js`

```javascript
// server/middleware/authMiddleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');
require('dotenv').config();

const authMiddleware = async (req, res, next) => {
    const authHeader = req.header('Authorization');

    if (!authHeader) {
        console.warn("Auth Middleware: No Authorization header found.");
        return res.status(401).json({ message: 'Not authorized, no token' });
    }

    const parts = authHeader.split(' ');

    if (parts.length !== 2 || parts[0] !== 'Bearer') {
        console.warn("Auth Middleware: Token format is 'Bearer <token>', received:", authHeader);
        return res.status(401).json({ message: 'Token format is invalid' });
    }

    const token = parts[1];

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.userId).select('-password');

        if (!user) {
            console.warn(`Auth Middleware: User not found for ID: ${decoded.userId} from token.`);
            return res.status(401).json({ message: 'User not found, token invalid' });
        }

        req.user = user;
        next();
    } catch (error) {
        console.warn("Auth Middleware: Token verification failed:", error.message);
        if (error.name === 'TokenExpiredError') {
            return res.status(401).json({ message: 'Token expired' });
        }
        if (error.name === 'JsonWebTokenError') {
            return res.status(401).json({ message: 'Token is not valid' });
        }
        res.status(401).json({ message: 'Not authorized, token verification failed' });
    }
};

module.exports = { authMiddleware }; // ONLY export this
```

`server/middleware/cacheMiddleware.js`

```javascript
// server/middleware/cacheMiddleware.js
const { redisClient } = require('../config/redisClient');

const cacheMiddleware = (durationInSeconds) => async (req, res, next) => {
    if (!redisClient || !redisClient.isOpen || req.method !== 'GET') {
        return next();
    }

    const key = `__express__${req.originalUrl || req.url}`;
    try {
        const cachedResponse = await redisClient.get(key);
        if (cachedResponse) {
            res.setHeader('X-Cache', 'HIT');
            res.send(JSON.parse(cachedResponse));
            return;
        }

        res.setHeader('X-Cache', 'MISS');
        const originalSend = res.send;

        res.send = (body) => {
            // Only cache successful 2xx responses
            if (res.statusCode >= 200 && res.statusCode < 300) {
                redisClient.setEx(key, durationInSeconds, JSON.stringify(body)).catch(err => {
                    console.error(`Redis SETEX error for key ${key}:`, err);
                });
            }
            return originalSend.call(res, body);
        };
        next();
    } catch (err) {
        console.error('Redis cache middleware error:', err);
        next();
    }
};

module.exports = { cacheMiddleware };
```

`server/middleware/fixedAdminAuthMiddleware.js`

```javascript
// server/middleware/fixedAdminAuthMiddleware.js
require('dotenv').config({ path: require('path').resolve(__dirname, '..', '.env') }); // Ensure .env from server directory is loaded

const ADMIN_USERNAME = process.env.FIXED_ADMIN_USERNAME || 'admin';
const ADMIN_PASSWORD = process.env.FIXED_ADMIN_PASSWORD || 'admin123';

const fixedAdminAuthMiddleware = (req, res, next) => {
    const authHeader = req.headers.authorization;

    if (!ADMIN_USERNAME || !ADMIN_PASSWORD) {
        console.error("FATAL: FIXED_ADMIN_USERNAME or FIXED_ADMIN_PASSWORD not set in environment for admin auth.");
        // Do not send WWW-Authenticate here as it's a server config issue
        return res.status(500).json({ message: "Admin authentication system not configured properly." });
    }

    if (!authHeader || !authHeader.toLowerCase().startsWith('basic ')) {
        // Prompt for Basic Authentication
        res.setHeader('WWW-Authenticate', 'Basic realm="Admin Document Area"');
        return res.status(401).json({ message: 'Admin authentication required (Basic Auth).' });
    }

    const encodedCreds = authHeader.substring(6); // Length of "Basic "
    let decodedCreds;
    try {
        decodedCreds = Buffer.from(encodedCreds, 'base64').toString('utf8');
    } catch (e) {
        console.warn("Admin Auth: Invalid Base64 encoding in Basic Auth header.");
        res.setHeader('WWW-Authenticate', 'Basic realm="Admin Document Area"'); // Re-prompt
        return res.status(400).json({ message: 'Invalid Basic Auth encoding format.' });
    }

    const [username, password] = decodedCreds.split(':', 2); // Split into max 2 parts

    if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
        // Attach a simple admin context to the request object
        // This isn't a full user object from DB, just an indicator
        req.adminUser = { 
            username: ADMIN_USERNAME, 
            id: "fixed_admin_id_marker" // A placeholder ID
        }; 
        return next(); // Authentication successful, proceed to the route handler
    }

    // Authentication failed
    console.warn(`Admin Auth Failed: Incorrect credentials received. Username: ${username}`);
    res.setHeader('WWW-Authenticate', 'Basic realm="Admin Document Area"'); // Re-prompt
    return res.status(401).json({ message: 'Invalid admin credentials.' });
};

module.exports = { fixedAdminAuthMiddleware };
```

`server/models/AdminDocument.js`

```javascript
// server/models/AdminDocument.js
const mongoose = require('mongoose');

const AdminDocumentSchema = new mongoose.Schema({
  filename: { // Server-generated unique filename (e.g., timestamp-originalname.ext)
    type: String,
    required: true,
    unique: true,
  },
  originalName: { // The original name of the file uploaded by the admin
    type: String,
    required: true,
  },
  text: { // Extracted text content from the document, ready for analysis input
    type: String,
    default: "",
  },
  analysis: {
    faq: { // Stores the full string output (including <thinking>) for FAQ generation
      type: String,
      default: "",
    },
    topics: { // Stores the full string output for Key Topics generation
      type: String,
      default: "",
    },
    mindmap: { // Stores the full string output for Mind Map generation
      type: String,
      default: "",
    },
  },
  uploadedAt: { // Timestamp of when the document record was created/file uploaded
    type: Date,
    default: Date.now,
  },
  // Optional: Add a timestamp for when analysis was last updated
  analysisUpdatedAt: {
    type: Date,
  }
});

// Index for frequently queried fields if necessary, e.g., originalName
AdminDocumentSchema.index({ originalName: 1 });

const AdminDocument = mongoose.model('AdminDocument', AdminDocumentSchema);

module.exports = AdminDocument;
```

`server/models/ChatHistory.js`

```javascript
// server/models/ChatHistory.js
const mongoose = require('mongoose');
const { v4: uuidv4 } = require('uuid');

const MessageSchema = new mongoose.Schema({
    role: { type: String, enum: ['user', 'model'], required: true },
    parts: [{ text: { type: String, required: true } }],
    timestamp: { type: Date, default: Date.now },
    thinking: { type: String, default: '' },
    references: { type: Array, default: [] },
    source_pipeline: { type: String, default: '' }
}, { _id: false });

const ChatHistorySchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true,
    },
    sessionId: {
        type: String,
        required: true,
        unique: true,
        index: true,
    },
    messages: [MessageSchema],
    summary: {
        type: String,
        default: ''
    },
    createdAt: {
        type: Date,
        default: Date.now,
    },
    updatedAt: {
        type: Date,
        default: Date.now,
    }
});

ChatHistorySchema.pre('save', function (next) {
    if (this.isModified()) {
      this.updatedAt = Date.now();
    }
    next();
});

ChatHistorySchema.pre('findOneAndUpdate', function(next) {
  this.set({ updatedAt: new Date() });
  next();
});

const ChatHistory = mongoose.model('ChatHistory', ChatHistorySchema);
module.exports = ChatHistory;
```

`server/models/User.js`

```javascript
// server/models/User.js
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const { encrypt } = require("../utils/crypto");

const ProfileSchema = new mongoose.Schema(
  {
    name: { type: String, default: "", trim: true },
    college: { type: String, default: "", trim: true },
    universityNumber: { type: String, default: "", trim: true },
    degreeType: { type: String, default: "", trim: true },
    branch: { type: String, default: "", trim: true },
    year: { type: String, default: "", trim: true },
  },
  { _id: false }
);

const UserSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, "Please provide an email"],
    unique: true,
    trim: true,
    lowercase: true,
    match: [
      /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
      "Please provide a valid email address",
    ],
  },
  username: {
    type: String,
    required: [true, "A unique username is required"],
    unique: true,
    trim: true,
  },
  password: {
    type: String,
    required: [true, "Please provide a password"],
    minlength: 6,
    select: false,
  },
  profile: {
    type: ProfileSchema,
    default: () => ({}),
  },
  apiKeyRequestStatus: {
    type: String,
    enum: ["none", "pending", "approved", "rejected"],
    default: "none",
  },
  encryptedApiKey: {
    type: String,
    select: false,
  },
  preferredLlmProvider: {
    type: String,
    enum: ["gemini", "ollama"],
    default: "gemini",
  },
  ollamaUrl: {
    type: String,
    trim: true,
    default: "",
  },
  ollamaModel: {
    type: String,
    default: process.env.OLLAMA_DEFAULT_MODEL || "llama3",
  },
  uploadedDocuments: [
    {
      filename: { type: String },
      text: { type: String, default: "" },
      analysis: {
        faq: { type: String, default: "" },
        topics: { type: String, default: "" },
        mindmap: { type: String, default: "" },
      },
      ragStatus: { type: String, default: "pending" },
      analysisStatus: { type: String, default: "pending" },
      analysisTimestamp: { type: Date },
      kgStatus: { type: String, default: "pending" },
      kgNodesCount: { type: Number, default: 0 },
      kgEdgesCount: { type: Number, default: 0 },
      kgTimestamp: { type: Date },
      uploadedAt: { type: Date, default: Date.now },
    },
  ],
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

UserSchema.pre("save", async function (next) {
  if (this.isModified("password")) {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
  }
  if (this.isModified("encryptedApiKey") && this.encryptedApiKey) {
    try {
      this.encryptedApiKey = encrypt(this.encryptedApiKey);
    } catch (encError) {
      console.error("Error encrypting API key during user save:", encError);
      return next(new Error("Failed to encrypt API key."));
    }
  } else if (this.isModified("encryptedApiKey") && !this.encryptedApiKey) {
    this.encryptedApiKey = null;
  }
  next();
});

UserSchema.methods.comparePassword = async function (candidatePassword) {
  if (!this.password) return false;
  return await bcrypt.compare(candidatePassword, this.password);
};

UserSchema.statics.findByCredentials = async function (email, password) {
  const user = await this.findOne({ email }).select("+password");
  if (!user) {
    return null;
  }
  const isMatch = await user.comparePassword(password);
  if (!isMatch) {
    return null;
  }
  return user;
};

const User = mongoose.model("User", UserSchema);
module.exports = User;

```

`server/protocols/contextProtocols.js`

```javascript
// server/protocols/contextProtocols.js

const createModelContext = ({ availableTools, currentMode = 'chat' }) => ({
  current_mode: currentMode,
  available_tools: Object.entries(availableTools).map(([name, details]) => ({
    name,
    description: details.description,
    parameters: details.requiredParams,
  })),
});

const createAgenticContext = ({ systemPrompt }) => ({
  agent_role: "AI Engineering Tutor",
  agent_objectives: ["Provide accurate, clear, and helpful answers.", "Intelligently use available tools to fulfill user requests."],
  long_term_goals: ["Help the user learn and solve complex engineering problems."],
  constraints: ["Base answers on provided context when available.", "Do not hallucinate facts.", "Adhere to safety guidelines."],
  base_instructions: systemPrompt,
});

const createThreadContext = ({ sessionId, userId, history }) => ({
  thread_id: sessionId,
  user_id: userId,
  prior_interactions_summary: null,
});

module.exports = {
    createModelContext,
    createAgenticContext,
    createThreadContext,
};
```

`server/rag_service/academic_search.py`

```python
# server/rag_service/academic_search.py
import requests
import xml.etree.ElementTree as ET
import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

def search_arxiv(query: str, max_results: int = 3) -> List[Dict[str, Any]]:
    """Searches the ArXiv API for papers."""
    base_url = 'http://export.arxiv.org/api/query?'
    search_query = f'search_query=all:{query}&start=0&max_results={max_results}&sortBy=relevance'
    
    logger.info(f"Querying ArXiv with: {query}")
    response = requests.get(base_url + search_query, timeout=10)
    response.raise_for_status()
    
    root = ET.fromstring(response.content)
    papers = []
    for entry in root.findall('{http://www.w3.org/2005/Atom}entry'):
        paper = {
            'source': 'ArXiv',
            'title': entry.find('{http://www.w3.org/2005/Atom}title').text.strip(),
            'url': entry.find('{http://www.w3.org/2005/Atom}id').text.strip(),
            'summary': entry.find('{http://www.w3.org/2005/Atom}summary').text.strip(),
            'authors': [author.find('{http://www.w3.org/2005/Atom}name').text for author in entry.findall('{http://www.w3.org/2005/Atom}author')]
        }
        papers.append(paper)
    return papers

def search_semantic_scholar(query: str, max_results: int = 3) -> List[Dict[str, Any]]:
    """Searches the Semantic Scholar API."""
    base_url = 'https://api.semanticscholar.org/graph/v1/paper/search'
    params = {'query': query, 'limit': max_results, 'fields': 'title,url,abstract,authors'}
    
    logger.info(f"Querying Semantic Scholar with: {query}")
    response = requests.get(base_url, params=params, timeout=10)
    response.raise_for_status()
    
    data = response.json()
    papers = []
    if 'data' in data:
        for item in data['data']:
            paper = {
                'source': 'Semantic Scholar',
                'title': item.get('title'),
                'url': item.get('url'),
                'summary': item.get('abstract'),
                'authors': [author['name'] for author in item.get('authors', []) if 'name' in author]
            }
            papers.append(paper)
    return papers

def search_all_apis(query: str, max_results_per_api: int = 3) -> List[Dict[str, Any]]:
    """Searches all configured academic APIs and aggregates results."""
    all_results = []
    
    api_functions = {
        'ArXiv': search_arxiv,
        'Semantic Scholar': search_semantic_scholar
    }
    
    for api_name, search_func in api_functions.items():
        try:
            results = search_func(query, max_results=max_results_per_api)
            all_results.extend(results)
            logger.info(f"Found {len(results)} results from {api_name}.")
        except Exception as e:
            logger.warning(f"Could not retrieve results from {api_name}: {e}")
            
    # Simple de-duplication based on title to avoid showing the same paper from two sources
    unique_results = {paper['title'].lower(): paper for paper in all_results if paper.get('title')}.values()
    
    return list(unique_results)
```

`server/rag_service/ai_core.py`

```python
# ./ai_core.py

# Standard Library Imports
import logging
import os
import io
import re
import copy
import uuid
from typing import Any, Callable, Dict, List, Optional, Union
from datetime import datetime # For improved date parsing in metadata

# --- Global Initializations ---
logger = logging.getLogger(__name__)

# --- Configuration Import ---
try:
    import config # This should import server/config.py
except ImportError as e:
    logger.critical(f"CRITICAL: Failed to import 'config' (expected server/config.py): {e}. ")
    # Depending on how critical config is, you might want to sys.exit(1)
    # For now, we'll let it proceed and other parts will fail if config isn't loaded.


# Local aliases for config flags, models, constants, and classes from config.py
# Ensure all these are actually defined in your config.py
PYPDF_AVAILABLE = getattr(config, 'PYPDF_AVAILABLE', False)
PDFPLUMBER_AVAILABLE = getattr(config, 'PDFPLUMBER_AVAILABLE', False)
PANDAS_AVAILABLE = getattr(config, 'PANDAS_AVAILABLE', False)
DOCX_AVAILABLE = getattr(config, 'DOCX_AVAILABLE', False)
PPTX_AVAILABLE = getattr(config, 'PPTX_AVAILABLE', False)
PIL_AVAILABLE = getattr(config, 'PIL_AVAILABLE', False)
FITZ_AVAILABLE = getattr(config, 'FITZ_AVAILABLE', False)
PYTESSERACT_AVAILABLE = getattr(config, 'PYTESSERACT_AVAILABLE', False)
SPACY_MODEL_LOADED = getattr(config, 'SPACY_MODEL_LOADED', False)
PYPDF2_AVAILABLE = getattr(config, 'PYPDF2_AVAILABLE', False)
EMBEDDING_MODEL_LOADED = getattr(config, 'EMBEDDING_MODEL_LOADED', False)
MAX_TEXT_LENGTH_FOR_NER  = getattr(config, 'MAX_TEXT_LENGTH_FOR_NER', 500000)
LANGCHAIN_SPLITTER_AVAILABLE = getattr(config, 'LANGCHAIN_SPLITTER_AVAILABLE', False)

PYPDF_PDFREADERROR = getattr(config, 'PYPDF_PDFREADERROR', Exception)
TESSERACT_ERROR = getattr(config, 'TESSERACT_ERROR', Exception)

# Libraries and Models (ensure these are None if not available to prevent AttributeError)
pypdf = getattr(config, 'pypdf', None)
PyPDF2 = getattr(config, 'PyPDF2', None)
pdfplumber = getattr(config, 'pdfplumber', None)
pd = getattr(config, 'pd', None)
DocxDocument = getattr(config, 'DocxDocument', None)
Presentation = getattr(config, 'Presentation', None)
Image = getattr(config, 'Image', None)
fitz = getattr(config, 'fitz', None)
pytesseract = getattr(config, 'pytesseract', None)
nlp_spacy_core = getattr(config, 'nlp_spacy_core', None)
document_embedding_model = getattr(config, 'document_embedding_model', None)
RecursiveCharacterTextSplitter = getattr(config, 'RecursiveCharacterTextSplitter', None)

# Constants
AI_CORE_CHUNK_SIZE = getattr(config, 'AI_CORE_CHUNK_SIZE', 1024) # Default if not in config
AI_CORE_CHUNK_OVERLAP = getattr(config, 'AI_CORE_CHUNK_OVERLAP', 200) # Default if not in config
DOCUMENT_EMBEDDING_MODEL_NAME = getattr(config, 'DOCUMENT_EMBEDDING_MODEL_NAME', "unknown_model")


# ==============================================================================
# Phase 2: Unified Rich Element Extraction Layer
# ==============================================================================

# Standard Output Structure for Element Extractors
# {
#     'text_content': Optional[str],
#     'tables': List[Union[pd.DataFrame, List[List[str]]]],
#     'images': List[Image.Image],
#     'parser_metadata': Dict[str, Any],
#     'is_scanned_heuristic': bool
# }

def _make_empty_extraction_result() -> Dict[str, Any]:
    """Helper to create a default empty result structure."""
    return {
        'text_content': None,
        'tables': [],
        'images': [],
        'parser_metadata': {},
        'is_scanned_heuristic': False
    }

def _extract_pdf_elements(file_path: str) -> Dict[str, Any]:
    if not os.path.exists(file_path):
        logger.error(f"PDF file not found: {file_path}")
        return _make_empty_extraction_result()

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    extracted_text_parts = []

    # 1. Text and Table Extraction with pdfplumber (if available)
    if PDFPLUMBER_AVAILABLE and pdfplumber:
        try:
            with pdfplumber.open(file_path) as pdf:
                num_pages_plumber = len(pdf.pages)
                for i, page in enumerate(pdf.pages):
                    page_text = page.extract_text(x_tolerance=1, y_tolerance=1.5, layout=False) # layout=False for more raw text
                    if page_text and page_text.strip():
                        extracted_text_parts.append(page_text.strip())

                    # Extract tables
                    page_tables_data = page.extract_tables()
                    if page_tables_data:
                        for table_data_list in page_tables_data:
                            if not table_data_list: continue
                            if PANDAS_AVAILABLE and pd:
                                try:
                                    # Attempt to use first row as header if meaningful
                                    if len(table_data_list) > 1 and all(c is not None and isinstance(c, str) for c in table_data_list[0]):
                                        df = pd.DataFrame(table_data_list[1:], columns=table_data_list[0])
                                    else:
                                        df = pd.DataFrame(table_data_list)
                                    result['tables'].append(df)
                                except Exception as df_err:
                                    logger.warning(f"pdfplumber: DataFrame conversion error for table on page {i+1} of {file_base_name}: {df_err}. Storing as list.")
                                    result['tables'].append(table_data_list)
                            else:
                                result['tables'].append(table_data_list)
                
                result['text_content'] = "\n\n".join(extracted_text_parts).strip() or None
                if result['tables']: logger.info(f"pdfplumber: Extracted {len(result['tables'])} tables from {file_base_name}.")

                # Scanned PDF Heuristic (based on pdfplumber text)
                if num_pages_plumber > 0:
                    total_chars = sum(len(pt.replace(" ", "")) for pt in extracted_text_parts)
                    avg_chars_per_page = total_chars / num_pages_plumber
                    # Heuristic: low average characters per page suggests scanned
                    if avg_chars_per_page < 20 and total_chars < (num_pages_plumber * 50): # Tunable thresholds
                        result['is_scanned_heuristic'] = True
                        logger.info(f"PDF {file_base_name} potentially scanned (low avg text [{avg_chars_per_page:.1f} chars/page] from pdfplumber).")

        except Exception as e_plumber:
            logger.warning(f"pdfplumber: Error processing PDF {file_base_name}: {e_plumber}", exc_info=True)
            # If pdfplumber fails, pypdf (now pypdf) can be a fallback for basic text
            if PYPDF_AVAILABLE and pypdf and not result['text_content']:
                logger.info(f"Attempting pypdf fallback for text extraction from {file_base_name}")
                try:
                    reader = pypdf.PdfReader(file_path)
                    pypdf_text_parts = []
                    for page in reader.pages:
                        page_text = page.extract_text()
                        if page_text and page_text.strip():
                            pypdf_text_parts.append(page_text.strip())
                    result['text_content'] = "\n\n".join(pypdf_text_parts).strip() or None
                except Exception as e_pypdf:
                    logger.warning(f"pypdf fallback also failed for {file_base_name}: {e_pypdf}")


    # 2. Image Extraction with Fitz (PyMuPDF)
    if FITZ_AVAILABLE and fitz and PIL_AVAILABLE and Image:
        try:
            doc_fitz = fitz.open(file_path)
            if not result['is_scanned_heuristic'] and not result['text_content'] and len(doc_fitz) > 0:
                # If no text from plumber/pypdf, but fitz finds pages, highly likely scanned.
                result['is_scanned_heuristic'] = True
                logger.info(f"PDF {file_base_name} likely scanned (no text extracted, but pages found by fitz).")

            for page_idx in range(len(doc_fitz)):
                for img_info_tuple in doc_fitz.get_page_images(page_idx):
                    xref = img_info_tuple[0]
                    try:
                        img_bytes_dict = doc_fitz.extract_image(xref)
                        if img_bytes_dict and "image" in img_bytes_dict:
                             result['images'].append(Image.open(io.BytesIO(img_bytes_dict["image"])))
                    except Exception as img_err:
                        logger.warning(f"fitz: Could not extract/open image xref {xref} from page {page_idx} of {file_base_name}: {img_err}")
            if result['images']: logger.info(f"fitz: Extracted {len(result['images'])} images from {file_base_name}.")
            doc_fitz.close()
        except Exception as e_fitz:
            logger.warning(f"fitz: Error processing PDF {file_base_name} for images: {e_fitz}", exc_info=True)

    # 3. Metadata with PyPDF2 (or pypdf if PyPDF2 not available/fails)
    metadata_extractor = None
    if PYPDF2_AVAILABLE and PyPDF2:
        metadata_extractor = PyPDF2.PdfReader
        extractor_name = "PyPDF2"
    elif PYPDF_AVAILABLE and pypdf: # Fallback to pypdf for metadata
        metadata_extractor = pypdf.PdfReader
        extractor_name = "pypdf"

    if metadata_extractor:
        try:
            with open(file_path, 'rb') as f:
                reader = metadata_extractor(f)
                info = reader.metadata
                if info:
                    if hasattr(info, 'title') and info.title: result['parser_metadata']['title'] = str(info.title).strip()
                    if hasattr(info, 'author') and info.author: result['parser_metadata']['author'] = str(info.author).strip()
                    
                    pdf_date_formats = [
                        "D:%Y%m%d%H%M%S%z",    
                        "D:%Y%m%d%H%M%S",
                        "D:%Y%m%d%H%M%SZ",
                        "%Y%m%d%H%M%S%z",
                        "%Y%m%d%H%M%S",
                        "%Y%m%d%H%M%SZ",
                    ]
                    def parse_pdf_date(date_val_str_or_dt):
                        if isinstance(date_val_str_or_dt, datetime): return date_val_str_or_dt
                        if not isinstance(date_val_str_or_dt, str): return None
                        clean_date_str = date_val_str_or_dt.strip().rstrip("'")
                        for fmt in pdf_date_formats:
                            try: return datetime.strptime(clean_date_str, fmt)
                            except ValueError: continue
                        return None
                    

                    raw_creation_date = info.get("/CreationDate") if isinstance(info, dict) else getattr(info, 'creation_date', None)
                    creation_date_obj = parse_pdf_date(raw_creation_date)

                    if creation_date_obj: result['parser_metadata']['creation_date'] = creation_date_obj.isoformat()
                    
                    raw_mod_date = info.get("/ModDate") if isinstance(info, dict) else getattr(info, 'modification_date', None)
                    modification_date_obj = parse_pdf_date(raw_mod_date)
                    
                    if modification_date_obj: result['parser_metadata']['modification_date'] = modification_date_obj.isoformat()

                result['parser_metadata']['page_count'] = len(reader.pages)
        except Exception as e_meta:
            logger.warning(f"Metadata: Error using {extractor_name} for {file_base_name}: {e_meta}", exc_info=True)
            if 'page_count' not in result['parser_metadata'] and FITZ_AVAILABLE and fitz: # Fallback page count
                try:
                    doc_fitz_pc = fitz.open(file_path)
                    result['parser_metadata']['page_count'] = len(doc_fitz_pc)
                    doc_fitz_pc.close()
                except: pass


    return result

def _extract_docx_elements(file_path: str) -> Dict[str, Any]:
    if not (DOCX_AVAILABLE and DocxDocument and PIL_AVAILABLE and Image):
        logger.error("python-docx or Pillow not available. DOCX parsing will be limited.")
        return _make_empty_extraction_result()
    
    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    text_content_parts = []

    try:
        doc = DocxDocument(file_path)
        # Text
        for para in doc.paragraphs:
            if para.text.strip():
                text_content_parts.append(para.text.strip())
        result['text_content'] = "\n".join(text_content_parts).strip() or None

        # Tables
        for i, table in enumerate(doc.tables):
            table_list = [[cell.text.strip() for cell in row.cells] for row in table.rows]
            if not table_list: continue
            if PANDAS_AVAILABLE and pd:
                try:
                    if len(table_list) > 1 and all(c for c in table_list[0]): # Use first row as header
                        result['tables'].append(pd.DataFrame(table_list[1:], columns=table_list[0]))
                    else:
                        result['tables'].append(pd.DataFrame(table_list))
                except Exception as df_err:
                    logger.warning(f"docx: DataFrame conversion error for table {i} in {file_base_name}: {df_err}. Storing as list.")
                    result['tables'].append(table_list)
            else:
                result['tables'].append(table_list)
        if result['tables']: logger.info(f"docx: Extracted {len(result['tables'])} tables from {file_base_name}.")

        # Images (Inline shapes)
        for rel_id, image_part in doc.part.image_parts:
             try:
                 img = Image.open(io.BytesIO(image_part.blob))
                 result['images'].append(img)
             except Exception as e_img:
                 logger.warning(f"docx: Error processing an image from {file_base_name}: {e_img}")
        # A more thorough way for inline_shapes if doc.part.image_parts is not sufficient:
        # for shape in doc.inline_shapes:
        #    if shape.type == MSO_SHAPE_TYPE.PICTURE: # Requires from docx.enum.shape import MSO_SHAPE_TYPE
        #        try:
        #            image_part = doc.part.related_parts[shape._inline.graphic.graphicData.pic.blipFill.blip.embed]
        #            img = Image.open(io.BytesIO(image_part.blob))
        #            result['images'].append(img)
        #        except Exception: pass # ignore if not an image or error
        if result['images']: logger.info(f"docx: Extracted {len(result['images'])} images from {file_base_name}.")


        # Metadata
        props = doc.core_properties
        if props.title: result['parser_metadata']['title'] = props.title
        if props.author: result['parser_metadata']['author'] = props.author
        if props.created: result['parser_metadata']['creation_date'] = props.created.isoformat()
        if props.modified: result['parser_metadata']['modification_date'] = props.modified.isoformat()
        result['parser_metadata']['page_count'] = len(doc.paragraphs) // 20 or 1 # Rough estimate

        # Scanned Heuristic
        if not result['text_content'] and result['images']:
            result['is_scanned_heuristic'] = True
            logger.info(f"DOCX {file_base_name} potentially image-based (no text, images present).")

    except FileNotFoundError:
        logger.error(f"docx: File not found: {file_path}")
    except Exception as e:
        logger.error(f"docx: Error parsing DOCX {file_base_name}: {e}", exc_info=True)
    
    return result

def _extract_pptx_elements(file_path: str) -> Dict[str, Any]:
    if not (PPTX_AVAILABLE and Presentation and PIL_AVAILABLE and Image):
        logger.error("python-pptx or Pillow not available. PPTX parsing will be limited.")
        return _make_empty_extraction_result()

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    text_content_parts = []

    try:
        prs = Presentation(file_path)
        for slide_idx, slide in enumerate(prs.slides):
            slide_texts = []
            for shape in slide.shapes:
                if hasattr(shape, "text_frame") and shape.text_frame and shape.text_frame.text.strip():
                    slide_texts.append(shape.text_frame.text.strip())
                elif hasattr(shape, "text") and shape.text.strip(): # For shapes with direct text
                    slide_texts.append(shape.text.strip())
                
                # Image extraction
                if hasattr(shape, "image"): # If shape is an image
                    try:
                        image_bytes = shape.image.blob
                        img = Image.open(io.BytesIO(image_bytes))
                        result['images'].append(img)
                    except Exception as e_img_shape:
                        logger.warning(f"pptx: Error extracting image from shape on slide {slide_idx} of {file_base_name}: {e_img_shape}")
            
            if slide_texts:
                text_content_parts.append("\n".join(slide_texts))
        
        result['text_content'] = "\n\n".join(text_content_parts).strip() or None
        if result['images']: logger.info(f"pptx: Extracted {len(result['images'])} images from {file_base_name}.")

        # Metadata
        props = prs.core_properties
        if props.title: result['parser_metadata']['title'] = props.title
        if props.author: result['parser_metadata']['author'] = props.author
        if props.created: result['parser_metadata']['creation_date'] = props.created.isoformat()
        if props.last_modified_by : result['parser_metadata']['last_modified_by'] = props.last_modified_by
        if props.modified : result['parser_metadata']['modification_date'] = props.modified.isoformat()

        result['parser_metadata']['page_count'] = len(prs.slides)

        # Scanned Heuristic
        if not result['text_content'] and result['images']:
            result['is_scanned_heuristic'] = True
            logger.info(f"PPTX {file_base_name} potentially image-based (no text, images present).")

    except FileNotFoundError:
        logger.error(f"pptx: File not found: {file_path}")
    except Exception as e:
        logger.error(f"pptx: Error parsing PPTX {file_base_name}: {e}", exc_info=True)

    return result

def _extract_csv_elements(file_path: str) -> Dict[str, Any]:
    if not (PANDAS_AVAILABLE and pd):
        logger.error("pandas not available. CSV parsing will be limited.")
        return _extract_generic_text_elements(file_path, ".csv") # Fallback to text

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    try:
        df = pd.read_csv(file_path)
        result['tables'].append(df)
        # Create a text representation of the CSV for text_content
        # Could be markdown, simple string, or first N rows.
        # Using to_string() for now. Consider to_markdown() for better structure if text will be LLM input.
        result['text_content'] = df.to_string(index=False, na_rep='NULL').strip() or None
        logger.info(f"csv: Extracted 1 table (shape: {df.shape}) from {file_base_name}.")
    except FileNotFoundError:
        logger.error(f"csv: File not found: {file_path}")
    except Exception as e:
        logger.error(f"csv: Error parsing CSV {file_base_name}: {e}", exc_info=True)
        # Fallback to generic text if pandas fails
        return _extract_generic_text_elements(file_path, ".csv")
    return result


def _extract_generic_text_elements(file_path: str, file_type_ext: str) -> Dict[str, Any]:
    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            text = f.read()
        result['text_content'] = text.strip() or None
        
        # For HTML/XML, optionally strip tags (basic)
        if file_type_ext in ['.html', '.xml'] and result['text_content']:
            stripped_text = re.sub(r'<[^>]+>', ' ', result['text_content'])
            result['text_content'] = re.sub(r'\s+', ' ', stripped_text).strip() or None

    except FileNotFoundError:
        logger.error(f"txt-like: File not found: {file_path}")
    except Exception as e:
        logger.error(f"txt-like: Error parsing {file_base_name}: {e}", exc_info=True)
    return result

def _extract_image_file_elements(file_path: str) -> Dict[str, Any]:
    if not (PIL_AVAILABLE and Image):
        logger.error("Pillow (PIL) not available. Image file parsing will fail.")
        return _make_empty_extraction_result()

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    try:
        img = Image.open(file_path)
        result['images'].append(img)
        result['is_scanned_heuristic'] = True # By definition, an image file is "scanned" for OCR
        logger.info(f"Image file {file_base_name} opened.")
    except FileNotFoundError:
        logger.error(f"image-file: File not found: {file_path}")
    except Exception as e:
        logger.error(f"image-file: Error opening {file_base_name}: {e}", exc_info=True)
    return result


def _get_rich_extraction_results(file_path: str) -> Dict[str, Any]:
    """Dispatcher for rich element extraction based on file type."""
    ext = os.path.splitext(file_path)[1].lower()
    logger.info(f"Rich extraction: Dispatching for file type '{ext}' ({os.path.basename(file_path)})")

    if ext == '.pdf':
        return _extract_pdf_elements(file_path)
    elif ext == '.docx':
        return _extract_docx_elements(file_path)
    elif ext == '.pptx':
        return _extract_pptx_elements(file_path)
    elif ext == '.csv':
        return _extract_csv_elements(file_path)
    elif ext in ['.txt', '.py', '.js', '.md', '.log', '.html', '.xml', '.json']:
        return _extract_generic_text_elements(file_path, ext)
    elif ext in ['.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.gif']:
        return _extract_image_file_elements(file_path)
    else:
        logger.warning(f"Unsupported file extension for rich extraction: {ext} ({os.path.basename(file_path)}). Attempting generic text.")
        return _extract_generic_text_elements(file_path, ext) # Fallback for unknown types


# ==============================================================================
# Phase 3: Streamlined Main Processing Pipeline
# ==============================================================================

def _get_initial_parsed_document(file_path: str) -> Dict[str, Any]:
    """Calls the appropriate rich element extractor for the file."""
    return _get_rich_extraction_results(file_path)


# --- Stages 2-7 (OCR, Cleaning, Layout, Metadata, Chunking, Embedding) ---
# These functions are largely the same as your corrected versions, but will now consume
# the structured output from _get_initial_parsed_document.

def perform_ocr_on_images(image_objects: List[Any], file_base_name_for_log: str ="") -> str: # Added filename for logging
    if not image_objects: return ""
    if not (PYTESSERACT_AVAILABLE and pytesseract):
        logger.error(f"Pytesseract not available. OCR for {file_base_name_for_log} cannot be performed.")
        return ""

    logger.info(f"Performing OCR on {len(image_objects)} image(s) for {file_base_name_for_log}.")
    ocr_text_parts = []
    images_ocrd = 0
    for i, img_obj in enumerate(image_objects):
        try:
            if not (PIL_AVAILABLE and Image and isinstance(img_obj, Image.Image)):
                logger.warning(f"Skipping non-PIL Image object at index {i} for OCR of {file_base_name_for_log}.")
                continue
            # Improve image for OCR: convert to grayscale, potentially apply thresholding if needed
            processed_img_for_ocr = img_obj.convert('L') # Grayscale
            text = pytesseract.image_to_string(processed_img_for_ocr)
            if text and text.strip():
                ocr_text_parts.append(text.strip())
                images_ocrd += 1
        except Exception as e:
            if TESSERACT_ERROR and isinstance(e, TESSERACT_ERROR): # Check specific Tesseract error
                logger.critical(f"Tesseract executable not found or error for {file_base_name_for_log}. OCR will fail. Error: {e}")
                # Re-raise if it's a critical setup issue that will affect all subsequent OCR
                # For now, we'll let it try other images, but this indicates a setup problem.
            logger.error(f"Error during OCR for image {i+1}/{len(image_objects)} of {file_base_name_for_log}: {e}", exc_info=True)
    
    full_ocr_text = "\n\n--- OCR Text from Image ---\n\n".join(ocr_text_parts).strip()
    logger.info(f"OCR for {file_base_name_for_log}: Extracted {len(full_ocr_text)} chars from {images_ocrd} image(s).")
    return full_ocr_text


def clean_and_normalize_text_content(text: str, file_base_name_for_log: str ="") -> str:
    if not text or not text.strip(): return ""
    logger.info(f"Text cleaning for {file_base_name_for_log}: Initial length {len(text)}")
    
    # Basic regex cleaning (order matters)
    text = re.sub(r'<script[^>]*>.*?</script>|<style[^>]*>.*?</style>', ' ', text, flags=re.I | re.S) # Remove script/style
    text = re.sub(r'<[^>]+>', ' ', text) # Remove all other HTML tags
    text = re.sub(r'http\S+|www\S+|https\S+', '', text, flags=re.MULTILINE) # Remove URLs
    text = re.sub(r'\S*@\S*\s?', '', text, flags=re.MULTILINE) # Remove emails
    text = re.sub(r'\s*&\w+;\s*', ' ', text) # Remove HTML entities like  
    text = re.sub(r'[\n\r\t]+', ' ', text) # Normalize whitespace (newlines, tabs to single space)
    text = re.sub(r'\s+', ' ', text).strip() # Consolidate multiple spaces to one and strip ends
    
    # Character filtering (allow more common punctuation useful for context)
    # text = re.sub(r'[^\w\s.,!?"\'():;-]', '', text) # Keeps more standard punctuation
    # For more aggressive cleaning for embedding, you might use:
    text = re.sub(r'[^a-zA-Z0-9\s.,!?-]', '', text) # More restrictive, closer to your original

    text_lower = text.lower() # Convert to lowercase AFTER regex to preserve case for URLs/emails if needed

    if not (SPACY_MODEL_LOADED and nlp_spacy_core):
        logger.warning(f"SpaCy model not loaded for {file_base_name_for_log}. Skipping lemmatization. Returning regex-cleaned text.")
        return text_lower
    
    try:
        # Process in chunks if text is very long to avoid SpaCy memory issues, though less likely after cleaning
        max_spacy_len = 1000000 # SpaCy's default internal limit for nlp()
        if len(text_lower) > max_spacy_len:
            logger.warning(f"Text for SpaCy in {file_base_name_for_log} exceeds {max_spacy_len} chars. Processing in parts or truncating.")
            # Simple truncation for now, chunking for spacy is more complex
            text_lower = text_lower[:max_spacy_len]

        doc = nlp_spacy_core(text_lower, disable=['parser', 'ner']) # Disable unused pipes
        lemmatized_tokens = [
            token.lemma_ for token in doc 
            if not token.is_stop and \
               not token.is_punct and \
               not token.is_space and \
               len(token.lemma_) > 1 and \
               token.lemma_ != '-PRON-' # Exclude pronouns after lemmatization
        ]
        final_cleaned_text = " ".join(lemmatized_tokens)
        logger.info(f"SpaCy cleaning for {file_base_name_for_log}: Final length {len(final_cleaned_text)}")
        return final_cleaned_text
    except Exception as e:
        logger.error(f"SpaCy processing failed for {file_base_name_for_log}: {e}. Returning pre-SpaCy cleaned text.", exc_info=True)
        return text_lower


def reconstruct_document_layout(text_content: str, tables_data: List[Any], file_type: str, file_base_name_for_log: str ="") -> str:
    if not text_content and not tables_data: return ""
    logger.info(f"Layout reconstruction for {file_base_name_for_log} ({file_type}): Text len {len(text_content)}, Tables {len(tables_data)}")
    
    # Hyphenated word de-joining (if text_content is not None)
    processed_text = text_content if text_content else ""
    processed_text = re.sub(r'(\w+)-\s*\n\s*(\w+)', r'\1\2', processed_text) # Across newlines
    # processed_text = re.sub(r'(\w+)-(\w+)', r'\1\2', processed_text) # Within same line (less common needed after initial parse)

    if tables_data:
        table_md_parts = []
        for i, table_obj in enumerate(tables_data):
            table_header = f"\n\n[START OF TABLE {i+1} extracted from {file_base_name_for_log}]\n"
            table_footer = f"\n[END OF TABLE {i+1}]\n"
            md_table_content = ""
            try:
                if PANDAS_AVAILABLE and pd and isinstance(table_obj, pd.DataFrame):
                    md_table_content = table_obj.to_markdown(index=False)
                elif isinstance(table_obj, list) and table_obj and all(isinstance(row, list) for row in table_obj):
                    # Basic list of lists to Markdown
                    if table_obj[0]: # Assume first row is header
                        md_table_content = "| " + " | ".join(map(str, table_obj[0])) + " |\n"
                        md_table_content += "| " + " | ".join(["---"] * len(table_obj[0])) + " |\n"
                        for row_data in table_obj[1:]:
                            if len(row_data) == len(table_obj[0]):
                                md_table_content += "| " + " | ".join(map(str, row_data)) + " |\n"
                            else: logger.warning(f"Table {i+1} (list) row length mismatch in {file_base_name_for_log}.")
                    else: md_table_content = "[Empty Table Data]"
                else: md_table_content = str(table_obj) # Fallback
            except Exception as e_table_md:
                logger.warning(f"Table {i+1} to Markdown conversion error for {file_base_name_for_log}: {e_table_md}. Using raw string.")
                md_table_content = str(table_obj)
            
            if md_table_content.strip():
                table_md_parts.append(table_header + md_table_content.strip() + table_footer)
        
        if table_md_parts:
            processed_text += "\n\n" + "\n\n".join(table_md_parts)
    
    # Final whitespace cleanup
    final_layout_text = re.sub(r'\s{2,}', ' ', processed_text).strip() # Consolidate multiple spaces
    logger.info(f"Layout reconstruction for {file_base_name_for_log}: Final length {len(final_layout_text)}")
    return final_layout_text


def extract_document_metadata_info(
    file_path: str, 
    processed_text: str, 
    parsed_doc_elements: Dict[str, Any], # Output from _get_initial_parsed_document
    original_file_name: str, 
    user_id: str
) -> Dict[str, Any]:
    logger.info(f"Metadata extraction for: {original_file_name} (User: {user_id})")
    
    parser_meta = parsed_doc_elements.get('parser_metadata', {})
    file_type_from_parser = os.path.splitext(original_file_name)[1].lower() # Fallback if not in parser_meta

    doc_meta = {
        'file_name': original_file_name,
        'file_path_on_server': file_path,
        'original_file_type': parser_meta.get('file_type', file_type_from_parser),
        'processing_user': user_id,
        'title': parser_meta.get('title', original_file_name), # Prioritize parser title
        'author': parser_meta.get('author', "Unknown"),       # Prioritize parser author
        'creation_date': parser_meta.get('creation_date'),   # Expect ISO format from parser
        'modification_date': parser_meta.get('modification_date'), # Expect ISO format
        'page_count': parser_meta.get('page_count', 0),
        'char_count_processed_text': len(processed_text),
        'named_entities': {},
        'structural_elements': "Paragraphs" + (", Tables" if parsed_doc_elements.get('tables') else ""),
        'is_scanned_document': parsed_doc_elements.get('is_scanned_heuristic', False), # Initial guess
        'ocr_applied': False # Will be set to True if OCR text was actually used
    }

    # OS-level metadata (can augment or be overridden by parser_meta)
    try:
        doc_meta['file_size_bytes'] = os.path.getsize(file_path)
        if PANDAS_AVAILABLE and pd: # Using pandas for robust timestamp conversion
            # Only set OS dates if not already provided by a more specific parser
            if not doc_meta['creation_date']:
                 doc_meta['creation_date_os'] = pd.Timestamp(os.path.getctime(file_path), unit='s').isoformat()
            if not doc_meta['modification_date']:
                 doc_meta['modification_date_os'] = pd.Timestamp(os.path.getmtime(file_path), unit='s').isoformat()
    except Exception as e_os_meta:
        logger.warning(f"Metadata: OS metadata error for {original_file_name}: {e_os_meta}")

    # If page_count is still 0 after parser, estimate from text
    if doc_meta['page_count'] == 0 and processed_text:
        doc_meta['page_count'] = max(1, processed_text.count('\n\n') + 1) # Rough estimate

    # NER (Named Entity Recognition) - using SpaCy
    if processed_text and SPACY_MODEL_LOADED and nlp_spacy_core:
        logger.info(f"Extracting named entities for {original_file_name}...")
        try:
            text_for_ner = processed_text[:MAX_TEXT_LENGTH_FOR_NER] # Use config alias
            spacy_doc = nlp_spacy_core(text_for_ner) # NER pipe should be enabled by default
            
            entities_by_type = {}
            for ent in spacy_doc.ents:
                entities_by_type.setdefault(ent.label_, set()).add(ent.text)
            
            doc_meta['named_entities'] = {label: sorted(list(texts)) for label, texts in entities_by_type.items()}
            num_entities_found = sum(len(v) for v in doc_meta['named_entities'].values())
            logger.info(f"Extracted {num_entities_found} unique named entities for {original_file_name}.")
        except Exception as e_ner:
            logger.error(f"Metadata: NER error for {original_file_name}: {e_ner}", exc_info=True)
    else:
        logger.info(f"Skipping NER for {original_file_name} (no text or SpaCy model not loaded/configured for NER).")
    
    logger.info(f"Metadata extraction complete for {original_file_name}.")
    return doc_meta

# Chunking and Embedding functions remain largely the same as your corrected versions,
# just ensure they consume the correct data.
def chunk_document_into_segments(
    text_to_chunk: str,
    document_level_metadata: Dict[str, Any] # This is the output from extract_document_metadata_info
) -> List[Dict[str, Any]]:
    if not text_to_chunk or not text_to_chunk.strip():
        logger.warning(f"Chunking: No text for {document_level_metadata.get('file_name', 'unknown')}.")
        return []

    if not (LANGCHAIN_SPLITTER_AVAILABLE and RecursiveCharacterTextSplitter):
        logger.error("RecursiveCharacterTextSplitter not available. Cannot chunk text.")
        return []
        
    chunk_s = AI_CORE_CHUNK_SIZE
    chunk_o = AI_CORE_CHUNK_OVERLAP
    original_doc_name_for_log = document_level_metadata.get('file_name', 'unknown_doc')
    logger.info(f"Chunking {original_doc_name_for_log}: Size={chunk_s}, Overlap={chunk_o}")
    
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=chunk_s,
        chunk_overlap=chunk_o,
        length_function=len,
        separators=["\n\n", "\n", ". ", " ", ""], 
        keep_separator=True # Consider if True or False is better for your LLM
    )

    try:
        raw_text_segments: List[str] = text_splitter.split_text(text_to_chunk)
    except Exception as e_split: 
        logger.error(f"Chunking: Error splitting text for {original_doc_name_for_log}: {e_split}", exc_info=True)
        return []
        
    output_chunks: List[Dict[str, Any]] = []
    # Use a more robust base name if original name contains problematic characters for reference
    base_file_name_for_ref = re.sub(r'[^a-zA-Z0-9_-]', '_', os.path.splitext(original_doc_name_for_log)[0])


    for i, segment_content in enumerate(raw_text_segments):
        if not segment_content.strip(): 
            logger.debug(f"Skipping empty chunk at index {i} for {original_doc_name_for_log}.")
            continue

        # Create a deep copy of document-level metadata for each chunk
        chunk_specific_metadata = copy.deepcopy(document_level_metadata)
        
        qdrant_point_id = str(uuid.uuid4()) # Unique ID for this chunk in Qdrant

        # Add chunk-specific details to its metadata
        chunk_specific_metadata['chunk_id'] = qdrant_point_id 
        chunk_specific_metadata['chunk_reference_name'] = f"{base_file_name_for_ref}_chunk_{i:04d}"
        chunk_specific_metadata['chunk_index'] = i
        chunk_specific_metadata['chunk_char_count'] = len(segment_content)
        # Remove potentially very large or redundant fields from chunk metadata if necessary
        # e.g., chunk_specific_metadata.pop('named_entities', None) if too verbose per chunk
        
        output_chunks.append({
            'id': qdrant_point_id, # This ID is for Qdrant
            'text_content': segment_content,
            'metadata': chunk_specific_metadata # This payload goes into Qdrant
        })
    
    logger.info(f"Chunking: Split '{original_doc_name_for_log}' into {len(output_chunks)} non-empty chunks.")
    return output_chunks

def generate_segment_embeddings(document_chunks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    if not document_chunks: return []
    if not (EMBEDDING_MODEL_LOADED and document_embedding_model):
        logger.error("Embedding model not loaded. Cannot generate embeddings.")
        for chunk_dict in document_chunks: chunk_dict['embedding'] = None
        return document_chunks

    model_name_for_logging = DOCUMENT_EMBEDDING_MODEL_NAME
    logger.info(f"Embedding {len(document_chunks)} chunks using {model_name_for_logging}.")
    
    texts_to_embed: List[str] = []
    valid_chunk_indices: List[int] = [] # To map embeddings back to original chunk objects

    for i, chunk_dict in enumerate(document_chunks):
        text_content = chunk_dict.get('text_content')
        if text_content and text_content.strip():
            texts_to_embed.append(text_content)
            valid_chunk_indices.append(i)
        else:
            chunk_dict['embedding'] = None # Ensure 'embedding' key exists
            logger.debug(f"Embedding: Chunk {chunk_dict.get('id', i)} has no text, skipping.")

    if not texts_to_embed:
        logger.warning("Embedding: No text content found in chunks to generate embeddings.")
        return document_chunks

    try:
        embeddings_np_array = document_embedding_model.encode(texts_to_embed, show_progress_bar=True) # Set to True for long lists
        
        for i, original_chunk_idx in enumerate(valid_chunk_indices):
            if i < len(embeddings_np_array):
                document_chunks[original_chunk_idx]['embedding'] = embeddings_np_array[i].tolist()
            else: # Should not happen if encode works correctly
                logger.error(f"Embedding: Mismatch in embedding count for chunk at original index {original_chunk_idx}.")
                document_chunks[original_chunk_idx]['embedding'] = None
        
        logger.info(f"Embedding: Generated and assigned embeddings to {len(valid_chunk_indices)} chunks.")
    except Exception as e_embed:
        logger.error(f"Embedding: Error during generation with {model_name_for_logging}: {e_embed}", exc_info=True)
        for original_chunk_idx in valid_chunk_indices: # Ensure all attempted chunks get None on error
            document_chunks[original_chunk_idx]['embedding'] = None
            
    return document_chunks


# --- Main Orchestration Function ---
def process_document_for_qdrant(file_path: str, original_name: str, user_id: str) -> tuple[List[Dict[str, Any]], Optional[str], List[Dict[str, Any]]]:
    """
    Main orchestrator for processing a document.
    Returns:
        - final_chunks_for_qdrant: List of chunks with embeddings for Qdrant.
        - text_for_node_analysis: Consolidated text for Node.js general analysis (FAQ, Topics).
        - chunks_for_kg_worker: List of chunks with metadata (no embeddings) for KG worker.
    """
    logger.info(f"ai_core: Orchestrating document processing for '{original_name}', user '{user_id}'")
    if not os.path.exists(file_path):
        logger.error(f"File not found at ai_core entry: {file_path}")
        # Return empty tuple of expected types
        return [], None, []


    # Default return values for failure cases
    empty_qdrant_chunks = []
    no_analysis_text = None
    empty_kg_chunks = []

    try:
        # 1. Initial Parsing (Rich Element Extraction)
        parsed_doc_elements = _get_initial_parsed_document(file_path)
        initial_text_from_parser = parsed_doc_elements.get('text_content')
        images_from_parser = parsed_doc_elements.get('images', [])
        tables_from_parser = parsed_doc_elements.get('tables', [])
        is_scanned_heuristic = parsed_doc_elements.get('is_scanned_heuristic', False)
        file_type_from_parser = os.path.splitext(original_name)[1].lower() # Or get from parsed_doc_elements if available

        # 2. OCR if needed
        ocr_text_output = ""
        ocr_applied_flag = False
        # Decide if OCR is necessary:
        # - Explicitly image file types.
        # - Parser's heuristic says scanned.
        # - Parser extracted no text but found images (strong indicator for OCR).
        # - Parser extracted minimal text and images are present (e.g., a DOCX that's mostly a picture).
        should_ocr = is_scanned_heuristic or \
                     (file_type_from_parser in ['.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.gif']) or \
                     (not initial_text_from_parser and images_from_parser) or \
                     (initial_text_from_parser and len(initial_text_from_parser) < 200 * len(images_from_parser) and images_from_parser) # Heuristic for low text + images

        if should_ocr and images_from_parser:
            if PYTESSERACT_AVAILABLE and pytesseract:
                logger.info(f"OCR triggered for {original_name} based on heuristics/file type.")
                ocr_text_output = perform_ocr_on_images(images_from_parser, original_name)
                if ocr_text_output: ocr_applied_flag = True
            else:
                logger.warning(f"OCR needed for {original_name} but Pytesseract not available. Content may be incomplete.")
        
        # 3. Combine Text (Parser + OCR)
        combined_raw_text_parts = []
        if initial_text_from_parser: combined_raw_text_parts.append(initial_text_from_parser)
        if ocr_text_output: combined_raw_text_parts.append(ocr_text_output)
        combined_raw_text = "\n\n".join(combined_raw_text_parts).strip()

        if not combined_raw_text and not tables_from_parser:
            logger.warning(f"No text content or tables for {original_name} after initial parsing/OCR. Processing cannot continue.")
            return empty_qdrant_chunks, no_analysis_text, empty_kg_chunks

        # 4. Clean Text
        cleaned_text = clean_and_normalize_text_content(combined_raw_text, original_name)
        if not cleaned_text and not tables_from_parser: # If cleaning results in empty text
            logger.warning(f"No meaningful text for {original_name} after cleaning, and no tables. Processing cannot continue.")
            return empty_qdrant_chunks, no_analysis_text, empty_kg_chunks

        # 5. Reconstruct Layout (Integrate Tables as Markdown)
        text_for_further_processing = reconstruct_document_layout(
            cleaned_text, # Use the cleaned text
            tables_from_parser,
            file_type_from_parser,
            original_name
        )
        # This `text_for_further_processing` is a good candidate for Node.js analysis (FAQ, topics)
        # as it's cleaned and has table context.
        raw_text_for_node_analysis = text_for_further_processing 

        # 6. Extract Comprehensive Metadata
        doc_metadata = extract_document_metadata_info(
            file_path,
            text_for_further_processing, # Pass the final text that will be chunked
            parsed_doc_elements, # Pass the full initial parse results
            original_name,
            user_id
        )
        doc_metadata['ocr_applied'] = ocr_applied_flag # Update with actual OCR status

        # 7. Chunk Document
        # We chunk `text_for_further_processing` which includes table representations.
        chunks_with_metadata_for_qdrant_and_kg = chunk_document_into_segments(
            text_for_further_processing,
            doc_metadata # Pass rich metadata to chunks
        )
        if not chunks_with_metadata_for_qdrant_and_kg:
            logger.warning(f"No chunks produced for {original_name}. Cannot proceed with Qdrant/KG.")
            # Still return raw_text_for_node_analysis if it exists
            return empty_qdrant_chunks, raw_text_for_node_analysis, empty_kg_chunks

        # Prepare chunks for KG worker (these don't need embeddings yet)
        # Important: Deep copy if you modify this list before embedding,
        # or if embedding modifies in-place (unlikely with current generate_segment_embeddings)
        chunks_for_kg_worker = copy.deepcopy(chunks_with_metadata_for_qdrant_and_kg) 
        # Remove embedding from KG chunks if it somehow got there, or any very large fields not needed by KG LLM
        for chunk in chunks_for_kg_worker:
            chunk.pop('embedding', None) 
            # Consider removing other large metadata fields if KG LLM doesn't need them from each chunk's metadata

        # 8. Generate Embeddings for Qdrant chunks
        final_chunks_for_qdrant = generate_segment_embeddings(chunks_with_metadata_for_qdrant_and_kg)
        
        logger.info(f"ai_core: Successfully processed '{original_name}'. Generated {len(final_chunks_for_qdrant)} chunks for Qdrant.")
        return final_chunks_for_qdrant, raw_text_for_node_analysis, chunks_for_kg_worker

    except Exception as e:
        # Check for specific critical errors like Tesseract not found
        if TESSERACT_ERROR and isinstance(e, TESSERACT_ERROR):
            logger.critical(f"ai_core: Tesseract (OCR) not found processing {original_name}. OCR failed. Error: {e}", exc_info=False)
            # Depending on policy, you might still want to return any text extracted *before* OCR attempt.
            # For now, re-raise to indicate critical failure to the caller (app.py).
            raise
        
        logger.error(f"ai_core: Critical error processing {original_name}: {e}", exc_info=True)
        # Re-raise the exception to be handled by the caller in app.py
        raise
```

`server/rag_service/app.py`

```python
# server/rag_service/app.py
import os
import sys
import traceback
import logging
import atexit
import uuid
import subprocess
import tempfile
import shutil
import json


from flask import Flask, request, jsonify, current_app, send_from_directory, after_this_request
from pydub import AudioSegment
from duckduckgo_search import DDGS
from qdrant_client import models as qdrant_models

import subprocess
import tempfile
import shutil
import json

# --- Add server directory to sys.path ---
SERVER_DIR = os.path.dirname(os.path.abspath(__file__))
if SERVER_DIR not in sys.path:
    sys.path.insert(0, SERVER_DIR)

import config
config.setup_logging()

# --- Import configurations and services ---
try:
    from vector_db_service import VectorDBService
    import ai_core
    import neo4j_handler 
    from neo4j import exceptions as neo4j_exceptions
    import document_generator
    import podcast_generator
    import academic_search
    import knowledge_graph_generator
    import google.generativeai as genai
    from prompts import CODE_ANALYSIS_PROMPT_TEMPLATE, TEST_CASE_GENERATION_PROMPT_TEMPLATE, EXPLAIN_ERROR_PROMPT_TEMPLATE


    if config.GEMINI_API_KEY:
        genai.configure(api_key=config.GEMINI_API_KEY)
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        LLM_MODEL = genai.GenerativeModel(config.GEMINI_MODEL_NAME, safety_settings=safety_settings)
    else:
        LLM_MODEL = None
        logging.getLogger(__name__).error("GEMINI_API_KEY not found, AI features will fail.")

    def llm_wrapper(prompt):
        if not LLM_MODEL:
            raise ConnectionError("Gemini API Key is not configured in the Python service.")
        for attempt in range(3):
            try:
                response = LLM_MODEL.generate_content(prompt)
                if response.parts:
                    return "".join(part.text for part in response.parts if hasattr(part, 'text'))
                elif response.prompt_feedback and response.prompt_feedback.block_reason:
                     raise ValueError(f"Prompt blocked by API. Reason: {response.prompt_feedback.block_reason_message}")
                else:
                    logger.warning("LLM returned empty response without explicit block reason.")
                    return ""
            except Exception as e:
                logger.warning(f"LLM generation attempt {attempt + 1} failed: {e}")
                if attempt == 2: raise
        return ""

except ImportError as e:
    print(f"CRITICAL IMPORT ERROR: {e}.")
    sys.exit(1)

logger = logging.getLogger(__name__)
app = Flask(__name__)

GENERATED_DOCS_DIR = os.path.join(SERVER_DIR, 'generated_docs')
os.makedirs(GENERATED_DOCS_DIR, exist_ok=True)
app.config['GENERATED_DOCS_DIR'] = GENERATED_DOCS_DIR

# --- Dynamic LLM Initialization & Wrapper ---
def get_llm_model(api_key: str):
    """Dynamically creates a GenerativeModel instance with the provided API key."""
    if not api_key:
        raise ValueError("An API key is required to initialize the LLM for this request.")
    
    genai.configure(api_key=api_key)
    safety_settings = [
        {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
        {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
    ]
    return genai.GenerativeModel(config.GEMINI_MODEL_NAME, safety_settings=safety_settings)

def llm_wrapper(prompt: str, api_key: str):
    """Wrapper that takes an api_key to initialize the model for each call."""
    if not api_key:
        raise ConnectionError("Gemini API Key was not provided for this operation.")
    
    llm_model = get_llm_model(api_key)
    
    for attempt in range(3):
        try:
            response = llm_model.generate_content(prompt)
            if response.parts:
                return "".join(part.text for part in response.parts if hasattr(part, 'text'))
            elif response.prompt_feedback and response.prompt_feedback.block_reason:
                 raise ValueError(f"Prompt blocked by API. Reason: {response.prompt_feedback.block_reason_message}")
            else:
                logger.warning("LLM returned empty response without explicit block reason.")
                return ""
        except Exception as e:
            logger.warning(f"LLM generation attempt {attempt + 1} failed: {e}")
            if attempt == 2: raise
    return ""

# --- Initialize other services ---
vector_service = None
try:
    vector_service = VectorDBService()
    vector_service.setup_collection()
    app.vector_service = vector_service
except Exception as e:
    logger.critical(f"Failed to initialize VectorDBService: {e}", exc_info=True)

try:
    neo4j_handler.init_driver()
except Exception as e:
    logger.critical(f"Neo4j driver failed to initialize: {e}.")
atexit.register(neo4j_handler.close_driver)

def create_error_response(message, status_code=500, details=None):
    log_message = f"API Error ({status_code}): {message}"
    if details: log_message += f" | Details: {details}"
    current_app.logger.error(log_message)
    response_payload = {"error": message}
    if details and status_code != 500: response_payload["details"] = details
    return jsonify(response_payload), status_code

# === API Endpoints ===
@app.route('/analyze_code', methods=['POST'])
def analyze_code():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    code, language = data.get('code'), data.get('language')
    if not all([code, language]): return create_error_response("Missing 'code' or 'language'", 400)
    try:
        prompt = CODE_ANALYSIS_PROMPT_TEMPLATE.format(language=language, code=code)
        analysis_text = llm_wrapper(prompt)
        return jsonify({"analysis": analysis_text}), 200
    except Exception as e:
        return create_error_response(f"Failed to analyze code: {str(e)}", 500)

@app.route('/generate_test_cases', methods=['POST'])
def generate_test_cases():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    code, language = data.get('code'), data.get('language')
    if not all([code, language]): return create_error_response("Missing 'code' or 'language'", 400)
    try:
        prompt = TEST_CASE_GENERATION_PROMPT_TEMPLATE.format(language=language, code=code)
        response_text = llm_wrapper(prompt)
        cleaned_json = response_text[response_text.find('['):response_text.rfind(']')+1]
        test_cases = json.loads(cleaned_json)
        return jsonify({"testCases": test_cases}), 200
    except Exception as e:
        return create_error_response(f"Failed to generate test cases: {str(e)}", 500)

@app.route('/explain_error', methods=['POST'])
def explain_error():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    code, language, error_message = data.get('code'), data.get('language'), data.get('errorMessage')
    if not all([code, language, error_message]):
        return create_error_response("Missing 'code', 'language', or 'errorMessage'", 400)
    try:
        prompt = EXPLAIN_ERROR_PROMPT_TEMPLATE.format(language=language, code=code, error_message=error_message)
        explanation_text = llm_wrapper(prompt)
        return jsonify({"explanation": explanation_text}), 200
    except Exception as e:
        return create_error_response(f"Failed to explain error: {str(e)}", 500)

LANGUAGE_CONFIG = {
    "python": {
        "filename": "main.py",
        "compile_cmd": None,
        "run_cmd": [sys.executable, "main.py"]
    },
    "java": {
        "filename": "Main.java",
        "compile_cmd": ["javac", "-Xlint:all", "Main.java"],
        "run_cmd": ["java", "Main"]
    },
    "c": {
        "filename": "main.c",
        "compile_cmd": ["gcc", "main.c", "-o", "main", "-Wall", "-Wextra", "-pedantic"],
        "run_cmd": ["./main"]
    },
    "cpp": {
        "filename": "main.cpp",
        "compile_cmd": ["g++", "main.cpp", "-o", "main", "-Wall", "-Wextra", "-pedantic"],
        "run_cmd": ["./main"]
    }
}

@app.route('/execute_code', methods=['POST'])
def execute_code():
    data = request.get_json()
    if not data:
        return create_error_response("Request must be JSON", 400)

    code = data.get('code')
    language = data.get('language', '').lower()
    test_cases = data.get('testCases', [])

    if not code or not language:
        return create_error_response("Missing 'code' or 'language'", 400)

    lang_config = LANGUAGE_CONFIG.get(language)
    if not lang_config:
        unsupported_message = f"Language '{language}' is not currently supported for execution."
        return jsonify({"compilationError": unsupported_message}), 200

    results = []
    temp_dir = tempfile.mkdtemp()
    
    try:
        source_path = os.path.join(temp_dir, lang_config["filename"])
        with open(source_path, 'w', encoding='utf-8') as f:
            f.write(code)

        # --- Compilation Step ---
        if lang_config["compile_cmd"]:
            compile_process = subprocess.run(
                lang_config["compile_cmd"],
                cwd=temp_dir,
                capture_output=True,
                text=True,
                timeout=10, # 10-second timeout for compilation
                encoding='utf-8'
            )
            if compile_process.returncode != 0:
                error_output = (compile_process.stdout + "\n" + compile_process.stderr).strip()
                logger.warning(f"Compilation failed for {language}. Error: {error_output}")
                return jsonify({"compilationError": error_output}), 200

        # --- Execution Step ---
        for i, case in enumerate(test_cases):
            case_input = case.get('input', '')
            expected_output = str(case.get('expectedOutput', '')).strip()
            
            case_result = {
                "input": case_input,
                "expected": expected_output,
                "output": "",
                "error": None,
                "status": "fail"
            }

            try:
                run_process = subprocess.run(
                    lang_config["run_cmd"],
                    cwd=temp_dir,
                    input=case_input,
                    capture_output=True,
                    text=True,
                    timeout=5,
                    encoding='utf-8'
                )

                stdout = run_process.stdout.strip()
                stderr = run_process.stderr.strip()
                case_result["output"] = stdout

                if run_process.returncode != 0:
                    case_result["status"] = "error"
                    case_result["error"] = stderr or "Script failed with a non-zero exit code."
                elif stderr:
                     case_result["error"] = f"Warning (stderr):\n{stderr}"
                
                if case_result["status"] != "error":
                    if stdout == expected_output:
                        case_result["status"] = "pass"
                    else:
                        case_result["status"] = "fail"
                
            except subprocess.TimeoutExpired:
                case_result["status"] = "error"
                case_result["error"] = "Execution timed out after 5 seconds."
            except Exception as exec_err:
                case_result["status"] = "error"
                case_result["error"] = f"An unexpected error occurred during execution: {str(exec_err)}"

            results.append(case_result)

    finally:
        shutil.rmtree(temp_dir)

    return jsonify({"results": results}), 200

@app.route('/health', methods=['GET'])
def health_check():
    status_details = { "status": "error", "qdrant_service": "not_initialized", "neo4j_service": "not_initialized_via_handler", "neo4j_connection": "unknown"}
    http_status_code = 503
    if not vector_service:
        status_details["qdrant_service"] = "failed_to_initialize"
    else:
        status_details["qdrant_service"] = "initialized"
        try:
            vector_service.client.get_collection(collection_name=vector_service.collection_name)
            status_details["qdrant_collection_status"] = "exists_and_accessible"
        except Exception as e:
            status_details["qdrant_collection_status"] = f"error: {str(e)}"
    
    neo4j_ok, neo4j_conn_status = neo4j_handler.check_neo4j_connectivity()
    if neo4j_ok:
        status_details["neo4j_service"], status_details["neo4j_connection"] = "initialized_via_handler", "connected"
    else:
        status_details["neo4j_service"], status_details["neo4j_connection"] = "initialization_failed_or_handler_error", neo4j_conn_status
    
    if status_details["qdrant_service"] == "initialized" and status_details.get("qdrant_collection_status") == "exists_and_accessible" and neo4j_ok:
        status_details["status"], http_status_code = "ok", 200
    
    return jsonify(status_details), http_status_code

@app.route('/add_document', methods=['POST'])
def add_document_qdrant():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, file_path, original_name = data.get('user_id'), data.get('file_path'), data.get('original_name')
    if not all([user_id, file_path, original_name]): return create_error_response("Missing required fields", 400)
    if not os.path.exists(file_path): return create_error_response(f"File not found: {file_path}", 404)
    try:
        processed_chunks, raw_text, kg_chunks = ai_core.process_document_for_qdrant(file_path, original_name, user_id)
        num_added, status = 0, "processed_no_content"
        if processed_chunks:
            num_added = app.vector_service.add_processed_chunks(processed_chunks)
            if num_added > 0: status = "added_to_qdrant"
        return jsonify({ "message": "Document processed.", "status": status, "filename": original_name, "num_chunks_added_to_qdrant": num_added, "raw_text_for_analysis": raw_text or "", "chunks_with_metadata": kg_chunks }), 201
    except Exception as e: return create_error_response(f"Failed to process document: {str(e)}", 500)

@app.route('/query', methods=['POST'])
def search_qdrant_documents():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    query_text, user_id, k, doc_name = data.get('query'), data.get('user_id'), data.get('k', 5), data.get('documentContextName')
    if not query_text or not user_id: return create_error_response("Missing 'query' or 'user_id'", 400)
    try:
        must_conditions = [qdrant_models.FieldCondition(key="file_name", match=qdrant_models.MatchValue(value=doc_name))] if doc_name else []
        qdrant_filters = qdrant_models.Filter(must=must_conditions) if must_conditions else None
        retrieved, snippet, docs_map = vector_service.search_documents(query=query_text, k=k, filter_conditions=qdrant_filters)
        return jsonify({"retrieved_documents_list": [d.to_dict() for d in retrieved], "formatted_context_snippet": snippet, "retrieved_documents_map": docs_map}), 200
    except Exception as e: return create_error_response(f"Query failed: {str(e)}", 500)

@app.route('/academic_search', methods=['POST'])
def academic_search_route():
    data = request.get_json()
    if not data or 'query' not in data: return create_error_response("Missing 'query'", 400)
    try:
        results = academic_search.search_all_apis(data['query'], max_results_per_api=data.get('max_results', 3))
        return jsonify({"success": True, "results": results}), 200
    except Exception as e:
        return create_error_response(f"Academic search failed: {str(e)}", 500)

@app.route('/web_search', methods=['POST'])
def web_search_route():
    data = request.get_json()
    if not data or 'query' not in data: return create_error_response("Missing 'query'", 400)
    try:
        with DDGS() as ddgs:
            results = list(ddgs.text(data['query'], max_results=5))
        return jsonify([{"title": r.get("title"), "url": r.get("href"), "content": r.get("body")} for r in results]), 200
    except Exception as e: return create_error_response(f"Web search failed: {str(e)}", 500)

@app.route('/export_podcast', methods=['POST'])
def export_podcast_route():
    current_app.logger.info("--- /export_podcast Request (gTTS + Speed-Up) ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    source_document_text = data.get('sourceDocumentText')
    analysis_content = data.get('analysisContent')
    podcast_options = data.get('podcastOptions', {})
    api_key = data.get('api_key')
    
    if not all([source_document_text, analysis_content, api_key]):
        return create_error_response("Missing 'sourceDocumentText', 'analysisContent', or 'api_key'", 400)

    try:
        script = podcast_generator.generate_podcast_script(
            source_document_text, 
            analysis_content,
            podcast_options,
            lambda p: llm_wrapper(p, api_key)
        )
        
        temp_gtts_filename = f"podcast_gtts_{uuid.uuid4()}.mp3"
        temp_gtts_path = os.path.join(app.config['GENERATED_DOCS_DIR'], temp_gtts_filename)
        podcast_generator.synthesize_audio_with_gtts(script, temp_gtts_path)

        sound = AudioSegment.from_mp3(temp_gtts_path)
        sped_up_sound = sound.speedup(playback_speed=1.20)
        
        final_mp3_filename = f"podcast_final_{uuid.uuid4()}.mp3"
        final_mp3_path = os.path.join(app.config['GENERATED_DOCS_DIR'], final_mp3_filename)
        
        sped_up_sound.export(final_mp3_path, format="mp3")
        os.remove(temp_gtts_path)

        @after_this_request
        def cleanup(response):
            try: os.remove(final_mp3_path)
            except OSError as e: logger.error(f"Error deleting temp podcast MP3 file {final_mp3_path}: {e}")
            return response
            
        return send_from_directory(app.config['GENERATED_DOCS_DIR'], final_mp3_filename, as_attachment=True)
    except Exception as e:
        logger.error(f"Failed to generate podcast: {e}", exc_info=True)
        return create_error_response(f"Failed to generate podcast: {str(e)}", 500)

@app.route('/generate_kg_from_text', methods=['POST'])
def generate_kg_from_text_route():
    current_app.logger.info("--- /generate_kg_from_text Request ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    document_text = data.get('document_text')
    api_key = data.get('api_key')
    
    if not document_text or not api_key:
        return create_error_response("Missing 'document_text' or 'api_key' in request body", 400)
    
    try:
        graph_data = knowledge_graph_generator.generate_graph_from_text(
            document_text, 
            lambda p: llm_wrapper(p, api_key)
        )
        return jsonify({"success": True, "graph_data": graph_data}), 200
    except Exception as e:
        logger.error(f"Error during on-the-fly KG generation: {e}", exc_info=True)
        return create_error_response(f"KG Generation failed: {str(e)}", 500)

@app.route('/generate_document', methods=['POST'])
def generate_document_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    outline, doc_type, source_text, api_key = data.get('markdownContent'), data.get('docType'), data.get('sourceDocumentText'), data.get('api_key')
    if not all([outline, doc_type, source_text, api_key]): return create_error_response("Missing required fields", 400)
    try:
        expanded_content = document_generator.expand_content_with_llm(outline, source_text, doc_type, lambda p: llm_wrapper(p, api_key))
        slides = document_generator.parse_pptx_json(expanded_content) if doc_type == 'pptx' else document_generator.refined_parse_docx_markdown(expanded_content)
        filename, path = f"gen_{uuid.uuid4()}.{doc_type}", os.path.join(app.config['GENERATED_DOCS_DIR'], f"gen_{uuid.uuid4()}.{doc_type}")
        if doc_type == 'pptx': document_generator.create_ppt(slides, path)
        else: document_generator.create_doc(slides, path, "text_content")
        return jsonify({"success": True, "filename": filename}), 201
    except Exception as e: return create_error_response(f"Failed to generate document: {str(e)}", 500)

@app.route('/download_document/<filename>', methods=['GET'])
def download_document_route(filename):
    if '..' in filename: return create_error_response("Invalid filename.", 400)
    try:
        file_path = os.path.join(app.config['GENERATED_DOCS_DIR'], filename)
        if not os.path.exists(file_path): return create_error_response("File not found.", 404)
        @after_this_request
        def cleanup(response):
            try: os.remove(file_path)
            except OSError as e: logger.error(f"Error deleting temp file {file_path}: {e}")
            return response
        return send_from_directory(app.config['GENERATED_DOCS_DIR'], filename, as_attachment=True)
    except Exception as e:
        return create_error_response("Could not process download request.", 500)

# KG & DB Management Routes
@app.route('/delete_qdrant_document_data', methods=['DELETE'])
def delete_qdrant_data_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, document_name = data.get('user_id'), data.get('document_name') 
    if not user_id or not document_name: return create_error_response("Missing fields", 400)
    try:
        result = vector_service.delete_document_vectors(user_id, document_name)
        return jsonify(result), 200
    except Exception as e: return create_error_response(f"Deletion failed: {str(e)}", 500)

@app.route('/kg', methods=['POST'])
def add_or_update_kg_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, original_name, nodes, edges = data.get('userId'), data.get('originalName'), data.get('nodes'), data.get('edges')
    if not all([user_id, original_name, isinstance(nodes, list), isinstance(edges, list)]): return create_error_response("Missing fields", 400)
    try:
        result = neo4j_handler.ingest_knowledge_graph(user_id, original_name, nodes, edges)
        return jsonify({"message": "KG ingested", "status": "completed", **result}), 201
    except Exception as e: return create_error_response(f"KG ingestion failed: {str(e)}", 500)

@app.route('/kg/<user_id>/<path:document_name>', methods=['GET'])
def get_kg_route(user_id, document_name):
    try:
        kg_data = neo4j_handler.get_knowledge_graph(user_id, document_name)
        return jsonify(kg_data) if kg_data else create_error_response("KG not found", 404)
    except Exception as e: return create_error_response(f"KG retrieval failed: {str(e)}", 500)

@app.route('/kg/<user_id>/<path:document_name>', methods=['DELETE'])
def delete_kg_route(user_id, document_name):
    try:
        deleted = neo4j_handler.delete_knowledge_graph(user_id, document_name)
        return jsonify({"message": "KG deleted"}) if deleted else create_error_response("KG not found", 404)
    except Exception as e: return create_error_response(f"KG deletion failed: {str(e)}", 500)

if __name__ == '__main__':
    logger.info(f"--- Starting RAG API Service on port {config.API_PORT} ---")
    app.run(host='0.0.0.0', port=config.API_PORT, debug=False, threaded=True)

```

`server/rag_service/config.py`

```python
# server/rag_service/config.py
import os
import logging
from dotenv import load_dotenv

# --- Load .env from the parent 'server' directory ---
# This ensures that both Node.js and Python use the same .env file
# The path is calculated relative to this config.py file
dotenv_path = os.path.join(os.path.dirname(__file__), '..', '.env')
load_dotenv(dotenv_path=dotenv_path)


# ─── Logging Configuration ───────────────────────────
logger = logging.getLogger(__name__)
LOGGING_LEVEL_NAME = os.getenv('LOGGING_LEVEL', 'INFO').upper()
LOGGING_LEVEL      = getattr(logging, LOGGING_LEVEL_NAME, logging.INFO)
LOGGING_FORMAT     = '%(asctime)s - %(levelname)s - [%(name)s:%(lineno)d] - %(message)s'

def setup_logging():
    """Configure logging across the app."""
    root_logger = logging.getLogger()
    if not root_logger.handlers:  # prevent duplicate handlers
        handler = logging.StreamHandler()
        formatter = logging.Formatter(LOGGING_FORMAT)
        handler.setFormatter(formatter)
        root_logger.addHandler(handler)
        root_logger.setLevel(LOGGING_LEVEL)

    logging.getLogger("urllib3").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("faiss.loader").setLevel(logging.WARNING)
    logging.getLogger(__name__).info(f"Logging initialized at {LOGGING_LEVEL_NAME}")

# --- API Keys and Service URLs ---
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
GEMINI_MODEL_NAME = "gemini-1.5-flash-latest" # Or your preferred Gemini model

NEO4J_URI = os.getenv("NEO4J_URI", "bolt://localhost:7687")
NEO4J_USERNAME = os.getenv("NEO4J_USERNAME", "neo4j")
NEO4J_PASSWORD = os.getenv("NEO4J_PASSWORD", "password")
NEO4J_DATABASE = os.getenv("NEO4J_DATABASE", "neo4j")

QDRANT_HOST = os.getenv("QDRANT_HOST", "localhost")
QDRANT_PORT = int(os.getenv("QDRANT_PORT", 6333))
QDRANT_COLLECTION_NAME = os.getenv("QDRANT_COLLECTION_NAME", "my_qdrant_rag_collection")
QDRANT_API_KEY = os.getenv("QDRANT_API_KEY", None)
QDRANT_URL = os.getenv("QDRANT_URL", None)

# --- Embedding Model Configuration ---
DEFAULT_DOC_EMBED_MODEL = 'mixedbread-ai/mxbai-embed-large-v1'
DOCUMENT_EMBEDDING_MODEL_NAME = os.getenv('DOCUMENT_EMBEDDING_MODEL_NAME', DEFAULT_DOC_EMBED_MODEL)

_MODEL_TO_DIM_MAPPING = {
    'mixedbread-ai/mxbai-embed-large-v1': 1024,
    'BAAI/bge-large-en-v1.5': 1024,
    'all-MiniLM-L6-v2': 384,
    'sentence-transformers/all-mpnet-base-v2': 768,
}
_FALLBACK_DIM = 768
DOCUMENT_VECTOR_DIMENSION = int(os.getenv("DOCUMENT_VECTOR_DIMENSION", _MODEL_TO_DIM_MAPPING.get(DOCUMENT_EMBEDDING_MODEL_NAME, _FALLBACK_DIM)))
QDRANT_COLLECTION_VECTOR_DIM = DOCUMENT_VECTOR_DIMENSION

QUERY_EMBEDDING_MODEL_NAME = os.getenv("QUERY_EMBEDDING_MODEL_NAME", DOCUMENT_EMBEDDING_MODEL_NAME)
QUERY_VECTOR_DIMENSION = int(os.getenv("QUERY_VECTOR_DIMENSION", _MODEL_TO_DIM_MAPPING.get(QUERY_EMBEDDING_MODEL_NAME, _FALLBACK_DIM)))

if QUERY_VECTOR_DIMENSION != QDRANT_COLLECTION_VECTOR_DIM:
    logger.warning(f"[Config Warning] Query vector dim ({QUERY_VECTOR_DIMENSION}) != Qdrant dim ({QDRANT_COLLECTION_VECTOR_DIM})")

# --- AI Core & Search Configuration ---
AI_CORE_CHUNK_SIZE = int(os.getenv("AI_CORE_CHUNK_SIZE", 512))
AI_CORE_CHUNK_OVERLAP = int(os.getenv("AI_CORE_CHUNK_OVERLAP", 100))
MAX_TEXT_LENGTH_FOR_NER = int(os.getenv("MAX_TEXT_LENGTH_FOR_NER", 500000))
QDRANT_DEFAULT_SEARCH_K = int(os.getenv("QDRANT_DEFAULT_SEARCH_K", 5))
QDRANT_SEARCH_MIN_RELEVANCE_SCORE = float(os.getenv("QDRANT_SEARCH_MIN_RELEVANCE_SCORE", 0.1))

# --- SpaCy Configuration ---
SPACY_MODEL_NAME = os.getenv('SPACY_MODEL_NAME', 'en_core_web_sm')

# --- API Port Configuration ---
API_PORT = int(os.getenv('API_PORT', 5000))

# --- Tesseract OCR Path ---
TESSERACT_CMD = os.getenv('TESSERACT_CMD', r'C:\Program Files\Tesseract-OCR\tesseract.exe')


# ─── Library Availability Flags & Dynamic Imports ──────────────────────
try:
    import pypdf
    PYPDF_AVAILABLE = True
    PYPDF_PDFREADERROR = pypdf.errors.PdfReadError
except ImportError: PYPDF_AVAILABLE, PYPDF_PDFREADERROR = False, Exception

try:
    from docx import Document as DocxDocument
    DOCX_AVAILABLE = True
except ImportError: DOCX_AVAILABLE, DocxDocument = False, None

try:
    from pptx import Presentation
    PPTX_AVAILABLE = True
except ImportError: PPTX_AVAILABLE, Presentation = False, None

try:
    import pdfplumber
    PDFPLUMBER_AVAILABLE = True
except ImportError: PDFPLUMBER_AVAILABLE, pdfplumber = False, None

try:
    import pandas as pd
    PANDAS_AVAILABLE = True
except ImportError: PANDAS_AVAILABLE, pd = False, None

try:
    from PIL import Image
    PIL_AVAILABLE = True
except ImportError: PIL_AVAILABLE, Image = False, None

try:
    import fitz
    FITZ_AVAILABLE = True
except ImportError: FITZ_AVAILABLE, fitz = False, None

try:
    import pytesseract
    PYTESSERACT_AVAILABLE = True
    TESSERACT_ERROR = pytesseract.TesseractNotFoundError
    if TESSERACT_CMD: pytesseract.pytesseract.tesseract_cmd = TESSERACT_CMD
except ImportError: PYTESSERACT_AVAILABLE, pytesseract, TESSERACT_ERROR = False, None, Exception

try:
    import PyPDF2
    PYPDF2_AVAILABLE = True
except ImportError: PYPDF2_AVAILABLE, PyPDF2 = False, None

try:
    from langchain.text_splitter import RecursiveCharacterTextSplitter
    LANGCHAIN_SPLITTER_AVAILABLE = True
except ImportError: LANGCHAIN_SPLITTER_AVAILABLE, RecursiveCharacterTextSplitter = False, None

# ─── Optional: Preload SpaCy & Embedding Model ───────
nlp_spacy_core, SPACY_MODEL_LOADED = None, False
try:
    import spacy
    nlp_spacy_core = spacy.load(SPACY_MODEL_NAME)
    SPACY_MODEL_LOADED = True
except Exception as e:
    logger.warning(f"Failed to load SpaCy model '{SPACY_MODEL_NAME}': {e}")

document_embedding_model, EMBEDDING_MODEL_LOADED = None, False
try:
    from sentence_transformers import SentenceTransformer
    document_embedding_model = SentenceTransformer(DOCUMENT_EMBEDDING_MODEL_NAME)
    EMBEDDING_MODEL_LOADED = True
except Exception as e:
    logger.warning(f"Failed to load Sentence Transformer model '{DOCUMENT_EMBEDDING_MODEL_NAME}': {e}")
```

`server/rag_service/document_generator.py`

```python
# server/rag_service/document_generator.py
import re
import json
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.text import PP_ALIGN
from docx import Document
from docx.shared import Inches as DocxInches
import logging

logger = logging.getLogger(__name__)

# --- PROMPT FOR INTELLIGENT PPTX GENERATION (JSON-based) ---
PPTX_EXPANSION_PROMPT_TEMPLATE = """
You are a professional presentation designer and subject matter expert.
Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, 6-8 slide presentation.
You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge.
Your output MUST be a single, valid JSON array, where each object represents a slide.

**JSON Object Schema for each slide:**
{{
  "slide_title": "A concise and engaging title for the slide.",
  "slide_content": "Detailed, professional paragraph(s) and/or bullet points elaborating on the outline point. This text will be displayed on the slide. Use Markdown for formatting (e.g., **bold**, *italics*, - bullet points).",
  "image_prompt": "A highly descriptive, creative prompt for an AI text-to-image model (like DALL-E or Midjourney) to generate a relevant and visually appealing image for this specific slide. Describe the style, subject, and composition. Example: 'A photorealistic image of a futuristic server room with glowing blue data streams flowing between racks, symbolizing data processing. Cinematic lighting.'"
}}

**INSTRUCTIONS:**
1.  **Analyze Outline & Source:** For each point in the OUTLINE, create at least one slide object in the JSON array.
2.  **Expand Content:** Elaborate on each outline point using only information from the SOURCE DOCUMENT TEXT.
3.  **Create Image Prompts:** For each slide, generate a unique and descriptive `image_prompt` that visually represents the slide's content.
4.  **JSON Format:** Ensure the final output is a single, clean JSON array with no other text before or after it.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a presentation):**
{outline_content}
---

**FINAL PRESENTATION JSON ARRAY:**
"""

# --- PROMPT FOR INTELLIGENT DOCX GENERATION (Markdown-based) ---
DOCX_EXPANSION_PROMPT_TEMPLATE = """
You are a professional content creator and subject matter expert.
Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, multi-page document in Markdown format.
You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge.
The final output must be a single block of well-structured Markdown text.

**INSTRUCTIONS:**
1.  **Main Title:** Start the document with a main title using H1 syntax (e.g., `# Expanded Report on Key Topics`).
2.  **Section per Outline Point:** For each point in the OUTLINE, create a detailed section with a clear H2 or H3 heading (e.g., `## Topic Name`).
3.  **Content Expansion:** For each section, write detailed, professional paragraphs that elaborate on the outline point. Extract relevant facts, figures, and explanations from the SOURCE DOCUMENT TEXT.
4.  **Markdown Usage:** Use bullet points, bold text, and clear paragraphs to structure the content effectively.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a document):**
{outline_content}
---

**FINAL DOCUMENT MARKDOWN:**
"""

def expand_content_with_llm(outline_content, source_document_text, doc_type, llm_function):
    """Uses an LLM to expand an outline into full content for the specified doc type."""
    logger.info(f"Expanding outline for '{doc_type}' using LLM...")
    
    if doc_type == 'pptx':
        prompt = PPTX_EXPANSION_PROMPT_TEMPLATE.format(
            source_document_text=source_document_text,
            outline_content=outline_content
        )
    else: # for 'docx'
        prompt = DOCX_EXPANSION_PROMPT_TEMPLATE.format(
            source_document_text=source_document_text,
            outline_content=outline_content
        )

    expanded_content = llm_function(prompt)
    
    if not expanded_content or not expanded_content.strip():
        raise ValueError("LLM failed to generate expanded content.")
    
    logger.info(f"LLM generated expanded content for {doc_type}. Length: {len(expanded_content)}")
    return expanded_content

def parse_pptx_json(json_string):
    """Parses the LLM's JSON output for PPTX generation."""
    try:
        cleaned_str = re.sub(r'^```json\s*|\s*```$', '', json_string.strip())
        slides_data = json.loads(cleaned_str)
        if not isinstance(slides_data, list):
            raise ValueError("Parsed JSON is not a list of slides.")
        return slides_data
    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"Failed to parse JSON from LLM response: {e}")
        raise ValueError("LLM returned invalid JSON format for the presentation.") from e

def refined_parse_docx_markdown(markdown_content):
    """Parses the expanded markdown for DOCX generation into a single 'slide' object for consistency."""
    if not markdown_content or not markdown_content.strip():
        return []
    
    title_match = re.search(r"^\s*#\s+(.*)", markdown_content, re.MULTILINE)
    if title_match:
        title = title_match.group(1).strip()
        content = markdown_content[title_match.end():].strip()
    else:
        title = "Generated Document"
        content = markdown_content

    return [{"title": title, "text_content": content}]

def add_text_to_shape_with_markdown(text_frame, markdown_text, is_title=False, is_notes=False):
    text_frame.clear()
    text_frame.word_wrap = True
    title_font_size = Pt(36)
    content_font_size = Pt(16)
    notes_font_size = Pt(11)

    for line in markdown_text.split('\n'):
        p = text_frame.add_paragraph()
        p.alignment = PP_ALIGN.LEFT
        bullet_match = re.match(r'^(\s*)[\*\-]\s*(.*)', line)
        
        if bullet_match and not is_title:
            leading_spaces, content_line = bullet_match.groups()
            p.level = min(len(leading_spaces) // 2, 5)
        else:
            content_line = line.lstrip()

        segments = re.split(r'(\*\*.*?\*\*|__.*?__)', content_line)
        for segment in segments:
            if not segment: continue
            run = p.add_run()
            if (segment.startswith("**") and segment.endswith("**")) or (segment.startswith("__") and segment.endswith("__")):
                run.text = segment[2:-2]
                run.font.bold = True
            else:
                run.text = segment
            
            if is_title:
                run.font.color.rgb = RGBColor(255, 255, 255)
                run.font.size = title_font_size
            elif is_notes:
                run.font.color.rgb = RGBColor(210, 210, 230)
                run.font.size = notes_font_size
                run.font.italic = True
            else:
                run.font.color.rgb = RGBColor(255, 255, 255)
                run.font.size = content_font_size

def create_ppt(slides_data, output_path):
    prs = Presentation()
    prs.slide_width = Inches(16)
    prs.slide_height = Inches(9)

    for slide_data in slides_data:
        slide_layout = prs.slide_layouts[6] # Blank layout
        slide = prs.slides.add_slide(slide_layout)
        background = slide.background
        fill = background.fill
        fill.solid()
        fill.fore_color.rgb = RGBColor(15, 23, 42)

        title_shape = slide.shapes.add_textbox(Inches(0.5), Inches(0.2), prs.slide_width - Inches(1.0), Inches(1.0))
        add_text_to_shape_with_markdown(title_shape.text_frame, slide_data.get("slide_title", "Untitled Slide"), is_title=True)

        content_shape = slide.shapes.add_textbox(Inches(0.5), Inches(1.3), Inches(8.5), Inches(7.0))
        add_text_to_shape_with_markdown(content_shape.text_frame, slide_data.get("slide_content", "[No content provided]"))

        notes_shape = slide.shapes.add_textbox(Inches(9.5), Inches(1.3), Inches(6.0), Inches(7.0))
        image_prompt_header = "🎨 Image Generation Prompt:"
        image_prompt_body = slide_data.get("image_prompt", "N/A")
        add_text_to_shape_with_markdown(notes_shape.text_frame, f"**{image_prompt_header}**\n{image_prompt_body}", is_notes=True)

    prs.save(output_path)
    return True

def add_markdown_line_to_docx(doc, markdown_line):
    heading_match = re.match(r'^(#+)\s+(.*)', markdown_line)
    if heading_match:
        level = len(heading_match.group(1))
        doc.add_heading(heading_match.group(2).strip(), level=min(level, 4))
        return

    bullet_match = re.match(r'^(\s*)[\*\-]\s+(.*)', markdown_line)
    if bullet_match:
        leading_spaces, content_line = bullet_match.groups()
        p = doc.add_paragraph(style='List Bullet')
        p.paragraph_format.left_indent = DocxInches(0.25 * (len(leading_spaces) // 2))
    else:
        content_line = markdown_line
        p = doc.add_paragraph()
    
    segments = re.split(r'(\*\*.*?\*\*|__.*?__)', content_line)
    for segment in segments:
        if not segment: continue
        run = p.add_run()
        if (segment.startswith("**") and segment.endswith("**")) or (segment.startswith("__") and segment.endswith("__")):
            run.text = segment[2:-2]
            run.font.bold = True
        else:
            run.text = segment

def create_doc(slides_data, output_path, content_key="text_content"):
    doc = Document()
    if slides_data:
        doc_title = slides_data[0].get("title", "Generated Document")
        doc.add_heading(doc_title, level=0)
        
        content_to_add = slides_data[0].get(content_key, "")
        if content_to_add.strip():
            for line in content_to_add.split('\n'):
                add_markdown_line_to_docx(doc, line)
    else:
        doc.add_paragraph("[No content to generate]")
    doc.save(output_path)
    return True
```

`server/rag_service/file_parser.py`

```python
# server/rag_service/file_parser.py
import os
try:
    import pypdf
except ImportError:
    print("pypdf not found, PDF parsing will fail. Install with: pip install pypdf")
    pypdf = None # Set to None if not installed

try:
    from docx import Document as DocxDocument
except ImportError:
    print("python-docx not found, DOCX parsing will fail. Install with: pip install python-docx")
    DocxDocument = None

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_core.documents import Document as LangchainDocument
from rag_service import config # Import from package
import logging

# Configure logger for this module
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO) # Or DEBUG for more details
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
if not logger.hasHandlers():
    logger.addHandler(handler)


def parse_pdf(file_path):
    """Extracts text content from a PDF file using pypdf."""
    if not pypdf: return None # Check if library loaded
    text = ""
    try:
        reader = pypdf.PdfReader(file_path)
        num_pages = len(reader.pages)
        # logger.debug(f"Reading {num_pages} pages from PDF: {os.path.basename(file_path)}")
        for i, page in enumerate(reader.pages):
            try:
                page_text = page.extract_text()
                if page_text:
                    text += page_text + "\n" # Add newline between pages
            except Exception as page_err:
                 logger.warning(f"Error extracting text from page {i+1} of {os.path.basename(file_path)}: {page_err}")
        # logger.debug(f"Extracted {len(text)} characters from PDF.")
        return text.strip() if text.strip() else None # Return None if empty after stripping
    except FileNotFoundError:
        logger.error(f"PDF file not found: {file_path}")
        return None
    except pypdf.errors.PdfReadError as pdf_err:
        logger.error(f"Error reading PDF {os.path.basename(file_path)} (possibly corrupted or encrypted): {pdf_err}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error parsing PDF {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

def parse_docx(file_path):
    """Extracts text content from a DOCX file."""
    if not DocxDocument: return None # Check if library loaded
    try:
        doc = DocxDocument(file_path)
        text = "\n".join([para.text for para in doc.paragraphs if para.text.strip()])
        # logger.debug(f"Extracted {len(text)} characters from DOCX.")
        return text.strip() if text.strip() else None
    except Exception as e:
        logger.error(f"Error parsing DOCX {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

def parse_txt(file_path):
    """Reads text content from a TXT file (or similar plain text like .py, .js)."""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            text = f.read()
        # logger.debug(f"Read {len(text)} characters from TXT file.")
        return text.strip() if text.strip() else None
    except Exception as e:
        logger.error(f"Error parsing TXT {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

# Add PPTX parsing (requires python-pptx)
try:
    from pptx import Presentation
    PPTX_SUPPORTED = True
    def parse_pptx(file_path):
        """Extracts text content from a PPTX file."""
        text = ""
        try:
            prs = Presentation(file_path)
            for slide in prs.slides:
                for shape in slide.shapes:
                    if hasattr(shape, "text"):
                        shape_text = shape.text.strip()
                        if shape_text:
                            text += shape_text + "\n" # Add newline between shape texts
            # logger.debug(f"Extracted {len(text)} characters from PPTX.")
            return text.strip() if text.strip() else None
        except Exception as e:
            logger.error(f"Error parsing PPTX {os.path.basename(file_path)}: {e}", exc_info=True)
            return None
except ImportError:
    PPTX_SUPPORTED = False
    logger.warning("python-pptx not installed. PPTX parsing will be skipped.")
    def parse_pptx(file_path):
        logger.warning(f"Skipping PPTX file {os.path.basename(file_path)} as python-pptx is not installed.")
        return None


def parse_file(file_path):
    """Parses a file based on its extension, returning text content or None."""
    _, ext = os.path.splitext(file_path)
    ext = ext.lower()
    logger.debug(f"Attempting to parse file: {os.path.basename(file_path)} (Extension: {ext})")

    if ext == '.pdf':
        return parse_pdf(file_path)
    elif ext == '.docx':
        return parse_docx(file_path)
    elif ext == '.pptx':
        return parse_pptx(file_path) # Use the conditional function
    elif ext in ['.txt', '.py', '.js', '.md', '.log', '.csv', '.html', '.xml', '.json']: # Expand text-like types
        return parse_txt(file_path)
    # Add other parsers here if needed (e.g., for .doc, .xls)
    elif ext == '.doc':
        # Requires antiword or similar external tool, more complex
        logger.warning(f"Parsing for legacy .doc files is not implemented: {os.path.basename(file_path)}")
        return None
    else:
        logger.warning(f"Unsupported file extension for parsing: {ext} ({os.path.basename(file_path)})")
        return None

def chunk_text(text, file_name, user_id):
    """Chunks text and creates Langchain Documents with metadata."""
    if not text or not isinstance(text, str):
        logger.warning(f"Invalid text input for chunking (file: {file_name}). Skipping.")
        return []

    # Use splitter configured in config.py
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=config.CHUNK_SIZE,
        chunk_overlap=config.CHUNK_OVERLAP,
        length_function=len,
        is_separator_regex=False, # Use default separators
        # separators=["\n\n", "\n", " ", ""] # Default separators
    )

    try:
        chunks = text_splitter.split_text(text)
        if not chunks:
             logger.warning(f"Text splitting resulted in zero chunks for file: {file_name}")
             return []

        documents = []
        for i, chunk in enumerate(chunks):
             # Ensure chunk is not just whitespace before creating Document
             if chunk and chunk.strip():
                 documents.append(
                     LangchainDocument(
                         page_content=chunk,
                         metadata={
                             'userId': user_id, # Store user ID
                             'documentName': file_name, # Store original filename
                             'chunkIndex': i # Store chunk index for reference
                         }
                     )
                 )
        if documents:
            logger.info(f"Split '{file_name}' into {len(documents)} non-empty chunks.")
        else:
            logger.warning(f"No non-empty chunks created for file: {file_name} after splitting.")
        return documents
    except Exception as e:
        logger.error(f"Error during text splitting for file {file_name}: {e}", exc_info=True)
        return [] # Return empty list on error

```

`server/rag_service/knowledge_graph_generator.py`

```python
# server/rag_service/knowledge_graph_generator.py
import logging
import json
import re
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

KG_GENERATION_PROMPT = """
You are an expert data architect. Your task is to analyze the provided text and extract a detailed knowledge graph. The graph should represent the core entities, concepts, and their relationships.

**INSTRUCTIONS:**
1.  **Identify Entities/Nodes**: Identify the key entities (people, places, concepts, processes, technologies). These will be your nodes. For each node, provide a unique ID (a short, descriptive string) and a 'type' (e.g., 'Concept', 'Technology', 'Process').
2.  **Identify Relationships/Edges**: Determine how these nodes are connected. The relationship should be a descriptive verb phrase (e.g., 'IS_A', 'USES', 'RESULTS_IN', 'PART_OF').
3.  **Format as JSON**: Your entire output MUST be a single, valid JSON object containing two keys: "nodes" and "edges".
    -   **Nodes**: An array of objects, where each object is `{"id": "NodeID", "label": "Full Node Name", "type": "NodeType"}`. The `label` is the full name, the `id` is a concise version for linking.
    -   **Edges**: An array of objects, where each object is `{"from": "SourceNodeID", "to": "TargetNodeID", "relationship": "RELATIONSHIP_TYPE"}`.
4.  **Be Thorough**: Extract as many meaningful nodes and edges as possible to create a rich, interconnected graph.

---
**DOCUMENT TEXT TO ANALYZE:**
__DOCUMENT_TEXT_PLACEHOLDER__
---

**FINAL KNOWLEDGE GRAPH JSON (start immediately with `{`):**
"""

def generate_graph_from_text(document_text: str, llm_function) -> Dict[str, Any]:
    """Uses an LLM to generate a knowledge graph from a block of text."""
    logger.info(f"Generating knowledge graph from text of length {len(document_text)}...")
    
    prompt = KG_GENERATION_PROMPT.replace(
        "__DOCUMENT_TEXT_PLACEHOLDER__", 
        document_text[:60000]
    )
    
    response_text = llm_function(prompt)
    
    if not response_text or not response_text.strip():
        raise ValueError("LLM failed to generate knowledge graph content.")
        
    json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
    if not json_match:
        raise ValueError("LLM response did not contain a valid JSON object for the knowledge graph.")
    
    json_string = json_match.group(0)
    
    try:
        graph_data = json.loads(json_string)
        if "nodes" not in graph_data or "edges" not in graph_data:
            raise ValueError("Parsed JSON is missing 'nodes' or 'edges' keys.")
        
        logger.info(f"Successfully generated knowledge graph with {len(graph_data['nodes'])} nodes and {len(graph_data['edges'])} edges.")
        return graph_data
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON from LLM response for KG: {e}")
        raise ValueError("LLM returned invalid JSON format for the knowledge graph.") from e
```

`server/rag_service/neo4j_handler.py`

```python
# server/rag_service/neo4j_handler.py

import logging
from neo4j import GraphDatabase, exceptions as neo4j_exceptions
import config

logger = logging.getLogger(__name__)

# --- Neo4j Driver Management (No changes here) ---
_neo4j_driver = None
def init_driver():
    global _neo4j_driver
    if _neo4j_driver is not None:
        try: _neo4j_driver.verify_connectivity(); return
        except Exception: 
            if _neo4j_driver: _neo4j_driver.close()
            _neo4j_driver = None
    try:
        _neo4j_driver = GraphDatabase.driver(config.NEO4J_URI, auth=(config.NEO4J_USERNAME, config.NEO4J_PASSWORD))
        _neo4j_driver.verify_connectivity()
        logger.info(f"Neo4j driver initialized. Connected to: {config.NEO4J_URI}")
    except Exception as e:
        logger.critical(f"Failed to initialize Neo4j driver: {e}", exc_info=True)
        _neo4j_driver = None
def get_driver_instance():
    if _neo4j_driver is None: init_driver()
    if _neo4j_driver is None: raise ConnectionError("Neo4j driver is not available.")
    return _neo4j_driver
def close_driver():
    global _neo4j_driver
    if _neo4j_driver: _neo4j_driver.close(); _neo4j_driver = None
def check_neo4j_connectivity():
    try: get_driver_instance().verify_connectivity(); return True, "connected"
    except Exception as e: return False, f"disconnected: {e}"
def _execute_read_tx(tx_function, *args, **kwargs):
    with get_driver_instance().session(database=config.NEO4J_DATABASE) as session:
        return session.execute_read(tx_function, *args, **kwargs)
def _execute_write_tx(tx_function, *args, **kwargs):
    with get_driver_instance().session(database=config.NEO4J_DATABASE) as session:
        return session.execute_write(tx_function, *args, **kwargs)


# --- Private Transactional Cypher Functions ---
# (ingest/delete/add functions are correct and do not need changes)
def _delete_kg_transactional(tx, user_id, document_name):
    query = "MATCH (n:KnowledgeNode {userId: $userId, documentName: $documentName}) DETACH DELETE n"
    tx.run(query, userId=user_id, documentName=document_name)
    return True
def _add_nodes_transactional(tx, nodes_param, user_id, document_name):
    processed_nodes = [
        {"id": n["id"].strip(), "type": n.get("type", "concept"), "description": n.get("description", ""), "llm_parent_id": n.get("parent")}
        for n in nodes_param if isinstance(n.get("id"), str) and n.get("id").strip()
    ]
    if not processed_nodes: return 0
    query = """
    UNWIND $nodes_data as props MERGE (n:KnowledgeNode {nodeId: props.id, userId: $userId, documentName: $documentName})
    SET n += props, n.userId = $userId, n.documentName = $documentName RETURN count(n)
    """
    result = tx.run(query, nodes_data=processed_nodes, userId=user_id, documentName=document_name)
    return result.single()[0] if result.peek() else 0
def _add_edges_transactional(tx, edges_param, user_id, document_name):
    valid_edges = [
        {"from": e["from"].strip(), "to": e["to"].strip(), "relationship": e["relationship"].strip().upper().replace(" ", "_")}
        for e in edges_param if isinstance(e.get("from"), str) and e["from"].strip() and isinstance(e.get("to"), str) and e["to"].strip() and isinstance(e.get("relationship"), str) and e["relationship"].strip()
    ]
    if not valid_edges: return 0
    query = """
    UNWIND $edges_data as edge
    MATCH (startNode:KnowledgeNode {nodeId: edge.from, userId: $userId, documentName: $documentName})
    MATCH (endNode:KnowledgeNode {nodeId: edge.to, userId: $userId, documentName: $documentName})
    MERGE (startNode)-[r:RELATED_TO {type: edge.relationship}]->(endNode) RETURN count(r)
    """
    result = tx.run(query, edges_data=valid_edges, userId=user_id, documentName=document_name)
    return result.single()[0] if result.peek() else 0

# --- CORRECTED SEARCH AND GET QUERIES ---

def _search_kg_transactional(tx, user_id, document_name, query_text):
    logger.info(f"Neo4j TX: Searching KG for user '{user_id}', doc '{document_name}' with query: '{query_text[:50]}...'")
    
    query = """
    CALL db.index.fulltext.queryNodes("node_search_index", $query_text) YIELD node, score
    WHERE node.userId = $userId AND toLower(node.documentName) = toLower($documentName)
    WITH node, score ORDER BY score DESC LIMIT 5
    MATCH (node)-[r:RELATED_TO]-(neighbor)
    WHERE neighbor.userId = $userId AND toLower(neighbor.documentName) = toLower($documentName)
    RETURN node.nodeId AS nodeId, node.description AS description, 
           COLLECT(DISTINCT { relationship: r.type, neighborId: neighbor.nodeId }) AS relations
    """
    
    results = tx.run(query, userId=user_id, documentName=document_name, query_text=query_text)
    
    # --- THIS IS THE FIX ---
    # The f-string was changed to use double quotes on the outside,
    # so the inner single quotes don't need to be escaped.
    facts = []
    for record in results:
        fact = f"- Concept '{record['nodeId']}': {record['description']}"
        relations = [f"is '{rel['relationship']}' '{rel['neighborId']}'" for rel in record['relations'] if rel.get('relationship') and rel.get('neighborId')]
        if relations:
            fact += f" | It {', '.join(relations)}."
        facts.append(fact)
    # --- END OF FIX ---
        
    if not facts:
        return "No specific facts were found in the knowledge graph for this query."
        
    return "Facts from Knowledge Graph:\n" + "\n".join(facts)


def _get_kg_transactional(tx, user_id, document_name):
    logger.info(f"Neo4j TX: Retrieving FULL KG for visualization. User '{user_id}', Doc '{document_name}'")
    
    nodes_query = """
    MATCH (n:KnowledgeNode {userId: $userId}) WHERE toLower(n.documentName) = toLower($documentName)
    RETURN n.nodeId AS id, n.type AS type, n.description AS description, n.llm_parent_id AS parent
    """
    nodes_result = tx.run(nodes_query, userId=user_id, documentName=document_name)
    nodes_data = [dict(record) for record in nodes_result]

    edges_query = """
    MATCH (startNode:KnowledgeNode {userId: $userId})-[r:RELATED_TO]->(endNode:KnowledgeNode {userId: $userId})
    WHERE toLower(startNode.documentName) = toLower($documentName) AND toLower(endNode.documentName) = toLower($documentName)
    RETURN startNode.nodeId AS from, endNode.nodeId AS to, r.type AS relationship
    """
    edges_result = tx.run(edges_query, userId=user_id, documentName=document_name)
    edges_data = [dict(record) for record in edges_result]

    logger.info(f"Neo4j TX: Retrieved {len(nodes_data)} nodes and {len(edges_data)} edges for '{document_name}'.")
    return {"nodes": nodes_data, "edges": edges_data}


# --- Public Service Functions ---
def ingest_knowledge_graph(user_id: str, document_name: str, nodes: list, edges: list) -> dict:
    try:
        _execute_write_tx(_delete_kg_transactional, user_id, document_name)
        nodes_affected = _execute_write_tx(_add_nodes_transactional, nodes, user_id, document_name) if nodes else 0
        edges_affected = _execute_write_tx(_add_edges_transactional, edges, user_id, document_name) if edges else 0
        return {"success": True, "message": "KG ingested.", "nodes_affected": nodes_affected, "edges_affected": edges_affected}
    except Exception as e:
        logger.error(f"Error during KG ingestion for doc '{document_name}': {e}", exc_info=True)
        raise

def get_knowledge_graph(user_id: str, document_name: str) -> dict:
    try:
        kg_data = _execute_read_tx(_get_kg_transactional, user_id, document_name)
        if not kg_data or (not kg_data.get("nodes") and not kg_data.get("edges")):
            logger.info(f"No KG data found for user '{user_id}', document '{document_name}'.")
            return None
        return kg_data
    except Exception as e:
        logger.error(f"Error retrieving KG for doc '{document_name}': {e}", exc_info=True)
        raise

def delete_knowledge_graph(user_id: str, document_name: str) -> bool:
    try:
        return _execute_write_tx(_delete_kg_transactional, user_id, document_name)
    except Exception as e:
        logger.error(f"Error deleting KG for doc '{document_name}': {e}", exc_info=True)
        raise

def search_knowledge_graph(user_id: str, document_name: str, query_text: str) -> str:
    try:
        return _execute_read_tx(_search_kg_transactional, user_id, document_name, query_text)
    except Exception as e:
        logger.error(f"Error searching KG for doc '{document_name}', user '{user_id}': {e}", exc_info=True)
        return f"An error occurred while searching the knowledge graph: {e}"

```

`server/rag_service/podcast_generator.py`

```python

# server/rag_service/podcast_generator.py
import logging
import re
from gtts import gTTS

logger = logging.getLogger(__name__)

PODCAST_SCRIPT_PROMPT_TEMPLATE = """
You are an AI podcast script generator. Your SOLE task is to generate a realistic, two-speaker educational dialogue based on the provided text. The script should be substantial, aiming for a length of at least 600-800 words to ensure a meaningful discussion.

**CRITICAL INSTRUCTION:** Your entire output must be ONLY the script itself. Start directly with "SPEAKER_A:". Do NOT include any preamble, introduction, or metadata like "Here is the script:".

---
## Podcast Style Guide
- **Format**: Two-speaker conversational podcast.
- **SPEAKER_A**: The "Curious Learner". Asks clarifying questions and drives the conversation.
- **SPEAKER_B**: The "Expert Teacher". Provides clear, detailed explanations based on the document.
- **Dialogue Flow**: Natural back-and-forth. Create at least 5-7 exchanges.

---
## Task-Specific Instructions
- **Podcast Purpose**: {purpose_instruction}
- **Podcast Length**: {length_instruction}

---
## Source Material
**STUDY FOCUS (The main topic for the podcast):**
{study_focus}
**DOCUMENT TEXT (Use this for all factual answers):**
{document_content}
---
**FINAL SCRIPT OUTPUT (Remember: Start IMMEDIATELY with "SPEAKER_A:"):**
"""

def generate_podcast_script(source_document_text, outline_content, podcast_options, llm_function):
    """Generates a two-speaker podcast script using the LLM with dynamic options."""
    logger.info(f"Generating podcast script with options: {podcast_options}")

    purpose_map = {
        'introduction': "Focus on high-level concepts and definitions. Assume the listener is new to the topic. Keep explanations simple and clear.",
        'exam_prep': "Focus on key facts, data, and potential test questions. The dialogue should be structured like a Q&A review session, covering the most important material for an exam.",
        'deep_dive': "Explore the topic in great detail. Discuss nuances, complexities, and specific examples from the text. Assume the listener has some prior knowledge.",
        'review': "Provide a balanced overview of the main topics. Cover the most important points without getting lost in minor details. This is for general understanding."
    }
    
    length_map = {
        'quick': "The script should be concise, resulting in approximately 5-7 minutes of spoken audio. Aim for around 800-1000 words.",
        'standard': "The script should be of a standard length, resulting in approximately 10-15 minutes of spoken audio. Aim for around 1500-2000 words.",
        'comprehensive': "The script should be very detailed and long, resulting in approximately 15-25 minutes of spoken audio. Aim for over 2500 words."
    }

    purpose_instruction = purpose_map.get(podcast_options.get('studyPurpose'), purpose_map['review'])
    length_instruction = length_map.get(podcast_options.get('sessionLength'), length_map['standard'])

    prompt = PODCAST_SCRIPT_PROMPT_TEMPLATE.format(
        purpose_instruction=purpose_instruction,
        length_instruction=length_instruction,
        document_content=source_document_text[:60000],
        study_focus=outline_content,
    )
    
    script = llm_function(prompt)
    if not script or not script.strip():
        raise ValueError("LLM failed to generate a podcast script.")
    logger.info(f"LLM generated podcast script. Length: {len(script)}")
    return script

def synthesize_audio_with_gtts(text: str, output_path: str):
    """
    Synthesizes audio from text using the gTTS library and saves it as an MP3.
    """
    logger.info(f"Synthesizing audio with gTTS for text of length {len(text)}...")
    
    clean_text = re.sub(r'SPEAKER_[AB]:', '', text).replace('*', '').replace('#', '').strip()
    
    try:
        tts = gTTS(text=clean_text, lang='en', slow=False)
        tts.save(output_path)
        logger.info(f"gTTS audio saved successfully to {output_path}")
    except Exception as e:
        logger.error(f"gTTS failed during synthesis: {e}", exc_info=True)
        raise IOError("Text-to-Speech synthesis with gTTS failed.") from e

```

`server/rag_service/prompts.py`

```python
# server/rag_service/prompts.py

CODE_ANALYSIS_PROMPT_TEMPLATE = """
You are an expert software engineer and code reviewer. Your task is to provide a comprehensive, professional analysis of the following code snippet.

**Analysis Sections (Use Markdown headings for each):**
1.  **Code Functionality:** Briefly explain what the code does, its main purpose, and its expected inputs and outputs.
2.  **Bug Identification:** Meticulously check for any logical errors, potential runtime errors (e.g., division by zero, index out of bounds), or security vulnerabilities. If you find any, explain the bug clearly. If not, state that no obvious bugs were found.
3.  **Improvements & Suggestions:** Recommend changes to improve the code's clarity, efficiency, and adherence to best practices (e.g., better variable names, more efficient algorithms, error handling).

**Formatting:**
- Use clear Markdown for structure.
- For code suggestions, use fenced code blocks with the correct language identifier.

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
```{language}
{code}```
---

**ANALYSIS REPORT:**
"""

TEST_CASE_GENERATION_PROMPT_TEMPLATE = """
You are a meticulous Quality Assurance (QA) engineer. Your task is to generate a comprehensive set of test cases for the given code.

**Instructions:**
1.  Analyze the code to understand its logic, inputs, and outputs.
2.  Create a diverse set of test cases that cover:
    -   **Standard Cases:** Common, expected inputs.
    -   **Edge Cases:** Boundary values, empty inputs, zeros, negative numbers, etc.
    -   **Error Cases:** Invalid inputs that should cause the program to handle an error gracefully (if applicable).
3.  Your entire output **MUST** be a single, valid JSON array of objects.
4.  Each object in the array must have two keys: `input` (a string) and `expectedOutput` (a string).
5.  For inputs that require multiple lines, use the newline character `\\n`.

**Example Output Format:**
[
  {{ "input": "5\\n10", "expectedOutput": "15" }},
  {{ "input": "0\\n0", "expectedOutput": "0" }},
  {{ "input": "-5\\n5", "expectedOutput": "0" }}
]

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
```{language}
{code}
"""


EXPLAIN_ERROR_PROMPT_TEMPLATE = """
You are an expert programming tutor, specializing in explaining complex errors to beginners. Your task is to explain the following runtime error in a clear, step-by-step manner.
Instructions:
Identify the Root Cause: Analyze the error message in the context of the provided code to determine the exact reason for the error.
Explain the Error: Describe what the error message means in simple terms. Avoid jargon where possible, or explain it if necessary.
Pinpoint the Location: State which line(s) of code are causing the problem.
Provide a Solution: Give a corrected version of the problematic code in a fenced code block and explain why the fix works.
Offer General Advice: Provide a concluding tip to help the user avoid similar errors in the future.
Formatting:
Use clear Markdown headings for each section (e.g., ## What Went Wrong, ## How to Fix It).
Use fenced code blocks for all code snippets.
LANGUAGE:
{language}
CODE WITH THE ERROR:
Generated {language}
{code}
Use code with caution.
{language}
ERROR MESSAGE:
Generated code
{error_message}
Use code with caution.
ERROR EXPLANATION:
"""
```

`server/rag_service/requirements.txt`

```
# server/rag_service/requirements.txt
flask
requests
# faiss-cpu # or faiss-gpu
langchain
langchain-huggingface
pypdf
PyPDF2
python-docx
python-dotenv
ollama # Keep if using Ollama embeddings
python-pptx
uuid
langchain-community
pdfplumber
fitz # PyMuPDF for PDF parsing
pytesseract
nltk
spacy-layout
pandas
numpy
typing
pytesseract # OCR
pillow
qdrant-client
neo4j
sentence_transformers
spacy
opencv-python
duckduckgo-search
python-pptx
python-docx
reportlab
google-generativeai
gTTS



```

`server/rag_service/speech_enhancer.py`

```python
# server/rag_service/speech_enhancer.py
import speech_recognition as sr
import logging
import io

logger = logging.getLogger(__name__)

recognizer = sr.Recognizer()

def transcribe_audio_from_wav_bytes(audio_bytes: bytes) -> str:
    """
    Transcribes audio from an in-memory WAV byte buffer using Google's free API.
    Note: The input MUST be WAV format bytes.
    """
    logger.info("Transcribing audio using SpeechRecognition (Google Web Speech API free tier)...")
    try:
        # The library's AudioFile class can read from a file-like object (the byte buffer)
        with sr.AudioFile(io.BytesIO(audio_bytes)) as source:
            audio_data = recognizer.record(source)
            text = recognizer.recognize_google(audio_data)
            logger.info(f"Transcription successful. Length: {len(text)}")
            return text
    except sr.UnknownValueError:
        logger.warning("Google Speech Recognition could not understand audio.")
        raise ValueError("Could not understand the audio. It may be silent or unclear.")
    except sr.RequestError as e:
        logger.error(f"Could not request results from Google Speech Recognition service; {e}")
        raise ConnectionError(f"Speech recognition service request failed: {e}")
    except Exception as e:
        logger.error(f"An unexpected error occurred during transcription: {e}", exc_info=True)
        raise

ENHANCEMENT_PROMPT_TEMPLATE = """
You are an expert academic editor and content strategist.
You have been given a raw, unedited transcription of a spoken audio clip. You also have the full source document the speaker was referencing.

Your task is to **enhance the raw transcription** into a polished, professional, and insightful script. You MUST adhere to these rules:
1.  **Correct Errors:** Fix any grammatical errors, stutters, or awkward phrasing from the raw transcription.
2.  **Add Academic Depth:** Seamlessly integrate key facts, data, or concepts from the provided **SOURCE DOCUMENT TEXT** to add depth and accuracy to the speaker's points.
3.  **Maintain Speaker's Voice:** The output should still sound like a natural, spoken script, not a dense academic paper. Keep the original intent and tone.
4.  **Output Only the Polished Script:** Your entire response must be ONLY the final, enhanced script text. Do not include any preambles like "Here is the enhanced script:".

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**RAW AUDIO TRANSCRIPTION (To be enhanced):**
{raw_transcription}
---

**FINAL, ENHANCED SCRIPT (Start immediately with the first sentence):**
"""

def enhance_script_with_llm(raw_transcription: str, source_document_text: str, llm_function) -> str:
    """Uses an LLM to enhance a raw transcription with context from a source document."""
    logger.info("Enhancing transcribed script using LLM...")
    
    prompt = ENHANCEMENT_PROMPT_TEMPLATE.format(
        source_document_text=source_document_text[:40000], # Limit context to avoid excessive token usage
        raw_transcription=raw_transcription
    )
    
    enhanced_script = llm_function(prompt)
    if not enhanced_script or not enhanced_script.strip():
        raise ValueError("LLM failed to generate the enhanced script.")
        
    logger.info(f"LLM generated enhanced script. Length: {len(enhanced_script)}")
    return enhanced_script
```

`server/rag_service/vector_db_service.py`

```python
import uuid
import logging
from typing import List, Dict, Tuple, Optional, Any

from qdrant_client import QdrantClient, models
from sentence_transformers import SentenceTransformer

# Assuming vector_db_service.py and config.py are in the same package directory (e.g., rag_service/)
# and you run your application as a module (e.g., python -m rag_service.main_app)
# or have otherwise correctly set up the Python path.
import config # Changed to relative import

# Configure basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Document: # For search result formatting
    def __init__(self, page_content: str, metadata: dict):
        self.page_content = page_content
        self.metadata = metadata

    def to_dict(self):
        return {"page_content": self.page_content, "metadata": self.metadata}

class VectorDBService:
    def __init__(self):
        logger.info("Initializing VectorDBService...")
        logger.info(f"  Qdrant Host: {config.QDRANT_HOST}, Port: {config.QDRANT_PORT}, URL: {config.QDRANT_URL}")
        logger.info(f"  Collection: {config.QDRANT_COLLECTION_NAME}")
        logger.info(f"  Query Embedding Model: {config.QUERY_EMBEDDING_MODEL_NAME}")
        
        # The vector dimension for the Qdrant collection is defined by the DOCUMENT embedding model
        # This is set in config.QDRANT_COLLECTION_VECTOR_DIM
        self.vector_dim = config.QDRANT_COLLECTION_VECTOR_DIM
        logger.info(f"  Service expects Vector Dim for Qdrant collection: {self.vector_dim} (from document model config)")

        if config.QDRANT_URL:
            self.client = QdrantClient(
                url=config.QDRANT_URL,
                api_key=config.QDRANT_API_KEY,
                timeout=30
            )
        else:
            self.client = QdrantClient(
                host=config.QDRANT_HOST,
                port=config.QDRANT_PORT,
                api_key=config.QDRANT_API_KEY,
                timeout=30
            )

        try:
            # This model is for encoding search queries.
            # Its output dimension MUST match self.vector_dim (QDRANT_COLLECTION_VECTOR_DIM).
            logger.info(f"  Loading query embedding model: '{config.QUERY_EMBEDDING_MODEL_NAME}'")
            self.model = SentenceTransformer(config.QUERY_EMBEDDING_MODEL_NAME)
            model_embedding_dim = self.model.get_sentence_embedding_dimension()
            logger.info(f"  Query model loaded. Output dimension: {model_embedding_dim}")

            if model_embedding_dim != self.vector_dim:
                error_msg = (
                    f"CRITICAL DIMENSION MISMATCH: Query model '{config.QUERY_EMBEDDING_MODEL_NAME}' "
                    f"outputs embeddings of dimension {model_embedding_dim}, but the Qdrant collection "
                    f"is configured for dimension {self.vector_dim} (derived from document model: "
                    f"'{config.DOCUMENT_EMBEDDING_MODEL_NAME}'). Search functionality will fail. "
                    "Ensure query and document models produce compatible embedding dimensions, "
                    "or environment variables for dimensions are correctly set."
                )
                logger.error(error_msg)
                raise ValueError(error_msg) # Critical error, stop initialization
            else:
                logger.info(f"  Query model output dimension ({model_embedding_dim}) matches "
                            f"Qdrant collection dimension ({self.vector_dim}).")

        except Exception as e:
            logger.error(f"Error initializing SentenceTransformer model '{config.QUERY_EMBEDDING_MODEL_NAME}' for query encoding: {e}", exc_info=True)
            raise # Re-raise to prevent service startup with a non-functional query encoder

        self.collection_name = config.QDRANT_COLLECTION_NAME
        # No ThreadPoolExecutor needed here if document encoding is external

    def _recreate_qdrant_collection(self):
        logger.info(f"Attempting to (re)create collection '{self.collection_name}' with vector size {self.vector_dim}.")
        try:
            self.client.recreate_collection(
                collection_name=self.collection_name,
                vectors_config=models.VectorParams(
                    size=self.vector_dim,
                    distance=models.Distance.COSINE,
                ),
            )
            logger.info(f"Collection '{self.collection_name}' (re)created successfully.")
        except Exception as e_recreate:
            logger.error(f"Failed to (re)create collection '{self.collection_name}': {e_recreate}", exc_info=True)
            raise

    def setup_collection(self):
        try:
            collection_info = self.client.get_collection(collection_name=self.collection_name)
            logger.info(f"Collection '{self.collection_name}' already exists.")
            
            # Handle different Qdrant client versions for accessing vector config
            current_vectors_config = None
            if hasattr(collection_info.config.params, 'vectors'): # For simple vector config
                if isinstance(collection_info.config.params.vectors, models.VectorParams):
                     current_vectors_config = collection_info.config.params.vectors
                elif isinstance(collection_info.config.params.vectors, dict): # For named vectors
                    # Assuming default unnamed vector or first one if named
                    default_vector_name = '' # Common for single vector setup
                    if default_vector_name in collection_info.config.params.vectors:
                        current_vectors_config = collection_info.config.params.vectors[default_vector_name]
                    elif collection_info.config.params.vectors: # Get first one if default not found
                        current_vectors_config = next(iter(collection_info.config.params.vectors.values()))

            if not current_vectors_config:
                 logger.error(f"Could not determine vector configuration for existing collection '{self.collection_name}'. Recreating.")
                 self._recreate_qdrant_collection()
            elif current_vectors_config.size != self.vector_dim:
                logger.warning(f"Collection '{self.collection_name}' vector size {current_vectors_config.size} "
                               f"differs from service's expected {self.vector_dim}. Recreating.")
                self._recreate_qdrant_collection()
            elif current_vectors_config.distance != models.Distance.COSINE: # Ensure distance is also checked
                logger.warning(f"Collection '{self.collection_name}' distance {current_vectors_config.distance} "
                               f"differs from expected {models.Distance.COSINE}. Recreating.")
                self._recreate_qdrant_collection()
            else:
                logger.info(f"Collection '{self.collection_name}' configuration is compatible (Size: {current_vectors_config.size}, Distance: {current_vectors_config.distance}).")

        except Exception as e: # Broad exception for Qdrant client errors
            # More specific check for "Not found" type errors
            if "not found" in str(e).lower() or \
               (hasattr(e, 'status_code') and e.status_code == 404) or \
               " ভাগ্যবান" in str(e).lower(): # "Lucky" in Bengali, seems to be part of an error message you encountered
                 logger.info(f"Collection '{self.collection_name}' not found. Attempting to create...")
            else:
                 logger.warning(f"Error checking collection '{self.collection_name}': {type(e).__name__} - {e}. Attempting to (re)create anyway...")
            self._recreate_qdrant_collection()

    def add_processed_chunks(self, processed_chunks: List[Dict[str, Any]]) -> int:
        if not processed_chunks:
            logger.warning("add_processed_chunks received an empty list. No points to upsert.")
            return 0

        points_to_upsert = []
        doc_name_for_logging = "Unknown Document"

        for chunk_data in processed_chunks:
            point_id = chunk_data.get('id', str(uuid.uuid4()))
            vector = chunk_data.get('embedding')
            
            payload = chunk_data.get('metadata', {}).copy()
            payload['chunk_text_content'] = chunk_data.get('text_content', '')

            if not doc_name_for_logging or doc_name_for_logging == "Unknown Document":
                doc_name_for_logging = payload.get('original_name', payload.get('document_name', "Unknown Document"))

            if not vector:
                logger.warning(f"Chunk with ID '{point_id}' from '{doc_name_for_logging}' is missing 'embedding'. Skipping.")
                continue
            if not isinstance(vector, list) or not all(isinstance(x, (float, int)) for x in vector): # Allow int too, SentenceTransformer can return float32 which might be int-like in lists
                logger.warning(f"Chunk with ID '{point_id}' from '{doc_name_for_logging}' has an invalid 'embedding' format. Skipping.")
                continue
            if len(vector) != self.vector_dim:
                logger.error(f"Chunk with ID '{point_id}' from '{doc_name_for_logging}' has embedding dimension {len(vector)}, "
                             f"but collection expects {self.vector_dim}. Skipping. "
                             f"Ensure ai_core's document embedding model ('{config.DOCUMENT_EMBEDDING_MODEL_NAME}') "
                             f"output dimension matches configuration.")
                continue

            points_to_upsert.append(models.PointStruct(
                id=point_id,
                vector=[float(v) for v in vector], # Ensure all are floats for Qdrant
                payload=payload
            ))

        if not points_to_upsert:
            logger.warning(f"No valid points constructed from processed_chunks for document: {doc_name_for_logging}.")
            return 0

        try:
            self.client.upsert(collection_name=self.collection_name, points=points_to_upsert, wait=True) # wait=True can be useful for debugging
            logger.info(f"Successfully upserted {len(points_to_upsert)} chunks for document: {doc_name_for_logging} into Qdrant.")
            return len(points_to_upsert)
        except Exception as e:
            logger.error(f"Error upserting processed chunks to Qdrant for document: {doc_name_for_logging}: {e}", exc_info=True)
            raise

    def search_documents(self, query: str, k: int = -1, filter_conditions: Optional[models.Filter] = None) -> Tuple[List[Document], str, Dict]:
        # Use default k from config if not provided or invalid
        if k <= 0:
            k_to_use = config.QDRANT_DEFAULT_SEARCH_K
        else:
            k_to_use = k

        context_docs = []
        formatted_context_text = "No relevant context was found in the available documents."
        context_docs_map = {}

        logger.info(f"Searching with query (first 50 chars): '{query[:50]}...', k: {k_to_use}")
        if filter_conditions:
            try: filter_dict = filter_conditions.dict()
            except AttributeError: # For older Pydantic versions
                try: filter_dict = filter_conditions.model_dump()
                except AttributeError: filter_dict = str(filter_conditions) # Fallback
            logger.info(f"Applying filter: {filter_dict}")
        else:
            logger.info("No filter applied for search.")

        try:
            query_embedding = self.model.encode(query).tolist()
            logger.debug(f"Generated query_embedding (length: {len(query_embedding)}, first 5 dims: {query_embedding[:5]})")

            search_results = self.client.search(
                collection_name=self.collection_name,
                query_vector=query_embedding,
                query_filter=filter_conditions,
                limit=k_to_use,
                with_payload=True,
                score_threshold=config.QDRANT_SEARCH_MIN_RELEVANCE_SCORE # Apply score threshold directly in search
            )
            logger.info(f"Qdrant client.search returned {len(search_results)} results (after score threshold).")

            if not search_results:
                return context_docs, formatted_context_text, context_docs_map

            for idx, point in enumerate(search_results):
                # Score threshold is already applied by Qdrant if score_threshold parameter is used.
                # If not using score_threshold in client.search, uncomment this:
                # if point.score < config.QDRANT_SEARCH_MIN_RELEVANCE_SCORE:
                #     logger.debug(f"Skipping point ID {point.id} with score {point.score:.4f} (below threshold {config.QDRANT_SEARCH_MIN_RELEVANCE_SCORE})")
                #     continue

                payload = point.payload
                content = payload.get("chunk_text_content", payload.get("text_content", payload.get("chunk_text", "")))

                retrieved_metadata = payload.copy()
                retrieved_metadata["qdrant_id"] = point.id
                retrieved_metadata["score"] = point.score

                doc = Document(page_content=content, metadata=retrieved_metadata)
                context_docs.append(doc)

            # Format context and citations
            formatted_context_parts = []
            for i, doc_obj in enumerate(context_docs):
                citation_index = i + 1
                doc_meta = doc_obj.metadata
                # Use more robust fetching of metadata keys
                display_subject = doc_meta.get("title", doc_meta.get("subject", "Unknown Subject")) # Prefer title for subject
                doc_name = doc_meta.get("original_name", doc_meta.get("file_name", "N/A"))
                page_num_info = f" (Page: {doc_meta.get('page_number', 'N/A')})" if doc_meta.get('page_number') else "" # Add page number if available
                
                content_preview = doc_obj.page_content[:200] + "..." if len(doc_obj.page_content) > 200 else doc_obj.page_content

                formatted = (f"[{citation_index}] Score: {doc_meta.get('score', 0.0):.4f} | "
                             f"Source: {doc_name}{page_num_info} | Subject: {display_subject}\n"
                             f"Content: {content_preview}") # Show content preview
                formatted_context_parts.append(formatted)

                context_docs_map[str(citation_index)] = {
                    "subject": display_subject,
                    "document_name": doc_name,
                    "page_number": doc_meta.get("page_number"),
                    "content_preview": content_preview, # Store preview
                    "full_content": doc_obj.page_content, # Store full content for potential later use
                    "score": doc_meta.get("score", 0.0),
                    "qdrant_id": doc_meta.get("qdrant_id"),
                    "original_metadata": doc_meta # Store all original metadata from payload
                }
            if formatted_context_parts:
                formatted_context_text = "\n\n---\n\n".join(formatted_context_parts)
            else:
                formatted_context_text = "No sufficiently relevant context was found after filtering."

        except Exception as e:
            logger.error(f"Qdrant search/RAG error: {e}", exc_info=True)
            formatted_context_text = "Error retrieving context due to an internal server error."

        return context_docs, formatted_context_text, context_docs_map
    
    # Add this method to the VectorDBService class in vector_db_service.py

    def delete_document_vectors(self, user_id: str, document_name: str) -> Dict[str, Any]:
        logger.info(f"Attempting to delete vectors for document: '{document_name}', user: '{user_id}' from Qdrant collection '{self.collection_name}'.")
        
        # These metadata keys must match what's stored during ingestion from ai_core.py
        # 'processing_user' was the user_id passed to ai_core
        # 'file_name' was the original_name passed to ai_core
        qdrant_filter = models.Filter(
            must=[
                models.FieldCondition(
                    key="processing_user", # The metadata field storing the user ID
                    match=models.MatchValue(value=user_id)
                ),
                models.FieldCondition(
                    key="file_name", # The metadata field storing the original document name
                    match=models.MatchValue(value=document_name)
                )
            ]
        )
        
        try:
            # Optional: Count points before deleting for logging/confirmation
            # count_response = self.client.count(collection_name=self.collection_name, count_filter=qdrant_filter)
            # num_to_delete = count_response.count
            # logger.info(f"Qdrant: Found {num_to_delete} points matching criteria for document '{document_name}', user '{user_id}'.")

            # if num_to_delete == 0:
            #     logger.info(f"Qdrant: No points found to delete for document '{document_name}', user '{user_id}'.")
            #     return {"success": True, "message": "No matching vectors found in Qdrant to delete.", "deleted_count": 0}

            delete_result = self.client.delete(
                collection_name=self.collection_name,
                points_selector=models.FilterSelector(filter=qdrant_filter),
                wait=True # Make it synchronous
            )
            
            # Check the status of the delete operation
            # delete_result should be an UpdateResult object
            if delete_result.status == models.UpdateStatus.COMPLETED or delete_result.status == models.UpdateStatus.ACKNOWLEDGED:
                # The actual number of deleted points isn't directly returned by filter-based delete.
                # We can infer it was successful if no error.
                # For a precise count, you'd need to list IDs by filter, then delete by IDs.
                logger.info(f"Qdrant delete operation for document '{document_name}', user '{user_id}' acknowledged/completed. Status: {delete_result.status}")
                return {"success": True, "message": f"Qdrant vector deletion for document '{document_name}' completed. Status: {delete_result.status}."}
            else:
                logger.warning(f"Qdrant delete operation for document '{document_name}', user '{user_id}' returned status: {delete_result.status}")
                return {"success": False, "message": f"Qdrant delete operation status: {delete_result.status}"}

        except Exception as e:
            logger.error(f"Error deleting document vectors from Qdrant for document '{document_name}', user '{user_id}': {e}", exc_info=True)
            # Check for specific Qdrant client errors if possible, e.g., if the collection doesn't exist.
            return {"success": False, "message": f"Failed to delete Qdrant vectors: {str(e)}"}

    def close(self):
        logger.info("VectorDBService close called.")
        # No specific resources like ThreadPoolExecutor to release in this version.
        # QdrantClient does not have an explicit close() method in recent versions.
```

`server/rag_service/__init__.py`

```python

```

`server/routes/admin.js`

```javascript
// server/routes/admin.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const fsPromises = fs.promises;
const AdminDocument = require('../models/AdminDocument');
const axios = require('axios');
const User = require('../models/User');
const ChatHistory = require('../models/ChatHistory');
const { cacheMiddleware } = require('../middleware/cacheMiddleware');
const { encrypt } = require('../utils/crypto');

const router = express.Router();
const CACHE_DURATION_SECONDS = 30; 
// --- NEW Dashboard Stats Route ---
// @route   GET /api/admin/dashboard-stats
// @desc    Get key statistics for the admin dashboard
router.get('/dashboard-stats',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const [totalUsers, totalAdminDocs, totalSessions, pendingApiKeys] = await Promise.all([
            User.countDocuments(),
            AdminDocument.countDocuments(),
            ChatHistory.countDocuments(),
            User.countDocuments({ apiKeyRequestStatus: 'pending' })
        ]);

        res.json({
            totalUsers,
            totalAdminDocs,
            totalSessions,
            pendingApiKeys
        });
    } catch (error) {
        console.error('Error fetching dashboard stats:', error);
        res.status(500).json({ message: 'Server error while fetching dashboard stats.' });
    }
});


// --- API Key Management Routes ---

// @route   GET /api/admin/key-requests
// @desc    Get all users with a pending API key request
router.get('/key-requests',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const requests = await User.find({ apiKeyRequestStatus: 'pending' })
            .select('email profile createdAt')
            .sort({ createdAt: -1 });
        res.json(requests);
    } catch (error) {
        console.error('Error fetching API key requests:', error);
        res.status(500).json({ message: 'Server error while fetching requests.' });
    }
});

// @route   POST /api/admin/key-requests/approve
// @desc    Approve a user's API key request
router.post("/key-requests/approve", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "User ID is required." });
  }

  try {
    const serverApiKey = process.env.GEMINI_API_KEY;
    if (!serverApiKey) {
      return res
        .status(500)
        .json({ message: "Server-side GEMINI_API_KEY is not configured." });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    user.encryptedApiKey = serverApiKey; // pre-save hook handles encryption
    user.apiKeyRequestStatus = "approved";
    user.preferredLlmProvider = "gemini";

    await user.save();

    res.json({
      message: `API key request for ${user.email} has been approved.`,
    });
  } catch (error) {
    console.error(`Error approving API key for user ${userId}:`, error);
    res.status(500).json({ message: "Server error while approving request." });
  }
});

// @route   POST /api/admin/key-requests/reject
// @desc    Reject a user's API key request
router.post("/key-requests/reject", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "User ID is required." });
  }

  try {
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    user.apiKeyRequestStatus = "rejected";
    await user.save();

    res.json({
      message: `API key request for ${user.email} has been rejected.`,
    });
  } catch (error) {
    console.error(`Error rejecting API key for user ${userId}:`, error);
    res.status(500).json({ message: "Server error while rejecting request." });
  }
});

// --- Document Management Routes ---

const ADMIN_UPLOAD_DIR_BASE = path.join(
  __dirname,
  "..",
  "assets",
  "_admin_uploads_"
);
const MAX_FILE_SIZE = 20 * 1024 * 1024;
const allowedAdminMimeTypes = {
  "application/pdf": "docs",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
    "docs",
  "text/plain": "docs",
  "text/markdown": "docs",
};
const allowedAdminExtensions = [".pdf", ".docx", ".txt", ".md"];

const adminStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const fileMimeType = file.mimetype.toLowerCase();
    const fileTypeSubfolder = allowedAdminMimeTypes[fileMimeType] || "others";
    const destinationPath = path.join(ADMIN_UPLOAD_DIR_BASE, fileTypeSubfolder);
    fs.mkdir(destinationPath, { recursive: true }, (err) => {
      if (err) return cb(err);
      cb(null, destinationPath);
    });
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const fileExt = path.extname(file.originalname).toLowerCase();
    const sanitizedBaseName = path
      .basename(file.originalname, fileExt)
      .replace(/[^a-zA-Z0-9._-]/g, "_")
      .substring(0, 100);
    cb(null, `${timestamp}-${sanitizedBaseName}${fileExt}`);
  },
});
const adminFileFilter = (req, file, cb) => {
  const fileExt = path.extname(file.originalname).toLowerCase();
  const mimeType = file.mimetype.toLowerCase();
  if (
    allowedAdminMimeTypes[mimeType] &&
    allowedAdminExtensions.includes(fileExt)
  ) {
    cb(null, true);
  } else {
    const error = new multer.MulterError("LIMIT_UNEXPECTED_FILE_TYPE_ADMIN");
    error.message = `Invalid file type. Allowed: ${allowedAdminExtensions.join(
      ", "
    )}`;
    cb(error, false);
  }
};
const adminUpload = multer({ storage: adminStorage, fileFilter: adminFileFilter, limits: { fileSize: MAX_FILE_SIZE }});
async function triggerPythonRagProcessingForAdmin(filePath, originalName) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        return { success: false, message: "Python service URL not configured.", text: null, chunksForKg: [] };
    }
    const addDocumentUrl = `${pythonServiceUrl}/add_document`;
    try {
        const response = await axios.post(addDocumentUrl, {
            user_id: "admin",
            file_path: filePath, original_name: originalName
        }, { timeout: 300000 });
        
        const text = response.data?.raw_text_for_analysis || null;
        const chunksForKg = response.data?.chunks_with_metadata || [];
        const isSuccess = !!(text && text.trim());
        return { 
            success: isSuccess, 
            message: response.data?.message || "Python RAG service call completed.", 
            text: text,
            chunksForKg: chunksForKg
        };
    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Unknown error calling Python RAG.";
        return { success: false, message: `Python RAG call failed: ${errorMsg}`, text: null, chunksForKg: [] };
    }
}
async function callPythonDeletionEndpoint(
  method,
  endpointPath,
  userId,
  originalName
) {
  const pythonServiceUrl =
    process.env.PYTHON_RAG_SERVICE_URL || "http://localhost:5000";
  const deleteUrl = `${pythonServiceUrl.replace(/\/$/, "")}${endpointPath}`;
  try {
    await axios.delete(deleteUrl, {
      data: { user_id: userId, document_name: originalName },
      timeout: 30000,
    });
    return {
      success: true,
      message: `Successfully requested deletion from ${endpointPath}`,
    };
  } catch (error) {
    return {
      success: false,
      message: `Python service call failed for ${endpointPath}: ${error.message}`,
    };
  }
}

// @route   POST /api/admin/documents/upload
router.post(
  "/documents/upload",
  adminUpload.single("file"),
  async (req, res) => {
    if (!req.file) {
      return res
        .status(400)
        .json({ message: "No file uploaded or file type rejected." });
    }
    const {
      filename: serverFilename,
      originalname: originalName,
      path: tempServerPath,
    } = req.file;
    let adminDocRecord;
    try {
      if (await AdminDocument.exists({ originalName: originalName })) {
        await fsPromises.unlink(tempServerPath);
        return res
          .status(409)
          .json({ message: `Document '${originalName}' already exists.` });
      }

      const ragResult = await triggerPythonRagProcessingForAdmin(
        tempServerPath,
        originalName
      );
      if (!ragResult.success) {
        await fsPromises.unlink(tempServerPath);
        return res.status(422).json({ message: ragResult.message });
      }

      adminDocRecord = new AdminDocument({
        filename: serverFilename,
        originalName: originalName,
        text: ragResult.text,
      });
      await adminDocRecord.save();
      await fsPromises.unlink(tempServerPath);

      res.status(202).json({
        message: `Admin document '${originalName}' uploaded. Background processing initiated.`,
      });

      const { Worker } = require("worker_threads");
      const analysisWorker = new Worker(
        path.resolve(__dirname, "..", "workers", "adminAnalysisWorker.js"),
        {
          workerData: {
            adminDocumentId: adminDocRecord._id.toString(),
            originalName: originalName,
            textForAnalysis: ragResult.text,
          },
        }
      );
      analysisWorker.on("error", (err) =>
        console.error(
          `Admin Analysis Worker Error [Doc: ${originalName}]:`,
          err
        )
      );

      if (ragResult.chunksForKg && ragResult.chunksForKg.length > 0) {
        const kgWorker = new Worker(
          path.resolve(__dirname, "..", "workers", "kgWorker.js"),
          {
            workerData: {
              adminDocumentId: adminDocRecord._id.toString(),
              userId: "admin",
              originalName: originalName,
              chunksForKg: ragResult.chunksForKg,
              llmProvider: "gemini",
            },
          }
        );
        kgWorker.on("error", (err) =>
          console.error(`Admin KG Worker Error [Doc: ${originalName}]:`, err)
        );
      } else {
        console.warn(
          `[Admin Upload] No chunks for KG processing for '${originalName}'.`
        );
        await AdminDocument.updateOne(
          { _id: adminDocRecord._id },
          { $set: { kgStatus: "skipped_no_chunks" } }
        );
      }
    } catch (error) {
      console.error(
        `Admin Upload: Overall error for '${
          originalName || req.file?.originalname
        }':`,
        error
      );
      if (tempServerPath && fs.existsSync(tempServerPath))
        await fsPromises.unlink(tempServerPath).catch(() => {});
      if (!res.headersSent) {
        res
          .status(500)
          .json({ message: "Server error during admin document upload." });
      }
    }
  }
);

// @route   GET /api/admin/documents
router.get('/documents',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const adminDocs = await AdminDocument.find().sort({ uploadedAt: -1 })
            .select('originalName filename uploadedAt analysisUpdatedAt analysis.faq analysis.topics analysis.mindmap');
        const documentsList = adminDocs.map(doc => ({
            originalName: doc.originalName, serverFilename: doc.filename, uploadedAt: doc.uploadedAt,
            analysisUpdatedAt: doc.analysisUpdatedAt,
            hasFaq: !!(doc.analysis?.faq?.trim()),
            hasTopics: !!(doc.analysis?.topics?.trim()),
            hasMindmap: !!(doc.analysis?.mindmap?.trim()),
        }));
        res.json({ documents: documentsList });
    } catch (error) {
        res.status(500).json({ message: 'Server error fetching admin documents.' });
    }
});

// @route   DELETE /api/admin/documents/:serverFilename
router.delete("/documents/:serverFilename", async (req, res) => {
  const { serverFilename } = req.params;
  if (!serverFilename) {
    return res.status(400).json({ message: "Server filename is required." });
  }
  try {
    const docToDelete = await AdminDocument.findOne({
      filename: serverFilename,
    });
    if (!docToDelete) {
      return res
        .status(404)
        .json({ message: `Admin document '${serverFilename}' not found.` });
    }

    const originalName = docToDelete.originalName;
    const userId = "admin";

    await callPythonDeletionEndpoint(
      "DELETE",
      `/delete_qdrant_document_data`,
      userId,
      originalName
    );
    await callPythonDeletionEndpoint(
      "DELETE",
      `/kg/${userId}/${encodeURIComponent(originalName)}`,
      userId,
      originalName
    );
    await AdminDocument.deleteOne({ _id: docToDelete._id });

    res
      .status(200)
      .json({
        message: `Admin document '${originalName}' and all associated data deleted.`,
      });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Server error during admin document deletion." });
  }
});

// @route   GET /api/admin/documents/:serverFilename/analysis
router.get("/documents/:serverFilename/analysis", async (req, res) => {
  const { serverFilename } = req.params;
  if (!serverFilename)
    return res
      .status(400)
      .json({ message: "Server filename parameter is required." });
  try {
    const adminDoc = await AdminDocument.findOne({
      filename: serverFilename,
    }).select("originalName analysis analysisUpdatedAt");
    if (!adminDoc)
      return res
        .status(404)
        .json({ message: `Admin document '${serverFilename}' not found.` });
    res.status(200).json({
      originalName: adminDoc.originalName,
      analysis: adminDoc.analysis || { faq: "", topics: "", mindmap: "" },
      analysisUpdatedAt: adminDoc.analysisUpdatedAt,
    });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Server error retrieving admin document analysis." });
  }
});

// @route   GET /api/admin/documents/by-original-name/:originalName/analysis
router.get(
  "/documents/by-original-name/:originalName/analysis",
  async (req, res) => {
    const { originalName } = req.params;
    if (!originalName)
      return res
        .status(400)
        .json({ message: "Original name parameter is required." });
    try {
      const decodedOriginalName = decodeURIComponent(originalName);
      const adminDoc = await AdminDocument.findOne({
        originalName: decodedOriginalName,
      }).select("originalName filename analysis analysisUpdatedAt");
      if (!adminDoc) {
        return res
          .status(404)
          .json({
            message: `Admin document '${decodedOriginalName}' not found.`,
          });
      }
      res.status(200).json({
        originalName: adminDoc.originalName,
        serverFilename: adminDoc.filename,
        analysis: adminDoc.analysis || { faq: "", topics: "", mindmap: "" },
        analysisUpdatedAt: adminDoc.analysisUpdatedAt,
      });
    } catch (error) {
      res
        .status(500)
        .json({
          message: "Server error while retrieving analysis by original name.",
        });
    }
  }
);

// --- User & Chat Management Routes ---

// @route   GET /api/admin/users-with-chats
// @desc    Get all users and their chat session summaries
router.get('/users-with-chats',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const allHistories = await ChatHistory.find({})
            .populate('userId', 'email profile.name')
            .sort({ updatedAt: -1 })
            .lean();

        const usersMap = new Map();

        for (const session of allHistories) {
            if (!session.userId) continue;

            const userId = session.userId._id.toString();

            if (!usersMap.has(userId)) {
                usersMap.set(userId, {
                    user: {
                        _id: userId,
                        email: session.userId.email,
                        name: session.userId.profile?.name || 'N/A'
                    },
                    sessions: []
                });
            }

            const userEntry = usersMap.get(userId);
            userEntry.sessions.push({
                sessionId: session.sessionId,
                updatedAt: session.updatedAt,
                summary: session.summary || 'No summary available.',
                messageCount: session.messages?.length || 0
            });
        }

        res.json(Array.from(usersMap.values()));

    } catch (error) {
        console.error('Error fetching users with chat summaries:', error);
        res.status(500).json({ message: 'Server error while fetching user chat data.' });
    }
});


module.exports = router;

```

`server/routes/analysis.js`

```javascript
// server/routes/analysis.js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');
const User = require('../models/User');

// @route   GET /api/analysis/:documentFilename
// @desc    Get analysis data (faq, topics, mindmap) for a specific document
// @access  Private (requires auth)
router.get('/:documentFilename', authMiddleware, async (req, res) => {
    const userId = req.user._id; // From authMiddleware
    const { documentFilename } = req.params;
    
    if (!documentFilename) {
        return res.status(400).json({ message: 'Document filename parameter is required.' });
    }

    try {
        const user = await User.findById(userId).select('uploadedDocuments');
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }

        const document = user.uploadedDocuments.find(doc => doc.filename === documentFilename);

        if (!document) {
            return res.status(404).json({ message: `Document '${documentFilename}' not found for this user.` });
        }

        if (!document.analysis) {
            // This case might happen if the analysis object itself is missing, though schema has defaults.
            console.warn(`Analysis object missing for document '${documentFilename}', user '${userId}'. Sending empty analysis.`);
            return res.status(200).json({
                faq: "",
                topics: "",
                mindmap: ""
            });
        }
        
        // Send the analysis sub-document
        res.status(200).json(document.analysis);

    } catch (error) {
        console.error(`Error fetching analysis for document '${documentFilename}', user '${userId}':`, error);
        res.status(500).json({ message: 'Server error while retrieving document analysis.' });
    }
});

module.exports = router;
```

`server/routes/auth.js`

```javascript
// server/routes/auth.js
const express = require('express');
const jwt = require('jsonwebtoken');
const { v4: uuidv4 } = require('uuid');
const User = require('../models/User');
const { authMiddleware } = require('../middleware/authMiddleware');
require('dotenv').config();

const router = express.Router();
const JWT_EXPIRATION = process.env.JWT_EXPIRATION || '7d';

// --- @route   POST /api/auth/signup ---
router.post('/signup', async (req, res) => {
  // --- FIX START ---
  // 1. Destructure the 'requestAdminKey' field from the request body.
  const { email, password, apiKey, ollamaUrl, preferredLlmProvider, requestAdminKey } = req.body;
  // --- FIX END ---

  if (!email || !password) {
    return res.status(400).json({ message: 'Email and password are required.' });
  }
  if (!/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/.test(email)) {
    return res.status(400).json({ message: 'Please provide a valid email address.' });
  }
  if (password.length < 6) {
     return res.status(400).json({ message: 'Password must be at least 6 characters long.' });
  }

  // --- FIX START ---
  // 2. Adjust validation logic: An API key is only required if the user *doesn't* request one from the admin.
  if (preferredLlmProvider === 'gemini' && !requestAdminKey && (!apiKey || apiKey.trim() === '')) {
    return res.status(400).json({ message: 'A Gemini API Key is required when one is not being requested from the admin.' });
  }
  // --- FIX END ---
  
  if (preferredLlmProvider === 'ollama' && (!ollamaUrl || ollamaUrl.trim() === '')) {
    return res.status(400).json({ message: 'An Ollama URL is required when Ollama is selected.' });
  }

  try {
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'An account with this email already exists.' });
    }

     const newUser = new User({
      email,
      username: email.split('@')[0],
      password,
      preferredLlmProvider: preferredLlmProvider || 'gemini',
      apiKeyRequestStatus: requestAdminKey ? 'pending' : 'none',
      encryptedApiKey: requestAdminKey ? null : (preferredLlmProvider === 'gemini' ? apiKey : null),
      ollamaUrl: (preferredLlmProvider === 'ollama') ? ollamaUrl.trim() : '',
    });
    
    await newUser.save();

    const payload = {
      userId: newUser._id,
      email: newUser.email,
      username: newUser.username,
    };
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: JWT_EXPIRATION });

    res.status(201).json({
      token,
      _id: newUser._id,
      email: newUser.email,
      username: newUser.username,
      sessionId: uuidv4(),
      message: "User registered successfully",
    });
  } catch (error) {
    console.error('Signup Error:', error);
    if (error.code === 11000 || error.message.includes('duplicate key error collection')) {
        return res.status(400).json({ message: 'An account with this email already exists.' });
    }
    if (error.name === 'ValidationError') {
        const messages = Object.values(error.errors).map(val => val.message);
        return res.status(400).json({ message: messages.join(', ') });
    }
    res.status(500).json({ message: 'Server error during signup.' });
  }
});

// --- @route   POST /api/auth/signin ---
router.post('/signin', async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ message: 'Please provide email and password.' });
  }

  try {
    const ADMIN_EMAIL = process.env.FIXED_ADMIN_USERNAME || 'admin@admin.com';
    const ADMIN_PASSWORD = process.env.FIXED_ADMIN_PASSWORD || 'admin123';

    if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
        console.log("Admin login successful via special auth check.");
        return res.status(200).json({
            isAdminLogin: true,
            message: 'Admin login successful',
        });
    }

    const user = await User.findByCredentials(email, password);
    if (!user) {
      return res.status(401).json({ message: 'Invalid email address or password.' });
    }

    const payload = { userId: user._id, email: user.email };
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: JWT_EXPIRATION });

    res.status(200).json({
      token,
      _id: user._id,
      email: user.email,
      username: user.username,
      sessionId: uuidv4(),
      message: "Login successful",
    });
  } catch (error) {
    console.error('Signin Error:', error);
    res.status(500).json({ message: 'Server error during signin.' });
  }
});

// --- @route   GET /api/auth/me ---
router.get('/me', authMiddleware, async (req, res) => {
  if (!req.user) {
    return res.status(401).json({ message: 'Not authorized.' });
  }
  res.status(200).json({
    _id: req.user._id,
    email: req.user.email,
    username: req.user.username,
  });
});

module.exports = router;
```

`server/routes/chat.js`

```javascript
// server/routes/chat.js
const express = require('express');
const { v4: uuidv4 } = require('uuid');
const ChatHistory = require('../models/ChatHistory');
const User = require('../models/User');
const { createOrUpdateSummary } = require('../services/summarizationService');
const { processAgenticRequest } = require('../services/agentService');
const { decrypt } = require('../utils/crypto');
const { redisClient } = require('../config/redisClient');
const router = express.Router();

function doesQuerySuggestRecall(query) {
    const lowerCaseQuery = query.toLowerCase();
    const recallKeywords = [
        'my name', 'my profession', 'i am', 'i told you',
        'remember', 'recall', 'remind me', 'go back to',
        'previously', 'before', 'we discussed', 'we were talking about',
        'earlier', 'yesterday', 'last session',
        'what did i say', 'what was', 'what were', 'who am i',
        'do you know', 'can you tell me again',
        'continue with', 'let\'s continue', 'pick up where we left off',
    ];
    return recallKeywords.some(keyword => lowerCaseQuery.includes(keyword));
}

router.post('/message', async (req, res) => {
    const {
        query, sessionId, useWebSearch, useAcademicSearch,
        systemPrompt: clientProvidedSystemInstruction, criticalThinkingEnabled,
        documentContextName, filter
    } = req.body;
    
    const userId = req.user._id;

    if (!query || typeof query !== 'string' || query.trim() === '') {
        return res.status(400).json({ message: 'Query message text required.' });
    }
    if (!sessionId || typeof sessionId !== 'string') {
        return res.status(400).json({ message: 'Session ID required.' });
    }

    const userMessageForDb = { role: 'user', parts: [{ text: query }], timestamp: new Date() };
    console.log(`>>> POST /api/chat/message (AGENTIC): User=${userId}, Session=${sessionId}, Query: "${query.substring(0, 50)}..."`);
    try {
        const [chatSession, user] = await Promise.all([
            ChatHistory.findOne({ sessionId: sessionId, userId: userId }),
            User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaModel ollamaUrl').lean()
        ]);

        const llmProvider = user?.preferredLlmProvider || 'gemini';
        const ollamaModel = user?.ollamaModel || process.env.OLLAMA_DEFAULT_MODEL;

        const historyFromDb = chatSession ? chatSession.messages : [];
        const summaryFromDb = chatSession ? chatSession.summary || "" : "";
        
        const historyForLlm = [];

        if (summaryFromDb && doesQuerySuggestRecall(query.trim())) {
            historyForLlm.push({ 
                role: 'user', 
                parts: [{ text: `CONTEXT (Summary of Past Conversations): """${summaryFromDb}"""` }] 
            });
            historyForLlm.push({ 
                role: 'model', 
                parts: [{ text: "Understood. I will use this context if the user's query is about our past conversations." }] 
            });
        }

        const formattedDbMessages = historyFromDb.map(msg => ({
            role: msg.role, parts: msg.parts.map(part => ({ text: part.text || '' }))
        }));
        historyForLlm.push(...formattedDbMessages);
        
        const requestContext = {
            documentContextName,
            criticalThinkingEnabled,
            filter,
            llmProvider,
            ollamaModel,
            isWebSearchEnabled: !!useWebSearch,
            isAcademicSearchEnabled: !!useAcademicSearch,
            userId: userId.toString(),
            ollamaUrl: user.ollamaUrl
        };

        if (llmProvider === 'gemini') {
            const userApiKey = user.encryptedApiKey ? decrypt(user.encryptedApiKey) : null;
            requestContext.apiKey = userApiKey;
        }

        const agentResponse = await processAgenticRequest(
            query.trim(),
            historyForLlm,
            clientProvidedSystemInstruction,
            requestContext
        );

        const aiMessageForDbAndClient = {
            sender: 'bot', role: 'model',
            parts: [{ text: agentResponse.finalAnswer }],
            text: agentResponse.finalAnswer,
            timestamp: new Date(),
            thinking: null,
            references: agentResponse.references || [],
            source_pipeline: agentResponse.sourcePipeline,
        };

        await ChatHistory.findOneAndUpdate(
            { sessionId: sessionId, userId: userId },
            { $push: { messages: { $each: [userMessageForDb, aiMessageForDbAndClient] } }, $set: { updatedAt: new Date() } },
            { upsert: true, new: true, setDefaultsOnInsert: true }
        );
        if (redisClient && redisClient.isOpen) {
            const cacheKey = `session:${sessionId}`;
            await redisClient.del(cacheKey);
        }
        console.log(`<<< POST /api/chat/message (AGENTIC) successful for Session ${sessionId}.`);
        res.status(200).json({ reply: aiMessageForDbAndClient });

    } catch (error) {
        console.error(`!!! Error processing agentic chat message for Session ${sessionId}:`, error);
        const statusCode = error.status || 500;
        const clientMessage = error.message || "Failed to get response from AI service.";
        
        const errorMessageForChat = {
            sender: 'bot', role: 'model',
            parts: [{ text: `Error: ${clientMessage}` }], text: `Error: ${clientMessage}`,
            timestamp: new Date(), thinking: `Agentic flow error: ${error.message}`,
            references: [], source_pipeline: 'error-agent-pipeline'
        };
        
        try {
            await ChatHistory.findOneAndUpdate(
                { sessionId: sessionId, userId: userId },
                { $push: { messages: { $each: [userMessageForDb, errorMessageForChat] } }, $set: { updatedAt: new Date() } },
                { upsert: true, new: true, setDefaultsOnInsert: true }
            );
        } catch (dbError) {
            console.error(`!!! CRITICAL: Failed to save error message to chat history for Session ${sessionId}:`, dbError);
        }
        res.status(statusCode).json({ message: clientMessage, reply: errorMessageForChat });
    }
});

router.post('/history', async (req, res) => {
    const { previousSessionId } = req.body;
    const userId = req.user._id;
    const newSessionId = uuidv4();
    let contextSummaryForNewSession = "";

    try {
        const user = await User.findById(userId).select('preferredLlmProvider ollamaModel ollamaUrl +encryptedApiKey').lean();
        const llmProvider = user?.preferredLlmProvider || 'gemini';
        const ollamaModel = user?.ollamaModel || process.env.OLLAMA_DEFAULT_MODEL;
        const userOllamaUrl = user?.ollamaUrl || null;
        let userApiKey = null;
        if (llmProvider === 'gemini') {
            userApiKey = user.encryptedApiKey ? decrypt(user.encryptedApiKey) : null;
        }

        // --- THIS IS THE FIX ---
        // 1. If there was a previous session, summarize IT and save that summary.
        if (previousSessionId) {
            const previousSession = await ChatHistory.findOne({ sessionId: previousSessionId, userId: userId });
            if (previousSession && previousSession.messages?.length > 0) {
                console.log(`[New Chat] Summarizing previous session ${previousSessionId} before creating new one.`);
                const summaryForOldSession = await createOrUpdateSummary(
                    previousSession.messages,
                    previousSession.summary, // Pass its own summary in case it's a continuation
                    llmProvider, ollamaModel, userApiKey, userOllamaUrl
                );
                
                // Save the generated summary to the *old* session document.
                previousSession.summary = summaryForOldSession;
                await previousSession.save();
                console.log(`[New Chat] Saved summary to previous session ${previousSessionId}.`);
            }
        }
        
        // 2. Now, create a new, broader summary for the NEW session's context.
        // This gives the new session memory of the last 5 conversations.
        const lastSessions = await ChatHistory.find({ userId: userId }).sort({ updatedAt: -1 }).limit(5).select('messages').lean();
        if (lastSessions && lastSessions.length > 0) {
            const messagesForNewSummary = lastSessions.flatMap(session => session.messages);
            if (messagesForNewSummary.length > 0) {
                 console.log(`[New Chat] Creating context summary for new session from the last ${lastSessions.length} sessions.`);
                contextSummaryForNewSession = await createOrUpdateSummary(
                    messagesForNewSummary, null, llmProvider, ollamaModel, userApiKey, userOllamaUrl
                );
            }
        }
        // --- END OF FIX ---

    } catch (summaryError) {
        console.error(`Could not create summary from last sessions:`, summaryError);
    }
    
    try {
        await ChatHistory.create({ userId, sessionId: newSessionId, messages: [], summary: contextSummaryForNewSession });
        res.status(200).json({ message: 'New session started.', newSessionId });
    } catch (dbError) {
        res.status(500).json({ message: 'Failed to create new session.' });
    }
});

router.get('/sessions', async (req, res) => {
    try {
        const sessions = await ChatHistory.find({ userId: req.user._id }).sort({ updatedAt: -1 }).select('sessionId createdAt updatedAt messages').lean();
        const sessionSummaries = sessions.map(session => {
            const firstUserMessage = session.messages?.find(m => m.role === 'user');
            let preview = firstUserMessage?.parts?.[0]?.text?.substring(0, 75) || 'Chat Session';
            if (preview.length === 75) preview += '...';
            return { sessionId: session.sessionId, createdAt: session.createdAt, updatedAt: session.updatedAt, messageCount: session.messages?.length || 0, preview: preview };
        });
        res.status(200).json(sessionSummaries);
    } catch (error) {
        res.status(500).json({ message: 'Failed to retrieve chat sessions.' });
    }
});

router.get('/session/:sessionId', async (req, res) => {
    const { sessionId } = req.params;
    const userId = req.user._id;
    const cacheKey = `session:${sessionId}`;
    const CACHE_TTL_SECONDS = 3600;
    try {
        // 1. Check Redis Cache First
        if (redisClient && redisClient.isOpen) {
            const cachedSession = await redisClient.get(cacheKey);
            if (cachedSession) {
                console.log(`[Chat History] Cache HIT for session ${sessionId}`);
                return res.status(200).json(JSON.parse(cachedSession));
            }
            console.log(`[Chat History] Cache MISS for session ${sessionId}`);
        }

        // 2. If miss, fetch from MongoDB
        const session = await ChatHistory.findOne({ sessionId, userId }).lean();
        if (!session) {
            return res.status(404).json({ message: 'Chat session not found.' });
        }
        
        const messagesForFrontend = (session.messages || []).map(msg => ({ 
            id: msg._id || uuidv4(), 
            sender: msg.role === 'model' ? 'bot' : 'user', 
            text: msg.parts?.[0]?.text || '', 
            thinking: msg.thinking, 
            references: msg.references, 
            timestamp: msg.timestamp, 
            source_pipeline: msg.source_pipeline 
        }));
        
        const responsePayload = { ...session, messages: messagesForFrontend };

        // 3. Store the result in Redis for next time
        if (redisClient && redisClient.isOpen) {
            redisClient.setEx(cacheKey, CACHE_TTL_SECONDS, JSON.stringify(responsePayload)).catch(err => {
                console.error(`Redis SETEX error for session ${sessionId}:`, err);
            });
        }

        res.status(200).json(responsePayload);
    } catch (error) {
        res.status(500).json({ message: 'Failed to retrieve chat session.' });
    }
});

router.delete('/session/:sessionId', async (req, res) => {
    const { sessionId } = req.params;
    const userId = req.user._id;
    try {
        const result = await ChatHistory.deleteOne({ sessionId: sessionId, userId: userId });
        if (redisClient && redisClient.isOpen) {
            const cacheKey = `session:${sessionId}`;
            await redisClient.del(cacheKey);
        }
        if (result.deletedCount === 0) {
            return res.status(404).json({ message: 'Chat session not found.' });
        }
        res.status(200).json({ message: 'Chat session deleted successfully.' });
    } catch (error) {
        res.status(500).json({ message: 'Server error while deleting chat session.' });
    }
});

module.exports = router;
```

`server/routes/export.js`

```javascript
// server/routes/export.js
const express = require('express');
const axios = require('axios');
const router = express.Router();
const User = require('../models/User');
const AdminDocument = require('../models/AdminDocument');
const { decrypt } = require('../utils/crypto');

router.post('/podcast', async (req, res) => {
    const { analysisContent, sourceDocumentName, podcastOptions } = req.body;
    const userId = req.user._id;

    if (!analysisContent || !sourceDocumentName || !podcastOptions) {
        return res.status(400).json({ message: 'analysisContent, sourceDocumentName, and podcastOptions are required.' });
    }

    try {
        let sourceDocumentText = null;
        let apiKeyForRequest = null;
        
        // Fetch the user to get their documents and encrypted API key
        const user = await User.findById(userId).select('uploadedDocuments.filename uploadedDocuments.text +encryptedApiKey');

        // Check user's documents first
        const userDoc = user?.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
        if (userDoc?.text) {
            sourceDocumentText = userDoc.text;
            if (user.encryptedApiKey) {
                apiKeyForRequest = decrypt(user.encryptedApiKey);
            }
        } else {
            // Fallback to checking admin documents
            const adminDoc = await AdminDocument.findOne({ originalName: sourceDocumentName }).select('text');
            if (adminDoc?.text) {
                sourceDocumentText = adminDoc.text;
                apiKeyForRequest = process.env.GEMINI_API_KEY; // Admin docs use server's key
            }
        }
        
        if (!sourceDocumentText) {
            return res.status(404).json({ message: `Source document '${sourceDocumentName}' not found.` });
        }
        if (!apiKeyForRequest) {
            return res.status(400).json({ message: "API Key for podcast generation is missing." });
        }

        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) {
            return res.status(500).json({ message: "Audio generation service is not configured." });
        }

        const generationUrl = `${pythonServiceUrl}/export_podcast`;
        
        console.log(`[Node Export] Forwarding HQ podcast request to Python with API Key.`);

        const pythonPayload = {
            sourceDocumentText: sourceDocumentText,
            analysisContent: analysisContent,
            podcastOptions: podcastOptions,
            api_key: apiKeyForRequest // <<< Pass the correct key
        };
        
        const fileResponse = await axios.post(generationUrl, pythonPayload, {
            responseType: 'stream',
            timeout: 600000 // 10 minute timeout
        });

        const safeFilename = sourceDocumentName.split('.')[0].replace(/[^a-zA-Z0-9]/g, '_');
        const finalFilename = `HQ_Podcast_${safeFilename}.mp3`;
        
        res.setHeader('Content-Disposition', `attachment; filename="${finalFilename}"`);
        res.setHeader('Content-Type', 'audio/mpeg');
        fileResponse.data.pipe(res);

    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Failed to generate podcast.";
        console.error(`[Node Export] Error proxying podcast generation: ${errorMsg}`);
        if (!res.headersSent) {
            res.status(error.response?.status || 500).json({ message: errorMsg });
        }
    }
});

module.exports = router;
```

`server/routes/files.js`

```javascript
// server/routes/files.js
const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const { authMiddleware } = require('../middleware/authMiddleware');
const User = require('../models/User');
const axios = require('axios');
const router = express.Router();

const ASSETS_DIR = path.join(__dirname, '..', 'assets');
const BACKUP_DIR = path.join(__dirname, '..', 'backup_assets');

// --- Helper functions (sanitizeUsernameForDir, parseServerFilename, ensureDirExists are existing) ---
const sanitizeUsernameForDir = (username) => {
    if (!username) return '';
    return username.replace(/[^a-zA-Z0-9_-]/g, '_');
};

const parseServerFilename = (filename) => {
    // Matches "timestamp-originalName.ext"
    // Allows originalName to contain dots now.
    const match = filename.match(/^(\d+)-(.+?)(\.\w+)$/);
    if (match && match.length === 4) {
        return { timestamp: match[1], originalName: `${match[2]}${match[3]}`, extension: match[3] };
    }
    // Fallback for names that might not perfectly fit the new pattern, or originalName without extension before timestamp
    const ext = path.extname(filename);
    const baseWithoutExt = filename.substring(0, filename.length - ext.length);
    const tsMatch = baseWithoutExt.match(/^(\d+)-(.*)$/);
    if (tsMatch) {
        return { timestamp: tsMatch[1], originalName: `${tsMatch[2]}${ext}`, extension: ext };
    }
    // Final fallback if no timestamp prefix is reliably parsed
    return { timestamp: null, originalName: filename, extension: path.extname(filename) };
};

const ensureDirExists = async (dirPath) => {
    try { await fs.mkdir(dirPath, { recursive: true }); }
    catch (error) { if (error.code !== 'EEXIST') { console.error(`Error creating dir ${dirPath}:`, error); throw error; } }
};

async function callPythonDeletionEndpoint(method, endpointPath, userId, originalName, logContext) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL || process.env.DEFAULT_PYTHON_RAG_URL || 'http://localhost:5000'; // Fallback if not set
    if (!pythonServiceUrl) {
        console.error(`Python Service Deletion Error for ${logContext}: PYTHON_RAG_SERVICE_URL not set.`);
        return { success: false, message: "Python service URL not configured." };
    }

    const deleteUrl = `${pythonServiceUrl.replace(/\/$/, '')}${endpointPath}`;

    try {
        console.log(`Calling Python Service (${method.toUpperCase()}) for deletion: ${deleteUrl} (Doc: ${originalName}, User: ${userId})`);
        let response;
        if (method.toUpperCase() === 'DELETE') {
            // For DELETE, data is often in query params or path, but axios allows a 'data' field for body
            response = await axios.delete(deleteUrl, {
                data: { // For Python endpoints that expect a body (like a new Qdrant delete one)
                    user_id: userId,
                    document_name: originalName
                },
                timeout: 30000 // 30s timeout
            });
        } else {
            throw new Error(`Unsupported method for Python deletion: ${method}`);
        }

        if (response.status === 200 || response.status === 204) { // 204 No Content is also success
            return { success: true, message: response.data?.message || `Successfully deleted from ${endpointPath}` };
        } else {
            return { success: false, message: response.data?.message || `Python service returned ${response.status} for ${endpointPath}` };
        }
    } catch (error) {
        const errorMsg = error.response?.data?.error || error.response?.data?.message || error.message || `Unknown error deleting from ${endpointPath}`;
        console.error(`Error calling Python Service for deletion (${deleteUrl}) for ${originalName} (User: ${userId}): ${errorMsg}`, error.response ? { status: error.response.status, data: error.response.data } : error);
        return { success: false, message: `Python service call failed for ${endpointPath}: ${errorMsg}` };
    }
}
// --- End Helper Functions ---


// --- @route   GET /api/files ---
// Use authMiddleware middleware 
// TO GET FILE NAMES
router.get('/', authMiddleware, async (req, res) => {
    
    const userFiles = []
    try {
        const userId = req.user._id.toString();

        // Find user by ID, select only uploadedDocuments to optimize
        const user = await User.findById(userId).select('uploadedDocuments');

        if (!user) return res.status(404).json({ msg: 'User not found' });

        // Extract filenames
        const filenames = user.uploadedDocuments
        .map(doc => doc.filename)
        .filter(Boolean)  // filter out undefined or null filenames just in case
        .reverse();       // reverse the order

        return res.json({ filenames });

    } catch (error) {
        console.log(error.message);
        return res.status(500).json({ msg: 'Server error' });
    }
});


// --- @route   DELETE /api/files/:serverFilename ---
// Use authMiddleware middleware
router.delete('/:serverFilename', authMiddleware, async (req, res) => {
  
    const { serverFilename } = req.params;
    const userId = req.user._id.toString(); // Get userId from authenticated user
    const usernameForLog = req.user.username;

    if (!serverFilename) {
        return res.status(400).json({ message: 'Server filename parameter is required.' });
    }

    const parsedFileDetails = parseServerFilename(serverFilename);
    const originalName = parsedFileDetails.originalName;
    if (!originalName) {
        console.error(`DELETE /api/files: Could not parse originalName from serverFilename: ${serverFilename}`);
        return res.status(400).json({ message: 'Invalid server filename format for deletion.' });
    }
    const logContext = `File: '${originalName}' (server: ${serverFilename}), User: ${usernameForLog} (${userId})`;
    console.log(`Attempting to delete all data for ${logContext}`);

    const results = {
        mongodb: { success: false, message: "Not attempted" },
        qdrant: { success: false, message: "Not attempted" },
        neo4j: { success: false, message: "Not attempted" },
        filesystem: { success: false, message: "Not attempted" },
    };
    let overallSuccess = true; // Assume success, set to false if any critical step fails
    let httpStatus = 200;
    let fileFoundInMongo = false;
    let physicalFileFound = false;

    try {
        // 1. Delete from MongoDB
        try {
            const user = await User.findById(userId);
            if (!user) {
                results.mongodb.message = "User not found.";
                // If user not found, we can't confirm if the file was theirs.
                // Treat as if the file wasn't found for this user.
            } else {
                const docIndex = user.uploadedDocuments.findIndex(doc => doc.filename === originalName);
                if (docIndex > -1) {
                    fileFoundInMongo = true;
                    user.uploadedDocuments.splice(docIndex, 1);
                    await user.save();
                    results.mongodb.success = true;
                    results.mongodb.message = "Successfully removed from user's document list.";
                    console.log(`MongoDB: Document entry '${originalName}' removed for user ${userId}.`);
                } else {
                    results.mongodb.message = "Document not found in user's list.";
                    console.log(`MongoDB: Document entry '${originalName}' not found for user ${userId}.`);
                }
            }
        } catch (mongoError) {
            console.error(`MongoDB Deletion Error for ${logContext}:`, mongoError);
            results.mongodb.message = `MongoDB deletion failed: ${mongoError.message}`;
            overallSuccess = false; // DB error is critical
        }

        // 2. Delete from Qdrant (via Python service)
        // This endpoint will need to be created in Python: e.g., /delete_qdrant_document_data
        // It should expect { user_id: userId, document_name: originalName } in the body
        const qdrantDeleteResult = await callPythonDeletionEndpoint(
            'DELETE',
            `/delete_qdrant_document_data`,
            userId,
            originalName,
            logContext
        );
        results.qdrant = qdrantDeleteResult;
        if (!qdrantDeleteResult.success) {
            console.warn(`Qdrant deletion failed or reported no data for ${logContext}. Message: ${qdrantDeleteResult.message}`);
            // overallSuccess = false; // Non-critical for now, but log
        }

        // 3. Delete from Neo4j (via Python service)
        // This uses the existing Python endpoint: /kg/<user_id>/<document_name>
        const neo4jEndpointPath = `/kg/${userId}/${encodeURIComponent(originalName)}`;
        const neo4jDeleteResult = await callPythonDeletionEndpoint(
            'DELETE',
            neo4jEndpointPath, // userId and originalName are in the path
            userId, // still pass for logging consistency in helper
            originalName, // still pass for logging consistency in helper
            logContext
        );
        results.neo4j = neo4jDeleteResult;
        if (!neo4jDeleteResult.success) {
            console.warn(`Neo4j deletion failed or reported no data for ${logContext}. Message: ${neo4jDeleteResult.message}`);
            // overallSuccess = false; // Non-critical for now, but log
        }

        // 4. Move physical file to backup (filesystem operation)
        let currentPath = null;
        let fileType = '';
        const fileTypesToSearch = ['docs', 'images', 'code', 'others'];
        const sanitizedUsernameForPath = sanitizeUsernameForDir(usernameForLog);

        for (const type of fileTypesToSearch) {
            const potentialPath = path.join(ASSETS_DIR, sanitizedUsernameForPath, type, serverFilename);
            try {
                await fs.access(potentialPath); // Check if file exists
                currentPath = potentialPath;
                fileType = type;
                physicalFileFound = true;
                break;
            } catch (e) {
                if (e.code !== 'ENOENT') {
                    console.warn(`Filesystem: Error accessing ${potentialPath} during delete scan: ${e.message}`);
                }
            }
        }

        if (currentPath) { // If physical file was found
            const backupUserDir = path.join(BACKUP_DIR, sanitizedUsernameForPath, fileType);
            await ensureDirExists(backupUserDir);
            const backupPath = path.join(backupUserDir, serverFilename);
            try {
                await fs.rename(currentPath, backupPath);
                results.filesystem = { success: true, message: "File moved to backup successfully." };
                console.log(`Filesystem: Moved '${currentPath}' to '${backupPath}'.`);
            } catch (fsError) {
                console.error(`Filesystem: Error moving file ${currentPath} to backup for ${logContext}:`, fsError);
                results.filesystem.message = `Filesystem move to backup failed: ${fsError.message}`;
                // overallSuccess = false; // Decide if this is critical enough to mark overall failure
            }
        } else {
            results.filesystem.message = "Physical file not found in assets, or already moved.";
            console.log(`Filesystem: Physical file '${serverFilename}' not found for user ${usernameForLog}.`);
        }

        // Determine final status and message
        const successfulDeletes = [results.mongodb.success, results.qdrant.success, results.neo4j.success, results.filesystem.success].filter(Boolean).length;

        if (!fileFoundInMongo && !physicalFileFound) {
            httpStatus = 404;
            finalMessage = `File '${originalName}' not found for user.`;
        } else if (results.mongodb.success) { // Primary record deleted
            if (successfulDeletes === 4) {
                finalMessage = `Successfully deleted all data associated with '${originalName}'.`;
                httpStatus = 200;
            } else {
                finalMessage = `File '${originalName}' removed from your list. Some backend data cleanup attempts had issues. Check server logs for details.`;
                httpStatus = 207; // Multi-Status
            }
        } else { // MongoDB deletion failed, but file might have existed
            finalMessage = `Failed to remove '${originalName}' from your list. Some backend data cleanup may have also failed. Check server logs.`;
            httpStatus = 500;
        }

        console.log(`Deletion outcome for ${logContext}: HTTP Status=${httpStatus}, Overall Success Flag (was pre-status logic)=${overallSuccess}`);
        return res.status(httpStatus).json({
            message: finalMessage,
            details: results
        });

    } catch (error) {
        console.error(`!!! UNEXPECTED Error in DELETE /api/files/${serverFilename} for user ${usernameForLog}:`, error);
        return res.status(500).json({
            message: 'An unexpected server error occurred during file deletion.',
            details: results // Send partial results if any
        });
    }
});


module.exports = router;

```

`server/routes/generation.js`

```javascript
// // server/routes/generation.js
// const express = require('express');
// const axios = require('axios');
// const router = express.Router();

// // This route is protected by authMiddleware applied in server.js

// // @route   POST /api/generate/document
// // @desc    Generate a document (PPTX or DOCX) by proxying to the Python service.
// // @access  Private
// router.post('/document', async (req, res) => {
//     const { markdownContent, docType } = req.body;

//     if (!markdownContent || !docType) {
//         return res.status(400).json({ message: 'markdownContent and docType are required.' });
//     }

//     const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
//     if (!pythonServiceUrl) {
//         console.error("[Generation Route] PYTHON_RAG_SERVICE_URL is not set.");
//         return res.status(500).json({ message: "Document generation service is not configured." });
//     }

//     const generationUrl = `${pythonServiceUrl}/generate_document`;
//     console.log(`[Generation Route] Forwarding request to Python service: ${generationUrl}`);

//     try {
//         const pythonResponse = await axios.post(generationUrl, {
//             markdownContent,
//             docType
//         }, { timeout: 60000 }); // 1 minute timeout for generation

//         if (pythonResponse.data && pythonResponse.data.success) {
//             const filename = pythonResponse.data.filename;
//             // Construct the full download URL for the client
//             const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;
            
//             res.status(200).json({
//                 success: true,
//                 downloadUrl: downloadUrl,
//                 filename: filename
//             });
//         } else {
//             throw new Error(pythonResponse.data.error || "Unknown error from generation service.");
//         }
//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
//         console.error(`[Generation Route] Error calling Python service: ${errorMsg}`);
//         res.status(500).json({ message: errorMsg });
//     }
// });

// module.exports = router;














// // server/routes/generation.js
// const express = require('express');
// const axios = require('axios');
// const router = express.Router();
// const User = require('../models/User'); // <-- Import User model

// // This route is protected by authMiddleware applied in server.js

// // @route   POST /api/generate/document
// // @desc    Generate a document (PPTX or DOCX) by proxying to the Python service.
// // @access  Private
// router.post('/document', async (req, res) => {
//     // --- MODIFIED: Destructure new fields ---
//     const { markdownContent, docType, sourceDocumentName } = req.body;
//     const userId = req.user._id;

//     if (!markdownContent || !docType || !sourceDocumentName) {
//         return res.status(400).json({ message: 'markdownContent, docType, and sourceDocumentName are required.' });
//     }

//     try {
//         // --- NEW: Fetch the full text of the source document ---
//         const user = await User.findById(userId).select('uploadedDocuments');
//         if (!user) {
//             return res.status(404).json({ message: 'User not found.' });
//         }
//         const sourceDocument = user.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
//         if (!sourceDocument || !sourceDocument.text) {
//             return res.status(404).json({ message: `Source document '${sourceDocumentName}' or its text content not found.` });
//         }
//         const sourceDocumentText = sourceDocument.text;
//         // --- END NEW ---

//         const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
//         if (!pythonServiceUrl) {
//             console.error("[Generation Route] PYTHON_RAG_SERVICE_URL is not set.");
//             return res.status(500).json({ message: "Document generation service is not configured." });
//         }

//         const generationUrl = `${pythonServiceUrl}/generate_document`;
//         console.log(`[Generation Route] Forwarding request to Python service: ${generationUrl}`);

//         const pythonResponse = await axios.post(generationUrl, {
//             markdownContent, // This is the outline (e.g., FAQ, Key Topics)
//             docType,
//             sourceDocumentText // Pass the full text for context
//         }, { timeout: 300000 }); // Increased timeout to 5 minutes for LLM generation

//         if (pythonResponse.data && pythonResponse.data.success) {
//             const filename = pythonResponse.data.filename;
//             const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;
            
//             res.status(200).json({
//                 success: true,
//                 downloadUrl: downloadUrl,
//                 filename: filename
//             });
//         } else {
//             throw new Error(pythonResponse.data.error || "Unknown error from generation service.");
//         }
//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
//         console.error(`[Generation Route] Error: ${errorMsg}`);
//         res.status(500).json({ message: errorMsg });
//     }
// });

// module.exports = router;










// // server/routes/generation.js
// const express = require('express');
// const axios = require('axios');
// const router = express.Router();
// const User = require('../models/User');
// const AdminDocument = require('../models/AdminDocument'); // <-- Import AdminDocument model

// // This route is protected by authMiddleware applied in server.js

// // @route   POST /api/generate/document
// // @desc    Generate a document (PPTX or DOCX) by proxying to the Python service.
// // @access  Private
// router.post('/document', async (req, res) => {
//     const { markdownContent, docType, sourceDocumentName } = req.body;
//     const userId = req.user._id;

//     if (!markdownContent || !docType || !sourceDocumentName) {
//         return res.status(400).json({ message: 'markdownContent, docType, and sourceDocumentName are required.' });
//     }

//     try {
//         let sourceDocumentText = null;

//         // --- NEW UNIFIED DOCUMENT RETRIEVAL LOGIC ---
//         // 1. First, try to find the document in the user's personal documents.
//         const user = await User.findById(userId).select('uploadedDocuments');
//         if (user) {
//             const userDocument = user.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
//             if (userDocument && userDocument.text) {
//                 sourceDocumentText = userDocument.text;
//                 console.log(`[Generation Route] Found source text in user's documents for: ${sourceDocumentName}`);
//             }
//         }

//         // 2. If not found in user's docs, try to find it in the Admin documents.
//         if (!sourceDocumentText) {
//             console.log(`[Generation Route] Not found in user docs. Checking admin 'Subjects' for: ${sourceDocumentName}`);
//             const adminDocument = await AdminDocument.findOne({ originalName: sourceDocumentName }).select('text');
//             if (adminDocument && adminDocument.text) {
//                 sourceDocumentText = adminDocument.text;
//                 console.log(`[Generation Route] Found source text in admin documents for: ${sourceDocumentName}`);
//             }
//         }
//         // --- END UNIFIED LOGIC ---
        
//         // 3. If still not found after checking both, return an error.
//         if (!sourceDocumentText) {
//             return res.status(404).json({ message: `Source document '${sourceDocumentName}' not found.` });
//         }

//         const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
//         if (!pythonServiceUrl) {
//             console.error("[Generation Route] PYTHON_RAG_SERVICE_URL is not set.");
//             return res.status(500).json({ message: "Document generation service is not configured." });
//         }

//         const generationUrl = `${pythonServiceUrl}/generate_document`;
//         console.log(`[Generation Route] Forwarding request to Python service: ${generationUrl}`);

//         const pythonResponse = await axios.post(generationUrl, {
//             markdownContent,
//             docType,
//             sourceDocumentText // Pass the full text from whichever source it was found
//         }, { timeout: 300000 });

//         if (pythonResponse.data && pythonResponse.data.success) {
//             const filename = pythonResponse.data.filename;
//             const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;
            
//             res.status(200).json({
//                 success: true,
//                 downloadUrl: downloadUrl,
//                 filename: filename
//             });
//         } else {
//             throw new Error(pythonResponse.data.error || "Unknown error from generation service.");
//         }
//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
//         console.error(`[Generation Route] Error: ${errorMsg}`);
//         res.status(500).json({ message: errorMsg });
//     }
// });

// module.exports = router;









// server/routes/generation.js
const express = require('express');
const axios = require('axios');
const router = express.Router();
const User = require('../models/User');
const AdminDocument = require('../models/AdminDocument');

router.post('/document', async (req, res) => {
    const { markdownContent, docType, sourceDocumentName } = req.body;
    const userId = req.user._id;

    if (!markdownContent || !docType || !sourceDocumentName) {
        return res.status(400).json({ message: 'markdownContent, docType, and sourceDocumentName are required.' });
    }

    try {
        let sourceDocumentText = null;

        const user = await User.findById(userId).select('uploadedDocuments');
        if (user) {
            const userDocument = user.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
            if (userDocument && userDocument.text) {
                sourceDocumentText = userDocument.text;
            }
        }

        if (!sourceDocumentText) {
            const adminDocument = await AdminDocument.findOne({ originalName: sourceDocumentName }).select('text');
            if (adminDocument && adminDocument.text) {
                sourceDocumentText = adminDocument.text;
            }
        }
        
        if (!sourceDocumentText) {
            return res.status(404).json({ message: `Source document '${sourceDocumentName}' not found.` });
        }

        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) {
            return res.status(500).json({ message: "Document generation service is not configured." });
        }

        const generationUrl = `${pythonServiceUrl}/generate_document`;
        
        // 1. Ask Python to generate the document and get the filename
        const genResponse = await axios.post(generationUrl, {
            markdownContent, docType, sourceDocumentText
        }, { timeout: 300000 });

        if (!genResponse.data || !genResponse.data.success) {
            throw new Error(genResponse.data.error || "Python service failed to generate the document.");
        }

        const filename = genResponse.data.filename;
        const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;

        // 2. Fetch the generated document from Python as a stream (blob)
        console.log(`[Generation Route] Fetching generated file from Python: ${downloadUrl}`);
        const fileResponse = await axios.get(downloadUrl, {
            responseType: 'stream'
        });

        // 3. Stream the file directly back to the client
        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);
        res.setHeader('Content-Type', fileResponse.headers['content-type']);
        fileResponse.data.pipe(res);

    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
        console.error(`[Generation Route] Error: ${errorMsg}`);
        res.status(500).json({ message: errorMsg });
    }
});

module.exports = router;
```

`server/routes/kg.js`

```javascript
// server/routes/kg.js
const express = require('express');
const router = express.Router();
const axios = require('axios');
const User = require('../models/User');
const AdminDocument = require('../models/AdminDocument');
const { decrypt } = require('../utils/crypto');

router.get('/visualize/:documentName', async (req, res) => {
    const { documentName } = req.params;
    const currentUserId = req.user._id;

    if (!documentName) {
        return res.status(400).json({ message: 'Document name is required.' });
    }

    try {
        let sourceDocumentText = null;
        let apiKeyForRequest = null;
        
        // We need to fetch the user to get their encrypted API key
        const user = await User.findById(currentUserId).select('uploadedDocuments.filename uploadedDocuments.text +encryptedApiKey');

        // Check if the requested document belongs to the user
        const userDoc = user?.uploadedDocuments.find(doc => doc.filename === documentName);
        
        if (userDoc?.text) {
            sourceDocumentText = userDoc.text;
            // Decrypt the key if the document is a user document
            if (user.encryptedApiKey) {
                apiKeyForRequest = decrypt(user.encryptedApiKey);
            }
        } else {
            // If not a user document, check if it's an admin document (Subject)
            const adminDoc = await AdminDocument.findOne({ originalName: documentName }).select('text');
            if (adminDoc?.text) {
                sourceDocumentText = adminDoc.text;
                // For admin docs, use the server's global API key
                apiKeyForRequest = process.env.GEMINI_API_KEY;
            }
        }
        
        if (!sourceDocumentText) {
            return res.status(404).json({ message: `Source document '${documentName}' not found.` });
        }

        if (!apiKeyForRequest) {
             return res.status(400).json({ message: "API Key for document processing is missing." });
        }

        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) {
            return res.status(500).json({ message: "Knowledge Graph service is not configured." });
        }
        
        const getKgUrl = `${pythonServiceUrl}/generate_kg_from_text`;
        
        console.log(`[KG Visualize] Proxying request to Python with API Key for KG generation.`);
        
        const pythonResponse = await axios.post(getKgUrl, {
            document_text: sourceDocumentText,
            api_key: apiKeyForRequest // <<< Pass the correct key
        }, { timeout: 300000 });

        if (pythonResponse.data && pythonResponse.data.success) {
            res.status(200).json(pythonResponse.data.graph_data);
        } else {
            throw new Error(pythonResponse.data.error || "Python service failed to generate the knowledge graph.");
        }
    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Failed to retrieve knowledge graph.";
        console.error(`[KG Visualize] Error for '${documentName}': ${errorMsg}`);
        res.status(error.response?.status || 500).json({ error: errorMsg });
    }
});

module.exports = router;
```

`server/routes/llmConfig.js`

```javascript
// server/routes/llmConfig.js
const express = require("express");
const router = express.Router();
const User = require("../models/User");
const { encrypt } = require("../utils/crypto");

// @route   PUT /api/llm/config
// @desc    Update user's LLM preferences (provider, key, or URL)
// @access  Private
router.put("/config", async (req, res) => {
  // 1. Destructure all possible fields.
  const { llmProvider, apiKey, ollamaUrl, ollamaModel } = req.body;
  const userId = req.user._id;

  try {
    // 2. Start with a blank object. We will only update what is sent.
    const updates = {};

    if (llmProvider) {
      if (!["gemini", "ollama"].includes(llmProvider)) {
        return res
          .status(400)
          .json({ message: "Invalid LLM provider specified." });
      }
      updates.preferredLlmProvider = llmProvider;
    }

    // If a new API key is provided, encrypt and add it to updates.
    if (apiKey) {
      updates.encryptedApiKey = encrypt(apiKey);
    }

    // If a new Ollama URL is provided, add it to updates.
    if (typeof ollamaUrl === "string") {
      updates.ollamaUrl = ollamaUrl.trim();
    }

    // If a new Ollama model is provided, add it to updates.
    if (ollamaModel) {
      updates.ollamaModel = ollamaModel;
    }

    // 3. If the updates object is empty, nothing was sent to change.
    if (Object.keys(updates).length === 0) {
      return res
        .status(400)
        .json({ message: "No valid update information provided." });
    }

    // 4. Use $set to only modify the fields present in the 'updates' object.
    // This will NEVER delete a field that isn't included in the request.
    await User.updateOne({ _id: userId }, { $set: updates });

    res.status(200).json({ message: "LLM preferences updated successfully." });
  } catch (error) {
    console.error(`Error updating LLM config for user ${userId}:`, error);
    res
      .status(500)
      .json({
        message: `Server error while updating LLM preferences: ${error.message}`,
      });
  }
});

// This GET route is correct and doesn't need changes, but it should also return ollamaUrl
router.get("/config", async (req, res) => {
  const userId = req.user._id;
  try {
    const user = await User.findById(userId).select(
      "preferredLlmProvider ollamaModel ollamaUrl"
    );
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }
    res.status(200).json({
      preferredLlmProvider: user.preferredLlmProvider,
      ollamaModel: user.ollamaModel,
      ollamaUrl: user.ollamaUrl, // Also return the URL
    });
  } catch (error) {
    console.error(`Error fetching LLM config for user ${userId}:`, error);
    res.status(500).json({ message: "Server error fetching LLM preferences." });
  }
});

module.exports = router;
```

`server/routes/mindmap.js`

```javascript
// server/routes/mindmap.js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');
const User = require('../models/User'); // For a more advanced implementation

// @route   GET /api/mindmap
// @desc    Get Mermaid code for a mind map
// @access  Private (requires auth)
router.get('/', authMiddleware, async (req, res) => {
    const userId = req.user._id; // User is authenticated
    console.log(`>>> GET /api/mindmap: User=${userId}`);

    try {
        const user = await User.findById(userId).select('uploadedDocuments.filename uploadedDocuments.analysis.mindmap'); // Select only necessary fields
        
        let mindmapCode = null;
        let sourceDocumentName = "Unknown Document";

        if (user && user.uploadedDocuments && user.uploadedDocuments.length > 0) {
            // Find the most recent document that has a mindmap analysis.
            // This assumes higher index means more recent, or you'd sort by an explicit timestamp if available.
            for (let i = user.uploadedDocuments.length - 1; i >= 0; i--) {
                const doc = user.uploadedDocuments[i];
                if (doc.analysis && typeof doc.analysis.mindmap === 'string' && doc.analysis.mindmap.trim() !== "") {
                    mindmapCode = doc.analysis.mindmap.trim();
                    sourceDocumentName = doc.filename || "Untitled Document";
                    console.log(`   Found mindmap for document '${sourceDocumentName}' for user ${userId}.`);
                    break;
                }
            }
        }

        if (mindmapCode) {
            // Basic check if the code starts with a known Mermaid diagram type.
            // This is a simple heuristic. Robust validation is complex.
            const trimmedCode = mindmapCode; // Already trimmed
            const validMermaidPrefixes = ['mindmap', 'graph', 'flowchart', 'sequenceDiagram', 'gantt', 'classDiagram', 'stateDiagram', 'pie', 'erDiagram', 'journey', 'requirementDiagram', 'gitGraph'];
            
            const isPotentiallyValidMermaid = validMermaidPrefixes.some(prefix => 
                trimmedCode.toLowerCase().startsWith(prefix)
            );

            if (!isPotentiallyValidMermaid) {
                // If the stored code doesn't look like Mermaid, prepend 'mindmap'
                // This is an assumption that the stored data *should* be a mindmap if it's in this field.
                console.warn(`   Mindmap code for '${sourceDocumentName}' does not start with a recognized Mermaid type. Prefixing with 'mindmap'.`);
                mindmapCode = `mindmap\n${trimmedCode}`; 
            } else if (!trimmedCode.toLowerCase().startsWith('mindmap')) {
                 // If it's valid Mermaid but not explicitly 'mindmap' (e.g. 'graph TD'),
                 // and the user specifically clicked "Mind Map", it's still okay to send.
                 // The Mermaid library on the frontend can render various diagram types.
                console.log(`   Sending stored analysis as Mermaid diagram. Type: ${trimmedCode.split('\n')[0].trim()}`);
            }
            return res.status(200).json({ mermaidCode: mindmapCode, source: sourceDocumentName });
        } else {
            console.log(`   No mindmap analysis found for user ${userId}. Returning default mindmap.`);
            const defaultMermaidCode = `
mindmap
  root((No Mind Map Available))
    (Please upload a document and ensure its analysis includes a mind map.)
    (Or, no documents processed yet.)
`;
            return res.status(200).json({ mermaidCode: defaultMermaidCode, source: "Default" });
        }

    } catch (error) {
        console.error(`!!! Error in GET /api/mindmap for User ${userId}:`, error);
        res.status(500).json({ message: "Failed to retrieve mind map code due to a server error." });
    }
});

module.exports = router;
```

`server/routes/network.js`

```javascript
const express = require('express');
const router = express.Router();
const os = require('os');

function getAllIPs() {
    const interfaces = os.networkInterfaces();
    const ips = new Set(['localhost']); // Include localhost by default

    for (const [name, netInterface] of Object.entries(interfaces)) {
        // Skip loopback and potentially virtual interfaces if desired
        if (name.includes('lo') || name.toLowerCase().includes('virtual') || name.toLowerCase().includes('vmnet')) continue;

        for (const addr of netInterface) {
            // Focus on IPv4, non-internal addresses
            if (addr.family === 'IPv4' && !addr.internal) {
                ips.add(addr.address);
            }
        }
    }
    return Array.from(ips);
}

router.get('/ip', (req, res) => {
    res.json({
        ips: getAllIPs(),
        // req.ip might be less reliable behind proxies, but can be included
        // currentRequestIp: req.ip
    });
});

module.exports = router;

```

`server/routes/subjects.js`

```javascript
// server/routes/subjects.js
const express = require('express');
const router = express.Router();
const AdminDocument = require('../models/AdminDocument'); // Model for admin-uploaded documents

// @route   GET /api/subjects
// @desc    Get a list of available subject names (derived from admin-uploaded document originalNames)
// @access  Private (Regular User Authenticated via JWT)
router.get('/', async (req, res) => {
    // req.user is available here from authMiddleware
    console.log(`User ${req.user.username} is requesting the list of subjects.`);
    try {
        // Fetch distinct originalName values from the AdminDocument collection
        // and sort them alphabetically.
        const subjectObjects = await AdminDocument.find().sort({ originalName: 1 }).select('originalName').lean();
        const subjectNames = subjectObjects.map(doc => doc.originalName);
        
        // Alternative using distinct, but sorting might be different or need post-processing
        // const subjectNames = await AdminDocument.distinct('originalName').exec();
        // subjectNames.sort((a, b) => a.localeCompare(b));


        res.json({ subjects: subjectNames }); // Send as { subjects: ["Subject 1", "Subject 2", ...] }
    } catch (error) {
        console.error("Error fetching subjects for user display:", error);
        res.status(500).json({ message: "Server error while fetching available subjects." });
    }
});

module.exports = router;
```

`server/routes/syllabus.js`

```javascript
// server/routes/syllabus.js
const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const { authMiddleware } = require('../middleware/authMiddleware'); // Protect the route

const router = express.Router();
const SYLLABI_DIR = path.join(__dirname, '..', 'syllabi');

// --- @route   GET /api/syllabus/:subjectId ---
// --- @desc    Get syllabus content for a specific subject ---
// --- @access  Private (requires auth) ---
router.get('/:subjectId', authMiddleware, async (req, res) => {
    const { subjectId } = req.params;

    // Basic sanitization: Allow only alphanumeric and underscores
    // Prevents directory traversal (e.g., ../../etc/passwd)
    const sanitizedSubjectId = subjectId.replace(/[^a-zA-Z0-9_]/g, '');

    if (!sanitizedSubjectId || sanitizedSubjectId !== subjectId) {
        console.warn(`Syllabus request rejected due to invalid characters: ${subjectId}`);
        return res.status(400).json({ message: 'Invalid subject identifier format.' });
    }

    const filePath = path.join(SYLLABI_DIR, `${sanitizedSubjectId}.md`);

    try {
        // Check if file exists first (more specific error)
        await fs.access(filePath);

        // Read the file content
        const content = await fs.readFile(filePath, 'utf-8');

        res.status(200).json({ syllabus: content });

    } catch (error) {
        if (error.code === 'ENOENT') {
            console.warn(`Syllabus file not found: ${filePath}`);
            return res.status(404).json({ message: `Syllabus for '${subjectId}' not found.` });
        } else {
            console.error(`Error reading syllabus file ${filePath}:`, error);
            return res.status(500).json({ message: 'Server error retrieving syllabus.' });
        }
    }
});

module.exports = router;

```

`server/routes/tools.js`

```javascript
// server/routes/tools.js
const express = require("express");
const axios = require("axios");
const router = express.Router();

// This entire router will be protected by the main authMiddleware in server.js

// @route   POST /api/tools/execute
// @desc    Execute code by proxying to the Python service
// @access  Private
router.post("/execute", async (req, res) => {
  const { language, code, testCases } = req.body;

  if (!code || !language) {
    return res.status(400).json({ message: "Code and language are required." });
  }

  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    console.error("[Code Executor] PYTHON_RAG_SERVICE_URL is not set.");
    return res
      .status(500)
      .json({ message: "Code execution service is not configured." });
  }

  const executionUrl = `${pythonServiceUrl}/execute_code`;
  console.log(
    `[Node Tools] Forwarding code execution request to: ${executionUrl}`
  );

  try {
    const pythonResponse = await axios.post(
      executionUrl,
      {
        language,
        code,
        testCases,
      },
      { timeout: 15000 }
    ); // 15-second timeout for the entire execution process

    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg =
      error.response?.data?.error || error.message || "Failed to execute code.";
    console.error(
      `[Node Tools] Error calling Python execution service: ${errorMsg}`
    );
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

// @route   POST /api/tools/analyze-code
router.post("/analyze-code", async (req, res) => {
  const { language, code } = req.body;
  if (!code || !language) {
    return res.status(400).json({ message: "Code and language are required." });
  }

  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    return res.status(500).json({ message: "AI service is not configured." });
  }

  const analysisUrl = `${pythonServiceUrl}/analyze_code`;
  try {
    const pythonResponse = await axios.post(
      analysisUrl,
      { language, code },
      { timeout: 60000 }
    ); // 1 min timeout
    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg = error.response?.data?.error || error.message;
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

// @route   POST /api/tools/generate-test-cases
router.post("/generate-test-cases", async (req, res) => {
  const { language, code } = req.body;
  if (!code || !language) {
    return res.status(400).json({ message: "Code and language are required." });
  }

  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    return res.status(500).json({ message: "AI service is not configured." });
  }

  const generationUrl = `${pythonServiceUrl}/generate_test_cases`;
  try {
    const pythonResponse = await axios.post(
      generationUrl,
      { language, code },
      { timeout: 60000 }
    ); // 1 min timeout
    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg = error.response?.data?.error || error.message;
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

// @route   POST /api/tools/explain-error
router.post("/explain-error", async (req, res) => {
  const { language, code, errorMessage } = req.body;
  if (!code || !language || !errorMessage) {
    return res
      .status(400)
      .json({ message: "Code, language, and errorMessage are required." });
  }

  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    return res.status(500).json({ message: "AI service is not configured." });
  }

  const explanationUrl = `${pythonServiceUrl}/explain_error`;
  try {
    const pythonResponse = await axios.post(
      explanationUrl,
      { language, code, errorMessage },
      { timeout: 60000 }
    );
    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg = error.response?.data?.error || error.message;
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

module.exports = router;

```

`server/routes/upload.js`

```javascript


// server/routes/upload.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const axios = require('axios');
const { authMiddleware } = require('../middleware/authMiddleware');
const User = require('../models/User');
const { Worker } = require('worker_threads');
const { decrypt } = require('../utils/crypto');

const router = express.Router();

// --- Constants & Multer Config ---
const UPLOAD_DIR = path.join(__dirname, '..', 'assets');
const MAX_FILE_SIZE = 20 * 1024 * 1024;
const allowedMimeTypes = {
    'application/pdf': 'docs',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docs',
    'application/msword': 'docs',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'docs',
    'application/vnd.ms-powerpoint': 'docs',
    'text/plain': 'docs', 'text/x-python': 'code', 'application/javascript': 'code',
    'text/javascript': 'code', 'text/markdown': 'code', 'text/html': 'code',
    'application/xml': 'code', 'text/xml': 'code', 'application/json': 'code',
    'text/csv': 'code', 'image/jpeg': 'images', 'image/png': 'images',
    'image/bmp': 'images', 'image/gif': 'images',
};
const allowedExtensions = [
    '.pdf', '.docx', '.doc', '.pptx', '.ppt', '.txt', '.py', '.js', '.md', 
    '.html', '.xml', '.json', '.csv', '.log', '.jpg', '.jpeg', '.png', '.bmp', '.gif'
];

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        if (!req.user || !req.user.email) {
            return cb(new Error("Authentication error: User context not found for upload destination."));
        }
        const sanitizedUsername = req.user.email.split('@')[0].replace(/[^a-zA-Z0-9_-]/g, '_');
        const fileMimeType = file.mimetype.toLowerCase();
        const fileTypeSubfolder = allowedMimeTypes[fileMimeType] || 'others';
        const destinationPath = path.join(UPLOAD_DIR, sanitizedUsername, fileTypeSubfolder);
        fs.mkdir(destinationPath, { recursive: true }, (err) => {
             if (err) cb(err); else cb(null, destinationPath);
         });
    },
    filename: (req, file, cb) => {
        const timestamp = Date.now();
        const fileExt = path.extname(file.originalname).toLowerCase();
        const sanitizedBaseName = path.basename(file.originalname, fileExt)
                                      .replace(/[^a-zA-Z0-9._-]/g, '_').substring(0, 100);
        const uniqueFilename = `${timestamp}-${sanitizedBaseName}${fileExt}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req, file, cb) => {
    if (!req.user) {
         const err = new multer.MulterError('UNAUTHENTICATED');
         err.message = 'User not authenticated.';
         return cb(err, false);
    }
    const fileExt = path.extname(file.originalname).toLowerCase();
    const mimeType = file.mimetype.toLowerCase();
    if (allowedMimeTypes[mimeType] && allowedExtensions.includes(fileExt)) {
        cb(null, true);
    } else {
        const err = new multer.MulterError('LIMIT_UNEXPECTED_FILE');
        err.message = `Invalid file type. Allowed: ${allowedExtensions.join(', ')}.`;
        cb(err, false);
    }
};

const upload = multer({ storage, fileFilter, limits: { fileSize: MAX_FILE_SIZE }});

async function triggerPythonRagProcessing(userId, filePath, originalName) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        return { success: false, message: "RAG service URL not configured." };
    }
    const addDocumentUrl = `${pythonServiceUrl}/add_document`;
    try {
        const response = await axios.post(addDocumentUrl, { user_id: userId, file_path: filePath, original_name: originalName });
        const pythonData = response.data;
        const text = pythonData?.raw_text_for_analysis || null;
        return {
            success: !!(text && text.trim()),
            status: pythonData?.status,
            message: pythonData?.message || "No message from Python.",
            text: text,
            chunksForKg: pythonData?.chunks_with_metadata || []
        };
    } catch (error) {
        return { success: false, message: `Python RAG call failed: ${error.response?.data?.error || error.message}`};
    }
}

router.post('/', (req, res) => {
    const uploader = upload.single('file');

    uploader(req, res, async function (err) {
        if (!req.user) {
            return res.status(401).json({ message: "Authentication error: User context not found." });
        }
        if (err) {
            console.error(`Upload Route: Multer error for user '${req.user.email}': ${err.message}`);
            return res.status(err instanceof multer.MulterError ? 400 : 500).json({ message: err.message });
        }
        if (!req.file) {
            return res.status(400).json({ message: "No file received or file type rejected." });
        }

        const userId = req.user._id.toString();
        const { originalname: originalName, path: tempServerPath } = req.file;
        if (!tempServerPath) {
            return res.status(500).json({ message: "File upload failed, temporary path not created." });
        }
        const absoluteFilePath = path.resolve(tempServerPath);

        try {
            const user = await User.findById(userId).select('uploadedDocuments.filename preferredLlmProvider ollamaModel ollamaUrl +encryptedApiKey');
            if (!user) {
                await fs.promises.unlink(absoluteFilePath).catch(e => console.error(`Cleanup Error: ${e.message}`));
                return res.status(404).json({ message: "User not found." });
            }

            if (user.uploadedDocuments.some(doc => doc.filename === originalName)) {
                await fs.promises.unlink(absoluteFilePath).catch(e => console.error(`Cleanup Error: ${e.message}`));
                return res.status(409).json({ message: `File '${originalName}' already exists.` });
            }

            const ragResult = await triggerPythonRagProcessing(userId, absoluteFilePath, originalName);

            if (!ragResult.success) {
                await fs.promises.unlink(absoluteFilePath).catch(e => console.error(`Cleanup Error: ${e.message}`));
                return res.status(422).json({ message: ragResult.message || "Failed to extract text." });
            }
            
            const newDocEntry = {
                filename: originalName, text: ragResult.text,
                analysis: {}, uploadedAt: new Date(), ragStatus: ragResult.status,
                analysisStatus: "pending", kgStatus: "pending"
            };
            await User.updateOne({ _id: userId }, { $push: { uploadedDocuments: newDocEntry } });
            
            res.status(202).json({
                message: `File '${originalName}' accepted. Background processing initiated.`,
                originalname: originalName,
            });

            const userApiKey = user.encryptedApiKey ? decrypt(user.encryptedApiKey) : null;
            const llmProviderForWorkers = user.preferredLlmProvider || 'gemini';

            if (llmProviderForWorkers === 'gemini' && !userApiKey) {
                console.warn(`[Upload Route] User ${userId} selected Gemini but has no API key. Workers may fail.`);
            }
            
            const workerData = { 
                userId, 
                originalName, 
                textForAnalysis: ragResult.text, 
                llmProvider: llmProviderForWorkers, 
                ollamaModel: user.ollamaModel,
                apiKey: userApiKey,
                ollamaUrl: user.ollamaUrl
            };
            const kgWorkerData = { ...workerData, chunksForKg: ragResult.chunksForKg };

            const analysisWorker = new Worker(path.resolve(__dirname, '../workers/analysisWorker.js'), { workerData });
            analysisWorker.on('error', (err) => console.error(`Analysis Worker Error [${originalName}]:`, err));

            if (ragResult.chunksForKg && ragResult.chunksForKg.length > 0) {
                const kgWorker = new Worker(path.resolve(__dirname, '../workers/kgWorker.js'), { workerData: kgWorkerData });
                kgWorker.on('error', (err) => console.error(`KG Worker Error [${originalName}]:`, err));
            } else {
                 await User.updateOne({ _id: userId, "uploadedDocuments.filename": originalName }, { $set: { "uploadedDocuments.$.kgStatus": "skipped_no_chunks" } });
            }

            await fs.promises.unlink(absoluteFilePath).catch(e => console.error(`Non-critical cleanup error: ${e.message}`));

        } catch (error) {
            console.error(`Overall Upload Error for ${originalName}:`, error);
            if (fs.existsSync(tempServerPath)) {
                await fs.promises.unlink(tempServerPath).catch(e => console.error(`Final Cleanup Error: ${e.message}`));
            }
            if (!res.headersSent) {
                res.status(500).json({ message: "Server error during file processing." });
            }
        }
    });
});

module.exports = router;
```

`server/routes/user.js`

```javascript
// server/routes/user.js
const express = require('express');
const router = express.Router();
const User = require('../models/User');
const { redisClient } = require('../config/redisClient');

// Note: The main 'authMiddleware' will be applied in server.js before this router is used,
// so we don't need to add it to each route here. req.user will be available.

// @route   GET /api/user/profile
// @desc    Get the current user's profile data
// @access  Private
router.get('/profile', async (req, res) => {
    try {
        const user = await User.findById(req.user._id).select('profile');
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }
        // Return the profile object, or an empty object if it doesn't exist
        res.json(user.profile || {});
    } catch (error) {
        console.error('Error fetching user profile:', error);
        res.status(500).json({ message: 'Server error while fetching profile.' });
    }
});

// @route   PUT /api/user/profile
// @desc    Update the current user's profile data
// @access  Private
router.put('/profile', async (req, res) => {
    const { name, college, universityNumber, degreeType, branch, year } = req.body;

    // Basic backend validation
    if (!name || !college || !universityNumber || !degreeType || !branch || !year) {
        return res.status(400).json({ message: 'All profile fields are required.' });
    }

    try {
        const user = await User.findById(req.user._id);
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }

        // Update the profile sub-document
        user.profile = {
            name,
            college,
            universityNumber,
            degreeType,
            branch,
            year
        };

        await user.save();
        if (redisClient && redisClient.isOpen) {
            const cacheKey = `user:${req.user._id}`;
            await redisClient.del(cacheKey);
            console.log(`[Cache Invalidation] Deleted cache for user ${req.user._id} due to profile update.`);
        }
        res.json({
            message: 'Profile updated successfully!',
            profile: user.profile
        });

    } catch (error) {
        console.error('Error updating user profile:', error);
        res.status(500).json({ message: 'Server error while updating profile.' });
    }
});

module.exports = router;
```

`server/server.js`

```javascript
// server/server.js
const dotenv = require("dotenv");
dotenv.config();

const express = require("express");
const cors = require("cors");
const path = require("path");
const fs = require("fs");
const axios = require("axios");
const mongoose = require("mongoose");

// --- Custom Modules & Middleware ---
const connectDB = require("./config/db");
const { getLocalIPs } = require("./utils/networkUtils");
const { performAssetCleanup } = require("./utils/assetCleanup");
const { authMiddleware } = require("./middleware/authMiddleware");
const {
  fixedAdminAuthMiddleware,
} = require("./middleware/fixedAdminAuthMiddleware");

// --- Route Imports ---
const networkRoutes = require("./routes/network");
const authRoutes = require("./routes/auth");
const userRoutes = require("./routes/user");
const chatRoutes = require("./routes/chat");
const uploadRoutes = require("./routes/upload");
const filesRoutes = require("./routes/files");
const analysisRoutes = require("./routes/analysis");
const adminApiRoutes = require("./routes/admin");
const subjectsRoutes = require("./routes/subjects");
const generationRoutes = require("./routes/generation");
const exportRoutes = require("./routes/export");
const kgRoutes = require("./routes/kg");
const llmConfigRoutes = require("./routes/llmConfig");
const toolsRoutes = require("./routes/tools");

// --- Configuration & Express App Setup ---
const port = process.env.PORT || 5001;
const mongoUri = process.env.MONGO_URI;
const pythonRagUrl = process.env.PYTHON_RAG_SERVICE_URL;

if (!process.env.JWT_SECRET || !process.env.ENCRYPTION_SECRET) {
  console.error(
    "!!! FATAL: JWT_SECRET or ENCRYPTION_SECRET is not set in .env file."
  );
  process.exit(1);
}
if (!mongoUri) {
  console.error("!!! FATAL: MONGO_URI is not set in .env file.");
  process.exit(1);
}

const app = express();
app.use(cors());
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

// --- API Route Mounting ---
app.get("/", (req, res) => res.send("AI Tutor Backend API is running..."));
app.use("/api/network", networkRoutes);
app.use("/api/auth", authRoutes);

// --- Admin Routes ---
// Apply the fixed admin auth middleware to the single admin router.
app.use("/api/admin", fixedAdminAuthMiddleware, adminApiRoutes);

// All subsequent routes are protected by the general JWT authMiddleware
app.use(authMiddleware);
app.use("/api/user", userRoutes);
app.use("/api/chat", chatRoutes);
app.use("/api/upload", uploadRoutes);
app.use("/api/files", filesRoutes);
app.use("/api/analysis", analysisRoutes);
app.use("/api/subjects", subjectsRoutes);
app.use("/api/generate", generationRoutes);
app.use("/api/export", exportRoutes);
app.use("/api/kg", kgRoutes);
app.use("/api/llm", llmConfigRoutes);
app.use("/api/tools", toolsRoutes);

// --- Centralized Error Handling ---
app.use((err, req, res, next) => {
  console.error("Unhandled Error:", err.stack || err);
  const statusCode = err.status || 500;
  const message = err.message || "An internal server error occurred.";
  if (!res.headersSent) {
    res.status(statusCode).json({ message });
  }
});

// --- Server Startup Logic ---
async function startServer() {
  console.log("\n--- Starting Server Initialization ---");
  try {
    await ensureServerDirectories();
    await connectDB(mongoUri);
    await performAssetCleanup();
    await checkRagService(pythonRagUrl);

    const server = app.listen(port, "0.0.0.0", () => {
      console.log("\n=== Node.js Server Ready ===");
      console.log(`🚀 Server listening on port ${port}`);
      getLocalIPs().forEach((ip) => {
        console.log(`   - http://${ip}:${port}`);
      });
      console.log("============================\n");
    });

    const gracefulShutdown = (signal) => {
      console.log(`\n${signal} received. Shutting down...`);
      server.close(() => {
        mongoose.connection.close(false, () => {
          console.log("MongoDB connection closed.");
          process.exit(0);
        });
      });
    };
    process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
    process.on("SIGINT", () => gracefulShutdown("SIGINT"));
  } catch (error) {
    console.error("!!! Failed to start Node.js server:", error.message);
    process.exit(1);
  }
}

// Helper functions
async function ensureServerDirectories() {
  const dirs = [
    path.join(__dirname, "assets"),
    path.join(__dirname, "backup_assets"),
    path.join(__dirname, "generated_docs"),
  ];
  for (const dir of dirs) {
    if (!fs.existsSync(dir)) await fs.promises.mkdir(dir, { recursive: true });
  }
}
async function checkRagService(url) {
  if (!url) {
    console.warn("! Python RAG service URL not configured.");
    return;
  }
  try {
    const response = await axios.get(`${url}/health`, { timeout: 7000 });
    if (response.data.status === "ok") {
      console.log("✓ Python RAG service is available.");
    } else {
      console.warn(
        `! Python RAG service responded but is not healthy. Status: ${response.data.status}`
      );
    }
  } catch (error) {
    console.warn("! Python RAG service is not reachable.");
  }
}

startServer();
```

`server/services/agentService.js`

```javascript
// server/services/agentService.js
const { createAgenticSystemPrompt, createSynthesizerPrompt } = require('../config/promptTemplates.js');
const { availableTools } = require('./toolRegistry.js');
const { createModelContext, createAgenticContext } = require('../protocols/contextProtocols.js');
const geminiService = require('./geminiService.js');
const ollamaService = require('./ollamaService.js');
const User = require('../models/User');
const { decrypt } = require('../utils/crypto');
const { redisClient } = require('../config/redisClient');

async function getCachedUser(userId) {
    if (!redisClient || !redisClient.isOpen) {
        // Fallback to DB if Redis is down
        return User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaModel ollamaUrl');
    }

    const cacheKey = `user:${userId}`;
    const CACHE_TTL_SECONDS = 300; // Cache user data for 5 minutes

    try {
        const cachedUser = await redisClient.get(cacheKey);
        if (cachedUser) {
            console.log(`[AgentService] Cache HIT for user ${userId}`);
            return JSON.parse(cachedUser);
        }

        console.log(`[AgentService] Cache MISS for user ${userId}`);
        const userFromDb = await User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaModel ollamaUrl').lean(); // Use .lean() for plain object
        if (userFromDb) {
            // Don't await this, let it run in the background
            redisClient.setEx(cacheKey, CACHE_TTL_SECONDS, JSON.stringify(userFromDb)).catch(err => {
                console.error(`Redis SETEX error for user ${userId}:`, err);
            });
        }
        return userFromDb;

    } catch (err) {
        console.error(`Redis error getting user ${userId}:`, err);
        // Fallback to DB on Redis error
        return User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaModel ollamaUrl');
    }
}

function parseToolCall(responseText) {
    const jsonMatch = responseText.match(/```(json)?\s*([\s\S]+?)\s*```/);
    const jsonString = jsonMatch ? jsonMatch[2] : responseText;
    try {
        const jsonResponse = JSON.parse(jsonString);
        if (jsonResponse && typeof jsonResponse.tool_call !== 'undefined') {
            return jsonResponse.tool_call;
        }
        return null;
    } catch (e) {
        console.warn(`[AgentService] Failed to parse JSON from LLM response: ${e.message}. Response: ${responseText.substring(0, 200)}...`);
        return null;
    }
}

async function processAgenticRequest(userQuery, chatHistory, systemPrompt, requestContext) {
    const { llmProvider, ollamaModel, userId, ollamaUrl, isAcademicSearchEnabled } = requestContext;

    // const user = await User.findById(userId).select('+encryptedApiKey');
    const user = await getCachedUser(userId);
    if (!user) {
        throw new Error("User not found during agent processing.");
    }
    const userApiKey = user.encryptedApiKey ? decrypt(user.encryptedApiKey) : null;
    if (user.encryptedApiKey && !userApiKey) {
        console.warn(`[AgentService] Failed to decrypt API key for user ${userId}.`);
    }

    const modelContext = createModelContext({ availableTools });
    const agenticContext = createAgenticContext({ systemPrompt });
    
    const agenticSystemPrompt = createAgenticSystemPrompt(
        modelContext, 
        agenticContext, 
        { ...requestContext, userQuery, isAcademicSearchEnabled }
    );

    const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;
    const llmOptions = {
        ...(llmProvider === 'ollama' && { model: ollamaModel }),
        apiKey: userApiKey,
        ollamaUrl: ollamaUrl
    };

    console.log(`[AgentService] Performing Router call using ${llmProvider}...`);
    const routerResponseText = await llmService.generateContentWithHistory(
        [], 
        "Please analyze the provided context and user query and return your JSON decision.", 
        agenticSystemPrompt,
        llmOptions
    );

    const toolCall = parseToolCall(routerResponseText);

    if (!toolCall || !toolCall.tool_name) {
        console.log('[AgentService] Decision: Direct Answer.');
        const directAnswer = await llmService.generateContentWithHistory(
            chatHistory,
            userQuery,
            systemPrompt,
            llmOptions
        );
        return {
            finalAnswer: directAnswer,
            references: [],
            sourcePipeline: `${llmProvider}-agent-direct`,
        };
    }

    console.log(`[AgentService] Decision: Tool Call -> ${toolCall.tool_name}`);
    const mainTool = availableTools[toolCall.tool_name];
    if (!mainTool) {
        return { finalAnswer: "I tried to use a tool that doesn't exist. Please try again.", references: [], sourcePipeline: 'agent-error-unknown-tool' };
    }

    try {
        const toolExecutionPromises = [];
        const executedToolNames = [];

        toolExecutionPromises.push(mainTool.execute(toolCall.parameters, requestContext));
        executedToolNames.push(toolCall.tool_name);
        
        let pipeline = `${llmProvider}-agent-${toolCall.tool_name}`;

        if (toolCall.tool_name === 'rag_search' && requestContext.criticalThinkingEnabled) {
            console.log('[AgentService] Critical Thinking enabled. Adding KG search to tool execution.');
            const kgTool = availableTools['kg_search'];
            toolExecutionPromises.push(kgTool.execute(toolCall.parameters, { ...requestContext, userId }));
            executedToolNames.push('kg_search');
            pipeline += '+kg';
        }

        const toolResults = await Promise.all(toolExecutionPromises);
        
        const combinedToolOutput = toolResults.map((result, index) => {
            const toolName = executedToolNames[index];
            return `--- TOOL OUTPUT: ${toolName.toUpperCase()} ---\n${result.toolOutput}`;
        }).join('\n\n');
        
        const combinedReferences = toolResults.flatMap(result => result.references || []);

        console.log(`[AgentService] Performing Synthesizer call using ${llmProvider}...`);
        const synthesizerPrompt = createSynthesizerPrompt(userQuery, combinedToolOutput, toolCall.tool_name);
        const finalAnswer = await llmService.generateContentWithHistory(
            chatHistory, synthesizerPrompt, systemPrompt, llmOptions
        );
        
        return {
            finalAnswer,
            references: combinedReferences,
            sourcePipeline: pipeline,
        };
    } catch (error) {
        console.error(`[AgentService] Error executing tool '${toolCall.tool_name}':`, error);
        return { finalAnswer: `I tried to use a tool, but it failed. Error: ${error.message}.`, references: [], sourcePipeline: `agent-error-tool-failed` };
    }
}

module.exports = {
    processAgenticRequest,
};
```

`server/services/geminiService.js`

```javascript
// server/services/geminiService.js
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require('@google/generative-ai');

const FALLBACK_API_KEY = process.env.GEMINI_API_KEY;
const MODEL_NAME = "gemini-1.5-flash";

const DEFAULT_MAX_OUTPUT_TOKENS_CHAT = 8192;
const DEFAULT_MAX_OUTPUT_TOKENS_KG = 65536;

const baseSafetySettings = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
];

async function generateContentWithHistory(
    chatHistory,
    currentUserQuery,
    systemPromptText = null,
    options = {} // Now accepts { maxOutputTokens, apiKey }
) {
    const apiKeyToUse = options.apiKey || FALLBACK_API_KEY;

    if (!apiKeyToUse) {
        console.error("FATAL ERROR: Gemini API key is not available for this request. Ensure server's GEMINI_API_KEY is set or user provides one.");
        throw new Error("Gemini API key is missing. Please configure it.");
    }

    try {
        const genAI = new GoogleGenerativeAI(apiKeyToUse);

        if (typeof currentUserQuery !== 'string' || currentUserQuery.trim() === '') {
             throw new Error("currentUserQuery must be a non-empty string.");
        }

        const generationConfig = {
            temperature: 0.7,
            maxOutputTokens: options.maxOutputTokens || DEFAULT_MAX_OUTPUT_TOKENS_CHAT,
        };
        
        const model = genAI.getGenerativeModel({
            model: MODEL_NAME,
            systemInstruction: (systemPromptText && typeof systemPromptText === 'string' && systemPromptText.trim() !== '') ? 
                { parts: [{ text: systemPromptText.trim() }] } : undefined,
            safetySettings: baseSafetySettings,
        });

        const historyForStartChat = (chatHistory || [])
            .map(msg => ({
                 role: msg.role, 
                 parts: Array.isArray(msg.parts) ? msg.parts.map(part => ({ text: part.text || '' })) : [{text: msg.text || ''}] 
            }))
            .filter(msg => msg.role && msg.parts && msg.parts.length > 0 && typeof msg.parts[0].text === 'string');
        
        const chat = model.startChat({
            history: historyForStartChat,
            generationConfig: generationConfig,
        });

        console.log(`Sending message to Gemini. History sent: ${historyForStartChat.length}. System Prompt: ${!!systemPromptText}. Max Tokens: ${generationConfig.maxOutputTokens}`);
        // console.log(`Current User Query to sendMessage (first 100): "${currentUserQuery.substring(0,100)}..."`); // Can be very long

        const result = await chat.sendMessage(currentUserQuery);
        const response = result.response;
        const candidate = response?.candidates?.[0];

        if (candidate && (candidate.finishReason === 'STOP' || candidate.finishReason === 'MAX_TOKENS')) {
            const responseText = candidate?.content?.parts?.[0]?.text || "";
            if (candidate.finishReason === 'MAX_TOKENS') {
                console.warn("Gemini response was truncated due to MAX_TOKENS limit.");
            }
            return responseText;
        } else {
             const finishReason = candidate?.finishReason || 'Unknown';
             const safetyRatings = candidate?.safetyRatings;
             console.warn("Gemini response was potentially blocked or had issues.", { finishReason, safetyRatings });
             let blockMessage = `AI response generation failed or was blocked.`;
             if (finishReason === 'SAFETY') {
                 blockMessage += ` Reason: SAFETY.`;
                 if (safetyRatings) {
                    const blockedCategories = safetyRatings.filter(r => r.blocked).map(r => r.category).join(', ');
                    if (blockedCategories) blockMessage += ` Blocked Categories: ${blockedCategories}.`;
                 }
             } else if (finishReason) {
                 blockMessage += ` Reason: ${finishReason}.`;
             }
             const error = new Error(blockMessage);
             error.status = 400;
             throw error;
        }
    } catch (error) {
        console.error("Gemini API Call Error:", error?.message || error);
        let clientMessage = "Failed to get response from AI service.";
        if (error.message?.includes("API key not valid")) clientMessage = "AI Service Error: Invalid API Key.";
        else if (error.message?.includes("API key not found")) clientMessage = "AI Service Error: API Key not found or invalid.";
        else if (error.message?.includes("billing account")) clientMessage = "AI Service Error: Billing account issue with the provided API Key.";
        else if (error.message?.includes("blocked due to safety")) clientMessage = "AI response blocked due to safety settings.";
        else if (error.message?.includes("Invalid JSON payload")) clientMessage = "AI Service Error: Invalid request format sent to AI.";
        else if (error.message?.includes("User location is not supported")) clientMessage = "AI Service Error: User location is not supported for this model.";
        else if (error.status === 400) clientMessage = `AI Service Error: ${error.message}`; 
        
        const enhancedError = new Error(clientMessage);
        enhancedError.status = error.status || 500; 
        enhancedError.originalError = error; 
        throw enhancedError;
    }
};

module.exports = {
    generateContentWithHistory,
    DEFAULT_MAX_OUTPUT_TOKENS_KG 
};
```

`server/services/kgService.js`

```javascript
// server/services/kgService.js
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const {
    KG_GENERATION_SYSTEM_PROMPT,
    KG_BATCH_USER_PROMPT_TEMPLATE
} = require('../config/promptTemplates');


function constructKgPromptForBatch(chunkTexts) {
    let formattedChunkTexts = "";
    chunkTexts.forEach((chunkText, index) => {
        formattedChunkTexts += `
--- START OF CHUNK ${index + 1} ---
${chunkText}
--- END OF CHUNK ${index + 1} ---
`;
    });
    return KG_BATCH_USER_PROMPT_TEMPLATE.replace('{BATCHED_CHUNK_TEXTS_HERE}', formattedChunkTexts);
}

async function _processBatchOfChunksForKg(batchOfChunkObjects, batchIndex, llmProvider, ollamaModel) {
    const logPrefix = `[KG Service Batch ${batchIndex}]`;

    const chunkTextsForPrompt = batchOfChunkObjects.map(chunk => chunk.text_content);

    if (chunkTextsForPrompt.length === 0) {
        console.log(`${logPrefix} No text content in this batch. Skipping.`);
        return [];
    }

    const userPromptForBatch = constructKgPromptForBatch(chunkTextsForPrompt);
    
    // For KG generation, the user prompt contains the data to be processed.
    // The system prompt contains the instructions on HOW to process it.
    const historyForLlm = [
        { role: 'user', parts: [{ text: "Please generate the knowledge graph fragments based on the provided text chunks and your system instructions." }] }
    ];

    try {
        console.log(`${logPrefix} Processing ${chunkTextsForPrompt.length} chunks for KG generation using ${llmProvider}.`);
        let responseText;

        if (llmProvider === 'ollama') {
            responseText = await ollamaService.generateContentWithHistory(
                historyForLlm,
                userPromptForBatch, // Pass the chunks as the "current query"
                KG_GENERATION_SYSTEM_PROMPT, // Pass the KG instructions as the system prompt
                { model: ollamaModel, maxOutputTokens: ollamaService.DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_KG }
            );
        } else { // Default to Gemini
            // --- THIS IS THE CORRECTED CALL ---
            responseText = await geminiService.generateContentWithHistory(
                historyForLlm,                      // Minimal history to kick off the chat
                userPromptForBatch,                 // The user prompt containing the document chunks to be analyzed
                KG_GENERATION_SYSTEM_PROMPT,        // The detailed instructions on how the LLM should behave
                { maxOutputTokens: geminiService.DEFAULT_MAX_OUTPUT_TOKENS_KG } // Pass maxOutputTokens correctly in the options object
            );
            // --- END CORRECTION ---
        }

        if (!responseText) {
            console.warn(`${logPrefix} Empty response from LLM for batch.`);
            return [];
        }

        let cleanedResponseText = responseText.trim();
        if (cleanedResponseText.startsWith("```json")) {
            cleanedResponseText = cleanedResponseText.substring(7);
            if (cleanedResponseText.endsWith("```")) {
                cleanedResponseText = cleanedResponseText.slice(0, -3);
            }
        } else if (cleanedResponseText.startsWith("```")) {
            cleanedResponseText = cleanedResponseText.substring(3);
            if (cleanedResponseText.endsWith("```")) {
                cleanedResponseText = cleanedResponseText.slice(0, -3);
            }
        }
        cleanedResponseText = cleanedResponseText.trim();
        
        const graphFragmentsArray = JSON.parse(cleanedResponseText);

        if (!Array.isArray(graphFragmentsArray)) {
            console.warn(`${logPrefix} LLM response was not a JSON array.`);
            return [];
        }

        if (graphFragmentsArray.length !== batchOfChunkObjects.length) {
            console.warn(`${logPrefix} Mismatch: Expected ${batchOfChunkObjects.length} KG fragments, but received ${graphFragmentsArray.length}.`);
        }
        
        const validFragments = graphFragmentsArray.filter(fragment =>
            fragment && typeof fragment === 'object' && Array.isArray(fragment.nodes) && Array.isArray(fragment.edges)
        );
        
        if (validFragments.length !== graphFragmentsArray.length) {
            console.warn(`${logPrefix} Some fragments from the LLM were malformed and discarded.`);
        }

        console.log(`${logPrefix} Successfully parsed ${validFragments.length} valid KG fragments.`);
        return validFragments;

    } catch (error) {
        console.error(`${logPrefix} Error processing batch:`, error.message);
        if (error.originalError) console.error(`${logPrefix} Original LLM error:`, error.originalError);
        return [];
    }
}


function _mergeGraphFragments(graphFragments) {
    console.log(`[KG Service] Merging ${graphFragments.length} graph fragments...`);
    const finalNodesMap = new Map();
    const finalEdgesSet = new Set();

    for (const fragment of graphFragments) {
        if (!fragment || !fragment.nodes || !fragment.edges) {
            console.warn("[KG Service Merge] Skipping invalid or null graph fragment.");
            continue;
        }
        
        for (const node of fragment.nodes) {
            if (!node || typeof node.id !== 'string' || !node.id.trim()) {
                console.warn("[KG Service Merge] Skipping invalid node (missing/empty ID):", node);
                continue;
            }
            const nodeId = node.id.trim();
            if (!finalNodesMap.has(nodeId)) {
                finalNodesMap.set(nodeId, { ...node, id: nodeId });
            } else {
                const existingNode = finalNodesMap.get(nodeId);
                if (node.description && typeof node.description === 'string' &&
                    (!existingNode.description || node.description.length > existingNode.description.length)) {
                    existingNode.description = node.description;
                }
                if (node.type && (!existingNode.type || existingNode.type === "generic" || existingNode.type.toLowerCase() === "unknown")) {
                    existingNode.type = node.type;
                }
                if (node.parent && !existingNode.parent) {
                    existingNode.parent = node.parent;
                }
            }
        }

        for (const edge of fragment.edges) {
            if (!edge || typeof edge.from !== 'string' || typeof edge.to !== 'string' || typeof edge.relationship !== 'string' ||
                !edge.from.trim() || !edge.to.trim() || !edge.relationship.trim()) {
                console.warn("[KG Service Merge] Skipping invalid edge (missing from/to/relationship or empty):", edge);
                continue;
            }
            const edgeKey = `${edge.from.trim()}|${edge.to.trim()}|${edge.relationship.trim().toUpperCase()}`;
            finalEdgesSet.add(edgeKey);
        }
    }

    const mergedNodes = Array.from(finalNodesMap.values());
    const mergedEdges = Array.from(finalEdgesSet).map(edgeKey => {
        const [from, to, relationship] = edgeKey.split('|');
        return { from, to, relationship };
    });

    console.log(`[KG Service Merge] Merged into ${mergedNodes.length} nodes and ${mergedEdges.length} edges.`);
    return { nodes: mergedNodes, edges: mergedEdges };
}

async function generateAndStoreKg(chunksForKg, userId, originalName, llmProvider, ollamaModel) {
    const logPrefix = `[KG Service Doc: ${originalName}, User: ${userId}]`;
    console.log(`${logPrefix} Starting KG generation with ${chunksForKg.length} initial chunks.`);

    if (!chunksForKg || chunksForKg.length === 0) {
        console.warn(`${logPrefix} No chunks provided for KG generation.`);
        return { success: true, message: "No chunks to process for KG.", finalKgNodesCount: 0, finalKgEdgesCount: 0 };
    }

    const allGraphFragments = [];
    const BATCH_SIZE = parseInt(process.env.KG_GENERATION_BATCH_SIZE) || 25;
    console.log(`${logPrefix} Using batch size: ${BATCH_SIZE}`);
    let batchIndex = 0;

    for (let i = 0; i < chunksForKg.length; i += BATCH_SIZE) {
        batchIndex++;
        const currentBatchOfChunks = chunksForKg.slice(i, i + BATCH_SIZE);
        
        const validChunksInBatch = currentBatchOfChunks.filter(chunk => chunk && chunk.text_content && chunk.text_content.trim() !== '');
        if (validChunksInBatch.length === 0) {
            console.log(`${logPrefix} Batch ${batchIndex} has no valid chunks with text. Skipping.`);
            continue;
        }
        
        console.log(`${logPrefix} Processing batch ${batchIndex} (chunks ${i} to ${Math.min(i + BATCH_SIZE - 1, chunksForKg.length - 1)}), ${validChunksInBatch.length} valid chunks.`);
        
        const fragmentsFromBatch = await _processBatchOfChunksForKg(validChunksInBatch, batchIndex, llmProvider, ollamaModel);
        if (fragmentsFromBatch && fragmentsFromBatch.length > 0) {
            allGraphFragments.push(...fragmentsFromBatch);
        } else {
            console.warn(`${logPrefix} Batch ${batchIndex} yielded no valid graph fragments.`);
        }
    }

    if (allGraphFragments.length === 0) {
        console.warn(`${logPrefix} No valid graph fragments were generated from any batch.`);
        return { success: true, message: "No KG data extracted from any document chunks.", finalKgNodesCount: 0, finalKgEdgesCount: 0 };
    }

    console.log(`${logPrefix} Generated a total of ${allGraphFragments.length} raw graph fragments. Merging...`);
    const finalKg = _mergeGraphFragments(allGraphFragments);
    
    if (!finalKg || finalKg.nodes.length === 0) {
        console.warn(`${logPrefix} Merged KG has no nodes. Nothing to store.`);
         return { success: true, message: "Merged KG was empty after processing all fragments.", finalKgNodesCount: 0, finalKgEdgesCount: 0 };
    }
    console.log(`${logPrefix} Merged KG successfully. Nodes: ${finalKg.nodes.length}, Edges: ${finalKg.edges.length}.`);

    const baseRagUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!baseRagUrl) {
        return { success: false, message: "KG generated, but Python Service URL is not configured. KG not stored." };
    }
    const kgIngestionApiUrl = `${baseRagUrl.replace(/\/$/, '')}/kg`;

    console.log(`${logPrefix} Sending final merged KG to Ingestion API: ${kgIngestionApiUrl}`);
    try {
        const payload = {
            userId: userId,
            originalName: originalName,
            nodes: finalKg.nodes,
            edges: finalKg.edges
        };

        const serviceResponse = await axios.post(kgIngestionApiUrl, payload, {
            timeout: 300000
        });

        const responseData = serviceResponse.data;
        const API_SUCCESS_STATUS_VALUE = "completed";

        if (serviceResponse.status >= 200 && serviceResponse.status < 300 && responseData && responseData.status === API_SUCCESS_STATUS_VALUE) {
            const successMessage = `KG for '${originalName}' successfully processed by Ingestion API.`;
            console.log(`${logPrefix} ${successMessage}`);
            return {
                success: true, message: successMessage,
                finalKgNodesCount: finalKg.nodes.length, finalKgEdgesCount: finalKg.edges.length
            };
        } else {
            const failureMessage = `KG Ingestion API for '${originalName}' indicated failure. API Msg: ${responseData?.message || responseData?.error || 'No specific error from API.'}`;
            console.warn(`${logPrefix} ${failureMessage}`);
            return {
                success: false, message: failureMessage,
                finalKgNodesCount: finalKg.nodes.length, finalKgEdgesCount: finalKg.edges.length
            };
        }
    } catch (error) {
        const errorMsg = error.response?.data?.message || error.response?.data?.error || error.message || "Unknown error calling KG Ingestion API";
        console.error(`${logPrefix} Error calling KG Ingestion API:`, errorMsg);
        return {
            success: false, message: `KG generated, but error calling KG Ingestion API: ${errorMsg}`,
            finalKgNodesCount: finalKg.nodes.length, finalKgEdgesCount: finalKg.edges.length
        };
    }
}

module.exports = { generateAndStoreKg };
```

`server/services/ollamaService.js`

```javascript
// server/services/ollamaService.js
const axios = require('axios');

const SERVER_DEFAULT_OLLAMA_URL = process.env.OLLAMA_API_BASE_URL || 'https://angels-himself-fixtures-unknown.trycloudflare.com';
const DEFAULT_OLLAMA_MODEL = process.env.OLLAMA_DEFAULT_MODEL || 'qwen2.5:14b-instruct';

const DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_CHAT = 4096;
const DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_KG = 8192;

// This function formats history for the /api/chat endpoint
function formatHistoryForOllamaChat(chatHistory) {
    return chatHistory.map(msg => ({
        role: msg.role === 'model' ? 'assistant' : 'user',
        content: msg.parts?.[0]?.text || ''
    }));
}

async function generateContentWithHistory(
    chatHistory,
    currentUserQuery,
    systemPromptText = null,
    options = {}
) {
    const baseUrlToUse = options.ollamaUrl || SERVER_DEFAULT_OLLAMA_URL;
    const modelToUse = options.model || DEFAULT_OLLAMA_MODEL;
    const effectiveMaxOutputTokens = options.maxOutputTokens || DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_CHAT;
    
    const headers = { 'Content-Type': 'application/json' };
    if (options.apiKey) {
        headers['Authorization'] = `Bearer ${options.apiKey}`;
    }

    // --- THIS IS THE FIX ---
    // Decide which endpoint to use based on whether there's a real history.
    // Our Router call sends an empty history, so it will use /api/generate.
    // Real chat calls will have history and use /api/chat.
    let endpoint;
    let requestPayload;

    if (!chatHistory || chatHistory.length === 0) {
        // Use /api/generate for one-shot requests like the Router agent
        endpoint = `${baseUrlToUse}/api/generate`;
        console.log(`Ollama Service: Using /api/generate endpoint for one-shot request.`);
        requestPayload = {
            model: modelToUse,
            prompt: currentUserQuery, // The user query is the full prompt
            system: systemPromptText || "You are a helpful AI assistant.",
            stream: false,
            options: {
                temperature: options.temperature || 0.7,
                num_predict: effectiveMaxOutputTokens,
            }
        };
    } else {
        // Use /api/chat for actual conversations with history
        endpoint = `${baseUrlToUse}/api/chat`;
        console.log(`Ollama Service: Using /api/chat endpoint for conversation with history.`);
        const messages = formatHistoryForOllamaChat(chatHistory);
        messages.push({ role: 'user', content: currentUserQuery }); // Add the current query
        
        requestPayload = {
            model: modelToUse,
            messages: messages,
            stream: false,
            options: {
                temperature: options.temperature || 0.7,
                // num_predict is often not needed for /chat, but can be included
            }
        };
        // For /chat, the system prompt is part of the messages array if needed
        if (systemPromptText) {
             messages.unshift({ role: 'system', content: systemPromptText });
        }
    }
    // --- END OF FIX ---

    console.log(`Ollama Service: Sending request to ${endpoint} for model ${modelToUse}.`);

    try {
        const response = await axios.post(endpoint, requestPayload, { 
            headers,
            timeout: 120000 
        });

        // Handle different response structures from /generate and /chat
        let responseText = '';
        if (response.data && response.data.response) { // from /api/generate
            responseText = response.data.response;
        } else if (response.data && response.data.message && response.data.message.content) { // from /api/chat
            responseText = response.data.message.content;
        } else {
            throw new Error("Ollama service returned an invalid or unrecognized response structure.");
        }

        return responseText.trim();
        
    } catch (error) {
        console.error("Ollama API Call Error:", error.message);
        const clientMessage = error.response?.data?.error || "Failed to get response from Ollama service.";
        const enhancedError = new Error(clientMessage);
        enhancedError.status = error.response?.status || 503;
        throw enhancedError;
    }
}

module.exports = {
    generateContentWithHistory,
    DEFAULT_OLLAMA_MODEL,
    DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_CHAT,
    DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_KG,
};
```

`server/services/ragQueryService.js`

```javascript
// server/services/ragQueryService.js
const axios = require('axios');

async function queryPythonRagService(
    query, documentContextNameToPass, criticalThinkingEnabled, clientFilter = null, k = 5
) {
    // ... (function logic is identical) ...
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        console.error("PYTHON_RAG_SERVICE_URL is not set. RAG features disabled for this request.");
        return { references: [], toolOutput: "RAG service is not configured on the server." };
    }
    const searchUrl = `${pythonServiceUrl}/query`;
    console.log(`[ragQueryService] Querying Python RAG: Query="${query.substring(0, 50)}...", DocContext=${documentContextNameToPass}`);

    const payload = {
        query: query,
        k: k,
        user_id: "agent_user",
        use_kg_critical_thinking: !!criticalThinkingEnabled,
        documentContextName: documentContextNameToPass || null
    };
    if (clientFilter && typeof clientFilter === 'object' && Object.keys(clientFilter).length > 0) {
        payload.filter = clientFilter;
    }

    try {
        const response = await axios.post(searchUrl, payload, {
            headers: { 'Content-Type': 'application/json' },
            timeout: process.env.PYTHON_RAG_TIMEOUT || 30000
        });

        const relevantDocs = response.data?.retrieved_documents_list || [];
        const references = relevantDocs.map((doc, index) => ({
            number: index + 1,
            source: doc.metadata?.file_name || doc.metadata?.original_name || 'Unknown Document',
            content_preview: (doc.page_content || "").substring(0, 100) + "...",
        }));
        
        const toolOutput = relevantDocs.length > 0
            ? response.data.formatted_context_snippet
            : "No relevant context was found in the specified documents for this query.";

        return { references, toolOutput };

    } catch (error) {
        let errorMsg = error.message;
        if (error.response?.data?.error) errorMsg = `Python Service Error: ${error.response.data.error}`;
        else if (error.code === 'ECONNABORTED') errorMsg = 'Python RAG service request timed out.';
        console.error(`[ragQueryService] Error calling Python RAG service at ${searchUrl}:`, errorMsg);
        throw new Error(errorMsg);
    }
}

module.exports = {
    queryPythonRagService,
};
```

`server/services/summarizationService.js`

```javascript
// server/services/summarizationService.js
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');

// This prompt is key. It instructs the LLM on how to create a good, cumulative summary.
const SUMMARIZATION_SYSTEM_PROMPT = `You are an expert conversation summarizer. Your task is to create a concise, yet comprehensive summary of the provided chat history between a User and an AI Assistant.

If an "Existing Summary" is provided, you MUST integrate the "New Messages" into it to create a single, updated, and coherent summary. Do not just append the new information; seamlessly weave it into the existing narrative.

The final summary MUST be in the third person.
Focus on capturing:
- The user's primary goals or questions.
- Key facts, concepts, or entities discussed.
- Important conclusions or resolutions reached.
- Any unresolved questions or next steps mentioned by the user.

Do NOT include conversational filler (e.g., "The user said hello"). The output should be a dense, information-rich paragraph.

Example of a good updated summary:
"Previously, the user, a PhD student, asked about 'Separation of Concerns'. In the latest exchange, they pivoted to inquiring about the specifics of Ohm's Law, and the AI provided the formula V=IR based on a document the user supplied. The user's current goal appears to be understanding foundational engineering concepts, moving from software to electrical principles."
`;

/**
 * Creates or updates a conversation summary.
 * @param {Array<Object>} messagesToSummarize - The array of new message objects to add to the summary.
 * @param {string} existingSummary - The existing summary from the database.
 * @param {string} llmProvider - The LLM provider to use ('gemini' or 'ollama').
 * @param {string} ollamaModel - The specific Ollama model if the provider is 'ollama'.
 * @returns {Promise<string>} The generated summary text.
 */
async function createOrUpdateSummary(messagesToSummarize, existingSummary, llmProvider, ollamaModel, userApiKey, userOllamaUrl) {
    if (!messagesToSummarize || messagesToSummarize.length === 0) {
        return existingSummary || "";
    }

    const newMessagesText = messagesToSummarize.map(msg => {
        const role = msg.role === 'model' ? 'Assistant' : 'User';
        const text = msg.parts?.[0]?.text || '';
        return `${role}: ${text}`;
    }).join('\n\n');

    let userPrompt = "";
    if (existingSummary && existingSummary.trim() !== "") {
        userPrompt = `Existing Summary:\n"""\n${existingSummary}\n"""\n\nNew Messages to integrate:\n"""\n${newMessagesText}\n"""\n\nPlease provide the new, updated summary.`;
    } else {
        userPrompt = `New Messages to summarize:\n"""\n${newMessagesText}\n"""\n\nPlease provide the summary.`;
    }

    const historyForLlm = [{ role: 'user', parts: [{ text: userPrompt }] }];

    console.log(`[SummarizationService] Requesting summary using ${llmProvider}.`);

    try {
        let summary;
        const llmOptions = { 
            apiKey: userApiKey,
            ollamaUrl: userOllamaUrl
        };
        if (llmProvider === 'ollama') {
            summary = await ollamaService.generateContentWithHistory(
                historyForLlm, SUMMARIZATION_SYSTEM_PROMPT, null, { ...llmOptions, model: ollamaModel }
            );
        } else {
            summary = await geminiService.generateContentWithHistory(
                historyForLlm, userPrompt, SUMMARIZATION_SYSTEM_PROMPT, llmOptions
            );
        }
        console.log(`[SummarizationService] Summary generated successfully.`);
        return summary.trim();
    } catch (error) {
        console.error(`[SummarizationService] Error generating summary: ${error.message}`);
        // --- THIS IS THE FIX ---
        // Instead of returning an empty string, return a descriptive error.
        // This will be saved in the DB and visible to the admin.
        const errorMessage = `Summary generation failed: ${error.message}`;
        return errorMessage;
        // --- END OF FIX ---
    }
}

module.exports = { createOrUpdateSummary };
```

`server/services/toolExecutionService.js`

```javascript
// server/services/toolExecutionService.js
const axios = require('axios');

const PYTHON_SERVICE_URL = process.env.PYTHON_RAG_SERVICE_URL;

async function queryPythonRagService(query, documentContextName, clientFilter = null, k = 5) {
    if (!PYTHON_SERVICE_URL) {
        throw new Error("RAG service is not configured on the server.");
    }
    const searchUrl = `${PYTHON_SERVICE_URL}/query`;
    
    const payload = {
        query: query,
        k: k,
        user_id: "agent_user",
        documentContextName: documentContextName || null
    };
    
    if (clientFilter) {
        payload.filter = clientFilter;
    }

    try {
        const response = await axios.post(searchUrl, payload, { timeout: 30000 });
        const relevantDocs = response.data?.retrieved_documents_list || [];
        const references = relevantDocs.map((doc, index) => ({
            number: index + 1,
            source: doc.metadata?.file_name || doc.metadata?.original_name || 'Unknown Document',
            content_preview: (doc.page_content || "").substring(0, 100) + "...",
        }));
        
        const toolOutput = relevantDocs.length > 0
            ? response.data.formatted_context_snippet
            : "No relevant context was found in the specified documents for this query.";

        return { references, toolOutput };
    } catch (error) {
        const errorMsg = error.response?.data?.error || `Python Service Error: ${error.message}`;
        console.error(`[toolExecutionService] Error calling RAG service:`, errorMsg);
        throw new Error(errorMsg);
    }
}

async function queryKgService(query, documentName, userId) {
    if (!PYTHON_SERVICE_URL) {
        throw new Error("Knowledge Graph service is not configured on the server.");
    }
    const kgUrl = `${PYTHON_SERVICE_URL}/query_kg`;
    try {
        const response = await axios.post(kgUrl, {
            query: query,
            document_name: documentName,
            user_id: userId,
        }, { timeout: 20000 });

        return response.data?.facts || "No facts found in knowledge graph.";
    } catch (error) {
        const errorMsg = error.response?.data?.error || `KG Service Error: ${error.message}`;
        console.error(`[toolExecutionService] Error calling KG service:`, errorMsg);
        return `Could not retrieve facts from knowledge graph: ${errorMsg}`;
    }
}

module.exports = {
    queryPythonRagService,
    queryKgService
};
```

`server/services/toolRegistry.js`

```javascript


// server/services/toolRegistry.js
const { performWebSearch } = require('./webSearchService.js');
const { queryPythonRagService, queryKgService } = require('./toolExecutionService.js');
const axios = require('axios');

// Helper function to call the Python academic search endpoint
async function queryAcademicService(query) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        throw new Error("Academic search service is not configured on the server.");
    }
    const searchUrl = `${pythonServiceUrl}/academic_search`;
    
    try {
        console.log(`[toolRegistry] Calling Python academic search at ${searchUrl} for query: "${query}"`);
        const response = await axios.post(searchUrl, { query }, { timeout: 45000 });
        const papers = response.data?.results || [];
        
        // --- THIS IS THE FIX ---
        // Format the results into a string with all necessary details for the Synthesizer prompt
        const toolOutput = papers.length > 0
            ? "Found the following relevant academic papers:\n\n" + papers.map((p, index) => 
                `[${index + 1}] Title: ${p.title || 'Untitled Paper'}\n` +
                `   Source: ${p.source || 'Unknown'}\n` +
                `   URL: ${p.url || '#'}\n` +
                `   Authors: ${p.authors ? p.authors.join(', ') : 'N/A'}\n` +
                `   Summary: ${p.summary ? p.summary.substring(0, 400).replace(/\s+/g, ' ') + '...' : 'No summary available.'}`
              ).join('\n\n')
            : "No relevant academic papers were found for this query.";
        
        const references = papers.map((p, index) => ({
            number: index + 1,
            source: `${p.authors ? p.authors.slice(0, 2).join(', ') + (p.authors.length > 2 ? ', et al.' : '') : 'N/A'}. (${p.source || 'N/A'})`,
            content_preview: p.title || 'Untitled Paper',
        }));

        return { references, toolOutput };
        // --- END OF FIX ---

    } catch (error) {
        const errorMsg = error.response?.data?.error || `Academic Service Error: ${error.message}`;
        console.error(`[toolRegistry] Error calling academic search service:`, errorMsg);
        throw new Error(errorMsg);
    }
}

const availableTools = {
  web_search: {
    description: "Use this tool to search the internet for real-time, up-to-date information.",
    execute: async (params) => {
        const searchResultsString = await performWebSearch(params.query);
        return {
            references: [],
            toolOutput: searchResultsString || "No results found from web search.",
        };
    },
    requiredParams: ['query'],
  },
  rag_search: {
    description: "Use this tool to search the content of a specific, user-provided document.",
    execute: async (params, context) => {
        return await queryPythonRagService(
            params.query,
            context.documentContextName,
            context.filter
        );
    },
    requiredParams: ['query'],
  },
  kg_search: {
    description: "Use this tool to find structured facts and relationships within a document's knowledge graph.",
     execute: async (params, context) => {
        const facts = await queryKgService(
            params.query,
            context.documentContextName,
            context.userId
        );
        return {
            references: [],
            toolOutput: facts,
        };
    },
    requiredParams: ['query'],
  },
  academic_search: {
    description: "Use this tool to find academic papers, research articles, and scholarly publications.",
    execute: async (params) => {
        return await queryAcademicService(params.query);
    },
    requiredParams: ['query'],
  }
};

module.exports = {
    availableTools,
};
```

`server/services/totOrchestrator.js`

```javascript
// server/services/totOrchestrator.js

const { processAgenticRequest } = require('./agentService'); // IMPORTANT: We now call the agent

/**
 * Helper function to write a Server-Sent Event (SSE) to the client.
 * @param {object} res - The Express response object.
 * @param {object} eventData - The data to send to the client.
 */
function streamEvent(res, eventData) {
    res.write(`data: ${JSON.stringify(eventData)}\n\n`);
}

/**
 * MOCKED Complexity Gate: Decides if a query needs the full ToT process.
 * In a real implementation, this would be a fast LLM call.
 * @param {string} query The user's query.
 * @returns {Promise<boolean>} True if the query is complex.
 */
async function isQueryComplex(query) {
    // Simple rule for testing: queries with multiple question marks or longer than 20 words are complex.
    const isComplex = (query.match(/\?/g) || []).length > 1 || query.split(' ').length > 20;
    console.log(`[ToT] Step 1: Complexity Gate. Query: "${query.substring(0, 30)}...". Decision: ${isComplex ? 'COMPLEX' : 'SIMPLE'}`);
    return isComplex;
}

/**
 * MOCKED Planner: Generates different high-level plans.
 * @param {string} query The user's query.
 * @returns {Promise<Array<Object>>} A list of plan objects.
 */
async function generatePlans(query) {
    console.log('[ToT] Step 2: Planner. Generating plans...');
    // In production, an LLM would generate these based on the query.
    // Each plan is an array of sub-tasks for the agent.
    const plans = [
        {
            name: "Structured Research Plan",
            steps: [
                "First, research the theoretical comparison between the two models using internal documents.",
                "Second, perform a web search for recent, real-world information on the topic."
            ]
        },
        {
            name: "Naive Combined Plan",
            steps: [
                "Perform a single, combined search using all keywords from the user's query."
            ]
        }
    ];
    return plans;
}

/**
 * MOCKED Evaluator: Selects the best plan.
 * @param {Array<Object>} plans The list of plans.
 * @returns {Promise<Object>} The winning plan object.
 */
async function evaluatePlans(plans) {
    console.log('[ToT] Step 3: Evaluator. Evaluating plans...');
    // In production, an LLM would rank these. We'll hardcode the choice for now.
    const winningPlan = plans[0]; // Always choose the "Structured Research Plan"
    console.log(`[ToT] Step 3: Evaluator. Winning plan selected: "${winningPlan.name}"`);
    return winningPlan;
}

/**
 * Executor: Executes the winning plan by calling the Agentic Router for each step.
 * @param {Object} winningPlan - The plan object with a `steps` array.
 * @param {string} originalQuery - The user's original full query.
 * @param {object} requestContext - The full context object for the agent.
 * @param {object} res - The Express response object for streaming thoughts.
 * @returns {Promise<string>} A string containing all the collected context.
 */
async function executePlan(winningPlan, originalQuery, requestContext, res) {
    console.log('[ToT] Step 4: Executor. Starting execution of plan...');
    let collectedContexts = [];

    for (let i = 0; i < winningPlan.steps.length; i++) {
        const stepDescription = winningPlan.steps[i];
        const thought = `Executing Step ${i + 1}/${winningPlan.steps.length}: ${stepDescription}`;
        streamEvent(res, { type: 'thought', content: thought });
        console.log(`[ToT] Executor: ${thought}`);
        
        // The Executor's job is to use the Agent for each sub-task.
        // We pass the *original query* to give the agent full context, but the sub-task
        // description could be used in a more advanced prompt to guide the agent.
        // For now, we rely on the agent's own routing based on the requestContext.
        const agentResponse = await processAgenticRequest(
            originalQuery, // Use the original query to ensure context is not lost
            [], // History is handled by the synthesizer later
            `Fulfill this sub-task: "${stepDescription}"`,
            requestContext
        );

        collectedContexts.push(`--- Context from Step ${i + 1} (${agentResponse.sourcePipeline}) ---\n${agentResponse.finalAnswer}`);
    }

    console.log('[ToT] Step 4: Executor. All steps executed.');
    return collectedContexts.join('\n\n');
}

/**
 * Synthesizer: Creates the final answer from all collected context.
 * @param {string} originalQuery - The user's original full query.
 * @param {string} finalContext - The combined context from all executor steps.
 * @param {Array} chatHistory - The full conversational history.
 * @param {object} requestContext - The context for the LLM call.
 * @returns {Promise<string>} The final, polished answer.
 */
async function synthesizeFinalAnswer(originalQuery, finalContext, chatHistory, requestContext) {
    console.log('[ToT] Step 5: Synthesizer. Creating final response...');
    const { llmProvider, ...llmOptions } = requestContext;
    const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;

    const synthesizerPrompt = `You are an expert AI Tutor. A multi-step reasoning process has been completed to gather comprehensive information. Your task is to synthesize all the provided context into a single, cohesive, and well-structured final answer for the user's original query.\n\n--- COLLECTED CONTEXT ---\n${finalContext}\n\n--- ORIGINAL USER QUERY ---\n${originalQuery}`;

    const finalAnswer = await llmService.generateContentWithHistory(
        chatHistory,
        synthesizerPrompt,
        requestContext.systemPrompt, // Use the user's selected system prompt
        llmOptions
    );
    return finalAnswer;
}


/**
 * Main orchestration logic for the Tree of Thoughts process with streaming.
 * @param {string} query The user's query.
 * @param {Array} chatHistory The conversational history.
 * @param {object} requestContext The full context for the request.
 * @param {object} res The Express response object for streaming.
 * @returns {Promise<Object>} An object containing the final answer and all thoughts.
 */
async function processQueryWithToT_Streaming(query, chatHistory, requestContext, res) {
    const allThoughts = [];

    const streamAndStoreThought = (content) => {
        streamEvent(res, { type: 'thought', content });
        allThoughts.push(content);
    };

    const isComplex = await isQueryComplex(query);

    if (!isComplex) {
        streamAndStoreThought("Query is straightforward. Generating a direct response.");
        const directResponse = await processAgenticRequest(query, chatHistory, requestContext.systemPrompt, requestContext);
        streamEvent(res, { type: 'final_answer', content: directResponse.finalAnswer });
        return { finalAnswer: directResponse.finalAnswer, thoughts: allThoughts, references: directResponse.references, sourcePipeline: directResponse.sourcePipeline };
    }

    // --- Full ToT Flow ---
    streamAndStoreThought("Complex query detected. Initiating multi-step reasoning process...");
    
    const plans = await generatePlans(query);
    streamAndStoreThought(`Generated ${plans.length} potential plans. Evaluating the best approach...`);
    
    const winningPlan = await evaluatePlans(plans);
    streamAndStoreThought(`Best plan selected: "${winningPlan.name}". Beginning execution...`);

    const finalContext = await executePlan(winningPlan, query, requestContext, res);
    streamAndStoreThought("All information gathered. Synthesizing final answer...");

    const finalAnswer = await synthesizeFinalAnswer(query, finalContext, chatHistory, requestContext);
    streamEvent(res, { type: 'final_answer', content: finalAnswer });
    
    console.log('--- ToT Streaming Orchestration Finished ---');
    return { finalAnswer, thoughts: allThoughts, references: [], sourcePipeline: `tot-${requestContext.llmProvider}` };
}

module.exports = {
    processQueryWithToT_Streaming
};
```

`server/services/webSearchService.js`

```javascript
// server/services/webSearchService.js
const axios = require('axios');

async function performWebSearch(query) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;

    if (!pythonServiceUrl) {
        console.warn("[WebSearch Service] PYTHON_RAG_SERVICE_URL is not set. Web search is disabled.");
        // Throw an error so the agent knows the tool is unavailable
        throw new Error("Web search tool is not configured on the server.");
    }

    const searchUrl = `${pythonServiceUrl}/web_search`;

    try {
        console.log(`[WebSearch Service] Calling Python endpoint for search: ${searchUrl}`);
        const response = await axios.post(searchUrl, { query: query }, { timeout: 15000 });

        if (response.data && Array.isArray(response.data) && response.data.length > 0) {
            const topResults = response.data;
            
            const formattedResults = topResults.map((result, index) => {
                const title = result.title || 'No Title';
                const url = result.url || '#';
                const content = result.content ? result.content.replace(/[\n\r]+/g, ' ').trim() : 'No content preview.';
                return `[${index + 1}] Title: ${title}\nSource: ${url}\nContent: ${content}`;
            }).join('\n\n');

            return `[WEB SEARCH RESULTS]\n${formattedResults}`;
        } else {
            console.log(`[WebSearch Service] Python service returned no results for query: "${query}"`);
            return "Web search did not return any results for this query.";
        }
    } catch (error) {
        let errorMessage = `Error calling Python service for query "${query}": `;
        if (error.response) {
            errorMessage += `Status ${error.response.status} - ${JSON.stringify(error.response.data)}`;
        } else if (error.request) {
            errorMessage += `No response received from Python service at ${searchUrl}.`;
        } else {
            errorMessage += error.message;
        }
        console.error(errorMessage);
        // --- FIX: Throw the error to be caught by the agent service ---
        throw new Error(error.message);
    }
}

module.exports = { performWebSearch };
```

`server/utils/assetCleanup.js`

```javascript
const fs = require('fs').promises; // Use fs.promises for async operations
const path = require('path');

// Define constants relative to this file's location (server/utils)
const ASSETS_DIR = path.join(__dirname, '..', 'assets'); // Go up one level to server/assets
const BACKUP_DIR = path.join(__dirname, '..', 'backup_assets'); // Go up one level to server/backup_assets
const FOLDER_TYPES = ['docs', 'images', 'code', 'others']; // Folders within each user's asset dir

/**
 * Moves existing user asset folders (docs, images, code, others) to a timestamped
 * backup location and recreates empty asset folders for each user on server startup.
 */
async function performAssetCleanup() {
    console.log("\n--- Starting Asset Cleanup ---");
    try {
        // Ensure backup base directory exists
        await fs.mkdir(BACKUP_DIR, { recursive: true });

        // List potential user directories in assets
        let userDirs = [];
        try {
            userDirs = await fs.readdir(ASSETS_DIR);
        } catch (err) {
            if (err.code === 'ENOENT') {
                console.log("Assets directory doesn't exist yet, creating it and skipping cleanup.");
                await fs.mkdir(ASSETS_DIR, { recursive: true }); // Ensure assets dir exists
                console.log("--- Finished Asset Cleanup (No existing assets found) ---");
                return; // Nothing to clean up
            }
            throw err; // Re-throw other errors accessing assets dir
        }

        if (userDirs.length === 0) {
             console.log("Assets directory is empty. Skipping backup/move operations.");
             console.log("--- Finished Asset Cleanup (No user assets found) ---");
             return;
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); // Create a safe timestamp string

        for (const userName of userDirs) {
            const userAssetPath = path.join(ASSETS_DIR, userName);
            const userBackupPathBase = path.join(BACKUP_DIR, userName);
            const userTimestampBackupPath = path.join(userBackupPathBase, `backup_${timestamp}`);

            try {
                // Check if the item in assets is actually a directory
                const stats = await fs.stat(userAssetPath);
                if (!stats.isDirectory()) {
                    console.log(`  Skipping non-directory item in assets: ${userName}`);
                    continue;
                }

                console.log(`  Processing assets for user: [${userName}]`);
                let backupDirCreated = false; // Track if backup dir was created for this user/run
                let movedSomething = false; // Track if anything was actually moved

                // Process each defined folder type (docs, images, etc.)
                for (const type of FOLDER_TYPES) {
                    const sourceTypePath = path.join(userAssetPath, type);
                    try {
                        // Check if the source type directory exists before trying to move
                        await fs.access(sourceTypePath);

                        // If source exists, ensure the timestamped backup directory is ready
                        if (!backupDirCreated) {
                            await fs.mkdir(userTimestampBackupPath, { recursive: true });
                            backupDirCreated = true;
                            // console.log(`    Created backup directory: ${userTimestampBackupPath}`);
                        }

                        // Define the destination path in the backup folder
                        const backupTypePath = path.join(userTimestampBackupPath, type);
                        // console.log(`    Moving ${sourceTypePath} to ${backupTypePath}`);
                        // Move the existing type folder to the backup location
                        await fs.rename(sourceTypePath, backupTypePath);
                        movedSomething = true;

                    } catch (accessErr) {
                        // Ignore error if the source directory doesn't exist (ENOENT)
                        if (accessErr.code !== 'ENOENT') {
                            console.error(`    Error accessing source folder ${sourceTypePath}:`, accessErr.message);
                        }
                        // If ENOENT, the folder doesn't exist, nothing to move.
                    }

                    // Always ensure the empty type directory exists in the main assets folder
                    try {
                        // console.log(`    Ensuring empty directory: ${sourceTypePath}`);
                        await fs.mkdir(sourceTypePath, { recursive: true });
                    } catch (mkdirErr) {
                         console.error(`    Failed to recreate directory ${sourceTypePath}:`, mkdirErr.message);
                    }
                } // End loop through FOLDER_TYPES

                 if (movedSomething) {
                     console.log(`  Finished backup for user [${userName}] to backup_${timestamp}`);
                 } else {
                     console.log(`  No existing asset types found to backup for user [${userName}]`);
                 }


            } catch (userDirStatErr) {
                 // Error checking if the item in assets is a directory
                 console.error(`Error processing potential user asset directory ${userAssetPath}:`, userDirStatErr.message);
            }
        } // End loop through userDirs

        console.log("--- Finished Asset Cleanup ---");

    } catch (error) {
        // Catch errors related to backup dir creation or reading the main assets dir
        console.error("!!! Critical Error during Asset Cleanup process:", error);
    }
}

// Export the function to be used elsewhere
module.exports = { performAssetCleanup };

```

`server/utils/crypto.js`

```javascript
// server/utils/crypto.js
const crypto = require("crypto");

const ALGORITHM = "aes-256-cbc";
const IV_LENGTH = 16;

let ENCRYPTION_KEY_BUFFER;
try {
  if (
    !process.env.ENCRYPTION_SECRET ||
    process.env.ENCRYPTION_SECRET.length !== 64
  ) {
    throw new Error(
      "ENCRYPTION_SECRET must be a 64-character hexadecimal string."
    );
  }
  ENCRYPTION_KEY_BUFFER = Buffer.from(process.env.ENCRYPTION_SECRET, "hex");
  if (ENCRYPTION_KEY_BUFFER.length !== 32) {
    throw new Error(
      "Derived encryption key is not 32 bytes long. Check ENCRYPTION_SECRET format."
    );
  }
} catch (e) {
  console.error(`FATAL CRYPTO CONFIG ERROR: ${e.message}`);
  ENCRYPTION_KEY_BUFFER = null;
}

function encrypt(text) {
  if (!text) return null;
  if (!ENCRYPTION_KEY_BUFFER) {
    console.error(
      "FATAL: Encryption service is not properly configured. Cannot encrypt."
    );
    throw new Error("Encryption service is not properly configured.");
  }
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY_BUFFER, iv);
  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");
  return iv.toString("hex") + ":" + encrypted;
}

function decrypt(text) {
  if (!text) return null;
  if (!ENCRYPTION_KEY_BUFFER) {
    console.error(
      "FATAL: Decryption service is not properly configured. Cannot decrypt."
    );
    throw new Error("Decryption service is not properly configured.");
  }
  try {
    const textParts = text.split(":");
    if (textParts.length !== 2) {
      console.error("Decryption failed: Invalid encrypted text format.");
      return null;
    }
    const iv = Buffer.from(textParts.shift(), "hex");
    const encryptedText = Buffer.from(textParts.join(":"), "hex");
    const decipher = crypto.createDecipheriv(
      ALGORITHM,
      ENCRYPTION_KEY_BUFFER,
      iv
    );
    let decrypted = decipher.update(encryptedText, "hex", "utf8");
    decrypted += decipher.final("utf8");

    return decrypted.toString();
  } catch (error) {
    console.error("Decryption failed for text:", text, "Error:", error.message);
    return null;
  }
}

module.exports = { encrypt, decrypt };

```

`server/utils/networkUtils.js`

```javascript
const os = require('os');

function getLocalIPs() {
    const interfaces = os.networkInterfaces();
    const ips = new Set(['localhost']); // Include localhost

    for (const iface of Object.values(interfaces)) {
        for (const addr of iface) {
            // Include IPv4 non-internal addresses
            if (addr.family === 'IPv4' && !addr.internal) {
                ips.add(addr.address);
            }
        }
    }
    return Array.from(ips);
}

function getPreferredLocalIP() {
    const ips = getLocalIPs();
    // Prioritize non-localhost, non-link-local (169.254) IPs
    // Often 192.168.* or 10.* or 172.16-31.* are common private ranges
    return ips.find(ip => !ip.startsWith('169.254.') && ip !== 'localhost' && (ip.startsWith('192.168.') || ip.startsWith('10.') || ip.match(/^172\.(1[6-9]|2[0-9]|3[0-1])\./))) ||
           ips.find(ip => !ip.startsWith('169.254.') && ip !== 'localhost') || // Any other non-link-local
           'localhost'; // Fallback
}

module.exports = { getLocalIPs, getPreferredLocalIP };

```

`server/workers/adminAnalysisWorker.js`

```javascript
// server/workers/adminAnalysisWorker.js
const { workerData, parentPort } = require('worker_threads');
const mongoose = require('mongoose');
const path = require('path');

const AdminDocument = require('../models/AdminDocument');
const connectDB = require('../config/db');
const geminiService = require('../services/geminiService');
const { ANALYSIS_PROMPTS } = require('../config/promptTemplates');

// Load .env variables from the server directory for the worker
require('dotenv').config({ path: path.resolve(__dirname, '..', '.env') });


async function performAdminDocAnalysis(adminDocumentId, originalName, textForAnalysis) {
    const logPrefix = `[AdminAnalysisWorker ${process.pid}, Doc: ${originalName}]`;
    console.log(`${logPrefix} Starting analysis. Text length: ${textForAnalysis ? textForAnalysis.length : 0}`);

    const analysisResults = { faq: "", topics: "", mindmap: "" };
    let allIndividualAnalysesSuccessful = true;

    // --- THIS IS THE FIX ---
    // The worker is a system process, so it must use the server's global API key.
    const serverApiKey = process.env.GEMINI_API_KEY;
    if (!serverApiKey) {
        console.error(`${logPrefix} FATAL: Server's GEMINI_API_KEY is not defined in the worker's environment.`);
        // Return a clear error message for all fields
        const errorMessage = "Error generating analysis: Server API key is not configured.";
        return { 
            success: false, 
            results: { faq: errorMessage, topics: errorMessage, mindmap: errorMessage }
        };
    }
    // --- END OF FIX ---

    async function generateSingleAnalysis(type, promptContentForLLM) {
        try {
            console.log(`${logPrefix} Generating ${type}...`);
            const historyForGemini = [{ role: 'user', parts: [{ text: "Perform the requested analysis based on the system instruction and provided document text." }] }];
            
            const generatedText = await geminiService.generateContentWithHistory(
                historyForGemini,
                promptContentForLLM,
                null, // No system prompt needed, it's in the user prompt template
                { apiKey: serverApiKey } // Explicitly pass the server's API key
            );

            if (!generatedText || typeof generatedText !== 'string' || generatedText.trim() === "") {
                console.warn(`${logPrefix} Gemini returned empty content for ${type}.`);
                return { success: false, content: `Notice: No content generated by the AI for ${type}.` };
            }
            console.log(`${logPrefix} ${type} generation successful.`);
            return { success: true, content: generatedText.trim() };
        } catch (error) {
            console.error(`${logPrefix} Error during ${type} generation: ${error.message}`);
            allIndividualAnalysesSuccessful = false;
            return { success: false, content: `Error generating ${type}: ${error.message.split('\n')[0].substring(0, 250)}` };
        }
    }

    if (!textForAnalysis || textForAnalysis.trim() === "") {
        console.warn(`${logPrefix} No text provided for analysis. Skipping generation.`);
        analysisResults.faq = "Skipped: No text content provided.";
        analysisResults.topics = "Skipped: No text content provided.";
        analysisResults.mindmap = "Skipped: No text content provided.";
    } else {
        const analysisPromises = [
            generateSingleAnalysis('FAQ', ANALYSIS_PROMPTS.faq.getPrompt(textForAnalysis)),
            generateSingleAnalysis('Topics', ANALYSIS_PROMPTS.topics.getPrompt(textForAnalysis)),
            generateSingleAnalysis('Mindmap', ANALYSIS_PROMPTS.mindmap.getPrompt(textForAnalysis))
        ];

        const [faqOutcome, topicsOutcome, mindmapOutcome] = await Promise.allSettled(analysisPromises);

        if (faqOutcome.status === 'fulfilled') {
            analysisResults.faq = faqOutcome.value.content;
            if (!faqOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.faq = `Error generating FAQ: ${faqOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }

        if (topicsOutcome.status === 'fulfilled') {
            analysisResults.topics = topicsOutcome.value.content;
            if (!topicsOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.topics = `Error generating Topics: ${topicsOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }

        if (mindmapOutcome.status === 'fulfilled') {
            analysisResults.mindmap = mindmapOutcome.value.content;
            if (!mindmapOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.mindmap = `Error generating Mindmap: ${mindmapOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }
    }
    
    try {
        await AdminDocument.updateOne(
            { _id: adminDocumentId },
            {
                $set: {
                    "analysis.faq": analysisResults.faq,
                    "analysis.topics": analysisResults.topics,
                    "analysis.mindmap": analysisResults.mindmap,
                    "analysisUpdatedAt": new Date()
                }
            }
        );
        console.log(`${logPrefix} Analysis results stored in DB.`);
        return { success: allIndividualAnalysesSuccessful, message: `Analysis ${allIndividualAnalysesSuccessful ? 'completed' : 'completed with some failures'}.`, results: analysisResults };
    } catch (dbError) {
        console.error(`${logPrefix} DB Error storing analysis results:`, dbError);
        return { success: false, message: `DB Error storing analysis: ${dbError.message}`, results: analysisResults };
    }
}

async function run() {
    // ... (The run function that orchestrates the worker remains the same)
    const { adminDocumentId, originalName, textForAnalysis } = workerData;
    let dbConnected = false;
    let overallTaskSuccess = false;
    let finalMessageToParent = "Admin analysis worker encountered an issue.";

    try {
        await connectDB(process.env.MONGO_URI);
        dbConnected = true;
        const analysisServiceResult = await performAdminDocAnalysis(adminDocumentId, originalName, textForAnalysis);
        overallTaskSuccess = analysisServiceResult.success;
        finalMessageToParent = analysisServiceResult.message;
        if (parentPort) {
            parentPort.postMessage({
                success: overallTaskSuccess,
                originalName: originalName,
                adminDocumentId: adminDocumentId,
                message: finalMessageToParent
            });
        }
    } catch (error) {
        console.error(`[AdminAnalysisWorker] Critical error in worker:`, error);
        finalMessageToParent = error.message || "Unknown critical error.";
        if (parentPort) {
            parentPort.postMessage({ success: false, originalName, adminDocumentId, error: finalMessageToParent });
        }
    } finally {
        if (dbConnected) {
            await mongoose.disconnect();
        }
        console.log(`[AdminAnalysisWorker] Finished task for ${originalName}. Overall Success: ${overallTaskSuccess}`);
    }
}

run();
```

`server/workers/analysisWorker.js`

```javascript


// server/workers/analysisWorker.js
const { workerData, parentPort } = require('worker_threads');
const mongoose = require('mongoose');
const path = require('path');

const User = require('../models/User');
const connectDB = require('../config/db');
const geminiService = require('../services/geminiService');
const ollamaService = require('../services/ollamaService');
const { ANALYSIS_PROMPTS } = require('../config/promptTemplates');

require('dotenv').config({ path: path.resolve(__dirname, '..', '.env') });

async function performFullAnalysis(userId, originalName, textForAnalysis, llmProvider, ollamaModel, apiKey, ollamaUrl) {
    const logPrefix = `[Analysis Worker ${process.pid}, Doc: ${originalName}]`;
    console.log(`${logPrefix} Starting analysis. Using provider: ${llmProvider}`);

    const analysisResults = { faq: "", topics: "", mindmap: "" };
    let allIndividualAnalysesSuccessful = true;

    if (llmProvider === 'gemini' && !apiKey) {
        const errorMessage = "Error: Analysis failed because no valid user Gemini API key was provided to the worker.";
        console.error(`${logPrefix} ${errorMessage}`);
        return { 
            success: false, 
            results: { faq: errorMessage, topics: errorMessage, mindmap: errorMessage }
        };
    }

    async function generateSingleAnalysis(type, promptContentForLLM) {
        try {
            console.log(`${logPrefix} Generating ${type} for '${originalName}'.`);
            const historyForLLM = [{ role: 'user', parts: [{ text: "Perform the requested analysis based on the system instruction provided." }] }];
            
            const llmOptions = { 
                apiKey,
                ollamaUrl,
                model: ollamaModel,
                maxOutputTokens: ollamaService.DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_CHAT
            };

            const generatedText = llmProvider === 'ollama'
                ? await ollamaService.generateContentWithHistory(historyForLLM, promptContentForLLM, null, llmOptions)
                : await geminiService.generateContentWithHistory(historyForLLM, promptContentForLLM, null, llmOptions);

            if (!generatedText || typeof generatedText !== 'string' || generatedText.trim() === "") {
                console.warn(`${logPrefix} LLM returned empty content for ${type}.`);
                return { success: false, content: `Notice: No content generated for ${type}.` };
            }
            console.log(`${logPrefix} ${type} generation successful.`);
            return { success: true, content: generatedText.trim() };
        } catch (error) {
            console.error(`${logPrefix} Error during ${type} generation: ${error.message}`);
            allIndividualAnalysesSuccessful = false;
            return { success: false, content: `Error generating ${type}: ${error.message.substring(0, 250)}` };
        }
    }

    const analysisPromises = [
        generateSingleAnalysis('FAQ', ANALYSIS_PROMPTS.faq.getPrompt(textForAnalysis)),
        generateSingleAnalysis('Topics', ANALYSIS_PROMPTS.topics.getPrompt(textForAnalysis)),
        generateSingleAnalysis('Mindmap', ANALYSIS_PROMPTS.mindmap.getPrompt(textForAnalysis))
    ];
    const outcomes = await Promise.allSettled(analysisPromises);

    outcomes.forEach((outcome, index) => {
        const type = ['faq', 'topics', 'mindmap'][index];
        if (outcome.status === 'fulfilled') {
            analysisResults[type] = outcome.value.content;
            if (!outcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults[type] = `Error generating ${type}: ${outcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }
    });
    
    const finalAnalysisStatus = allIndividualAnalysesSuccessful ? "completed" : "failed_partial";
    try {
        await User.updateOne(
            { _id: userId, "uploadedDocuments.filename": originalName },
            {
                $set: {
                    "uploadedDocuments.$.analysis.faq": analysisResults.faq,
                    "uploadedDocuments.$.analysis.topics": analysisResults.topics,
                    "uploadedDocuments.$.analysis.mindmap": analysisResults.mindmap,
                    "uploadedDocuments.$.analysisStatus": finalAnalysisStatus,
                    "uploadedDocuments.$.analysisTimestamp": new Date()
                }
            }
        );
        console.log(`${logPrefix} Analysis results (Status: ${finalAnalysisStatus}) stored in DB.`);
        return { success: allIndividualAnalysesSuccessful, message: `Analysis ${allIndividualAnalysesSuccessful ? 'completed' : 'completed with some failures'}.` };
    } catch (dbError) {
        console.error(`${logPrefix} DB Error storing analysis results:`, dbError);
        return { success: false, message: `DB Error storing analysis: ${dbError.message}` };
    }
}

async function run() {
    const { userId, originalName, textForAnalysis, llmProvider, ollamaModel, apiKey, ollamaUrl } = workerData;
    let dbConnected = false;
    let overallTaskSuccess = false;
    let finalMessageToParent = "Analysis worker encountered an issue.";

    try {
        if (!process.env.MONGO_URI || !userId || !originalName) {
            throw new Error("Worker started with incomplete data (MONGO_URI, userId, or originalName missing).");
        }
        
        await connectDB(process.env.MONGO_URI);
        dbConnected = true;
        await User.updateOne(
            { _id: userId, "uploadedDocuments.filename": originalName },
            { $set: { "uploadedDocuments.$.analysisStatus": "processing" } }
        );

        if (!textForAnalysis || textForAnalysis.trim() === '') {
            await User.updateOne(
                { _id: userId, "uploadedDocuments.filename": originalName },
                { $set: { "uploadedDocuments.$.analysisStatus": "skipped_no_text", "uploadedDocuments.$.analysisTimestamp": new Date() } }
            );
            overallTaskSuccess = true;
            finalMessageToParent = "Analysis skipped: No text provided.";
        } else {
            const result = await performFullAnalysis(
                userId, originalName, textForAnalysis, llmProvider, ollamaModel, apiKey, ollamaUrl
            );
            overallTaskSuccess = result.success;
            finalMessageToParent = result.message;
        }

        if (parentPort) {
            parentPort.postMessage({ success: overallTaskSuccess, originalName, message: finalMessageToParent });
        }

    } catch (error) {
        console.error(`[Analysis Worker] Critical error for '${originalName}':`, error);
        finalMessageToParent = error.message;
        if (dbConnected && userId && originalName) {
            try {
                await User.updateOne(
                    { _id: userId, "uploadedDocuments.filename": originalName },
                    { $set: { "uploadedDocuments.$.analysisStatus": "failed_critical" } }
                );
            } catch (dbUpdateError) {
                console.error(`[Analysis Worker] Failed to update status to 'failed_critical':`, dbUpdateError);
            }
        }
        if (parentPort) {
            parentPort.postMessage({ success: false, originalName, error: finalMessageToParent });
        }
    } finally {
        if (dbConnected) {
            await mongoose.disconnect();
        }
        console.log(`[Analysis Worker] Finished task for ${originalName}. Success: ${overallTaskSuccess}`);
    }
}

run();

```

`server/workers/kgWorker.js`

```javascript
// server/workers/kgWorker.js
const { workerData, parentPort } = require('worker_threads');
const mongoose = require('mongoose');

// --- Models and Services ---
const User = require('../models/User');
const AdminDocument = require('../models/AdminDocument'); // Import AdminDocument model
const connectDB = require('../config/db');
const kgService = require('../services/kgService');

async function runKgGeneration() {
    // --- Destructure all possible fields from workerData ---
    const { chunksForKg, userId, originalName, llmProvider, ollamaModel, adminDocumentId } = workerData;
    
    let dbConnected = false;
    let overallSuccess = false;
    let finalMessage = "KG processing encountered an issue.";
    const logPrefix = `[KG Worker ${process.pid}, Doc: ${originalName}]`;

    try {
        console.log(`${logPrefix} Received task. User/Context: '${userId}'. Chunks: ${chunksForKg ? chunksForKg.length : 0}`);
        if (!process.env.MONGO_URI) throw new Error("MONGO_URI not set in KG worker environment.");
        if (!userId || !originalName) throw new Error("Missing userId or originalName in workerData.");

        await connectDB(process.env.MONGO_URI);
        dbConnected = true;
        console.log(`${logPrefix} DB Connected.`);

        // --- THIS IS THE CORE REFACTORING LOGIC ---
        // Determine which model to update based on the presence of adminDocumentId
        const isProcessingAdminDoc = !!adminDocumentId;
        const ModelToUpdate = isProcessingAdminDoc ? AdminDocument : User;
        const findQuery = isProcessingAdminDoc ? { _id: adminDocumentId } : { _id: userId, "uploadedDocuments.filename": originalName };
        const statusUpdateField = isProcessingAdminDoc ? "kgStatus" : "uploadedDocuments.$.kgStatus";

        await ModelToUpdate.updateOne(findQuery, { $set: { [statusUpdateField]: "processing" } });
        console.log(`${logPrefix} Status set to 'processing' for ${isProcessingAdminDoc ? 'admin document' : 'user document'}.`);

        if (!chunksForKg || chunksForKg.length === 0) {
            finalMessage = "No chunks provided for KG generation.";
            await ModelToUpdate.updateOne(findQuery, { $set: { [statusUpdateField]: "skipped_no_chunks", kgTimestamp: new Date() } });
            overallSuccess = true;
        } else {
            const kgExtractionResult = await kgService.generateAndStoreKg(chunksForKg, userId, originalName, llmProvider, ollamaModel);

            if (kgExtractionResult && kgExtractionResult.success) {
                const updatePayload = {
                    [isProcessingAdminDoc ? "kgStatus" : "uploadedDocuments.$.kgStatus"]: "completed",
                    [isProcessingAdminDoc ? "kgNodesCount" : "uploadedDocuments.$.kgNodesCount"]: kgExtractionResult.finalKgNodesCount,
                    [isProcessingAdminDoc ? "kgEdgesCount" : "uploadedDocuments.$.kgEdgesCount"]: kgExtractionResult.finalKgEdgesCount,
                    [isProcessingAdminDoc ? "kgTimestamp" : "uploadedDocuments.$.kgTimestamp"]: new Date()
                };
                await ModelToUpdate.updateOne(findQuery, { $set: updatePayload });
                overallSuccess = true;
                finalMessage = kgExtractionResult.message || "KG generation and storage completed successfully.";
            } else {
                await ModelToUpdate.updateOne(findQuery, { $set: { [statusUpdateField]: "failed_extraction" } });
                finalMessage = kgExtractionResult?.message || "KG detailed extraction or storage failed.";
                overallSuccess = false;
            }
        }

        if (parentPort) {
            parentPort.postMessage({ success: overallSuccess, originalName, message: finalMessage });
        }

    } catch (error) {
        console.error(`${logPrefix} CRITICAL error:`, error);
        finalMessage = error.message || "Unknown critical error in KG worker.";
        overallSuccess = false;
        if (dbConnected && (userId || adminDocumentId)) {
            try {
                const isProcessingAdminDoc = !!adminDocumentId;
                const ModelToUpdate = isProcessingAdminDoc ? AdminDocument : User;
                const findQuery = isProcessingAdminDoc ? { _id: adminDocumentId } : { _id: userId, "uploadedDocuments.filename": originalName };
                const statusUpdateField = isProcessingAdminDoc ? "kgStatus" : "uploadedDocuments.$.kgStatus";
                await ModelToUpdate.updateOne(findQuery, { $set: { [statusUpdateField]: "failed_critical" } });
            } catch (dbUpdateError) {
                console.error(`${logPrefix} DB update error on critical fail:`, dbUpdateError);
            }
        }
    } finally {
        if (dbConnected) {
            await mongoose.disconnect();
        }
        console.log(`${logPrefix} Finished task. Overall Success: ${overallSuccess}`);
    }
}

runKgGeneration();
```

