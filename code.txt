`code.txt`

```

```

`frontend/code.txt`

```
`.env`

```
#REACT_APP_API_BASE_URL=http://localhost:5001/api
# OR for Vite:
VITE_API_BASE_URL=http://localhost:5001/api
VITE_ADMIN_USERNAME=admin@admin.com
VITE_ADMIN_PASSWORD=admin123

```

`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI TUTOR</title>

    <script src="https://cdn.jsdelivr.net/npm/d3@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-lib@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-view@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest/dist/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js"></script>
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        if (typeof mermaid !== 'undefined') {
          mermaid.initialize({ startOnLoad: false, theme: 'neutral' }); 
          console.log("Mermaid.js initialized globally with 'neutral' theme via index.html.");
        } else {
          console.error("Mermaid.js not found on window after script load. Mermaid diagrams may not render.");
        }
      });
    </script>

  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

`o.txt`

```

```

`postcss.config.js`

```javascript
export default {
  plugins: {
    'postcss-nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

`src/App.css`

```css
/* #root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
} */

```

`src/App.jsx`

```javascript
// frontend/src/App.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate, useLocation } from 'react-router-dom';
import { useAuth as useRegularAuth } from './hooks/useAuth.jsx';
import { useAppState } from './contexts/AppStateContext.jsx';
import AuthModal from './components/auth/AuthModal.jsx';
import TopNav from './components/layout/TopNav.jsx';
import LeftPanel from './components/layout/LeftPanel.jsx';
import CenterPanel from './components/layout/CenterPanel.jsx';
import RightPanel from './components/layout/RightPanel.jsx';
import LeftCollapsedNav from './components/layout/LeftCollapsedNav.jsx';
import RightCollapsedNav from './components/layout/RightCollapsedNav.jsx';
import ChatHistoryModal from './components/chat/ChatHistoryModal.jsx';
import AdminDashboardPage from './components/admin/AdminDashboardPage.jsx';
import AdminProtectedRoute from './components/admin/AdminProtectedRoute.jsx';
import CodeExecutorPage from './components/tools/CodeExecutorPage.jsx';
import api from './services/api.js';
import toast from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';

function MainAppLayout({ orchestratorStatus }) {
    const { user: regularUser, logout: regularUserLogout } = useRegularAuth();
    const {
        currentSessionId,
        isLeftPanelOpen,
        isRightPanelOpen,
        setSessionId: setGlobalSessionId,
    } = useAppState();
    const [appStateMessages, setAppStateMessages] = useState([]);
    const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false);
    const [isChatProcessing, setIsChatProcessing] = useState(false);

    const handleChatProcessingStatusChange = (isLoading) => {
        setIsChatProcessing(isLoading);
    };

    const handleRegularUserLogout = () => {
        regularUserLogout();
        setGlobalSessionId(null);
    };

    const handleNewChat = async () => {
        try {
            const data = await api.startNewSession(currentSessionId); 
            if (data && data.newSessionId) {
                setGlobalSessionId(data.newSessionId);
                toast.success("New chat started!");
            } else {
                toast.error("Could not start new chat session.");
            }
        } catch (error) {
            toast.error(`Failed to start new chat: ${error.message}`);
        }
    };

    const handleSelectSessionFromHistory = (sessionId) => {
        if (sessionId && sessionId !== currentSessionId) {
            setGlobalSessionId(sessionId);
            toast.success(`Loading session...`);
        }
        setIsHistoryModalOpen(false);
    };

    const { token: regularUserTokenValue } = useRegularAuth();

    const fetchChatHistory = useCallback(async (sid) => {
        if (!sid || !regularUserTokenValue) {
            setAppStateMessages([]);
            return;
        }
        try {
            const sessionData = await api.getChatHistory(sid);
            
            // --- THIS IS THE CORRECTED LOGIC ---
            // The API now returns messages pre-formatted with `sender`.
            // We no longer need to map or transform the data here.
            setAppStateMessages(Array.isArray(sessionData.messages) ? sessionData.messages : []);
            // --- END OF CORRECTION ---

        } catch (error) {
            toast.error(`History load failed: ${error.message}`);
        }
    }, [regularUserTokenValue]);

    useEffect(() => {
        if (currentSessionId && regularUserTokenValue) {
            fetchChatHistory(currentSessionId);
        } else if (!regularUserTokenValue) {
            setAppStateMessages([]);
        }
    }, [currentSessionId, regularUserTokenValue, fetchChatHistory]);

    return (
        <>
            <TopNav 
                user={regularUser} 
                onLogout={handleRegularUserLogout} 
                onNewChat={handleNewChat} 
                onHistoryClick={() => setIsHistoryModalOpen(true)} 
                orchestratorStatus={orchestratorStatus}
                isChatProcessing={isChatProcessing}
            />
            <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark">
                <AnimatePresence mode="wait">
                    {isLeftPanelOpen ? (
                        <motion.aside key="left-panel-main" initial={{ x: '-100%' }} animate={{ x: '0%' }} exit={{ x: '-100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                            <LeftPanel />
                        </motion.aside>
                    ) : ( <LeftCollapsedNav /> )}
                </AnimatePresence>
                <main className={`flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4 transition-all duration-300 ease-in-out ${isLeftPanelOpen ? 'lg:ml-0' : 'lg:ml-16 md:ml-14'} ${isRightPanelOpen ? 'lg:mr-0' : 'lg:mr-16 md:mr-14'}`}>
                    <CenterPanel 
                        messages={appStateMessages} 
                        setMessages={setAppStateMessages} 
                        currentSessionId={currentSessionId}
                        onChatProcessingChange={handleChatProcessingStatusChange}
                    />
                </main>
                <AnimatePresence mode="wait">
                    {isRightPanelOpen ? (
                        <motion.aside key="right-panel-main" initial={{ x: '100%' }} animate={{ x: '0%' }} exit={{ x: '100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="hidden md:flex md:flex-col md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                            <RightPanel />
                        </motion.aside>
                    ) : ( <RightCollapsedNav /> )}
                </AnimatePresence>
            </div>
            <ChatHistoryModal isOpen={isHistoryModalOpen} onClose={() => setIsHistoryModalOpen(false)} onSelectSession={handleSelectSessionFromHistory} />
        </>
    );
}

function App() {
    const { token: regularUserToken, user: regularUser, loading: regularUserAuthLoading, setUser: setRegularUserInAuthContext } = useRegularAuth();
    const { theme, setSessionId: setGlobalSessionId, currentSessionId, isAdminSessionActive } = useAppState();
    const navigate = useNavigate();
    const location = useLocation();
    const [appInitializing, setAppInitializing] = useState(true);
    const [showAuthModal, setShowAuthModal] = useState(false);
    const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });

    useEffect(() => { document.documentElement.className = theme; }, [theme]);
    useEffect(() => { api.getOrchestratorStatus().then(setOrchestratorStatus); }, []);

    useEffect(() => {
        if (isAdminSessionActive) {
            setAppInitializing(false);
            setShowAuthModal(false);
            if (!location.pathname.startsWith('/admin')) {
                navigate('/admin/dashboard', { replace: true });
            }
            return;
        }
        if (regularUserAuthLoading) {
            setAppInitializing(true);
            return;
        }
        setAppInitializing(false);
        if (regularUserToken && regularUser) {
            setShowAuthModal(false);
            if (location.pathname.startsWith('/admin')) {
                navigate('/', { replace: true });
            } else if (!currentSessionId && !location.pathname.startsWith('/tools')) { 
                api.startNewSession(null).then(data => {
                    if (data && data.newSessionId) {
                        setGlobalSessionId(data.newSessionId);
                    }
                });
            }
        } else if (!location.pathname.startsWith('/admin')) {
            setShowAuthModal(true);
        }
    }, [regularUserAuthLoading, regularUserToken, regularUser, isAdminSessionActive, currentSessionId, navigate, location.pathname, setGlobalSessionId]);

    const handleAuthSuccess = (authData) => {
        setShowAuthModal(false);
        if (authData && !authData.isAdminLogin && authData.token) {
            api.startNewSession(null).then(data => {
                if (data && data.newSessionId) {
                    setGlobalSessionId(data.newSessionId);
                }
            });
            if (authData.email && authData._id) {
                setRegularUserInAuthContext({ id: authData._id, email: authData.email });
            }
        }
    };

    if (appInitializing) {
        return (
            <div className="fixed inset-0 flex items-center justify-center bg-background-light dark:bg-background-dark">
                <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary"></div>
            </div>
        );
    }

    return (
        <div className="flex flex-col h-screen overflow-hidden font-sans">
            <AnimatePresence>
                {showAuthModal && <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />}
            </AnimatePresence>
            <Routes>
                 <Route path="/tools/code-executor" element={(regularUserToken && regularUser) ? 
                    <CodeExecutorPage /> : <Navigate to="/" />} 
                />
                <Route path="/admin/dashboard" element={<AdminProtectedRoute><AdminDashboardPage /></AdminProtectedRoute>} />
                <Route path="/*" element={isAdminSessionActive ? <Navigate to="/admin/dashboard" replace /> : (regularUserToken && regularUser) ? <MainAppLayout orchestratorStatus={orchestratorStatus} /> : null} />
            </Routes>
        </div>
    );
}

function AppWrapper() {
    return (
        <Router>
            <App />
        </Router>
    );
}

export default AppWrapper;
```

`src/components/admin/AdminDashboardPage.jsx`

```javascript
// frontend/src/components/admin/AdminDashboardPage.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import * as adminApi from '../../services/adminApi.js';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import ApiKeyRequestManager from './ApiKeyRequestManager.jsx'; // <<< NEW IMPORT
import { UploadCloud, FileText, Trash2, Eye, LogOut, Loader2, AlertTriangle, CheckCircle, RefreshCw } from 'lucide-react';
import toast from 'react-hot-toast';
import { format } from 'date-fns';

// AdminDocumentUpload Component (no changes)
function AdminDocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const fileInputRef = useRef(null);
    const handleFileChange = (e) => { if (isUploading) return; const file = e.target.files && e.target.files[0]; if (file) setSelectedFile(file); else setSelectedFile(null); };
    const handleUpload = async () => {
        if (!selectedFile) { toast.error("Please select a file to upload."); return; }
        setIsUploading(true);
        const toastId = toast.loading(`Uploading "${selectedFile.name}"...`);
        const formData = new FormData();
        formData.append('file', selectedFile);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.uploadAdminDocument(formData, authHeaders);
            toast.success(response.message || `Admin document "${selectedFile.name}" uploaded.`, { id: toastId });
            onUploadSuccess();
            setSelectedFile(null);
            if (fileInputRef.current) fileInputRef.current.value = null;
        } catch (error) {
            toast.error(error.message || `Failed to upload "${selectedFile.name}".`, { id: toastId });
        } finally {
            setIsUploading(false);
        }
    };
    return (
        <div className="card-base p-4 mb-6">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark">Upload New Admin Document</h2>
            <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
                <input type="file" ref={fileInputRef} onChange={handleFileChange} className="input-field flex-grow text-sm p-2.5 min-h-[44px]" accept=".pdf,.docx,.txt,.md" disabled={isUploading} />
                <Button onClick={handleUpload} isLoading={isUploading} disabled={!selectedFile || isUploading} leftIcon={<UploadCloud size={16} />} size="md" className="w-full sm:w-auto !py-2.5">Upload</Button>
            </div>
            {selectedFile && !isUploading && <p className="text-xs mt-2 text-text-muted-light dark:text-text-muted-dark">Selected: {selectedFile.name} ({(selectedFile.size / 1024).toFixed(1)} KB)</p>}
        </div>
    );
}

// Main AdminDashboardPage Component
function AdminDashboardPage() {
    const { setIsAdminSessionActive } = useAppState();
    const navigate = useNavigate();

    const [documents, setDocuments] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState('');
    const [isAnalysisModalOpen, setIsAnalysisModalOpen] = useState(false);
    const [currentDocForModal, setCurrentDocForModal] = useState(null);
    const [analysisContent, setAnalysisContent] = useState(null);
    const [isLoadingAnalysis, setIsLoadingAnalysis] = useState(false);

    // --- NEW STATE FOR KEY REQUESTS ---
    const [keyRequests, setKeyRequests] = useState([]);
    const [isLoadingRequests, setIsLoadingRequests] = useState(true);

    const adminLogoutHandler = () => {
        setIsAdminSessionActive(false);
        toast.success("Admin logged out.");
        navigate('/');
    };

    // --- RENAMED & EXPANDED to fetch all admin data ---
    const fetchAdminData = useCallback(async (showLoadingToast = false) => {
        let toastId;
        if (showLoadingToast) {
            toastId = toast.loading("Refreshing admin data...");
        } else {
            setIsLoading(true);
            setIsLoadingRequests(true);
        }
        setError('');
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const [docsResponse, requestsResponse] = await Promise.all([
                adminApi.getAdminDocuments(authHeaders),
                adminApi.getApiKeyRequests(authHeaders) // New API call
            ]);

            setDocuments(Array.isArray(docsResponse.documents) ? docsResponse.documents : []);
            setKeyRequests(Array.isArray(requestsResponse) ? requestsResponse : []);

            if (showLoadingToast) toast.success("Admin data refreshed.", { id: toastId });
        } catch (err) {
            const errorMessage = err.message || "Failed to fetch admin data.";
            setError(errorMessage);
            if (showLoadingToast) toast.error(errorMessage, { id: toastId });
            else toast.error(errorMessage);
        } finally {
            if (!showLoadingToast) {
                setIsLoading(false);
                setIsLoadingRequests(false);
            }
        }
    }, []);

    useEffect(() => {
        fetchAdminData();
    }, [fetchAdminData]);

    const handleDeleteDocument = async (serverFilename, originalName) => {
        if (!window.confirm(`Are you sure you want to delete admin document "${originalName}"?`)) return;
        const toastId = toast.loading(`Deleting "${originalName}"...`);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            await adminApi.deleteAdminDocument(serverFilename, authHeaders);
            toast.success(`Document "${originalName}" deleted.`, { id: toastId });
            fetchAdminData();
            if (isAnalysisModalOpen && currentDocForModal?.serverFilename === serverFilename) {
                setIsAnalysisModalOpen(false);
            }
        } catch (err) {
            toast.error(err.message || `Failed to delete "${originalName}".`, { id: toastId });
        }
    };

    const handleViewAnalysis = async (doc) => {
        setCurrentDocForModal(doc);
        setAnalysisContent(null);
        setIsAnalysisModalOpen(true);
        setIsLoadingAnalysis(true);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.getAdminDocumentAnalysis(doc.serverFilename, authHeaders);
            setAnalysisContent(response.analysis);
        } catch (err) {
            toast.error(`Failed to load analysis: ${err.message}`);
            setAnalysisContent({ error: `Failed to load analysis: ${err.message}` });
        } finally {
            setIsLoadingAnalysis(false);
        }
    };

    const renderAnalysisModalContent = () => { /* ... (no change to this function) ... */ return null; };
    
    return (
        <div className="min-h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark p-4 sm:p-6">
            <header className="flex items-center justify-between mb-6 pb-3 border-b border-border-light dark:border-border-dark">
                <h1 className="text-2xl font-bold">Admin Dashboard</h1>
                <div className="flex items-center gap-2">
                    <IconButton
                        icon={RefreshCw}
                        onClick={() => fetchAdminData(true)} // Refresh all data
                        title="Refresh Admin Data"
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                    />
                    <Button onClick={adminLogoutHandler} variant="danger" size="sm" leftIcon={<LogOut size={16}/>}>
                        Logout Admin
                    </Button>
                </div>
            </header>

            <AdminDocumentUpload onUploadSuccess={() => fetchAdminData(false)} />
            
            {/* --- NEW API KEY REQUEST MANAGER SECTION --- */}
            {isLoadingRequests ? (
                 <div className="card-base p-4 mt-6 text-center">
                    <Loader2 size={24} className="animate-spin text-primary inline-block mr-2" /> Loading API Key Requests...
                 </div>
            ) : (
                <ApiKeyRequestManager requests={keyRequests} onAction={() => fetchAdminData(false)} />
            )}

            {/* Existing Admin Documents List */}
            <div className="card-base p-0 sm:p-4 mt-6">
                <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">
                    Uploaded Admin Documents
                </h2>
                {isLoading && (
                    <div className="flex items-center justify-center p-6">
                        <Loader2 size={24} className="animate-spin text-primary mr-2" /> Loading documents...
                    </div>
                )}
                {error && (
                    <div className="p-3 my-3 mx-4 sm:mx-0 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                        <AlertTriangle size={18} /> {error}
                        <button onClick={() => fetchAdminData(true)} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
                    </div>
                )}
                {!isLoading && !error && documents.length === 0 && (
                    <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                        No admin documents uploaded yet.
                    </p>
                )}
                {!isLoading && !error && documents.length > 0 && (
                    <div className="overflow-x-auto custom-scrollbar">
                        <table className="w-full text-sm text-left">
                            <thead className="bg-gray-50 dark:bg-gray-800">
                                <tr>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium">Original Name</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium hidden md:table-cell">Uploaded</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium">Analysis Status</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium text-center">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {documents.map((doc) => (
                                    <tr key={doc.serverFilename} className="border-b border-border-light dark:border-border-dark hover:bg-gray-50/50 dark:hover:bg-gray-700/30 transition-colors">
                                        <td className="px-3 sm:px-4 py-2 truncate max-w-[150px] sm:max-w-xs" title={doc.originalName}>{doc.originalName}</td>
                                        <td className="px-3 sm:px-4 py-2 whitespace-nowrap hidden md:table-cell">
                                            {doc.uploadedAt ? format(new Date(doc.uploadedAt), 'MMM d, yyyy HH:mm') : 'N/A'}
                                        </td>
                                        <td className="px-3 sm:px-4 py-2">
                                            {(doc.hasFaq || doc.hasTopics || doc.hasMindmap) ? (
                                                <span className="flex items-center text-green-600 dark:text-green-400 text-xs"><CheckCircle size={14} className="mr-1"/> Generated</span>
                                            ) : (doc.analysisUpdatedAt ? <span className="text-gray-500 dark:text-gray-400 text-xs">Empty/Skipped</span> : <span className="text-yellow-500 dark:text-yellow-400 text-xs">Pending</span>)}
                                        </td>
                                        <td className="px-1 sm:px-4 py-2 text-center whitespace-nowrap">
                                            <IconButton icon={Eye} title="View Analysis" size="sm" variant="ghost" className="text-primary hover:text-primary-dark mr-0.5 sm:mr-1" onClick={() => handleViewAnalysis(doc)} disabled={isLoadingAnalysis && currentDocForModal?.serverFilename === doc.serverFilename} />
                                            <IconButton icon={Trash2} title="Delete Document" size="sm" variant="ghost" className="text-red-500 hover:text-red-700" onClick={() => handleDeleteDocument(doc.serverFilename, doc.originalName)} />
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>

            <Modal isOpen={isAnalysisModalOpen} onClose={() => setIsAnalysisModalOpen(false)} title={`Analysis Results: ${currentDocForModal?.originalName || 'Document'}`} size="2xl">
                {renderAnalysisModalContent()}
            </Modal>
        </div>
    );
}

export default AdminDashboardPage;
```

`src/components/admin/AdminProtectedRoute.jsx`

```javascript
// frontend/src/components/admin/AdminProtectedRoute.jsx
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // Using AppStateContext
import toast from 'react-hot-toast'; // Optional: for a message if redirecting

function AdminProtectedRoute({ children }) { // Accept children for different react-router-dom versions
    const { isAdminSessionActive } = useAppState(); // Get the admin session flag
    const location = useLocation();

    if (!isAdminSessionActive) {
        // If admin session is not active, redirect the user.
        // Redirecting to the main page ('/') is a common approach.
        // The main App component's logic will then likely show the AuthModal
        // if no regular user is logged in either.
        console.log("AdminProtectedRoute: Admin session not active. Redirecting from", location.pathname);
        toast.error("Admin access required. Please log in as admin."); // Optional feedback
        return <Navigate to="/" state={{ from: location }} replace />;
    }

    // If admin session is active, render the child components (the protected route's content)
    return children ? children : <Outlet />; // Outlet is for v6 nested routes, children for direct wrapping
}

export default AdminProtectedRoute;
```

`src/components/admin/ApiKeyRequestManager.jsx`

```javascript
// frontend/src/components/admin/ApiKeyRequestManager.jsx
import React, { useState } from 'react';
import { formatDistanceToNow } from 'date-fns';
import { Check, X, Loader2 } from 'lucide-react';
import toast from 'react-hot-toast';
import * as adminApi from '../../services/adminApi.js';
import IconButton from '../core/IconButton.jsx';

function ApiKeyRequestManager({ requests, onAction }) {
    const [loadingStates, setLoadingStates] = useState({});

    const handleAction = async (userId, action) => {
        setLoadingStates(prev => ({ ...prev, [userId]: true }));
        const toastId = toast.loading(`${action === 'approve' ? 'Approving' : 'Rejecting'} request...`);
        
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            let response;
            if (action === 'approve') {
                response = await adminApi.approveApiKeyRequest(userId, authHeaders);
            } else {
                response = await adminApi.rejectApiKeyRequest(userId, authHeaders);
            }
            toast.success(response.message, { id: toastId });
            onAction(); // Trigger a refresh in the parent component
        } catch (error) {
            toast.error(error.message, { id: toastId });
        } finally {
            setLoadingStates(prev => ({ ...prev, [userId]: false }));
        }
    };

    return (
        <div className="card-base p-0 sm:p-4 mt-6">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">
                Pending API Key Requests
            </h2>
            {requests.length === 0 ? (
                <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                    No pending requests.
                </p>
            ) : (
                <div className="overflow-x-auto custom-scrollbar">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-gray-50 dark:bg-gray-800">
                            <tr>
                                <th className="px-4 py-2.5 font-medium">User Email</th>
                                <th className="px-4 py-2.5 font-medium hidden md:table-cell">Name</th>
                                <th className="px-4 py-2.5 font-medium hidden lg:table-cell">Requested</th>
                                <th className="px-4 py-2.5 font-medium text-center">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {requests.map((req) => (
                                <tr key={req._id} className="border-b border-border-light dark:border-border-dark">
                                    <td className="px-4 py-2 font-mono text-xs" title={req.email}>{req.email}</td>
                                    <td className="px-4 py-2 hidden md:table-cell">{req.profile?.name || 'N/A'}</td>
                                    <td className="px-4 py-2 hidden lg:table-cell" title={new Date(req.createdAt).toLocaleString()}>
                                        {formatDistanceToNow(new Date(req.createdAt), { addSuffix: true })}
                                    </td>
                                    <td className="px-4 py-2 text-center whitespace-nowrap">
                                        {loadingStates[req._id] ? (
                                            <Loader2 size={16} className="animate-spin text-primary inline-block" />
                                        ) : (
                                            <>
                                                <IconButton
                                                    icon={Check}
                                                    title="Approve Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-green-500 hover:text-green-700 dark:hover:text-green-400"
                                                    onClick={() => handleAction(req._id, 'approve')}
                                                />
                                                <IconButton
                                                    icon={X}
                                                    title="Reject Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-red-500 hover:text-red-700 dark:hover:text-red-400"
                                                    onClick={() => handleAction(req._id, 'reject')}
                                                />
                                            </>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}
        </div>
    );
}

export default ApiKeyRequestManager;
```

`src/components/analysis/AnalysisTool.jsx`

```javascript
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js'; // For user documents
import * as adminApi from '../../services/adminApi.js'; // For admin documents
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.", // Added for admin docs
    "Retrieved stored admin analysis." // Added for admin docs
];

// Added isTargetAdminDoc prop
function AnalysisTool({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => { // Reset when selected document changes
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => { // Prism for modal content
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => { // Prism for AI reasoning
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                console.log(`AnalysisToolRunner: Fetching ADMIN analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const authHeaders = adminApi.getFixedAdminAuthHeaders(); // Get admin auth
                // Fetches { originalName, serverFilename, analysis: {faq, topics, mindmap}, analysisUpdatedAt }
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                        // Content for this specific analysis type is empty or null
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}". The admin might not have generated this specific analysis type yet, or it was empty.`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc "${selectedDocumentFilename}".`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title} for "${selectedDocumentFilename}"!`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found or response format invalid for document "${selectedDocumentFilename}".`);
                }
            } else { // User document
                console.log(`AnalysisToolRunner: Requesting USER analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload); // This uses the mock/frontend API for user docs
                // The success toast for user docs is handled inside api.requestAnalysis mock for now.
                // If it were a real API, we might add toast.success here.
                // For consistency with admin path:
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated for "${selectedDocumentFilename}"!`, { id: toastId });
                } else {
                    toast.dismiss(toastId); // Dismiss loading if there was an issue caught below
                }
            }

            // Common response processing
            if (response) {
                if (response.content && response.content.trim() !== "" && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content && (response.content.startsWith("Error:") || response.content.startsWith("Notice:"))) {
                    // If it's an error or notice, display it as content but also set error state
                    setAnalysisContent(response.content); // Display the error/notice in the content area
                    setError(response.content); // Also set the error state for styling/logging
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else { // No content, but not an explicit error/notice in response.content
                    setAnalysisContent(`No content was returned for ${title}.`); // Display this
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content was generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content was generated for ${title}.`);
                }

                if (response.thinking && response.thinking.trim() !== "") {
                    setAiReasoning(response.thinking);
                } else {
                    setAiReasoning(response.content ? "Retrieved analysis. No detailed AI reasoning provided." : "AI reasoning not available.");
                }
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to generate or fetch ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`); // Display error in content area too
            toast.error(errorMessage);
            console.error(`Run ${title} Analysis Error:`, err);
            setIsDropdownOpen(false);
        } finally {
            setIsLoading(false);
        }
    };

    const handleDownloadMindmap = async (format = 'svg') => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    if (saveSvgAsPng) {
                        saveSvgAsPng(svgElement, filename, {
                            scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF'
                        });
                        toast.success("PNG download started!", { id: pngToastId });
                    } else { throw new Error("saveSvgAsPng function not found."); }
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48">
                       <Loader2 size={32} className="animate-spin text-primary" />
                       <p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p>
                   </div>;
        }
        // Display error directly if it's set and no other content (or if content is the error itself)
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center">
                       <MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} />
                   </div>;
        }
        return <div ref={modalAnalysisContentRef}
                    className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed"
                    dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div
                    className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors"
                    onClick={() => setIsSectionOpen(!isSectionOpen)}
                    aria-expanded={isSectionOpen}
                >
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button
                        onClick={handleRunAnalysis} variant="primary" size="sm"
                        className="!px-3 !py-1 text-xs" isLoading={isLoading}
                        disabled={!selectedDocumentFilename || isLoading}
                        title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}
                    >
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton
                        icon={isSectionOpen ? ChevronUp : ChevronDown}
                        onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost"
                        className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"}
                        disabled={isLoading && isSectionOpen}
                    />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div
                        key="tool-section-content" initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.25, ease: "easeInOut" }}
                        className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden"
                    >
                        {isLoading && (
                            <div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn">
                                <Loader2 size={14} className="animate-spin"/> {currentEngagementText}
                            </div>
                        )}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && ( // Show error only if no other content or content is the error
                            <div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1">
                                <AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}
                            </div>
                        )}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div
                                key="analysis-dropdown" initial={{ opacity: 0, y: -10 }}
                                animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }}
                                transition={{ duration: 0.2 }} className="mt-2 space-y-2"
                            >
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md">
                                            <span className="flex items-center gap-1.5 font-medium">
                                                <Sparkles size={14} className="text-accent" /> AI Reasoning
                                            </span>
                                            <ChevronDown size={16} className="group-open:rotate-180 transition-transform" />
                                        </summary>
                                        <div ref={aiReasoningContentRef}
                                            className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md"
                                            dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && (!error || analysisContent !== error) && ( // Show view button if content is not the error message itself
                                     <Button
                                        onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth
                                        leftIcon={<Eye size={14}/>}
                                        className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10"
                                    >View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">
                                {selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}
                            </p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={<>
                        {toolType === 'mindmap' && analysisContent && (
                            <><Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                             <div className="flex-grow"></div></>
                        )}
                        <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs">Close</Button>
                    </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisTool;
```

`src/components/analysis/AnalysisToolRunner.jsx`

```javascript
// frontend/src/components/analysis/AnalysisToolRunner.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js';
import * as adminApi from '../../services/adminApi.js';
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download, FileText, FileBarChart2 } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.",
    "Retrieved stored admin analysis."
];

function AnalysisToolRunner({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');
    const [generatingDocType, setGeneratingDocType] = useState(null);

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => {
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => {
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => {
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                const authHeaders = adminApi.getFixedAdminAuthHeaders();
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}".`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc.`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title}.`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found.`);
                }
            } else {
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload);
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated!`, { id: toastId });
                } else {
                    toast.dismiss(toastId);
                }
            }

            if (response) {
                if (response.content && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content) {
                    setAnalysisContent(response.content);
                    setError(response.content);
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else {
                    setAnalysisContent(`No content was returned for ${title}.`);
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content generated for ${title}.`);
                }
                setAiReasoning(response.thinking || "AI reasoning not available.");
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to process ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };

    const handleGenerateDocument = async (docType) => {
        if (!analysisContent || generatingDocType) {
            return;
        }

        setGeneratingDocType(docType);
        const toastId = toast.loading(`Generating ${docType.toUpperCase()} document...`);

        try {
            const fullMarkdownContent = `## ${title}\n\n**Source Document:** \`${selectedDocumentFilename}\`\n\n---\n\n${analysisContent}`;
            
            const { fileBlob, filename } = await api.generateDocument({
                markdownContent: fullMarkdownContent,
                docType: docType,
                sourceDocumentName: selectedDocumentFilename
            });
            
            const url = window.URL.createObjectURL(fileBlob);
            const link = document.createElement('a');
            link.href = url;
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);

            toast.success(`${docType.toUpperCase()} document downloaded.`, { id: toastId });

        } catch (err) {
            toast.error(`Failed to generate document: ${err.message}`, { id: toastId });
        } finally {
            setGeneratingDocType(null);
        }
    };

    const handleDownloadMindmap = async (format) => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    saveSvgAsPng(svgElement, filename, { scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF' });
                    toast.success("PNG download started!", { id: pngToastId });
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48"><Loader2 size={32} className="animate-spin text-primary" /><p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p></div>;
        }
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center"><MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} /></div>;
        }
        return <div ref={modalAnalysisContentRef} className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed" dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors" onClick={() => setIsSectionOpen(!isSectionOpen)} aria-expanded={isSectionOpen}>
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button onClick={handleRunAnalysis} variant="primary" size="sm" className="!px-3 !py-1 text-xs" isLoading={isLoading} disabled={!selectedDocumentFilename || isLoading} title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}>
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton icon={isSectionOpen ? ChevronUp : ChevronDown} onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost" className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"} disabled={isLoading && isSectionOpen} />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div key="tool-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.25, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        {isLoading && (<div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn"><Loader2 size={14} className="animate-spin"/> {currentEngagementText}</div>)}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && (<div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1"><AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}</div>)}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div key="analysis-dropdown" initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }} transition={{ duration: 0.2 }} className="mt-2 space-y-2">
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md"><span className="flex items-center gap-1.5 font-medium"><Sparkles size={14} className="text-accent" /> AI Reasoning</span><ChevronDown size={16} className="group-open:rotate-180 transition-transform" /></summary>
                                        <div ref={aiReasoningContentRef} className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md" dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && !error && (
                                     <Button onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth leftIcon={<Eye size={14}/>} className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10">View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">{selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}</p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={
                <>
                    {toolType === 'mindmap' && analysisContent && !error && (
                        <Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                    )}
                    
                    {toolType !== 'mindmap' && analysisContent && !error && (
                        <>
                           <Button 
                                onClick={() => handleGenerateDocument('pptx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileBarChart2 size={14}/>}
                                isLoading={generatingDocType === 'pptx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'pptx' ? 'Generating...' : 'Generate PPTX'}
                            </Button>
                           <Button 
                                onClick={() => handleGenerateDocument('docx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileText size={14}/>}
                                isLoading={generatingDocType === 'docx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'docx' ? 'Generating...' : 'Generate DOCX'}
                            </Button>
                        </>
                    )}

                    <div className="flex-grow"></div>
                    <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs" disabled={!!generatingDocType}>
                        Close
                    </Button>
                </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisToolRunner;
```

`src/components/analysis/KnowledgeGraphViewer.jsx`

```javascript
// frontend/src/components/analysis/KnowledgeGraphViewer.jsx
import React, { useEffect, useState, useMemo } from 'react';
import Graph from 'react-vis-network-graph';
import { Loader2, AlertTriangle, ZoomIn, ZoomOut, Maximize } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';
import IconButton from '../core/IconButton.jsx';

const KnowledgeGraphViewer = ({ graphData }) => {
    const { theme } = useTheme();

    // --- FIX START: Add state to hold the network instance ---
    const [network, setNetwork] = useState(null);
    // --- FIX END ---

    // Memoize options to prevent re-renders
    const options = useMemo(() => {
        const isDark = theme === 'dark';
        return {
            layout: {
                hierarchical: {
                    enabled: true,
                    direction: 'UD', // Up-Down
                    sortMethod: 'directed',
                    levelSeparation: 150,
                    nodeSpacing: 200,
                },
            },
            nodes: {
                shape: 'box',
                borderWidth: 1.5,
                font: {
                    color: isDark ? '#E2E8F0' : '#0F172A',
                    size: 14,
                    face: 'Inter',
                },
                color: {
                    border: isDark ? '#4B5563' : '#9CA3AF',
                    background: isDark ? '#1E293B' : '#FFFFFF',
                    highlight: {
                        border: '#3b82f6',
                        background: isDark ? '#2563eb' : '#60a5fa',
                    },
                },
                shadow: true,
            },
            edges: {
                color: {
                    color: isDark ? '#64748B' : '#9CA3AF',
                    highlight: '#3b82f6',
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.7 },
                },
                font: {
                    color: isDark ? '#94A3B8' : '#6B7280',
                    size: 10,
                    align: 'middle',
                    strokeWidth: 2,
                    strokeColor: isDark ? '#1E293B' : '#FFFFFF',
                },
                smooth: {
                    type: 'cubicBezier',
                    forceDirection: 'vertical',
                    roundness: 0.4,
                },
            },
            physics: {
                enabled: true,
                hierarchicalRepulsion: {
                    centralGravity: 0.0,
                    springLength: 100,
                    springConstant: 0.01,
                    nodeDistance: 200,
                    damping: 0.09,
                },
                solver: 'hierarchicalRepulsion',
            },
            interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true,
                tooltipDelay: 200,
            },
            height: '100%',
            width: '100%',
        };
    }, [theme]);

    const formattedGraph = useMemo(() => {
        if (!graphData || !graphData.nodes || !graphData.edges) {
            return { nodes: [], edges: [] };
        }
        const nodes = graphData.nodes.map(node => ({
            id: node.id,
            label: node.id,
            title: `Type: ${node.type}\nParent: ${node.parent || 'N/A'}\n\n${node.description}`,
            color: node.type === 'major' 
                ? { border: '#3b82f6', background: theme === 'dark' ? '#1E3A8A' : '#BFDBFE' } 
                : undefined,
        }));
        const edges = graphData.edges.map(edge => ({
            from: edge.from,
            to: edge.to,
            label: edge.relationship.replace(/_/g, ' '),
        }));
        return { nodes, edges };
    }, [graphData, theme]);

    // --- FIX START: These handlers will now work because 'network' is in state ---
    const handleZoomIn = () => network?.zoomIn();
    const handleZoomOut = () => network?.zoomOut();
    const handleFit = () => network?.fit();
    // --- FIX END ---

    if (!graphData) {
        return (
            <div className="flex items-center justify-center h-full">
                <Loader2 className="animate-spin text-primary mr-2" /> Loading graph data...
            </div>
        );
    }

    if (graphData.error) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-red-500">
                <AlertTriangle size={32} className="mb-2" />
                <p className="font-semibold">Failed to load Knowledge Graph</p>
                <p className="text-xs">{graphData.error}</p>
            </div>
        );
    }
    
    if (formattedGraph.nodes.length === 0) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark">
                <AlertTriangle size={32} className="mb-2" />
                <p>No graph data found for this document.</p>
             </div>
        );
    }

    return (
        <div className="relative w-full h-[70vh] border border-border-light dark:border-border-dark rounded-md bg-gray-50 dark:bg-gray-800/50">
            <Graph
                key={theme}
                graph={formattedGraph}
                options={options}
                // --- FIX START: Use the 'getNetwork' callback to update our state ---
                getNetwork={net => setNetwork(net)}
                // --- FIX END ---
            />
            <div className="absolute top-2 right-2 flex flex-col gap-1.5 bg-surface-light dark:bg-surface-dark p-1.5 rounded-md shadow-lg border border-border-light dark:border-border-dark">
                <IconButton icon={ZoomIn} onClick={handleZoomIn} title="Zoom In" size="sm" />
                <IconButton icon={ZoomOut} onClick={handleZoomOut} title="Zoom Out" size="sm" />
                <IconButton icon={Maximize} onClick={handleFit} title="Fit to View" size="sm" />
            </div>
        </div>
    );
};

export default KnowledgeGraphViewer;
```

`src/components/analysis/MindmapViewer.jsx`

```javascript
// frontend/src/components/analysis/MindmapViewer.jsx
import React, { useEffect, useRef, useState, useImperativeHandle, forwardRef } from 'react';
import toast from 'react-hot-toast';
import { escapeHtml } from '../../utils/helpers.js';

const MindmapViewer = forwardRef(({ mermaidCode }, ref) => {
    const svgContainerRef = useRef(null);
    const [error, setError] = useState(null);
    const [isMermaidReady, setIsMermaidReady] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [uniqueId] = useState(() => `mermaid-graph-${Math.random().toString(36).substr(2, 9)}`);

    useImperativeHandle(ref, () => ({
        getSvgElement: () => {
            return svgContainerRef.current?.querySelector('svg');
        }
    }));

    useEffect(() => {
        if (typeof window.mermaid !== 'undefined') {
            setIsMermaidReady(true);
        } else {
            const intervalId = setInterval(() => {
                if (typeof window.mermaid !== 'undefined') {
                    setIsMermaidReady(true);
                    clearInterval(intervalId);
                }
            }, 100);
            return () => clearInterval(intervalId);
        }
    }, []);

    useEffect(() => {
        if (!isMermaidReady || !mermaidCode || !svgContainerRef.current) {
            if (svgContainerRef.current) svgContainerRef.current.innerHTML = '';
            setError(null);
            setIsLoading(false);
            return;
        }

        const renderMermaidDiagram = async () => {
            setIsLoading(true);
            setError(null);
            if (!svgContainerRef.current) {
                setIsLoading(false);
                return;
            }
            svgContainerRef.current.innerHTML = '<div class="flex justify-center items-center h-full w-full text-sm text-text-muted-light dark:text-text-muted-dark"><div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-primary mr-2"></div>Rendering diagram...</div>';
            
            let codeToRender = mermaidCode.trim();
            
            // --- THIS IS THE FIX ---
            // New, more robust regex to find the diagram code.
            // It looks for a code block that CONTAINS a known diagram type (e.g., 'graph', 'mindmap').
            // It is no longer anchored to the start (^) of the string, so it can find the
            // block even if there's leading garbage or extra backticks from the LLM.
            const fenceRegex = /```(?:mermaid)?\s*([\s\S]*?(?:graph|mindmap|flowchart|sequenceDiagram)[\s\S]*?)\s*```/i;
            const match = codeToRender.match(fenceRegex);

            if (match && match[1]) {
                // If we found a fenced block, use its content.
                codeToRender = match[1].trim();
            } else {
                // Fallback for cases where LLM might forget the fences entirely.
                // We still trim to remove potential whitespace.
                codeToRender = codeToRender.trim();
            }
            // --- END OF FIX ---

            try {
                if (typeof window.mermaid === 'undefined') {
                    throw new Error("Mermaid library failed to load or initialize properly.");
                }

                const { svg, bindFunctions } = await window.mermaid.render(uniqueId, codeToRender);
                
                if (svgContainerRef.current) {
                    svgContainerRef.current.innerHTML = svg;
                    if (bindFunctions) {
                        bindFunctions(svgContainerRef.current);
                    }
                    const svgElement = svgContainerRef.current.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto'; 
                        svgElement.style.maxWidth = '100%'; 
                        svgElement.style.display = 'block';
                    }
                }
            } catch (e) {
                console.error("Error rendering Mermaid diagram with input:", codeToRender, e);
                const errorMsg = e.message || "Failed to render mind map. Invalid Mermaid syntax?";
                setError(errorMsg);
                if (svgContainerRef.current) {
                    const codeSnippet = escapeHtml(codeToRender.substring(0, 200) + (codeToRender.length > 200 ? "..." : ""));
                    svgContainerRef.current.innerHTML = `<div class="p-4 text-center text-red-500 dark:text-red-400 text-xs break-all"><strong>Error rendering:</strong> ${escapeHtml(errorMsg)}<br><strong class='mt-2 block'>Input Code (first 200 chars):</strong><pre class='text-left text-xs bg-gray-100 dark:bg-gray-700 p-2 rounded mt-1 whitespace-pre-wrap'>${codeSnippet}</pre></div>`;
                }
            } finally {
                setIsLoading(false);
            }
        };

        const timer = setTimeout(renderMermaidDiagram, 100); 
        return () => clearTimeout(timer);
        
    }, [mermaidCode, uniqueId, isMermaidReady]);

    if (!isMermaidReady && !error) {
      return <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark text-xs">Waiting for Mermaid.js library...</div>;
    }
    if (error && (!isLoading || (svgContainerRef.current && svgContainerRef.current.innerHTML.includes('Error rendering')))) {
        return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
                {/* Error message will be injected by useEffect's catch block */}
               </div>;
    }
    
    if (isLoading) { 
         return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
            {/* Loading message is set by renderMermaidDiagram's initial innerHTML write */}
         </div>;
    }

    if (!mermaidCode && !error && isMermaidReady) { 
        return <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark p-4">No mind map data to display.</p>;
    }
    
    return (
        <div 
            ref={svgContainerRef} 
            className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md"
        >

        </div>
    );
});

export default MindmapViewer;

```

`src/components/analysis/PodcastGenerator.jsx`

```javascript
// frontend/src/components/analysis/PodcastGenerator.jsx
import React, { useState } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { Headphones, ChevronDown, ChevronUp } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion, AnimatePresence } from 'framer-motion';

function PodcastGenerator({ selectedDocumentFilename }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isLoading, setIsLoading] = useState(false);
    const [podcastPurpose, setPodcastPurpose] = useState('review');
    const [podcastLength, setPodcastLength] = useState('standard');

    const handleGeneratePodcast = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true);
        const toastId = toast.loading("Generating high-quality podcast script & audio. This may take a moment...");
        try {
            const { audioBlob, sourceDocumentName } = await api.generatePodcast({
                analysisContent: `A study session on: ${selectedDocumentFilename}`,
                sourceDocumentName: selectedDocumentFilename,
                podcastOptions: { studyPurpose: podcastPurpose, sessionLength: podcastLength }
            });
            
            toast.success("High-Quality Podcast is ready for download!", { id: toastId, duration: 5000 });

            const url = window.URL.createObjectURL(audioBlob);
            const link = document.createElement('a');
            const safeFilename = sourceDocumentName.split('.')[0].replace(/[^a-zA-Z0-9]/g, '_');
            link.href = url;
            link.setAttribute('download', `AI_Podcast_${safeFilename}.mp3`);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || "Failed to generate podcast.";
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between cursor-pointer" onClick={() => setIsSectionOpen(!isSectionOpen)}>
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark">
                    <Headphones size={16} className="text-accent" />
                    <span className="flex-grow">HQ Podcast Generator</span>
                </div>
                {isSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-3">
                            Generate a high-quality, conversational audio study session from the selected document.
                        </p>
                        <div className="flex flex-col sm:flex-row gap-2 mb-3">
                            <div className="flex-1">
                                <label htmlFor="podcast-purpose" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Purpose</label>
                                <select id="podcast-purpose" value={podcastPurpose} onChange={(e) => setPodcastPurpose(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="review">General Review</option>
                                    <option value="introduction">Introduction</option>
                                    <option value="exam_prep">Exam Prep</option>
                                    <option value="deep_dive">Deep Dive</option>
                                </select>
                            </div>
                            <div className="flex-1">
                                <label htmlFor="podcast-length" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Length</label>
                                <select id="podcast-length" value={podcastLength} onChange={(e) => setPodcastLength(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="quick">Quick (~5-7m)</option>
                                    <option value="standard">Standard (~10-15m)</option>
                                    <option value="comprehensive">Comprehensive (~15-25m)</option>
                                </select>
                            </div>
                        </div>
                        <Button
                            onClick={handleGeneratePodcast}
                            variant="primary"
                            size="sm"
                            fullWidth
                            isLoading={isLoading}
                            disabled={!selectedDocumentFilename || isLoading}
                            title={!selectedDocumentFilename ? "Select a document first" : "Generate Podcast"}
                        >
                           {isLoading ? 'Generating Audio...' : 'Generate High-Quality Podcast'}
                        </Button>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}

export default PodcastGenerator;
// This code defines a React component for generating podcasts from selected documents.

```

`src/components/analysis/RightPanel.jsx`

```javascript
// // frontend/src/components/layout/RightPanel.jsx
// import React, { useState } from 'react';
// import { useAppState } from '../../contexts/AppStateContext';
// import AnalysisTool from '../analysis/AnalysisTool.jsx'; // Added .jsx
// import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
// import IconButton from '../core/IconButton.jsx'; // Added .jsx
// import { motion } from 'framer-motion';

// function RightPanel() {
//     const { setIsRightPanelOpen, selectedDocumentForAnalysis } = useAppState();
//     const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

//     const currentSelectedDocFilename = selectedDocumentForAnalysis?.originalName || null;

//     return (
//         <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
//             <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
//                 <h2 className="text-base font-semibold">Advanced Analyzer</h2>
//                 <IconButton 
//                     icon={PanelRightClose} 
//                     onClick={() => setIsRightPanelOpen(false)} 
//                     title="Close Analyzer Panel"
//                     variant="ghost"
//                     size="sm"
//                     className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
//                 />
//             </div>
            
//             <button 
//                 onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
//                 className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
//             >
//                 <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
//                 {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
//             </button>

//             {isAnalyzerOpen && (
//                 <motion.div 
//                     initial={{ height: 0, opacity: 0 }} 
//                     animate={{ height: 'auto', opacity: 1 }} 
//                     exit={{ height: 0, opacity: 0 }}
//                     transition={{ duration: 0.2, ease: "easeInOut" }}
//                     className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
//                 >
//                     {!currentSelectedDocFilename && (
//                         <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
//                             <p>Select a document from the left panel to enable analysis tools.</p>
//                         </div>
//                     )}
//                     <AnalysisTool toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} />
//                 </motion.div>
//             )}
//         </div>
//     );
// }
// export default RightPanel;











// frontend/src/components/analysis/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
// FIX: Use the new, more capable AnalysisToolRunner component
import AnalysisToolRunner from './AnalysisToolRunner.jsx'; // FIX: Corrected relative import path
import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

function RightPanel() {
    // FIX: Get selectedSubject to determine if the document is an admin document
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    // FIX: Logic corrected to handle filename string directly
    const currentSelectedDocFilename = selectedDocumentForAnalysis || null;
    // FIX: Add logic to determine if the selected document is a "Subject" (admin doc)
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    return (
        <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                <IconButton
                    icon={PanelRightClose}
                    onClick={() => setIsRightPanelOpen(false)}
                    title="Close Analyzer Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>

            <button
                onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
                className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
            >
                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </button>

            {isAnalyzerOpen && (
                <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
                >
                    {!currentSelectedDocFilename && (
                        <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable analysis tools.</p>
                        </div>
                    )}
                    {/* FIX: Use AnalysisToolRunner and pass the isTargetAdminDoc prop */}
                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                </motion.div>
            )}
        </div>
    );
}
export default RightPanel;
```

`src/components/auth/AuthModal.jsx`

```javascript
// frontend/src/components/auth/AuthModal.jsx
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../hooks/useAuth.jsx';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import LLMSelection from './LLMSelection.jsx';
import toast from 'react-hot-toast';
import { LogIn, UserPlus, X, KeyRound, AtSign, AlertCircle, HardDrive, CheckSquare, Square } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';

function AuthModal({ isOpen, onClose }) {
    const { login, signup } = useAuth();
    const { setIsAdminSessionActive, switchLLM: setGlobalLLM, selectedLLM } = useAppState();

    const [isLoginView, setIsLoginView] = useState(true);
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [localSelectedLLM, setLocalSelectedLLM] = useState('gemini');
    const [apiKey, setApiKey] = useState('');
    const [ollamaUrl, setOllamaUrl] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [requestKeyFromAdmin, setRequestKeyFromAdmin] = useState(false); // New state for checkbox
    
    const emailRegex = /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/;

    useEffect(() => {
        if (isOpen) {
            setError('');
            setEmail('');
            setPassword('');
            setApiKey('');
            setOllamaUrl('');
            setRequestKeyFromAdmin(false); // Reset checkbox
            setLocalSelectedLLM(selectedLLM || 'gemini');
        } else {
            setIsLoginView(true);
        }
    }, [isOpen, selectedLLM]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');

        if (!emailRegex.test(email) && !(isLoginView && email === (process.env.VITE_ADMIN_USERNAME || 'admin@admin.com'))) {
            return setError("Please enter a valid email address.");
        }
        if (password.length < 6) {
            return setError("Password must be at least 6 characters long.");
        }
        if (!isLoginView && localSelectedLLM === 'gemini' && !apiKey.trim() && !requestKeyFromAdmin) {
            return setError("Gemini API Key is required, or request one from the admin.");
        }
        if (!isLoginView && localSelectedLLM === 'ollama' && !ollamaUrl.trim()) {
            return setError("Ollama URL is required.");
        }
        
        setLoading(true);
        const toastId = toast.loading(isLoginView ? 'Logging in...' : 'Creating account...');

        try {
            if (isLoginView) {
                const authDataResponse = await login({ email, password });
                if (authDataResponse.isAdminLogin) {
                    toast.dismiss(toastId);
                    toast.success("Admin login successful!");
                    setIsAdminSessionActive(true); 
                    onClose({ isAdminLogin: true });
                } else {
                    toast.dismiss(toastId);
                    toast.success(authDataResponse.message || 'Login Successful!');
                    onClose(authDataResponse);
                }
            } else { // Signup logic
                const signupData = {
                    email, password,
                    preferredLlmProvider: localSelectedLLM,
                };

                if (localSelectedLLM === 'gemini') {
                    if (requestKeyFromAdmin) {
                        signupData.requestAdminKey = true;
                    } else {
                        signupData.apiKey = apiKey;
                    }
                } else if (localSelectedLLM === 'ollama') {
                    signupData.ollamaUrl = ollamaUrl;
                }

                const authDataResponse = await signup(signupData);
                setGlobalLLM(localSelectedLLM);
                toast.dismiss(toastId);
                toast.success(authDataResponse.message || 'Signup Successful!');
                onClose(authDataResponse);
            }
        } catch (err) {
            toast.dismiss(toastId);
            const errorMessage = err.response?.data?.message || err.message || `An error occurred.`;
            setError(errorMessage);
        } finally {
            setLoading(false);
        }
    };

    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm w-full";

    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-fadeIn">
            <motion.div 
                key="auth-modal-content"
                initial={{ opacity: 0, scale: 0.95, y: -10 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.95, y: 10 }}
                className="card-base p-6 sm:p-8 w-full max-w-md"
            >
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl sm:text-2xl font-bold">{isLoginView ? 'Welcome Back' : 'Create Your Account'}</h2>
                    <IconButton icon={X} onClick={() => onClose(null)} variant="ghost" size="sm" title="Close" />
                </div>

                {error && (
                    <div className="mb-4 p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                        <AlertCircle size={16}/>{error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-5">
                    <div className={inputWrapperClass}>
                        <AtSign className={inputIconClass} />
                        <input type="text" id="auth-email" className={inputFieldStyledClass} placeholder="Email Address" value={email} onChange={(e) => setEmail(e.target.value)} required disabled={loading} />
                    </div>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input type="password" id="auth-password" className={inputFieldStyledClass} placeholder="Password (min. 6 characters)" value={password} onChange={(e) => setPassword(e.target.value)} required minLength="6" disabled={loading} />
                    </div>

                    {!isLoginView && (
                        <div className="space-y-4 pt-2 animate-fadeIn">
                            <LLMSelection selectedLLM={localSelectedLLM} onLlmChange={setLocalSelectedLLM} disabled={loading} />
                            
                            <div style={{ display: localSelectedLLM === 'gemini' ? 'block' : 'none' }}>
                                <motion.div key="gemini-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <div className="flex items-center mb-3">
                                        <button
                                            type="button"
                                            onClick={() => setRequestKeyFromAdmin(!requestKeyFromAdmin)}
                                            className="flex items-center text-sm text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors"
                                            disabled={loading}
                                        >
                                            {requestKeyFromAdmin ? <CheckSquare size={16} className="text-primary mr-2" /> : <Square size={16} className="mr-2" />}
                                            Request API Key from Admin
                                        </button>
                                    </div>
                                    <AnimatePresence>
                                        {!requestKeyFromAdmin && (
                                            <motion.div
                                                key="api-key-field"
                                                initial={{ opacity: 0, height: 0 }}
                                                animate={{ opacity: 1, height: 'auto' }}
                                                exit={{ opacity: 0, height: 0 }}
                                                className="overflow-hidden"
                                            >
                                                <label htmlFor="api-key-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Gemini API Key <span className="text-red-500">*</span></label>
                                                <div className={inputWrapperClass}>
                                                    <KeyRound className={inputIconClass} />
                                                    <input type="password" id="api-key-input" className={inputFieldStyledClass} placeholder="Enter your Gemini API Key" value={apiKey} onChange={(e) => setApiKey(e.target.value)} required={!requestKeyFromAdmin && localSelectedLLM === 'gemini'} disabled={loading} />
                                                </div>
                                            </motion.div>
                                        )}
                                    </AnimatePresence>
                                </motion.div>
                            </div>
                        
                            <div style={{ display: localSelectedLLM === 'ollama' ? 'block' : 'none' }}>
                                <motion.div key="ollama-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <label htmlFor="ollama-url-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Ollama URL <span className="text-red-500">*</span></label>
                                    <div className={inputWrapperClass}>
                                        <HardDrive className={inputIconClass} />
                                        <input type="text" id="ollama-url-input" className={inputFieldStyledClass} placeholder="e.g., http://localhost:11434" value={ollamaUrl} onChange={(e) => setOllamaUrl(e.target.value)} required={localSelectedLLM === 'ollama'} disabled={loading} />
                                    </div>
                                </motion.div>
                            </div>
                        </div>
                    )}

                    <Button type="submit" fullWidth isLoading={loading} leftIcon={isLoginView ? <LogIn size={18}/> : <UserPlus size={18}/>} className="py-2.5 !text-base">
                        {isLoginView ? 'Login' : 'Sign Up'}
                    </Button>
                </form>

                <p className="mt-6 text-center text-sm">
                    <button onClick={() => setIsLoginView(!isLoginView)} className="font-medium text-primary hover:underline" disabled={loading}>
                        {isLoginView ? "Don't have an account? Sign Up" : "Already have an account? Login"}
                    </button>
                </p>
            </motion.div>
        </div>
    );
}
export default AuthModal;
```

`src/components/auth/LLMSelection.jsx`

```javascript
// frontend/src/components/auth/LLMSelection.jsx
import React from 'react';
import { HardDrive, Cloud } from 'lucide-react';

function LLMSelection({ selectedLLM, onLlmChange, disabled = false }) {
    const llms = [
        { id: 'ollama', name: 'Ollama LLM', description: 'Local & Private. Requires Ollama running.', Icon: HardDrive },
        { id: 'gemini', name: 'Gemini LLM', description: 'Cloud-based by Google. API Key may be required.', Icon: Cloud },
    ];

    return (
        <div>
            <label className="block text-sm font-medium text-text-light dark:text-text-dark mb-2">
                Choose Your LLM Provider
            </label>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {llms.map((llm) => {
                    const isSelected = selectedLLM === llm.id;
                    return (
                        <button
                            key={llm.id}
                            type="button"
                            onClick={() => onLlmChange(llm.id)}
                            disabled={disabled}
                            className={`p-4 border rounded-lg text-left transition-all duration-150 focus:outline-none group focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-surface-dark focus:ring-primary
                                ${isSelected 
                                    ? 'bg-primary dark:bg-primary border-primary dark:border-primary-dark ring-2 ring-primary dark:ring-primary-dark shadow-lg' 
                                    : 'bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark hover:border-primary-light dark:hover:border-primary-dark hover:shadow-md'
                                }
                                ${disabled ? 'opacity-70 cursor-not-allowed' : ''}
                            `}
                        >
                            <div className="flex items-center mb-1">
                                <llm.Icon size={20} className={`mr-2 transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-blue-100' // High contrast for selected
                                        : 'text-text-muted-light dark:text-text-muted-dark group-hover:text-primary dark:group-hover:text-primary-light'}`} />
                                <span className={`font-semibold transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-white' // High contrast for selected
                                        : 'text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light'}`}>
                                    {llm.name}
                                </span>
                            </div>
                            <p className={`text-xs transition-colors 
                                ${isSelected 
                                    ? 'text-blue-100 dark:text-blue-200' // High contrast for selected
                                    : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                {llm.description}
                            </p>
                        </button>
                    );
                })}
            </div>
        </div>
    );
}

export default LLMSelection;
```

`src/components/chat/ChatHistory.jsx`

```javascript
import React, { useRef, useEffect } from 'react';
import MessageBubble from './MessageBubble';
import { motion, AnimatePresence } from 'framer-motion';

function ChatHistory({ messages, botStatusPlaceholder }) {
    const chatHistoryRef = useRef(null);

    useEffect(() => {
        if (chatHistoryRef.current) {
            chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
        }
    }, [messages, botStatusPlaceholder]);

    return (
        <div ref={chatHistoryRef} className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
            <AnimatePresence initial={false}>
                {messages.map((msg, index) => (
                    <motion.div
                        key={msg.id || `msg-${index}-${msg.timestamp}`}
                        layout
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10, transition: { duration: 0.15 } }}
                        transition={{ duration: 0.3, ease: "easeOut" }}
                    >
                        <MessageBubble
                            id={msg.id || `msg-${index}-${msg.timestamp}`}
                            sender={msg.sender}
                            text={msg.text}
                            thinking={msg.thinking}
                            references={msg.references}
                            timestamp={msg.timestamp}
                            sourcePipeline={msg.source_pipeline}
                        />
                    </motion.div>
                ))}
            </AnimatePresence>

            {botStatusPlaceholder && (
                <motion.div 
                    layout
                    key="bot-status-placeholder"
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.3 }}
                    className="flex justify-start pl-2 mt-2"
                >
                    <div className="max-w-[85%] bg-gray-100 dark:bg-gray-800 text-gray-800 dark:text-gray-100 px-4 py-2 rounded-xl shadow-md animate-pulse text-sm">
                        {botStatusPlaceholder}
                    </div>
                </motion.div>
            )}
        </div>
    );
}

export default ChatHistory;

```

`src/components/chat/ChatHistoryModal.jsx`

```javascript
// src/components/chat/ChatHistoryModal.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { X, MessageSquareText, Loader2, AlertTriangle, Trash2 } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import IconButton from '../core/IconButton.jsx';

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString(undefined, { 
            month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' 
        });
    } catch (e) {
        return 'Invalid Date';
    }
};

function ChatHistoryModal({ isOpen, onClose, onSelectSession }) {
    const [sessions, setSessions] = useState([]);
    const [selectedSessionId, setSelectedSessionId] = useState(null);
    const [sessionMessages, setSessionMessages] = useState([]);
    const [loadingSessions, setLoadingSessions] = useState(false);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState('');

    const fetchSessions = useCallback(async () => {
        if (!isOpen) return; 
        setLoadingSessions(true);
        setError('');
        try {
            const data = await api.getChatSessions();
            setSessions(Array.isArray(data) ? data : []);
        } catch (err) {
            toast.error("Failed to load chat sessions.");
            setError(err.message || "Could not fetch sessions.");
        } finally {
            setLoadingSessions(false);
        }
    }, [isOpen]);

    useEffect(() => {
        if (isOpen) {
            fetchSessions();
            setSelectedSessionId(null); 
            setSessionMessages([]);
        }
    }, [isOpen, fetchSessions]); 

    const handleSessionSelectForPreview = async (sessionId) => {
        if (selectedSessionId === sessionId && sessionMessages.length > 0) return; 

        setSelectedSessionId(sessionId);
        setLoadingMessages(true);
        setSessionMessages([]);
        setError(''); 
        try {
            const sessionData = await api.getChatHistory(sessionId);
            
            // --- THIS IS THE CORRECTED LOGIC ---
            // We trust the API to send correctly formatted data with the 'sender' property.
            const messagesArray = Array.isArray(sessionData.messages) ? sessionData.messages : [];
            setSessionMessages(messagesArray);
            // --- END OF CORRECTION ---

        } catch (err) {
            toast.error("Failed to load messages for this session.");
            setError(`Error loading messages: ${err.message}`);
        } finally {
            setLoadingMessages(false);
        }
    };

    const handleLoadSessionAndClose = () => {
        if (selectedSessionId) {
            onSelectSession(selectedSessionId); 
            onClose();
        } else {
            toast.error("Please select a session to load.");
        }
    };
    
    const handleDeleteSession = async (sessionIdToDelete, e) => {
        e.stopPropagation();
        if (!window.confirm(`Are you sure you want to delete this session? This action cannot be undone.`)) return;
        
        const toastId = toast.loading(`Deleting session...`);
        try {
            await api.deleteChatSession(sessionIdToDelete);
            toast.success(`Session deleted.`, { id: toastId });
            setSessions(prev => prev.filter(s => s.sessionId !== sessionIdToDelete)); 
            if (selectedSessionId === sessionIdToDelete) {
                setSelectedSessionId(null);
                setSessionMessages([]);
            }
        } catch (err) {
            toast.error(`Delete failed: ${err.response?.data?.message || err.message}`, { id: toastId });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Chat History" size="2xl">
            <div className="flex flex-col md:flex-row gap-4 max-h-[70vh] h-[70vh]">
                <div className="w-full md:w-1/3 border-r border-border-light dark:border-border-dark pr-0 md:pr-2 overflow-y-auto custom-scrollbar">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark px-1">Your Sessions</h3>
                    {loadingSessions && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24}/></div>}
                    {!loadingSessions && !sessions.length && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">No past sessions found.</p>}
                    <ul className="space-y-1">
                        {sessions.map(session => (
                            <li key={session.sessionId} onClick={() => handleSessionSelectForPreview(session.sessionId)}
                                className={`p-2.5 rounded-md cursor-pointer text-xs transition-colors group relative hover:shadow-md
                                            ${selectedSessionId === session.sessionId ? 'bg-primary text-white' : 'bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700'}`} >
                                <div className="font-medium truncate" title={session.preview}>{session.preview || `Session ${session.sessionId.substring(0,8)}`}</div>
                                <div className={`text-[0.7rem] ${selectedSessionId === session.sessionId ? 'text-blue-200' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                    {formatDate(session.updatedAt)} - {session.messageCount} msgs
                                </div>
                                <IconButton icon={Trash2} size="sm" variant="ghost" title="Delete session"
                                    className="absolute top-1 right-1 p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100"
                                    onClick={(e) => handleDeleteSession(session.sessionId, e)} />
                            </li>
                        ))}
                    </ul>
                </div>

                <div className="w-full md:w-2/3 flex flex-col overflow-hidden mt-4 md:mt-0">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark">Preview</h3>
                    <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md overflow-y-auto custom-scrollbar border border-border-light dark:border-border-dark">
                        {loadingMessages && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24} /></div>}
                        
                        <div className="space-y-3 flex flex-col">
                            {sessionMessages.map(msg => {
                                const isUser = msg.sender === 'user';
                                return (
                                    <div key={msg.id} className={`flex w-full ${isUser ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`p-2.5 rounded-lg shadow-sm w-fit max-w-[90%] text-xs
                                            ${isUser 
                                                ? 'bg-blue-500 text-white' 
                                                : 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100'
                                            }`}>
                                            <p className="font-semibold text-[0.7rem] mb-0.5">{isUser ? 'You' : 'AI Tutor'}</p>
                                            <p className="whitespace-pre-wrap break-words">{msg.text}</p>
                                            <p className={`text-[0.65rem] mt-1 text-right ${isUser ? 'opacity-70' : 'opacity-50'}`}>{formatDate(msg.timestamp)}</p>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {!loadingMessages && !selectedSessionId && (
                            <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark text-sm">
                                <MessageSquareText size={40} className="mb-3 opacity-50" />
                                <p>Select a session to view its messages.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            <div className="mt-6 pt-4 border-t border-border-light dark:border-border-dark flex justify-end gap-3">
                <button onClick={onClose} className="btn-secondary !text-xs !py-1.5 !px-3">Cancel</button>
                <button onClick={handleLoadSessionAndClose} className="btn-primary !text-xs !py-1.5 !px-3" disabled={!selectedSessionId || loadingMessages || loadingSessions}>Load Session</button>
            </div>
        </Modal>
    );
}
export default ChatHistoryModal;
```

`src/components/chat/ChatInput.jsx`

```javascript


// frontend/src/components/chat/ChatInput.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Send, Mic, Plus, Brain, Zap, Globe, BookMarked } from 'lucide-react'; // Ensure BookMarked is imported
import { useWebSpeech } from '../../hooks/useWebSpeech';
import Button from '../core/Button.jsx'; 
import IconButton from '../core/IconButton.jsx';
import toast from 'react-hot-toast';
import blueBrain from "./../../assets/blueBrain.svg";
import { motion, AnimatePresence } from 'framer-motion';

function ChatInput({ 
    onSendMessage, 
    isLoading,
    useWebSearch,
    setUseWebSearch,
    useAcademicSearch, // This prop is now used
    setUseAcademicSearch, // This prop is now used
    criticalThinkingEnabled,
    setCriticalThinkingEnabled
}) {
    const [inputValue, setInputValue] = useState('');
    const { transcript, listening, isSpeechSupported, startListening, stopListening, resetTranscript } = useWebSpeech();
    const textareaRef = useRef(null);
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const menuRef = useRef(null);

    useEffect(() => {
        if (transcript) {
            setInputValue(prev => prev + (prev ? " " : "") + transcript);
            resetTranscript(); 
        }
    }, [transcript, resetTranscript]);
    
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 128)}px`;
        }
    }, [inputValue]);

    useEffect(() => {
        function handleClickOutside(event) {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                setIsMenuOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
    }, [menuRef]);

    const handleSubmit = (e) => {
        e.preventDefault();
        if (inputValue.trim() && !isLoading) {
            onSendMessage(inputValue.trim());
            setInputValue('');
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !isLoading) {
            e.preventDefault();
            handleSubmit(e);
        }
    };
    
    const handleWebSearchToggle = () => {
        const newWebSearchState = !useWebSearch;
        setUseWebSearch(newWebSearchState);
        toast(newWebSearchState ? "Web Search enabled." : "Web Search disabled.", { icon: newWebSearchState ? "🌐" : "📄" });
        setIsMenuOpen(false);
    };

    // Handler for the Academic Search Toggle
    const handleAcademicSearchToggle = () => {
        const newState = !useAcademicSearch;
        setUseAcademicSearch(newState);
        toast(newState ? "Academic Search enabled." : "Academic Search disabled.", { icon: newState ? "🎓" : "📄" });
        setIsMenuOpen(false);
    };

    const icon = criticalThinkingEnabled ? () => <img src={blueBrain} alt="Blue Brain" className="w-5 h-5" /> : Brain;

    return (
        <div className="p-2 sm:p-3 bg-surface-light dark:bg-surface-dark/50 backdrop-blur-sm rounded-b-lg shadow-inner">
            <form onSubmit={handleSubmit} className="flex items-end gap-2">
                <div className="relative" ref={menuRef}>
                    <IconButton
                        icon={Plus}
                        title="More Options"
                        onClick={() => setIsMenuOpen(!isMenuOpen)}
                        variant="ghost"
                        size="md" 
                        className="p-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                        disabled={isLoading}
                    />
                    <AnimatePresence>
                    {isMenuOpen && (
                        <motion.div
                            initial={{ opacity: 0, y: 10, scale: 0.95 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: 10, scale: 0.95 }}
                            className="absolute bottom-full left-0 mb-2 w-52 bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl border border-border-light dark:border-border-dark p-1 z-10"
                        >
                            {/* Web Search Button */}
                            <button
                                onClick={handleWebSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useWebSearch
                                    ? 'bg-primary/10 text-primary dark:bg-primary-dark/20 dark:text-primary-light'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <Globe size={16} />
                                {useWebSearch ? 'Disable Web Search' : 'Enable Web Search'}
                            </button>

                            {/* --- THIS IS THE BUTTON THAT WAS MISSING --- */}
                            <button
                                onClick={handleAcademicSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useAcademicSearch
                                    ? 'bg-purple-500/10 text-purple-600 dark:bg-purple-400/20 dark:text-purple-300'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <BookMarked size={16} />
                                {useAcademicSearch ? 'Disable Academic Search' : 'Enable Academic Search'}
                            </button>
                             
                             <button
                                onClick={() => {toast("File attachment coming soon!", { icon: "📎" }); setIsMenuOpen(false);}}
                                className="w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md text-text-muted-light dark:text-text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700"
                            >
                                <Zap size={16} />
                                Attach File (soon)
                            </button>
                        </motion.div>
                    )}
                    </AnimatePresence>
                </div>

                <textarea
                    ref={textareaRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder={isLoading ? "Waiting for response..." : "Type your message or ask a question..."}
                    className="input-field flex-1 p-2.5 resize-none min-h-[44px] max-h-32 custom-scrollbar text-sm" 
                    rows="1"
                    disabled={isLoading}
                />

                {isSpeechSupported && (
                    <IconButton
                        icon={Mic}
                        onClick={() => listening ? stopListening() : startListening()}
                        title={listening ? "Stop listening" : "Start voice input"}
                        variant={listening ? "danger" : "ghost"} 
                        size="md"
                        className={`p-2 ${listening ? 'text-red-500 animate-pulse' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        disabled={isLoading}
                    />
                )}

               <IconButton
                    icon={icon}
                    onClick={() => setCriticalThinkingEnabled(!criticalThinkingEnabled)}
                    title={criticalThinkingEnabled ? "Disable Critical Thinking (KG)" : "Enable Critical Thinking (KG)"}
                    variant="ghost"
                    size="md"
                    className={`p-2 ${criticalThinkingEnabled ? 'text-purple-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                    disabled={isLoading}
                />

                <Button 
                    type="submit"
                    variant="primary"
                    size="md" 
                    className="!p-2.5" 
                    disabled={isLoading || !inputValue.trim()}
                    isLoading={isLoading && !!inputValue.trim()} 
                    title="Send message"
                >
                    {(!isLoading || !inputValue.trim()) ? <Send size={20} /> : null}
                </Button>
            </form>
            
            <div className="flex flex-col items-center justify-center mt-2 px-2 text-center h-4">
                <AnimatePresence>
                    {useWebSearch && (
                        <motion.p
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-blue-500 dark:text-blue-400 flex items-center gap-1.5 font-medium"
                        >
                            <Globe size={12} /> Web Search is ON
                        </motion.p>
                    )}
                    {useAcademicSearch && (
                        <motion.p
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-purple-500 dark:text-purple-400 flex items-center gap-1.5 font-medium"
                        >
                            <BookMarked size={12} /> Academic Search is ON
                        </motion.p>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default ChatInput;
```

`src/components/chat/MessageBubble.jsx`

```javascript
// src/components/chat/MessageBubble.jsx
import React, { useEffect, useRef } from 'react'; // Import useEffect and useRef
import { marked } from 'marked';
import Prism from 'prismjs'; // Import Prism for manual highlighting
import { ChevronDown, Brain, Link as LinkIcon, Zap, Server, Volume2, StopCircle, ServerCrash } from 'lucide-react';
import { useTextToSpeech } from '../../hooks/useTextToSpeech.js';
import IconButton from '../core/IconButton.jsx';
import { renderMathInHtml } from '../../utils/markdownUtils'; // Import the math renderer
import DOMPurify from 'dompurify'; // Import DOMPurify for security

// Configure marked - it's good to have it here
marked.setOptions({
  breaks: true,
  gfm: true,
});

// Create a new, safer markup creation function
const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    // 1. Convert Markdown to HTML
    let rawHtml = marked.parse(markdownText);
    // 2. Render KaTeX math within the HTML
    rawHtml = renderMathInHtml(rawHtml);
    // 3. Sanitize the final HTML to prevent XSS attacks
    const cleanHtml = DOMPurify.sanitize(rawHtml, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};


const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

function MessageBubble({ sender, text, thinking, references, timestamp, sourcePipeline, id: messageId }) {
    const isUser = sender === 'user';
    const { speak, cancel, isSpeaking: isCurrentlySpeakingThisBubble, isSupported: ttsIsSupported } = useTextToSpeech();
    
    // --- START OF CHANGES ---
    // 1. Create a ref to attach to the content container
    const contentRef = useRef(null);

    // 2. Use an effect to run Prism highlighting after the component renders/updates
    useEffect(() => {
        // The timeout ensures that React has finished rendering the HTML from `dangerouslySetInnerHTML`
        // before Prism tries to find the code blocks.
        const timer = setTimeout(() => {
            if (contentRef.current) {
                Prism.highlightAllUnder(contentRef.current);
            }
        }, 50); // A small delay is usually sufficient

        return () => clearTimeout(timer); // Cleanup timer on unmount
    }, [text]); // Re-run this effect whenever the message text changes
    // --- END OF CHANGES ---

    const formatTimestamp = (ts) => {
        if (!ts) return '';
        try {
            return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } catch (e) { return 'Invalid Time'; }
    };

    const getPipelineIcon = () => {
        if (!sourcePipeline) return null;
        const lowerPipeline = sourcePipeline.toLowerCase();
        if (lowerPipeline.includes('ollama')) return <Zap size={12} className="text-green-400" title="Ollama Powered" />;
        if (lowerPipeline.includes('gemini')) return <Server size={12} className="text-blue-400" title="Gemini Powered" />;
        if (lowerPipeline.includes('rag')) return <Zap size={12} className="text-purple-400" title="RAG Enhanced" />;
        if (lowerPipeline.includes('error')) return <ServerCrash size={12} className="text-red-400" title="Error" />;
        return null;
    };

    const handleToggleSpeech = () => {
        if (!ttsIsSupported || !text) return;
        if (isCurrentlySpeakingThisBubble) {
            cancel();
        } else {
            speak({ text });
        }
    };
    
    return (
        <div className={`flex flex-col ${isUser ? 'items-end' : 'items-start'} w-full group`}>
            <div 
                className={`message-bubble max-w-[85%] md:max-w-[75%] p-3 rounded-2xl shadow-md break-words ${
                    isUser 
                    ? 'bg-primary dark:bg-primary-dark text-white rounded-br-lg' 
                    : 'bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark rounded-bl-lg border border-border-light dark:border-border-dark'
                }`}
            >
                {/* Main message content */}
                <div 
                    // 3. Attach the ref to the div that contains the dangerous HTML
                    ref={contentRef}
                    className="prose prose-sm dark:prose-invert max-w-none message-content leading-relaxed" 
                    dangerouslySetInnerHTML={createMarkup(text || '')} 
                />
                
                {/* Timestamp, Pipeline Icon, and TTS Button */}
                <div className="flex items-center justify-end mt-1.5 text-xs opacity-70 gap-2">
                    {!isUser && getPipelineIcon() && <span className="mr-1">{getPipelineIcon()}</span>}
                    <span>{formatTimestamp(timestamp)}</span>
                    {!isUser && ttsIsSupported && text && (
                        <IconButton
                            icon={isCurrentlySpeakingThisBubble ? StopCircle : Volume2}
                            onClick={handleToggleSpeech}
                            title={isCurrentlySpeakingThisBubble ? "Stop reading" : "Read aloud"}
                            size="sm"
                            variant="ghost"
                            className={`p-0.5 ${isCurrentlySpeakingThisBubble ? 'text-red-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        />
                    )}
                </div>
            </div>

            {/* Metadata: Thinking and References for Bot Messages */}
            {!isUser && (thinking || (references && references.length > 0)) && (
                <div className="message-metadata-container max-w-[85%] md:max-w-[75%] mt-1.5 pl-2 space-y-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                    {thinking && thinking.trim() && (
                        <details className="group/details text-xs">
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <Brain size={14} /> AI Reasoning
                                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
                            </summary>
                            <pre className="mt-1 p-2 bg-gray-100 dark:bg-gray-800 rounded-md text-text-light dark:text-text-dark whitespace-pre-wrap break-all text-[0.7rem] max-h-32 overflow-y-auto custom-scrollbar">
                                <code>{escapeHtml(thinking)}</code>
                            </pre>
                        </details>
                    )}
                    {references && references.length > 0 && (
                        <details className="group/details text-xs" open>
                            <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                                <LinkIcon size={14} /> References
                                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
                            </summary>
                            <ul className="mt-1 pl-1 space-y-0.5 text-[0.7rem]">
                                {references.map((ref, index) => (
                                    <li 
                                        key={index} 
                                        className="text-text-muted-light dark:text-text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors truncate"
                                        title={`Preview: ${escapeHtml(ref.content_preview || '')}\nSource: ${escapeHtml(ref.source || '')}`}
                                    >
                                        <span className="font-semibold text-accent">[{ref.number}]</span> {escapeHtml(ref.source)}
                                    </li>
                                ))}
                            </ul>
                        </details>
                    )}
                </div>
            )}
        </div>
    );
}
export default MessageBubble;
```

`src/components/chat/ThinkingDropdown.jsx`

```javascript
// frontend/src/components/chat/ThinkingDropdown.jsx
import React, { useState } from 'react';
import { ChevronDown, BrainCircuit } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

function ThinkingDropdown({ children, isStreaming }) {
    const [isOpen, setIsOpen] = useState(false);

    return (
        <div className="text-xs border border-border-light dark:border-border-dark rounded-md bg-surface-light/50 dark:bg-surface-dark/50 shadow-sm mt-1.5 w-full">
            <button
                onClick={() => setIsOpen(!isOpen)}
                className="w-full flex items-center justify-between p-2 text-left text-text-muted-light dark:text-text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700/50 transition-colors rounded-t-md"
                aria-expanded={isOpen}
            >
                <div className="flex items-center gap-2 font-medium">
                    <BrainCircuit size={14} />
                    <span className="flex-grow">Thinking Process</span>
                </div>
                {/* Shimmer effect for when streaming is active */}
                {isStreaming && (
                    <div className="relative w-20 h-4 ml-auto mr-2 overflow-hidden rounded bg-gray-200 dark:bg-gray-600">
                        <div className="shimmer-animation"></div>
                    </div>
                )}
                <ChevronDown size={16} className={`transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} />
            </button>
            <AnimatePresence initial={false}>
                {isOpen && (
                    <motion.div
                        key="content"
                        initial="collapsed"
                        animate="open"
                        exit="collapsed"
                        variants={{
                            open: { opacity: 1, height: 'auto' },
                            collapsed: { opacity: 0, height: 0 }
                        }}
                        transition={{ duration: 0.3, ease: 'easeInOut' }}
                        className="overflow-hidden"
                    >
                        <div className="p-2.5 border-t border-border-light dark:border-border-dark bg-white dark:bg-gray-800 rounded-b-md">
                            {children}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}

export default ThinkingDropdown;
```

`src/components/common/ThemeToggle.jsx`

```javascript
import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="p-2 rounded-full text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
            aria-label={theme === 'light' ? 'Switch to dark theme' : 'Switch to light theme'}
        >
            {theme === 'light' ? <Moon size={20} /> : <Sun size={20} />}
        </button>
    );
}

export default ThemeToggle;
```

`src/components/core/Button.jsx`

```javascript
// src/components/core/Button.jsx
import React from 'react';
import { Loader2 } from 'lucide-react'; // For loading spinner

const Button = ({
    children,
    onClick,
    type = 'button',
    variant = 'primary', // 'primary', 'secondary', 'danger', 'outline', 'ghost'
    size = 'md', // 'sm', 'md', 'lg'
    leftIcon,
    rightIcon,
    isLoading = false,
    disabled = false,
    fullWidth = false,
    className = '',
    ...props
}) => {
    const baseStyles = "font-semibold rounded-lg focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2";

    const variantStyles = {
        primary: "bg-primary hover:bg-primary-dark text-white focus:ring-primary",
        secondary: "bg-secondary hover:bg-secondary-dark text-white focus:ring-secondary",
        danger: "bg-red-500 hover:bg-red-600 text-white focus:ring-red-500",
        outline: "border border-primary text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
        ghost: "text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
    };

    const sizeStyles = {
        sm: "px-3 py-1.5 text-xs",
        md: "px-4 py-2 text-sm",
        lg: "px-6 py-3 text-base",
    };

    const widthStyle = fullWidth ? "w-full" : "";
    const isDisabled = disabled || isLoading;
    const finalDisabledStyle = isDisabled ? "opacity-60 cursor-not-allowed" : "cursor-pointer";

    const spinnerSize = size === 'sm' ? 14 : (size === 'lg' ? 20 : 16);
    
    return (
        <button
            type={type}
            onClick={onClick}
            disabled={isDisabled} // Use the corrected variable
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${widthStyle} ${finalDisabledStyle} ${className}`}
            {...props}
        >
            {isLoading && (
                <Loader2 size={spinnerSize} className="animate-spin" />
            )}
            {!isLoading && leftIcon && <span className="icon-left">{leftIcon}</span>}

            <span className={isLoading ? 'ml-2' : ''}>{children}</span>

            {!isLoading && rightIcon && <span className="icon-right">{rightIcon}</span>}
        </button>
    );
};

export default Button;
```

`src/components/core/IconButton.jsx`

```javascript
import React from 'react';
import { Loader2 } from 'lucide-react';

const IconButton = ({
    icon: Icon, // Pass the Lucide icon component directly
    onClick,
    variant = 'ghost', // 'ghost', 'outline', 'subtle'
    size = 'md', // 'sm', 'md', 'lg'
    isLoading = false,
    disabled = false,
    className = '',
    title, // For accessibility and tooltips
    ariaLabel,
    ...props
}) => {
    const baseStyles = "rounded-md focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-colors duration-150 flex items-center justify-center";

    const variantStyles = {
        ghost: "text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:ring-primary",
        outline: "border border-gray-300 dark:border-gray-600 text-text-muted-light dark:text-text-muted-dark hover:border-primary hover:text-primary focus:ring-primary",
        subtle: "bg-gray-100 dark:bg-gray-700 text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-600 focus:ring-primary",
        danger: "text-red-500 hover:bg-red-100 dark:hover:bg-red-900 focus:ring-red-500"
    };

    const sizeStyles = {
        sm: "p-1.5", // Icon size typically 14-16px
        md: "p-2",   // Icon size typically 18-20px
        lg: "p-2.5", // Icon size typically 22-24px
    };
    
    const iconSizeMap = {
        sm: 16,
        md: 20,
        lg: 24,
    };

    const disabledStyle = (disabled || isLoading) ? "opacity-50 cursor-not-allowed" : "cursor-pointer";

    return (
        <button
            type="button"
            onClick={onClick}
            disabled={disabled || isLoading}
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${disabledStyle} ${className}`}
            title={title}
            aria-label={ariaLabel || title}
            {...props}
        >
            {isLoading ? (
                <Loader2 size={iconSizeMap[size]} className="animate-spin" />
            ) : (
                Icon && <Icon size={iconSizeMap[size]} />
            )}
        </button>
    );
};

export default IconButton;
```

`src/components/core/Modal.jsx`

```javascript
// src/components/core/Modal.jsx
import React, { useEffect, useRef } from 'react';
import { X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const Modal = ({
    isOpen,
    onClose,
    title,
    children,
    footerContent,
    size = 'md', // 'sm', 'md', 'lg', 'xl', '2xl', '3xl', '4xl', '5xl', 'full'
    closeOnOverlayClick = true,
    initialFocusRef, // Optional ref for focusing an element inside the modal on open
}) => {
    const modalRef = useRef(null);

    // Handle Escape key for closing
    useEffect(() => {
        const handleEscapeKey = (event) => {
            if (event.key === 'Escape' && isOpen) {
                onClose();
            }
        };
        if (isOpen) {
            document.addEventListener('keydown', handleEscapeKey);
        }
        return () => {
            document.removeEventListener('keydown', handleEscapeKey);
        };
    }, [isOpen, onClose]);

    // Handle focus trapping and initial focus
    useEffect(() => {
        if (isOpen) {
            // Set focus to the initialFocusRef or the modal itself
            if (initialFocusRef && initialFocusRef.current) {
                initialFocusRef.current.focus();
            } else if (modalRef.current) {
                modalRef.current.focus(); // Fallback to modal itself
            }

            // Basic focus trapping (can be made more robust with a library)
            const focusableElements = modalRef.current?.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements && focusableElements.length > 0) {
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                const onKeyDown = (e) => {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) { // Shift + Tab
                            if (document.activeElement === firstElement) {
                                lastElement.focus();
                                e.preventDefault();
                            }
                        } else { // Tab
                            if (document.activeElement === lastElement) {
                                firstElement.focus();
                                e.preventDefault();
                            }
                        }
                    }
                };
                modalRef.current?.addEventListener('keydown', onKeyDown);
                return () => modalRef.current?.removeEventListener('keydown', onKeyDown);
            }
        }
    }, [isOpen, initialFocusRef]);


    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl',
        '3xl': 'max-w-3xl',
        '4xl': 'max-w-4xl',
        '5xl': 'max-w-5xl',
        full: 'max-w-full h-full rounded-none sm:rounded-lg sm:max-h-[95vh]', // Special case for full screen like
    };

    const backdropVariants = {
        visible: { opacity: 1, transition: { duration: 0.2, ease: "easeOut" } },
        hidden: { opacity: 0, transition: { duration: 0.15, ease: "easeIn" } },
    };

    const modalVariants = {
        hidden: { y: "-30px", opacity: 0, scale: 0.98, transition: { duration: 0.15, ease: "easeIn" } },
        visible: { y: "0", opacity: 1, scale: 1, transition: { type: "spring", stiffness: 400, damping: 30, duration: 0.3 } },
        exit: { y: "30px", opacity: 0, scale: 0.98, transition: { duration: 0.2, ease: "easeIn" } }
    };

    if (!isOpen) return null;

    return (
        <AnimatePresence mode="wait">
            {isOpen && (
                <motion.div
                    key="modal-backdrop"
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 dark:bg-black/80 backdrop-blur-sm"
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    variants={backdropVariants}
                    onClick={closeOnOverlayClick ? onClose : undefined}
                    aria-labelledby="modal-title" // For screen readers
                    role="dialog" // Role for the backdrop itself, more specific roles on content
                    aria-modal="true" // Indicate it's a modal overlaying other content
                >
                    <motion.div
                        key="modal-content-wrapper" // Changed key for potential AnimatePresence behavior
                        ref={modalRef}
                        tabIndex={-1} // Make the modal itself focusable for fallback
                        className={`bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl w-full ${sizeClasses[size]} flex flex-col overflow-hidden
                                    ${size === 'full' ? '' : 'max-h-[90vh] sm:max-h-[85vh]'}`} 
                                    // Apply max-h unless it's 'full' size
                        role="document" // The actual dialog content
                        aria-modal="true"
                        aria-labelledby={title ? "modal-title-text" : undefined} // Point to title if exists
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        variants={modalVariants}
                        onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside modal
                    >
                        {/* Modal Header */}
                        <div className="flex items-center justify-between px-5 py-3.5 border-b border-border-light dark:border-border-dark sticky top-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                            {title && (
                                <h2 id="modal-title-text" className="text-lg font-semibold text-text-light dark:text-text-dark truncate pr-4">
                                    {title}
                                </h2>
                            )}
                            <button
                                onClick={onClose}
                                className="p-1.5 rounded-full text-text-muted-light dark:text-text-muted-dark 
                                           hover:bg-gray-200/80 dark:hover:bg-gray-700/80 
                                           hover:text-red-500 dark:hover:text-red-400 
                                           focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary-light focus:ring-offset-1 dark:focus:ring-offset-surface-dark"
                                aria-label="Close modal"
                            >
                                <X size={20} />
                            </button>
                        </div>

                        {/* Modal Body */}
                        <div className="px-5 py-4 overflow-y-auto flex-grow custom-scrollbar">
                            {children}
                        </div>

                        {/* Modal Footer */}
                        {footerContent && (
                            <div className="px-5 py-3.5 border-t border-border-light dark:border-border-dark flex justify-end gap-3 sticky bottom-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                                {footerContent}
                            </div>
                        )}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

export default Modal;
```

`src/components/documents/DocumentList.jsx`

```javascript


// frontend/src/components/documents/DocumentList.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api.js'; // Mocked for V1
import toast from 'react-hot-toast';
import { FileText, Edit3, Trash2, Loader2, AlertTriangle, CheckCircle } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Make sure IconButton is imported
import { useAuth } from '../../hooks/useAuth.jsx';

// Props from LeftPanel: onSelectDocument is selectDocumentForAnalysis from AppStateContext
// selectedDocument is selectedDocumentForAnalysis from AppStateContext
function DocumentList({ onSelectDocument, selectedDocument }) {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const fetchFiles = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      
      const response = await api.getFiles(); // Returns { filenames: ["A.txt", "B.pdf"] }
      const filenames = Array.isArray(response.filenames) ? response.filenames : [];
      setFiles(filenames);
      
    } catch (err) {
      console.error("Failed to fetch files:", err);
      setError(err.message || "Failed to fetch files.");
      toast.error("Could not load documents.");
    } finally {
      setLoading(false);
    }
  }, []);



  useEffect(() => {
    fetchFiles();
  }, [fetchFiles]);

  const handleDelete = async (filename) => {
    if (!window.confirm(`Are you sure you want to delete "${filename}"?`)) return;
    const toastId = toast.loading(`Deleting ${filename}...`);
    try {
      await api.deleteFile(filename); // Assumes this works with filename
      toast.success(`${filename} deleted.`, { id: toastId });
      fetchFiles();
      if (selectedDocument === filename) {
        onSelectDocument(null);
      }
    } catch (err) {
      toast.error(`Delete failed: ${err.message}`, { id: toastId });
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark">
        <Loader2 size={20} className="animate-spin mr-2" /> Loading documents...
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
        <AlertTriangle size={18} /> {error}
        <button onClick={fetchFiles} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
      </div>
    );
  }

  if (files.length === 0) {
    return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-4">No documents uploaded.</p>;
  }

  return (
    <div className="space-y-1.5 text-xs custom-scrollbar pr-1">
      {files.map(filename => {
        const isSelected = selectedDocument === filename;

        return (
          <div
            key={filename}
            onClick={() => onSelectDocument(isSelected ? null : filename)}
            className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                        ${isSelected
                          ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                          : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
            title={`Select ${filename}`}
          >
            <div className="flex items-center gap-2 truncate">
              {isSelected ? (
                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
              ) : (
                <FileText size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
              )}
              <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                {filename}
              </span>
            </div>
            <div className="flex-shrink-0 flex items-center gap-0.5">
              <IconButton
                icon={Trash2}
                size="sm"
                variant="ghost"
                title="Delete"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete(filename);
                }}
                className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"
              />
            </div>
          </div>
        );
      })}
    </div>
  );
}


export default DocumentList;
```

`src/components/documents/DocumentUpload.jsx`

```javascript
// frontend/src/components/documents/DocumentUpload.jsx
import React, { useState, useRef, useEffect } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { UploadCloud, FileText, XCircle, Paperclip } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';

// Define the stages for our static simulation
const RAG_STAGES = [
    { name: "Uploading", duration: 1500, message: "Transferring your document to the server..." },
    { name: "Processing", duration: 2000, message: "Validating file format and structure..." },
    { name: "Extracting", duration: 3000, message: "Extracting text and content from your document..." },
    { name: "Chunking", duration: 1500, message: "Breaking document into manageable segments..." },
    { name: "Embedding", duration: 4000, message: "Converting content to searchable vectors..." },
    { name: "Analyzing", duration: 3000, message: "Indexing content for optimal retrieval..." },
];

function DocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const [progress, setProgress] = useState(0);
    const [currentStage, setCurrentStage] = useState('');
    const [stageMessage, setStageMessage] = useState('');
    const [errorMessage, setErrorMessage] = useState('');
    const [dragActive, setDragActive] = useState(false);

    const fileInputRef = useRef(null);
    const processingTimeoutRef = useRef(null);
    
    useEffect(() => {
        return () => {
            if (processingTimeoutRef.current) {
                clearTimeout(processingTimeoutRef.current);
            }
        };
    }, []);

    const handleFileChange = (e) => {
        if (isProcessing) return;
        const file = e.target.files && e.target.files[0];
        if (file) {
            setSelectedFile(file);
            setErrorMessage('');
        }
    };

    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(e.type === "dragenter" || e.type === "dragover"); };
    const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(false); const file = e.dataTransfer.files && e.dataTransfer.files[0]; if (file) { setSelectedFile(file); setErrorMessage(''); }};

    const resetState = () => {
        setSelectedFile(null);
        setIsProcessing(false);
        setProgress(0);
        setCurrentStage('');
        setStageMessage('');
        setErrorMessage('');
        if (fileInputRef.current) fileInputRef.current.value = null;
    };
    
    const runProgressSimulation = (stageIndex = 0) => {
        if (stageIndex >= RAG_STAGES.length) return;

        const stage = RAG_STAGES[stageIndex];
        setCurrentStage(stage.name);
        setStageMessage(stage.message);
        
        const totalDuration = RAG_STAGES.reduce((acc, s) => acc + s.duration, 0);
        const elapsedDuration = RAG_STAGES.slice(0, stageIndex).reduce((acc, s) => acc + s.duration, 0);
        setProgress(Math.round((elapsedDuration / totalDuration) * 100));

        processingTimeoutRef.current = setTimeout(() => {
            runProgressSimulation(stageIndex + 1);
        }, stage.duration);
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            toast.error("Please select a file first.");
            return;
        }

        setIsProcessing(true);
        setErrorMessage('');
        runProgressSimulation(0);

        const formData = new FormData();
        formData.append("file", selectedFile);
        
        try {
            await api.uploadFile(formData);

            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            setCurrentStage("Ready");
            setStageMessage("Document successfully processed and ready to use!");
            setProgress(100);
            toast.success(`'${selectedFile.name}' processed successfully!`);
            
            setTimeout(() => {
                resetState();
                if (onUploadSuccess) onUploadSuccess();
            }, 2500);

        } catch (error) {
            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            const msg = error.response?.data?.message || error.message || "Upload failed.";
            setErrorMessage(msg);
            toast.error(`Upload failed: ${msg}`);
            setIsProcessing(false);
            setCurrentStage('Failed');
            setProgress(100);
        }
    };

    if (isProcessing) {
        return (
            <div className="card-base p-4 mb-4">
                <h3 className="font-semibold text-text-light dark:text-text-dark">
                    📄 Processing: <span className="font-normal truncate">{selectedFile.name}</span>
                </h3>
                <div className="relative w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 my-2">
                    <motion.div
                        className={`h-2.5 rounded-full ${errorMessage ? 'bg-red-500' : 'bg-primary'}`}
                        initial={{ width: '0%' }}
                        animate={{ width: `${progress}%` }}
                        transition={{ duration: 0.5, ease: 'linear' }}
                    />
                </div>
                <div className="flex justify-between text-xs text-text-muted-light dark:text-text-muted-dark">
                    <span>{errorMessage ? 'Error' : `Stage: ${currentStage}`} ({progress}%)</span>
                </div>
                <p className="text-xs text-center mt-2 h-4">{errorMessage || stageMessage}</p>
                {errorMessage && (
                    <Button onClick={resetState} fullWidth variant="danger" size="sm" className="mt-3">
                        Close
                    </Button>
                )}
            </div>
        );
    }
    
    return (
        <div className="mb-4 p-1">
            <label
                htmlFor="file-upload-input"
                onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}
                className={`flex flex-col items-center justify-center w-full h-36 px-4 transition-colors duration-200 ease-in-out bg-surface-light dark:bg-gray-800 border-2 border-dashed rounded-lg cursor-pointer border-border-light dark:border-border-dark hover:border-primary dark:hover:border-primary-light ${dragActive ? "border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light bg-primary/10 dark:bg-primary-dark/20" : ""}`}
            >
                <div className="flex flex-col items-center justify-center text-center">
                    <Paperclip size={36} className={`mb-2 transition-colors ${dragActive ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                    <p className="mb-1 text-sm text-text-muted-light dark:text-text-muted-dark">
                        <span className="font-semibold text-primary dark:text-primary-light">Click to upload</span> or drag and drop
                    </p>
                    <p className="text-xs text-text-muted-light dark:text-text-muted-dark">PDF, DOCX, TXT, PPTX, code files</p>
                </div>
                <input ref={fileInputRef} id="file-upload-input" type="file" className="hidden" onChange={handleFileChange}
                       accept=".pdf,.doc,.docx,.ppt,.pptx,.txt,.py,.js,.md,.html,.xml,.json,.csv,.log,.c,.cpp,.java" />
            </label>

            {selectedFile && (
                <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm animate-fadeIn">
                    <div className="flex items-center gap-2 truncate">
                        <FileText size={18} className="text-primary flex-shrink-0" />
                        <span className="truncate text-text-light dark:text-text-dark" title={selectedFile.name}>{selectedFile.name}</span>
                        <span className="text-text-muted-light dark:text-text-muted-dark text-xs whitespace-nowrap">
                            ({(selectedFile.size / 1024).toFixed(1)} KB)
                        </span>
                    </div>
                    <button onClick={() => setSelectedFile(null)} className="text-red-500 hover:text-red-700 dark:hover:text-red-400 transition-colors p-1 rounded-full hover:bg-red-500/10">
                        <XCircle size={18} />
                    </button>
                </div>
            )}

            <Button
                onClick={handleUpload}
                fullWidth
                className="mt-3 text-sm min-h-[38px]"
                variant="primary"
                disabled={!selectedFile}
                leftIcon={<UploadCloud size={16} />}
            >
                Upload Document
            </Button>
        </div>
    );
}

export default DocumentUpload;
```

`src/components/documents/SubjectList.jsx`

```javascript
// frontend/src/components/documents/SubjectList.jsx
import React from 'react';
import { Library, CheckCircle, Loader2, AlertTriangle } from 'lucide-react'; // Added AlertTriangle

function SubjectList({
    subjects,           // Array of subject name strings
    selectedSubject,    // Currently selected subject name (string or null)
    onSelectSubject,    // Function to call when a subject is selected (passes subjectName or null)
    isLoading,          // Boolean to indicate if subjects are being fetched
    error               // String error message if fetching failed
}) {
    if (isLoading) {
        return (
            <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark text-xs">
                <Loader2 size={16} className="animate-spin mr-2" /> Loading subjects...
            </div>
        );
    }

    if (error) {
        return (
            <div className="p-2 my-1 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center justify-center gap-1">
                <AlertTriangle size={14} /> {error}
            </div>
        );
    }

    if (!subjects || subjects.length === 0) {
        return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-3">No subjects configured by admin yet.</p>;
    }

    return (
        <div className="space-y-1.5 text-xs custom-scrollbar pr-1 max-h-60 overflow-y-auto"> {/* Added max-h and overflow */}
            {/* Option to deselect/choose general chat */}
            <div
                onClick={() => onSelectSubject(null)} // Pass null to deselect
                className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                            ${!selectedSubject // Highlighted if no subject is selected
                                ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                title="Select General Chat (No Specific Subject)"
            >
                <div className="flex items-center gap-2 truncate">
                    {!selectedSubject ? (
                        <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                    ) : (
                        // Using a generic icon, or you can use a different one for "none"
                        <Library size={16} className="text-gray-400 dark:text-gray-500 flex-shrink-0" />
                    )}
                    <span className={`truncate ${!selectedSubject ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                        -- General Chat --
                    </span>
                </div>
            </div>

            {/* List of available subjects */}
            {subjects.map(subjectName => {
                const isSelected = selectedSubject === subjectName;
                return (
                    <div
                        key={subjectName}
                        onClick={() => onSelectSubject(isSelected ? null : subjectName)} // Toggle selection
                        className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                                    ${isSelected
                                        ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                        : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                        title={`Select Subject: ${subjectName}`}
                    >
                        <div className="flex items-center gap-2 truncate">
                            {isSelected ? (
                                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                            ) : (
                                <Library size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                            )}
                            <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                                {subjectName}
                            </span>
                        </div>
                        {/* No actions like delete for subjects from this view */}
                    </div>
                );
            })}
        </div>
    );
}

export default SubjectList;
```

`src/components/layout/CenterPanel.jsx`

```javascript

// frontend/src/components/layout/CenterPanel.jsx
import React, { useState, useEffect, useRef } from 'react';
import ChatHistory from '../chat/ChatHistory';
import ChatInput from '../chat/ChatInput';
import api from '../../services/api';
import { useAuth as useRegularAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import toast from 'react-hot-toast';

const THINKING_VARIANTS = ["🧠 Thinking...", "💭 Processing...", "🤔 Analyzing query..."];
const RAG_ANALYSIS_VARIANTS = ["📚 Reviewing documents...", "🎯 Finding relevant info...", "🧩 Combining sources..."];
const WEB_ANALYSIS_VARIANTS = ["🌐 Searching the web...", "🔎 Filtering results...", "📰 Reading latest info..."];
const ACADEMIC_ANALYSIS_VARIANTS = ["🎓 Searching academic papers...", "🔬 Reviewing studies...", "📚 Compiling research..."];
const GENERAL_ANALYSIS_VARIANTS = ["📊 Analyzing context...", "🔍 Searching knowledge base..."];
const GENERATION_VARIANTS = ["✨ Generating response...", "🚀 Crafting answer...", "📝 Preparing explanation..."];

const getRandomItem = (arr) => arr[Math.floor(Math.random() * arr.length)];
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

function CenterPanel({ messages, setMessages, currentSessionId, onChatProcessingChange }) {
    const { token: regularUserToken } = useRegularAuth();
    const { selectedLLM, systemPrompt, selectedDocumentForAnalysis, selectedSubject } = useAppState();

    const [useWebSearch, setUseWebSearch] = useState(false);
    const [useAcademicSearch, setUseAcademicSearch] = useState(false);
    const [criticalThinkingEnabled, setCriticalThinkingEnabled] = useState(false);

    const [botStatusPlaceholder, setBotStatusPlaceholder] = useState(null);

    const isMountedRef = useRef(true);
    const simulationControllerRef = useRef(new AbortController());
    const [isActuallySendingAPI, setIsActuallySendingAPI] = useState(false);

    useEffect(() => {
        isMountedRef.current = true;
        return () => {
            isMountedRef.current = false;
            simulationControllerRef.current.abort();
        };
    }, []);

    useEffect(() => {
        const documentContext = selectedSubject || selectedDocumentForAnalysis;
        if (documentContext && (useWebSearch || useAcademicSearch)) {
            setUseWebSearch(false);
            setUseAcademicSearch(false);
            toast("Web and Academic Search disabled automatically while a document is selected.", { icon: "ℹ️" });
        }
    }, [selectedDocumentForAnalysis, selectedSubject, useWebSearch, useAcademicSearch]);

    const runStatusSimulation = async (isRagActive, isWebActive, isAcademicActive, signal) => {
        let analysisVariants;
        if (isWebActive) {
            analysisVariants = WEB_ANALYSIS_VARIANTS;
        } else if (isAcademicActive) {
            analysisVariants = ACADEMIC_ANALYSIS_VARIANTS;
        } else if (isRagActive) {
            analysisVariants = RAG_ANALYSIS_VARIANTS;
        } else {
            analysisVariants = GENERAL_ANALYSIS_VARIANTS;
        }

        const sequence = [
            { message: getRandomItem(THINKING_VARIANTS), duration: 1200 },
            { message: getRandomItem(analysisVariants), duration: 1500 },
            { message: getRandomItem(GENERATION_VARIANTS), duration: 1300 },
        ];

        for (const stage of sequence) {
            if (signal.aborted) return;
            setBotStatusPlaceholder(stage.message);
            await wait(stage.duration + (Math.random() * 400 - 200));
        }
    };

    const handleSendMessage = async (inputText) => {
        if (!inputText.trim() || !regularUserToken || !currentSessionId || isActuallySendingAPI) return;

        const documentContextName = selectedSubject || selectedDocumentForAnalysis;
        const isRagActive = !!documentContextName;

        simulationControllerRef.current.abort();
        simulationControllerRef.current = new AbortController();
        onChatProcessingChange(true);
        setIsActuallySendingAPI(true);

        const userMessage = {
            id: `user-${Date.now()}`,
            sender: 'user',
            role: 'user',
            text: inputText.trim(),
            parts: [{ text: inputText.trim() }],
            timestamp: new Date().toISOString(),
        };

        setMessages(prev => [...prev, userMessage]);
        setBotStatusPlaceholder("🧠 Thinking...");

        runStatusSimulation(isRagActive, useWebSearch, useAcademicSearch, simulationControllerRef.current.signal);

        try {
            const response = await api.sendMessage({
                query: inputText.trim(),
                history: messages.map(m => ({
                    role: m.role === 'model' ? 'model' : 'user',
                    parts: m.parts || [{ text: m.text }]
                })),
                sessionId: currentSessionId,
                useWebSearch,
                useAcademicSearch,
                systemPrompt,
                criticalThinkingEnabled,
                documentContextName
            });

            if (response && response.reply) {
                if (isMountedRef.current) {
                    setBotStatusPlaceholder(null);
                    setMessages(prev => [...prev, { ...response.reply, id: `bot-${Date.now()}` }]);
                }
            } else {
                throw new Error("Invalid response from AI service.");
            }
        } catch (error) {
            const errorText = error.response?.data?.message || error.message || 'Failed to get response from AI.';
            const errorReply = {
                id: `error-${Date.now()}`,
                sender: 'bot',
                role: 'model',
                text: `Error: ${errorText}`,
                parts: [{ text: `Error: ${errorText}` }],
                timestamp: new Date().toISOString(),
                source_pipeline: "error-pipeline"
            };
            if (isMountedRef.current) {
                setBotStatusPlaceholder(null);
                setMessages(prev => [...prev, errorReply]);
            }
            toast.error(errorText);
        } finally {
            simulationControllerRef.current.abort();
            if (isMountedRef.current) {
                onChatProcessingChange(false);
                setIsActuallySendingAPI(false);
            }
        }
    };

    return (
        <div className="flex flex-col h-full bg-background-light dark:bg-background-dark rounded-lg shadow-inner">
            {messages.length === 0 && !isActuallySendingAPI && currentSessionId ? (
                <div className="p-6 sm:p-8 text-center text-text-muted-light dark:text-text-muted-dark animate-fadeIn">
                    <h2 className="text-xl sm:text-2xl font-semibold mb-2 text-text-light dark:text-text-dark">AI Engineering Tutor</h2>
                    <p className="text-base sm:text-lg mb-3">Session ID: {currentSessionId.substring(0, 8)}...</p>
                    <div className="text-xs sm:text-sm space-y-1">
                        <p>Current LLM: <span className="font-semibold text-accent">{selectedLLM.toUpperCase()}</span>.</p>
                        <p className="max-w-md mx-auto">
                            Assistant Mode: <span className="italic">"{systemPrompt.length > 60 ? systemPrompt.substring(0, 60) + '...' : systemPrompt}"</span>
                        </p>
                        {(selectedSubject || selectedDocumentForAnalysis) && (
                            <p className="mt-1 font-medium">
                                Chat Focus: <span className="text-indigo-500 dark:text-indigo-400">{selectedSubject || selectedDocumentForAnalysis}</span>
                            </p>
                        )}
                    </div>
                </div>
            ) : null}

            <ChatHistory messages={messages} botStatusPlaceholder={botStatusPlaceholder} />

            <ChatInput
                onSendMessage={handleSendMessage}
                isLoading={isActuallySendingAPI}
                useWebSearch={useWebSearch}
                setUseWebSearch={setUseWebSearch}
                useAcademicSearch={useAcademicSearch} 
                setUseAcademicSearch={setUseAcademicSearch}
                criticalThinkingEnabled={criticalThinkingEnabled}
                setCriticalThinkingEnabled={setCriticalThinkingEnabled}
            />
        </div>
    );
}

export default CenterPanel;

```

`src/components/layout/LeftCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/LeftCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { Edit3, UploadCloud, FileText, ChevronRight, Settings2 } from 'lucide-react'; // Settings2 for fallback
import IconButton from '../core/IconButton.jsx'; 
import { motion } from 'framer-motion';

// Mapping icon names (or IDs) to Lucide components
const iconMap = {
    prompt: Edit3,       // Icon for "Custom Prompt"
    upload: UploadCloud, // Icon for "Upload Document"
    docs: FileText,      // Icon for "Document List"
};

function LeftCollapsedNav() {
    const { setIsLeftPanelOpen } = useAppState();

    // Define the items for the collapsed navigation bar
    const navItems = [
        { 
            id: 'prompt', 
            label: 'Custom Prompt', 
            iconName: 'prompt', // Matches key in iconMap
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, also scroll to/focus the prompt section in LeftPanel
            } 
        },
        { 
            id: 'upload', 
            label: 'Upload Document', 
            iconName: 'upload', 
            action: () => { 
                setIsLeftPanelOpen(true);
                // TODO: Optionally, open LeftPanel and focus/highlight upload area
            } 
        },
        { 
            id: 'docs', 
            label: 'Document List', 
            iconName: 'docs', 
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, open LeftPanel scrolled to document list
            } 
        },
    ];

    return (
        <motion.aside
            key="left-collapsed-nav" // Unique key for AnimatePresence
            initial={{ x: '-100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '-100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            // Styling for the thin vertical bar
            className="fixed left-0 top-16 bottom-0 z-30 w-14 sm:w-16 
                       bg-surface-light dark:bg-surface-dark 
                       border-r border-border-light dark:border-border-dark 
                       shadow-lg flex flex-col items-center py-3 space-y-2 custom-scrollbar"
        >
            {/* Button to open the full LeftPanel - Placed at the top */}
            <IconButton 
                icon={ChevronRight} 
                onClick={() => setIsLeftPanelOpen(true)} 
                title="Open Assistant Panel"
                ariaLabel="Open Assistant Panel"
                variant="ghost" 
                size="lg" // Make it prominent
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />

            {/* Icons for different sections of LeftPanel */}
            {navItems.map(item => {
                const IconComponent = iconMap[item.iconName] || Settings2; // Fallback icon
                return (
                    <IconButton 
                        key={item.id}
                        icon={IconComponent}
                        onClick={item.action} // Action currently just opens the panel
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md" 
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
            {/* Add a flexible spacer if you want the open button pushed further down from items */}
            {/* <div className="flex-grow"></div> */}
        </motion.aside>
    );
}
export default LeftCollapsedNav;
```

`src/components/layout/LeftPanel.jsx`

```javascript
// frontend/src/components/layout/LeftPanel.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import DocumentUpload from '../documents/DocumentUpload.jsx';
import DocumentList from '../documents/DocumentList.jsx';
import SubjectList from '../documents/SubjectList.jsx'; // <<< NEW IMPORT
import {
    PanelLeftClose, ChevronDown, ChevronUp, FilePlus, Settings2,
    Bot, BookOpen, Lightbulb, Library, Loader2, AlertTriangle // Added AlertTriangle
} from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';
import toast from 'react-hot-toast';
import api from '../../services/api.js'; // Main API service

const PROMPT_PRESETS = [
     { id: 'friendly_tutor', name: 'Friendly Tutor', icon: Bot, text: "You are a friendly, patient, and encouraging tutor specializing in engineering and scientific topics for PhD students. Explain concepts clearly, break down complex ideas, use analogies, and offer positive reinforcement. Ask follow-up questions to ensure understanding." },
     { id: 'concept_explorer', name: 'Concept Explorer', icon: BookOpen, text: "You are an expert academic lecturer introducing a new, complex engineering or scientific concept. Your goal is to provide a deep, structured explanation. Define terms rigorously, outline the theory, provide relevant mathematical formulations (using Markdown), illustrative examples, and discuss applications or limitations pertinent to PhD-level research." },
     { id: 'knowledge_check', name: 'Knowledge Check', icon: Lightbulb, text: "You are assessing understanding of engineering/scientific topics. Ask targeted questions to test knowledge, identify misconceptions, and provide feedback on the answers. Start by asking the user what topic they want to be quizzed on." },
     { id: 'custom', name: 'Custom Prompt', icon: Settings2, text: "You are a helpful AI engineering tutor." }
];

function LeftPanel() {
    const {
        setIsLeftPanelOpen,
        systemPrompt, setSystemPrompt,
        selectDocumentForAnalysis, selectedDocumentForAnalysis,
        selectedSubject, setSelectedSubject // AppState context will handle setting this
    } = useAppState();

    const [isPromptSectionOpen, setIsPromptSectionOpen] = useState(true);
    const [isSubjectSectionOpen, setIsSubjectSectionOpen] = useState(true);
    const [isDocManagementOpen, setIsDocManagementOpen] = useState(true);

    const [selectedPresetId, setSelectedPresetId] = useState('custom');
    const [availableSubjects, setAvailableSubjects] = useState([]);      // State to hold fetched subjects
    const [isLoadingSubjects, setIsLoadingSubjects] = useState(false);   // Loading state for subjects
    const [subjectFetchError, setSubjectFetchError] = useState('');     // Error state for subjects
    const [docListKey, setDocListKey] = useState(Date.now()); // For user's own DocumentList refresh

    useEffect(() => {
        const matchedPreset = PROMPT_PRESETS.find(p => p.text === systemPrompt);
        setSelectedPresetId(matchedPreset ? matchedPreset.id : 'custom');
    }, [systemPrompt]);

    // Fetch subjects (admin document names) on component mount
    const fetchSubjects = useCallback(async () => {
        setIsLoadingSubjects(true);
        setSubjectFetchError(''); // Clear previous errors
        try {
            const response = await api.getSubjects(); // Calls /api/subjects
            // The backend returns { subjects: ["Subject 1", "Subject 2", ...] }
            const subjects = Array.isArray(response.subjects) ? response.subjects : [];
            setAvailableSubjects(subjects);
            if (subjects.length === 0) {
                // FIX: Changed toast.info to just toast() for a standard informational message.
                toast("No admin-defined subjects found to select for chat focus.");
            }
        } catch (error) {
            const errorMsg = error.response?.data?.message || error.message || "Failed to load available subjects.";
            toast.error(errorMsg);
            setSubjectFetchError(errorMsg); // Store error message for display
            console.error("Error fetching subjects:", error);
        } finally {
            setIsLoadingSubjects(false);
        }
    }, []);

    useEffect(() => {
        fetchSubjects();
    }, [fetchSubjects]);

    const handlePresetChange = (event) => {
        const presetId = event.target.value;
        setSelectedPresetId(presetId);
        const selectedPreset = PROMPT_PRESETS.find(p => p.id === presetId);
        if (selectedPreset) setSystemPrompt(selectedPreset.text);
    };

    const handleUploadSuccessForUserDocs = () => {
        setDocListKey(Date.now());
        toast.success("Your document list refreshed after upload.");
    };

    // setSelectedSubject from AppStateContext is passed directly to SubjectList's onSelectSubject prop.

    const SelectedPresetIcon = PROMPT_PRESETS.find(p => p.id === selectedPresetId)?.icon || Settings2;

    return (
        <div className="flex flex-col h-full">
            <div className="flex items-center justify-between mb-3 px-1 pt-1">
                <h2 className="text-sm font-semibold text-text-light dark:text-text-dark">Assistant Controls</h2>
                <IconButton
                    icon={PanelLeftClose}
                    onClick={() => setIsLeftPanelOpen(false)}
                    title="Close Assistant Panel"
                    variant="ghost" size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                />
            </div>

            {/* Custom Prompt Section (Existing) */}
            <div className="mb-4">
                <button onClick={() => setIsPromptSectionOpen(!isPromptSectionOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark" aria-expanded={isPromptSectionOpen}>
                    <span className="flex items-center gap-2"><SelectedPresetIcon size={16} className="text-primary dark:text-primary-light" /> Custom Prompt</span>
                    {isPromptSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isPromptSectionOpen && (
                        <motion.div key="prompt-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden">
                            <label htmlFor="prompt-preset-select" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Prompt Mode:</label>
                             <select id="prompt-preset-select" value={selectedPresetId} onChange={handlePresetChange} className="input-field mb-2 text-xs py-1.5">
                                 {PROMPT_PRESETS.map(preset => (<option key={preset.id} value={preset.id}>{preset.name}</option>))}
                             </select>
                             <label htmlFor="system-prompt-area" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">System Prompt (Editable):</label>
                             <textarea id="system-prompt-area" value={systemPrompt} onChange={(e) => { setSystemPrompt(e.target.value); setSelectedPresetId('custom'); }} rows="5" className="input-field text-xs custom-scrollbar" placeholder="Enter system prompt..."/>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* --- NEW: Select Subject Section --- */}
            <div className="mb-4">
                <button
                    onClick={() => setIsSubjectSectionOpen(!isSubjectSectionOpen)}
                    className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark"
                    aria-expanded={isSubjectSectionOpen}
                >
                    <span className="flex items-center gap-2">
                        <Library size={16} className="text-primary dark:text-primary-light" /> Select Subject Focus
                    </span>
                    {isSubjectSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isSubjectSectionOpen && (
                        <motion.div
                            key="subject-select-content"
                            initial={{ height: 0, opacity: 0 }}
                            animate={{ height: 'auto', opacity: 1 }}
                            exit={{ height: 0, opacity: 0 }}
                            transition={{ duration: 0.2, ease: "easeInOut" }}
                            className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden"
                        >
                           {/* Using the new SubjectList component */}
                           <SubjectList
                                subjects={availableSubjects}
                                selectedSubject={selectedSubject}
                                onSelectSubject={setSelectedSubject} // Pass the setter from AppStateContext
                                isLoading={isLoadingSubjects}
                                error={subjectFetchError}
                           />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* Document Management Section (For REGULAR USER's own documents) */}
            <div className="flex-grow flex flex-col overflow-hidden">
                <button onClick={() => setIsDocManagementOpen(!isDocManagementOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-2" aria-expanded={isDocManagementOpen}>
                    <span className="flex items-center gap-2"><FilePlus size={16} className="text-primary dark:text-primary-light" /> My Documents (for Analysis Tools)</span>
                    {isDocManagementOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isDocManagementOpen && (
                        <motion.div key="doc-management-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="flex-grow flex flex-col overflow-hidden p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner">
                            <DocumentUpload onUploadSuccess={handleUploadSuccessForUserDocs} />
                            <div className="mt-3 flex-grow overflow-y-auto custom-scrollbar">
                                <DocumentList
                                    key={docListKey}
                                    onSelectDocument={selectDocumentForAnalysis}
                                    selectedDocument={selectedDocumentForAnalysis}
                                />
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default LeftPanel;

```

`src/components/layout/LLMSelectionModal.jsx`

```javascript
// frontend/src/components/layout/LLMSelectionModal.jsx
import React, { useState, useEffect } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { X, Save, KeyRound, AlertCircle, HardDrive } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import LLMSelection from '../auth/LLMSelection.jsx';
import { motion } from 'framer-motion';

function LLMSelectionModal({ isOpen, onClose }) {
    const { selectedLLM: currentLLM, switchLLM: setGlobalLLMPreference } = useAppState();
    
    // State for the provider selection
    const [locallySelectedLLM, setLocallySelectedLLM] = useState(currentLLM);
    
    // Separate state for each input field
    const [geminiApiKeyInput, setGeminiApiKeyInput] = useState('');
    const [ollamaUrlInput, setOllamaUrlInput] = useState('');
    
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        // Reset state every time the modal opens
        if (isOpen) {
            setLocallySelectedLLM(currentLLM);
            setGeminiApiKeyInput(''); 
            setOllamaUrlInput(''); 
            setError('');
        }
    }, [isOpen, currentLLM]);

    const handleSavePreference = async () => {
        setLoading(true); 
        setError('');
        
        try {
            // Start with the provider selection
            const configData = { llmProvider: locallySelectedLLM };

            // Only add other fields if the user actually typed something into them
            if (geminiApiKeyInput.trim()) {
                configData.apiKey = geminiApiKeyInput.trim();
            }
            if (ollamaUrlInput.trim()) {
                configData.ollamaUrl = ollamaUrlInput.trim();
            }
            
            await api.updateUserLLMConfig(configData);
            setGlobalLLMPreference(locallySelectedLLM);
            
            toast.success(`LLM preference updated to ${locallySelectedLLM.toUpperCase()}.`);
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update preference.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2 text-sm w-full";

    return (
         <Modal isOpen={isOpen} onClose={onClose} title="Switch LLM Provider & Credentials" size="lg"
            footerContent={
                <>
                    <Button onClick={onClose} variant="secondary" size="sm" className="text-xs">Cancel</Button>
                    <Button onClick={handleSavePreference} isLoading={loading} size="sm" className="text-xs">
                        <Save size={14} className="mr-1.5"/> Save Preference
                    </Button>
                </>
            }
        >
            <div className="space-y-5"> 
                <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                    Select your preferred LLM. You can also update your credentials here. <br/><strong>Leave a field blank to keep your existing setting.</strong>
                </p>
                <LLMSelection 
                    selectedLLM={locallySelectedLLM} 
                    onLlmChange={setLocallySelectedLLM}
                    disabled={loading}
                />
                
                <motion.div key="gemini-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalGeminiApiKey" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Gemini API Key (Optional)
                    </label>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input type="password" id="modalGeminiApiKey" className={inputFieldStyledClass} placeholder="Leave blank to keep existing key" value={geminiApiKeyInput} onChange={(e) => setGeminiApiKeyInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>
                
                <motion.div key="ollama-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalOllamaUrl" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Ollama URL (Optional)
                    </label>
                     <div className={inputWrapperClass}>
                        <HardDrive className={inputIconClass} />
                        <input type="text" id="modalOllamaUrl" className={inputFieldStyledClass} placeholder="Leave blank to keep existing URL" value={ollamaUrlInput} onChange={(e) => setOllamaUrlInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>

                {error && (
                    <div className="flex items-center gap-2 p-2 text-xs text-red-700 bg-red-100 dark:bg-red-900/30 dark:text-red-300 rounded-md">
                        <AlertCircle size={16} />
                        <span>{error}</span>
                    </div>
                )}
            </div>
        </Modal>
    );
}

export default LLMSelectionModal;
```

`src/components/layout/RightCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/RightCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { HelpCircle, GitFork, Tags, ChevronLeft } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

const iconMap = {
    HelpCircle: HelpCircle,
    Tags: Tags,
    GitFork: GitFork,
};

function RightCollapsedNav() {
    const { setIsRightPanelOpen } = useAppState();

    const navItems = [
        { id: 'faq', label: 'FAQ Generator', iconName: 'HelpCircle', action: () => { setIsRightPanelOpen(true); /* TODO: set analysis type contextually */ } },
        { id: 'topics', label: 'Key Topics Extractor', iconName: 'Tags', action: () => { setIsRightPanelOpen(true); } },
        { id: 'mindmap', label: 'Mind Map Creator', iconName: 'GitFork', action: () => { setIsRightPanelOpen(true); } },
    ];

    return (
        <motion.aside
            key="right-collapsed-nav"
            initial={{ x: '100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="fixed right-0 top-16 bottom-0 z-30 w-14 sm:w-16 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark shadow-lg flex-col items-center py-3 space-y-2 hidden md:flex"
        >
            {/* Open Panel Button AT THE TOP */}
            <IconButton 
                icon={ChevronLeft} 
                onClick={() => setIsRightPanelOpen(true)} 
                title="Open Analyzer Panel"
                ariaLabel="Open Analyzer Panel"
                variant="ghost" 
                size="lg"
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />
            {navItems.map(item => {
                 const Icon = iconMap[item.iconName] || HelpCircle;
                return (
                    <IconButton 
                        key={item.id}
                        icon={Icon}
                        onClick={item.action}
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
        </motion.aside>
    );
}
export default RightCollapsedNav;
```

`src/components/layout/RightPanel.jsx`

```javascript


// frontend/src/components/layout/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import AnalysisToolRunner from '../analysis/AnalysisToolRunner.jsx';
import PodcastGenerator from '../analysis/PodcastGenerator.jsx';
import KnowledgeGraphViewer from '../analysis/KnowledgeGraphViewer.jsx';
import api from '../../services/api.js';
import { PanelRightClose, ChevronDown, ChevronUp, Telescope, Radio, BrainCircuit } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';

function RightPanel() {
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    const [isKgModalOpen, setIsKgModalOpen] = useState(false);
    const [kgData, setKgData] = useState(null);
    const [isLoadingKg, setIsLoadingKg] = useState(false);

    const currentSelectedDocFilename = selectedDocumentForAnalysis || selectedSubject || null;
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    const handleVisualizeKg = async () => {
        if (!currentSelectedDocFilename) return;
        setIsKgModalOpen(true);
        setIsLoadingKg(true);
        setKgData(null);
        try {
            const data = await api.getKnowledgeGraph(currentSelectedDocFilename);
            if(data.error) {
                toast.error(`KG Error: ${data.error}`);
                setKgData({ error: data.error });
            } else {
                setKgData(data);
            }
        } catch (error) {
            const errorMessage = error.response?.data?.error || "Could not fetch knowledge graph.";
            toast.error(errorMessage);
            setKgData({ error: errorMessage });
        } finally {
            setIsLoadingKg(false);
        }
    };

    return (
        <>
            <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
                <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                    <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                    <IconButton
                        icon={PanelRightClose}
                        onClick={() => setIsRightPanelOpen(false)}
                        title="Close Analyzer Panel"
                        variant="ghost" size="sm"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                </div>
                
                {!currentSelectedDocFilename ? (
                    <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                        <p>Select a document from the left panel to enable analysis and generation tools.</p>
                    </div>
                ) : (
                    <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-1">
                        <div>
                            <button onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark">
                                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                            </button>
                            {isAnalyzerOpen && (
                                <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 space-y-3 overflow-hidden">
                                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                </motion.div>
                            )}
                        </div>
                        <div>
                            <div className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                               <span className="flex items-center gap-2"><Radio size={16} /> Content Exporters & Synthesis</span>
                            </div>
                             <div className="mt-2 space-y-3">
                                <PodcastGenerator selectedDocumentFilename={currentSelectedDocFilename} />
                                <Button onClick={handleVisualizeKg} variant="outline" size="sm" fullWidth isLoading={isLoadingKg} leftIcon={<BrainCircuit size={16} />}>
                                    Visualize Knowledge Graph
                                </Button>
                            </div>
                        </div>
                    </div>
                )}
            </div>

            <Modal isOpen={isKgModalOpen} onClose={() => setIsKgModalOpen(false)} title={`Knowledge Graph: ${currentSelectedDocFilename}`} size="5xl">
                <KnowledgeGraphViewer graphData={isLoadingKg ? null : kgData} />
            </Modal>
        </>
    );
}
export default RightPanel;
```

`src/components/layout/TopNav.jsx`

```javascript
// frontend/src/components/layout/TopNav.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import ThemeToggle from '../common/ThemeToggle.jsx';
import LLMSelectionModal from './LLMSelectionModal.jsx';
import ProfileSettingsModal from '../profile/ProfileSettingsModal.jsx';
import { Link } from 'react-router-dom';
import { 
    LogOut, User, MessageSquare, History as HistoryIcon, Settings, Cpu, Zap, ServerCrash, Server, Wrench 
} from 'lucide-react';
import ToolsModal from '../tools/ToolsModal.jsx'; 



function TopNav({ user: authUser, onLogout, onNewChat, onHistoryClick, orchestratorStatus, isChatProcessing  }) {
    const { selectedLLM, switchLLM } = useAppState();
    const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
    const [isToolsModalOpen, setIsToolsModalOpen] = useState(false); // <<< NEW STATE

    
    const [isProfileDropdownOpen, setIsProfileDropdownOpen] = useState(false);
    const profileDropdownRef = useRef(null);

    const getStatusIndicator = () => {
        if (!orchestratorStatus) return <div title="Status unavailable" className="w-4 h-4 bg-gray-400 rounded-full"></div>;
        if (orchestratorStatus.status === "ok") {
            return <Zap size={18} className="text-green-400 animate-pulse" title={`Backend Online: ${orchestratorStatus.message}`} />;
        } else if (orchestratorStatus.status === "loading") {
            return <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-yellow-400" title="Connecting..."></div>;
        } else {
            return <ServerCrash size={18} className="text-red-400" title={`Backend Offline: ${orchestratorStatus.message}`} />;
        }
    };
    
    useEffect(() => {
        function handleClickOutside(event) {
            if (profileDropdownRef.current && !profileDropdownRef.current.contains(event.target)) {
                setIsProfileDropdownOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [profileDropdownRef]);

    return (
        <>
            <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark shadow-sm h-16 flex items-center justify-between px-2 sm:px-4">
                <div className="flex items-center gap-2">
                    <a href="/" className="flex items-center gap-1.5 sm:gap-2 text-lg sm:text-xl font-semibold text-text-light dark:text-text-dark">
                        <Server size={24} className="text-primary dark:text-primary-light" />
                        <span className="hidden sm:inline">AI Tutor</span>
                    </a>
                </div>

                <div className="flex-1 flex justify-center px-2">
                    <div className="flex items-center gap-1 sm:gap-2">
                         <button
                            onClick={onNewChat}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Start a new chat session"
                        >
                            <MessageSquare size={14} /> <span className="hidden sm:inline">New Chat</span>
                        </button>
                        
                        <button
                            onClick={onHistoryClick}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="View chat history"
                        >
                            <HistoryIcon size={14} /> <span className="hidden sm:inline">History</span>
                        </button>

                         <button
                            onClick={() => setIsToolsModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-amber-400/20 dark:bg-amber-500/20 hover:bg-amber-400/30 dark:hover:bg-amber-500/30 text-amber-700 dark:text-amber-400 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Open Tools"
                        >
                            <Wrench size={14} /> <span className="hidden sm:inline">Tools</span>
                        </button>

                        <button
                            onClick={() => setIsLLMModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
                        >
                            <Cpu size={14} /> <span className="hidden xs:inline">{selectedLLM.toUpperCase()}</span>
                        </button>
                    </div>
                </div>

                <div className="flex items-center gap-1.5 sm:gap-2">
                    {/* --- FIX: Added a fixed-size wrapper div for the status indicator --- */}
                    <div className="w-8 h-8 flex items-center justify-center">
                        {getStatusIndicator()}
                    </div>
                    <ThemeToggle />
                    <div className="relative" ref={profileDropdownRef}>
                        <button 
                            onClick={() => setIsProfileDropdownOpen(prev => !prev)}
                            className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary"
                        >
                            <User size={18} />
                        </button>
                        <div 
                            className={`absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 transition-all duration-150 ease-in-out transform origin-top-right z-50
                                ${isProfileDropdownOpen 
                                    ? 'opacity-100 scale-100 visible' 
                                    : 'opacity-0 scale-95 invisible'
                                }`
                            }
                        >
                            <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-border-light dark:border-border-dark">
                                Signed in as <br/><strong>{authUser?.username || 'User'}</strong>
                            </div>
                            <button
                                onClick={() => { setIsProfileModalOpen(true); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
                            >
                                <Settings size={16} /> Profile
                            </button>
                            <button
                                onClick={() => { onLogout(); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
                            >
                                <LogOut size={16} /> Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
            <LLMSelectionModal 
                isOpen={isLLMModalOpen} 
                onClose={() => setIsLLMModalOpen(false)} 
                currentLLM={selectedLLM}
                onSelectLLM={(llm) => {
                    switchLLM(llm);
                    setIsLLMModalOpen(false);
                }}
            />
            <ProfileSettingsModal
                isOpen={isProfileModalOpen}
                onClose={() => setIsProfileModalOpen(false)}
            />
        </>
    );
}
export default TopNav;
```

`src/components/profile/ProfileSettingsModal.jsx`

```javascript
// frontend/src/components/profile/ProfileSettingsModal.jsx
import React, { useState, useEffect } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { Save, User, School, Hash, Award, Wrench, Calendar } from 'lucide-react';

const ProfileSettingsModal = ({ isOpen, onClose }) => {
    const [profile, setProfile] = useState({
        name: '',
        college: '',
        universityNumber: '',
        degreeType: '',
        branch: '',
        year: ''
    });
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        if (isOpen) {
            const fetchProfile = async () => {
                setIsLoading(true);
                setError('');
                try {
                    const data = await api.getUserProfile();
                    // Set profile data, ensuring defaults for any missing fields
                    setProfile({
                        name: data.name || '',
                        college: data.college || '',
                        universityNumber: data.universityNumber || '',
                        degreeType: data.degreeType || 'Bachelors', // Default value
                        branch: data.branch || 'Computer Science', // Default value
                        year: data.year || '1st Year' // Default value
                    });
                } catch (err) {
                    toast.error('Failed to load profile data.');
                    setError(err.message || 'Could not fetch profile.');
                } finally {
                    setIsLoading(false);
                }
            };
            fetchProfile();
        }
    }, [isOpen]);

    const handleChange = (e) => {
        const { name, value } = e.target;
        setProfile(prev => ({ ...prev, [name]: value }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        // Simple validation
        for (const key in profile) {
            if (!profile[key] || profile[key].trim() === '') {
                toast.error(`Please fill out the '${key.replace(/([A-Z])/g, ' $1').trim()}' field.`);
                return;
            }
        }
        setIsLoading(true);
        setError('');
        try {
            const response = await api.updateUserProfile(profile);
            toast.success(response.message || 'Profile updated successfully!');
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update profile.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark pointer-events-none";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm";
    const selectFieldStyledClass = "input-field !pl-10 !pr-8 py-2.5 text-sm";

    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title="Student Profile Settings"
            size="lg"
            footerContent={
                <>
                    <Button variant="ghost" onClick={onClose} disabled={isLoading}>Cancel</Button>
                    <Button onClick={handleSubmit} isLoading={isLoading} leftIcon={<Save size={16} />}>
                        Save Changes
                    </Button>
                </>
            }
        >
            <form onSubmit={handleSubmit} className="space-y-4">
                {error && <p className="text-sm text-red-500">{error}</p>}
                
                <div className={inputWrapperClass}>
                    <User className={inputIconClass} />
                    <input type="text" name="name" value={profile.name} onChange={handleChange} placeholder="Full Name" className={inputFieldStyledClass} required />
                </div>

                <div className={inputWrapperClass}>
                    <School className={inputIconClass} />
                    <input type="text" name="college" value={profile.college} onChange={handleChange} placeholder="College / Institution" className={inputFieldStyledClass} required />
                </div>
                
                <div className={inputWrapperClass}>
                    <Hash className={inputIconClass} />
                    <input type="text" name="universityNumber" value={profile.universityNumber} onChange={handleChange} placeholder="Registered University Number" className={inputFieldStyledClass} required />
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className={inputWrapperClass}>
                        <Award className={inputIconClass} />
                        <select name="degreeType" value={profile.degreeType} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="Bachelors">Bachelor's</option>
                            <option value="Masters">Master's</option>
                            <option value="PhD">PhD</option>
                            <option value="Diploma">Diploma</option>
                        </select>
                    </div>
                    
                    <div className={inputWrapperClass}>
                        <Wrench className={inputIconClass} />
                        <select name="branch" value={profile.branch} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="Computer Science">Computer Science</option>
                            <option value="Mechanical Engineering">Mechanical</option>
                            <option value="Electrical Engineering">Electrical</option>
                            <option value="Civil Engineering">Civil</option>
                            <option value="Electronics & Communication">Electronics & Comm.</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>

                    <div className={inputWrapperClass}>
                        <Calendar className={inputIconClass} />
                        <select name="year" value={profile.year} onChange={handleChange} className={selectFieldStyledClass} required>
                            <option value="1st Year">1st Year</option>
                            <option value="2nd Year">2nd Year</option>
                            <option value="3rd Year">3rd Year</option>
                            <option value="4th Year">4th Year</option>
                            <option value="Final Year">Final Year</option>
                            <option value="Graduated">Graduated</option>
                        </select>
                    </div>
                </div>
            </form>
        </Modal>
    );
};

export default ProfileSettingsModal;
```

`src/components/tools/AIAssistantBot.jsx`

```javascript
// frontend/src/components/tools/AIAssistantBot.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle, Sparkles, X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import IconButton from '../core/IconButton';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantBot = ({ code, language }) => {
    const [isOpen, setIsOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [analysis, setAnalysis] = useState('');
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (isOpen && analysis && contentRef.current) {
            const timer = setTimeout(() => Prism.highlightAllUnder(contentRef.current), 50);
            return () => clearTimeout(timer);
        }
    }, [isOpen, analysis]);
    
    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <>
            <div className="fixed bottom-6 right-6 z-50">
                <motion.button
                    whileHover={{ scale: 1.1, backgroundColor: "var(--color-primary-dark)" }}
                    whileTap={{ scale: 0.9 }}
                    onClick={() => setIsOpen(true)}
                    title="AI Assistant"
                    className="bg-primary text-white rounded-full p-4 shadow-lg flex items-center justify-center"
                    style={{'--color-primary-dark': '#2563eb'}} // For tailwind color access in motion
                >
                    <Bot size={28} />
                </motion.button>
            </div>

            <AnimatePresence>
                {isOpen && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4"
                        onClick={() => setIsOpen(false)}
                    >
                        <motion.div
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            onClick={(e) => e.stopPropagation()}
                            className="bg-surface-light dark:bg-surface-dark w-full max-w-2xl h-[70vh] rounded-lg shadow-2xl flex flex-col"
                        >
                            <header className="flex items-center justify-between p-4 border-b border-border-light dark:border-border-dark">
                                <h3 className="font-semibold flex items-center gap-2 text-text-light dark:text-text-dark">
                                    <Sparkles className="text-primary"/> AI Assistant
                                </h3>
                                <IconButton icon={X} onClick={() => setIsOpen(false)} title="Close" />
                            </header>

                            <div className="p-4 flex-shrink-0">
                                <Button onClick={handleAnalyze} size="sm" variant="primary" isLoading={isLoading} disabled={!code.trim()}>
                                    Analyze Current Code
                                </Button>
                            </div>
                            
                            <div className="flex-grow p-4 border-t border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                                {isLoading && (
                                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                                    </div>
                                )}
                                {error && !isLoading && (
                                    <div className="p-3 text-red-400 text-sm"><AlertTriangle className="inline mr-2" />{error}</div>
                                )}
                                {!isLoading && !error && !analysis && (
                                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                                        Click "Analyze Code" to get an AI-powered review.
                                    </div>
                                )}
                                {analysis && !isLoading && (
                                    <div 
                                        ref={contentRef}
                                        className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark"
                                        dangerouslySetInnerHTML={createMarkup(analysis)}
                                    />
                                )}
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

export default AIAssistantBot;
```

`src/components/tools/AIAssistantPanel.jsx`

```javascript
// frontend/src/components/tools/AIAssistantPanel.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle } from 'lucide-react';
import Button from '../core/Button.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantPanel = ({ code, language }) => {
    const [analysis, setAnalysis] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (analysis && contentRef.current) {
            const timer = setTimeout(() => {
                Prism.highlightAllUnder(contentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [analysis]);

    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="p-4 h-full flex flex-col bg-surface-light dark:bg-surface-dark">
            <h3 className="text-lg font-semibold mb-2 flex items-center justify-between">
                <span className="flex items-center gap-2">
                    <Bot className="text-primary"/> AI Assistant
                </span>
                <Button onClick={handleAnalyze} size="sm" variant="outline" isLoading={isLoading} disabled={!code.trim()}>
                    Analyze Code
                </Button>
            </h3>
            <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 rounded-md p-1 border border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                {isLoading && (
                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                    </div>
                )}
                {error && !isLoading && (
                    <div className="p-3 text-red-400 text-sm">
                        <AlertTriangle className="inline mr-2" /> {error}
                    </div>
                )}
                {!isLoading && !error && !analysis && (
                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                        Click "Analyze Code" to get an AI-powered review of your code.
                    </div>
                )}
                {analysis && !isLoading && (
                    <div 
                        ref={contentRef}
                        className="prose prose-sm dark:prose-invert max-w-none p-3 text-text-light dark:text-text-dark"
                        dangerouslySetInnerHTML={createMarkup(analysis)}
                    />
                )}
            </div>
        </div>
    );
};

export default AIAssistantPanel;
```

`src/components/tools/CodeEditor.jsx`

```javascript
// frontend/src/components/tools/CodeEditor.jsx
import React from 'react';
import Editor from '@monaco-editor/react';
import { useTheme } from '../../hooks/useTheme';
import { Loader2 } from 'lucide-react';

const CodeEditor = ({ code, setCode, language }) => {
    const { theme } = useTheme();

    const handleEditorChange = (value) => {
        setCode(value || '');
    };

    return (
        <div className="h-full w-full border border-border-light dark:border-border-dark rounded-lg overflow-hidden shadow-inner">
            <Editor
                height="100%"
                language={language}
                value={code}
                onChange={handleEditorChange}
                theme={theme === 'dark' ? 'vs-dark' : 'light'}
                loading={<Loader2 className="animate-spin text-primary" />}
                options={{
                    fontSize: 14,
                    minimap: { enabled: true },
                    contextmenu: true,
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    automaticLayout: true,
                }}
            />
        </div>
    );
};

export default CodeEditor;
```

`src/components/tools/CodeEditorWrapper.jsx`

```javascript
// frontend/src/components/tools/CodeEditorWrapper.jsx
import React, { useState } from 'react';
import { Play, Copy, ChevronDown, Check } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '../core/Button';
import IconButton from '../core/IconButton';
import CodeEditor from './CodeEditor';
import toast from 'react-hot-toast';

const CodeEditorWrapper = ({ code, setCode, language, setLanguage, onExecute, isExecuting }) => {
    
    const [copied, setCopied] = useState(false);

    const handleCopy = () => {
        navigator.clipboard.writeText(code).then(() => {
            toast.success("Code copied to clipboard!");
            setCopied(true);
            setTimeout(() => setCopied(false), 2000); // Reset after 2 seconds
        }, () => {
            toast.error("Failed to copy code.");
        });
    };
    
    return (
        <div className="flex flex-col h-full bg-surface-light dark:bg-surface-dark rounded-lg border border-border-light dark:border-border-dark">
            <header className="flex items-center justify-between p-2 border-b border-border-light dark:border-border-dark flex-shrink-0">
                <div className="relative">
                    <select 
                        value={language}
                        onChange={(e) => setLanguage(e.target.value)}
                        className="input-field !text-xs !py-1 !pl-3 !pr-8 appearance-none"
                    >
                        <option value="python">Python</option>
                        <option value="java">Java</option>
                        <option value="c">C</option>
                        <option value="cpp">C++</option>
                    </select>
                    <ChevronDown size={14} className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
                <div className="flex items-center gap-2">
                    <IconButton 
                        icon={() => (
                            <AnimatePresence mode="wait" initial={false}>
                                <motion.span
                                    key={copied ? 'check' : 'copy'}
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.8 }}
                                    transition={{ duration: 0.15 }}
                                >
                                    {copied ? <Check className="text-green-500" /> : <Copy />}
                                </motion.span>
                            </AnimatePresence>
                        )} 
                        size="sm" 
                        onClick={handleCopy} 
                        title="Copy Code" 
                    />
                    <Button onClick={onExecute} size="sm" leftIcon={<Play size={14}/>} isLoading={isExecuting}>
                        Run
                    </Button>
                </div>
            </header>
            <div className="flex-grow overflow-hidden">
                <CodeEditor code={code} setCode={setCode} language={language} />
            </div>
        </div>
    );
};

export default CodeEditorWrapper;
```

`src/components/tools/CodeExecutorPage.jsx`

```javascript
// frontend/src/components/tools/CodeExecutorPage.jsx
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { Home } from 'lucide-react';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
import CodeEditorWrapper from './CodeEditorWrapper';
import TestCaseManager from './TestCaseManager';
import OutputDisplay from './OutputDisplay';
import AIAssistantBot from './AIAssistantBot';
import api from '../../services/api';
import toast from 'react-hot-toast';

const starterCode = {
    python: `# Welcome to the Code Executor!\n# Write your Python code here.\n\ndef main():\n    # Example: Read two numbers and print their sum\n    try:\n        line1 = input()\n        line2 = input()\n        print(int(line1) + int(line2))\n    except (ValueError, EOFError):\n        print("Invalid input.")\n\nif __name__ == "__main__":\n    main()\n`,
    java: `// Welcome to the Code Executor!\n// Your public class must be named "Main".\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        System.out.println(a + b);\n        sc.close();\n    }\n}\n`,
    c: `// Welcome to the Code Executor!\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    if (scanf("%d %d", &a, &b) == 2) {\n        printf("%d\\n", a + b);\n    }\n    return 0;\n}\n`,
    cpp: `// Welcome to the Code Executor!\n#include <iostream>\n\nint main() {\n    int a, b;\n    if (std::cin >> a >> b) {\n        std::cout << a + b << std::endl;\n    }\n    return 0;\n}\n`
};

const CodeExecutorPage = () => {
    const [language, setLanguage] = useState('python');
    const [code, setCode] = useState(starterCode.python);
    const [testCases, setTestCases] = useState([
        { input: '5\n10', expectedOutput: '15' }
    ]);
    const [results, setResults] = useState([]);
    const [compilationError, setCompilationError] = useState(null);
    const [isExecuting, setIsExecuting] = useState(false);

    const handleLanguageChange = (newLanguage) => {
        setLanguage(newLanguage);
        setCode(starterCode[newLanguage] || '');
    };

    const handleExecute = async () => {
        setIsExecuting(true);
        setResults([]);
        setCompilationError(null);
        const toastId = toast.loading('Executing code...');

        try {
            const response = await api.executeCode({ language, code, testCases });
            
            if (response.compilationError) {
                setCompilationError(response.compilationError);
                toast.error("Code failed to compile.", { id: toastId });
            } else {
                setResults(response.results);
                const failures = response.results.filter(r => r.status !== 'pass').length;
                if (failures > 0) {
                    toast.error(`${failures} test case(s) failed or had errors.`, { id: toastId });
                } else {
                    toast.success('All test cases passed!', { id: toastId });
                }
            }

        } catch (error) {
            const errorMessage = error.response?.data?.message || "An unknown error occurred.";
            setCompilationError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsExecuting(false);
        }
    };

    return (
        <div className="flex flex-col h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark font-sans">
            <header className="flex-shrink-0 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark h-16 flex items-center justify-between px-6 z-10">
                <h1 className="text-xl font-bold">Secure Code Executor</h1>
                <Link to="/" className="flex items-center gap-2 text-sm btn btn-ghost">
                    <Home size={16}/>
                    Back to Main App
                </Link>
            </header>

            <div className="flex-1 overflow-hidden">
                <PanelGroup direction="horizontal">
                    <Panel defaultSize={65} minSize={30}>
                        <PanelGroup direction="vertical">
                            <Panel defaultSize={60} minSize={20}>
                                <div className="p-1 md:p-2 h-full">
                                    <CodeEditorWrapper
                                        code={code} setCode={setCode}
                                        language={language} setLanguage={handleLanguageChange}
                                        onExecute={handleExecute} isExecuting={isExecuting}
                                    />
                                </div>
                            </Panel>
                            <PanelResizeHandle className="h-2 panel-resize-handle" />
                            <Panel defaultSize={40} minSize={20}>
                                <OutputDisplay
                                    results={results}
                                    compilationError={compilationError}
                                    code={code}
                                    language={language}
                                />
                            </Panel>
                        </PanelGroup>
                    </Panel>
                    <PanelResizeHandle className="w-2 panel-resize-handle" />
                    <Panel defaultSize={35} minSize={25}>
                         <TestCaseManager 
                            testCases={testCases} 
                            setTestCases={setTestCases}
                            code={code}
                            language={language}
                        />
                    </Panel>
                </PanelGroup>
            </div>
            
            <AIAssistantBot code={code} language={language} />
        </div>
    );
};

export default CodeExecutorPage;
```

`src/components/tools/OutputDisplay.jsx`

```javascript
// frontend/src/components/tools/OutputDisplay.jsx
import React, { useState } from 'react';
import { CheckCircle, XCircle, AlertTriangle, Clock, Sparkles, Loader2 } from 'lucide-react';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};


const OutputDisplay = ({ results, compilationError, code, language }) => {
    const [explanations, setExplanations] = useState({});
    const [isLoadingExplanation, setIsLoadingExplanation] = useState(null); // Tracks index

    const handleExplainError = async (index, errorMessage) => {
        setIsLoadingExplanation(index);
        try {
            const response = await api.explainError({ code, language, errorMessage });
            setExplanations(prev => ({ ...prev, [index]: response.explanation }));
        } catch (err) {
            toast.error(err.response?.data?.message || "Failed to get explanation.");
        } finally {
            setIsLoadingExplanation(null);
        }
    };

    if (compilationError) {
        return (
            <div className="p-4 bg-red-900/10 text-red-400 border-t border-red-500/30 h-full flex flex-col">
                <h3 className="text-lg font-semibold mb-2 flex items-center gap-2"><AlertTriangle /> Compilation Error</h3>
                <pre className="flex-grow bg-red-900/20 p-4 rounded-md text-xs whitespace-pre-wrap font-mono overflow-auto custom-scrollbar">{compilationError}</pre>
            </div>
        );
    }
    
    if (!results || results.length === 0) {
        return (
            <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark border-t border-border-light dark:border-border-dark h-full flex items-center justify-center">
                <p>Run the code to see the output and test case results here.</p>
            </div>
        );
    }

    const getStatusIcon = (status) => {
        if (status === 'pass') return <CheckCircle className="text-green-500" />;
        if (status === 'fail') return <XCircle className="text-yellow-500" />;
        return <AlertTriangle className="text-red-500" />;
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark border-t border-border-light dark:border-border-dark h-full flex flex-col">
            <h3 className="text-lg font-semibold mb-3 flex-shrink-0">Execution Results</h3>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {results.map((res, index) => (
                    <div key={index} className="p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex justify-between items-center mb-2">
                            <h4 className="font-semibold flex items-center gap-2">
                                {getStatusIcon(res.status)}
                                Test Case #{index + 1}: <span className="uppercase">{res.status}</span>
                            </h4>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-xs">
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Input:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.input || '(empty)'}</pre>
                            </div>
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Expected Output:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.expected || '(empty)'}</pre>
                            </div>
                            <div className="md:col-span-2">
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Actual Output:</strong>
                                <pre className={`p-2 rounded whitespace-pre-wrap font-mono ${res.status === 'pass' ? 'bg-green-900/20' : 'bg-yellow-900/20'}`}>{res.output || '(empty)'}</pre>
                            </div>
                            {res.error && (
                                <div className="md:col-span-2">
                                    <div className="flex justify-between items-center">
                                        <strong className="block mb-1 text-red-500 dark:text-red-400">Error:</strong>
                                        {!explanations[index] && (
                                            <Button size="sm" variant="ghost" className="!text-xs" leftIcon={<Sparkles size={12}/>} onClick={() => handleExplainError(index, res.error)} isLoading={isLoadingExplanation === index}>
                                                Explain Error
                                            </Button>
                                        )}
                                    </div>
                                    <pre className="bg-red-900/20 p-2 rounded text-red-400 whitespace-pre-wrap font-mono">{res.error}</pre>
                                </div>
                            )}
                            {isLoadingExplanation === index && (
                                <div className="md:col-span-2 p-3 text-sm text-center text-text-muted-light dark:text-text-muted-dark"><Loader2 className="animate-spin inline mr-2"/>AI is explaining the error...</div>
                            )}
                            {explanations[index] && (
                                <div className="md:col-span-2 mt-2 p-3 bg-primary/10 rounded-md border border-primary/30">
                                    <h5 className="font-bold text-sm mb-1 text-primary dark:text-primary-light flex items-center gap-1.5"><Sparkles size={14}/> AI Explanation</h5>
                                    <div className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark" dangerouslySetInnerHTML={createMarkup(explanations[index])} />
                                </div>
                            )}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default OutputDisplay;
```

`src/components/tools/TestCaseManager.jsx`

```javascript
// frontend/src/components/tools/TestCaseManager.jsx
import React, { useState } from 'react';
import { Plus, Trash2, Sparkles } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';

const TestCaseManager = ({ testCases, setTestCases, code, language }) => {
    const [isGenerating, setIsGenerating] = useState(false);

    const addTestCase = () => {
        const lastTestCase = testCases[testCases.length - 1];
        if (testCases.length > 0 && lastTestCase.input.trim() === '' && lastTestCase.expectedOutput.trim() === '') {
            toast.error('Please fill out the current empty test case first.');
            return;
        }
        setTestCases([...testCases, { input: '', expectedOutput: '' }]);
    };

    const removeTestCase = (index) => {
        const newTestCases = testCases.filter((_, i) => i !== index);
        setTestCases(newTestCases);
    };

    const updateTestCase = (index, field, value) => {
        const newTestCases = [...testCases];
        newTestCases[index][field] = value;
        setTestCases(newTestCases);
    };

    const handleGenerateCases = async () => {
        if (!code.trim()) {
            toast.error("There is no code to generate test cases for.");
            return;
        }
        setIsGenerating(true);
        const toastId = toast.loading("AI is generating test cases...");
        try {
            const response = await api.generateTestCases({ code, language });
            if (response.testCases && Array.isArray(response.testCases) && response.testCases.length > 0) {
                setTestCases(response.testCases);
                toast.success('AI generated a new set of test cases!', { id: toastId });
            } else {
                toast.error("The AI could not generate valid test cases.", { id: toastId });
            }
        } catch (err) {
             const errorMessage = err.response?.data?.message || "Failed to generate test cases.";
             toast.error(errorMessage, { id: toastId });
        } finally {
            setIsGenerating(false);
        }
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark h-full flex flex-col">
            <div className="flex items-center justify-between mb-3 flex-shrink-0">
                <h3 className="text-lg font-semibold">Test Cases</h3>
                <div className="flex items-center gap-2">
                    <Button onClick={addTestCase} size="sm" variant="outline" leftIcon={<Plus size={14}/>}>
                        Add Case
                    </Button>
                    <Button onClick={handleGenerateCases} size="sm" variant="outline" leftIcon={<Sparkles size={14} />} isLoading={isGenerating} disabled={!code.trim()}>
                            Generate by AI
                    </Button>
                </div>
            </div>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {testCases.map((tc, index) => (
                    <div key={index} className="flex flex-col md:flex-row gap-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Input (stdin)</label>
                            <textarea
                                value={tc.input}
                                onChange={(e) => updateTestCase(index, 'input', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter input, separate lines with \n"
                            />
                        </div>
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Expected Output (stdout)</label>
                            <textarea
                                value={tc.expectedOutput}
                                onChange={(e) => updateTestCase(index, 'expectedOutput', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter expected exact output"
                            />
                        </div>
                        <div className="flex items-end">
                            <IconButton icon={Trash2} variant="danger" size="sm" onClick={() => removeTestCase(index)} title="Remove Test Case" />
                        </div>
                    </div>
                ))}
                {testCases.length === 0 && (
                    <div className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-8">
                        Add a test case to begin.
                    </div>
                )}
            </div>
        </div>
    );
};

export default TestCaseManager;
```

`src/components/tools/ToolsModal.jsx`

```javascript
// frontend/src/components/tools/ToolsModal.jsx
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import Modal from '../core/Modal';
import { Code, TestTubeDiagonal } from 'lucide-react'; // Add more icons as you add tools
const availableTools = [
    {
    title: 'Secure Code Executor',
    description: 'Write, compile, and run code in a sandboxed environment with AI assistance.',
    icon: Code,
    path: '/tools/code-executor',
    status: 'active'
    },
    {
    title: 'API Endpoint Tester',
    description: 'A tool for testing and validating API endpoints will be available soon.',
    icon: TestTubeDiagonal,
    path: '#',
    status: 'soon'
    },
// Add more tools here in the future
];
const ToolsModal = ({ isOpen, onClose }) => {
    const navigate = useNavigate();
    const handleNavigate = (path) => {
        if (path !== '#') {
            onClose();
            navigate(path);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Developer Tools" size="2xl">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {availableTools.map((tool) => (
                    <div
                        key={tool.title}
                        onClick={() => handleNavigate(tool.path)}
                        className={`p-4 border rounded-lg transition-all duration-150 group relative
                            ${tool.status === 'active' 
                                ? 'cursor-pointer hover:border-primary dark:hover:border-primary-light hover:shadow-lg' 
                                : 'opacity-50 cursor-not-allowed'
                            }
                            bg-surface-light dark:bg-gray-800 border-border-light dark:border-border-dark
                        `}
                    >
                        {tool.status === 'soon' && (
                            <span className="absolute top-2 right-2 text-xs bg-yellow-400/20 text-yellow-500 font-semibold px-2 py-0.5 rounded-full">
                                Coming Soon
                            </span>
                        )}
                        <div className="flex items-center mb-2">
                            <tool.icon size={22} className="mr-3 text-primary dark:text-primary-light" />
                            <h3 className="font-semibold text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light">
                                {tool.title}
                            </h3>
                        </div>
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                            {tool.description}
                        </p>
                    </div>
                ))}
            </div>
        </Modal>
    );
};


export default ToolsModal;
```

`src/contexts/AppStateContext.jsx`

```javascript
import React, { createContext, useState, useContext, useEffect } from 'react';

export const AppStateContext = createContext(null);

export const useAppState = () => {
    const context = useContext(AppStateContext);
    if (!context) throw new Error('useAppState must be used within an AppStateProvider');
    return context;
};

const defaultSystemPromptText = "You are a helpful AI engineering tutor.";

export const AppStateProvider = ({ children }) => {
    const [theme, setThemeState] = useState(() => {
        const storedTheme = localStorage.getItem('theme') || 'dark';
        if (typeof window !== 'undefined') {
            document.documentElement.classList.remove('light', 'dark');
            document.documentElement.classList.add(storedTheme);
        }
        return storedTheme;
    });

    const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'gemini');
    const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
    const [isRightPanelOpen, setIsRightPanelOpen] = useState(true);

    const [currentSessionId, setCurrentSessionIdState] = useState(() => {
        return localStorage.getItem('aiTutorSessionId') || null;
    });
    const [systemPrompt, setSystemPromptState] = useState(
        localStorage.getItem('aiTutorSystemPrompt') || defaultSystemPromptText
    );

    const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null);
    const [selectedSubject, setSelectedSubjectState] = useState(
        localStorage.getItem('aiTutorSelectedSubject') || null
    );

    const [isAdminSessionActive, setIsAdminSessionActiveState] = useState(() => {
        return sessionStorage.getItem('isAdminSessionActive') === 'true';
    });

    const toggleTheme = () => {
        setThemeState(prevTheme => {
            const newTheme = prevTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            return newTheme;
        });
    };

    const switchLLM = (llm) => {
         setSelectedLLM(llm);
         localStorage.setItem('selectedLLM', llm);
         console.log("AppStateContext: Switched LLM to:", llm);
    };

    const setSessionId = (sessionId) => {
        if (sessionId) {
            localStorage.setItem('aiTutorSessionId', sessionId);
        } else {
            console.log("AppStateContext: Clearing session and related context (logout).");
            localStorage.removeItem('aiTutorSessionId');
            
            localStorage.removeItem('aiTutorSelectedSubject'); 
            setSelectedSubjectState(null);
            
            setSelectedDocumentForAnalysisState(null);
        }
        setCurrentSessionIdState(sessionId);
        console.log("AppStateContext: Regular user session ID updated to:", sessionId);
    };

    const setSystemPrompt = (promptText) => {
        setSystemPromptState(promptText);
        localStorage.setItem('aiTutorSystemPrompt', promptText);
    };

    const selectDocumentForAnalysis = (documentFilename) => {
        setSelectedDocumentForAnalysisState(documentFilename);
        console.log("AppStateContext: Document for analysis tools set to:", documentFilename || "None");
        if (documentFilename && selectedSubject !== documentFilename) {
            if (selectedSubject !== null) {
                console.log("AppStateContext: Clearing selected subject because a specific user document was chosen for analysis tools.");
                setSelectedSubjectState(null);
                localStorage.removeItem('aiTutorSelectedSubject');
            }
        }
    };

    const setSelectedSubject = (subjectName) => {
        const newSubject = subjectName === "none" || !subjectName ? null : subjectName;
        if (newSubject) {
            localStorage.setItem('aiTutorSelectedSubject', newSubject);
        } else {
            localStorage.removeItem('aiTutorSelectedSubject');
        }
        setSelectedSubjectState(newSubject);
        console.log("AppStateContext: Selected subject (for chat RAG) updated to:", newSubject || "None");

        setSelectedDocumentForAnalysisState(newSubject);
        if (newSubject) {
             console.log("AppStateContext: Also set document for analysis tools to (admin subject):", newSubject);
        } else {
            if (selectedDocumentForAnalysis === subjectName) {
                 setSelectedDocumentForAnalysisState(null);
                 console.log("AppStateContext: Cleared document for analysis tools as linked subject was cleared.");
            }
        }
    };

    const setIsAdminSessionActive = (isActive) => {
        if (isActive) {
            sessionStorage.setItem('isAdminSessionActive', 'true');
            setSessionId(null); 
        } else {
            sessionStorage.removeItem('isAdminSessionActive');
        }
        setIsAdminSessionActiveState(isActive);
        console.log("AppStateContext: Admin session active status set to:", isActive);
    };

    useEffect(() => {
        const rootHtmlElement = document.documentElement;
        rootHtmlElement.classList.remove('light', 'dark');
        rootHtmlElement.classList.add(theme);
        document.body.className = '';
        document.body.classList.add(theme === 'dark' ? 'bg-background-dark' : 'bg-background-light');
    }, [theme]);

    return (
        <AppStateContext.Provider value={{
            theme, toggleTheme,
            selectedLLM, switchLLM,
            isLeftPanelOpen, setIsLeftPanelOpen,
            isRightPanelOpen, setIsRightPanelOpen,
            currentSessionId, setSessionId,
            systemPrompt, setSystemPrompt,
            selectedDocumentForAnalysis, selectDocumentForAnalysis,
            selectedSubject, setSelectedSubject,
            isAdminSessionActive, setIsAdminSessionActive
        }}>
            {children}
        </AppStateContext.Provider>
    );
};
```

`src/contexts/AuthContext.jsx`

```javascript
// frontend/src/contexts/AuthContext.jsx
import React, { createContext, useState, useEffect, useCallback } from 'react';
import api from '../services/api.js'; 
import toast from 'react-hot-toast';

export const AuthContext = createContext(null);

export const DEV_MODE_ALLOW_DEV_LOGIN = false;

export const AuthProvider = ({ children }) => {
    const [token, setTokenState] = useState(localStorage.getItem('authToken'));
    const [user, setUserState] = useState(null);
    const [loading, setLoading] = useState(true);

    const setToken = (newToken) => {
        if (newToken) localStorage.setItem('authToken', newToken);
        else localStorage.removeItem('authToken');
        setTokenState(newToken);
    };

    const setUser = (newUser) => setUserState(newUser);
    
    const processAuthData = useCallback((authApiResponse) => {
        if (authApiResponse && authApiResponse.token && authApiResponse._id && authApiResponse.email) {
            setToken(authApiResponse.token);
            setUser({ id: authApiResponse._id, email: authApiResponse.email, username: authApiResponse.username });
             console.log("AuthContext: User and Token set.", { email: authApiResponse.email, username: authApiResponse.username });
            return authApiResponse; 
        } else {
            setToken(null);
            setUser(null);
            console.error("AuthContext: processAuthData received incomplete data for a regular user.", authApiResponse);
            throw new Error("Authentication response from server was incomplete for a regular user.");
        }
    }, []);

    useEffect(() => {
        const verifyTokenAndLoadUser = async () => {
            const storedToken = localStorage.getItem('authToken');
            if (storedToken) {
                setTokenState(storedToken);
                try {
                    const userDataFromMe = await api.getMe();
                    if (userDataFromMe && userDataFromMe._id && userDataFromMe.email) {
                        setUser({ id: userDataFromMe._id, email: userDataFromMe.email, username: userDataFromMe.username });
                    } else {
                        setToken(null);
                        setUser(null);
                    }
                } catch (error) {
                    setToken(null);
                    setUser(null);
                }
            }
            setLoading(false);
        };
        verifyTokenAndLoadUser();
    }, []);

    const login = async (credentials) => {
        setLoading(true);
        try {
            const data = await api.login(credentials);
            if (data && data.isAdminLogin) {
                return data;
            }
            return processAuthData(data);
        } catch (error) {
            setToken(null); 
            setUser(null);
            throw error; 
        } finally {
            setLoading(false);
        }
    };
    
    const signup = async (signupData) => {
        setLoading(true);
        try {
            const data = await api.signup(signupData);
            return processAuthData(data); 
        } catch (error) {
            setToken(null);
            setUser(null);
            throw error;
        } finally {
            setLoading(false);
        }
    };

    const logout = () => {
        console.log("AuthContext: Logging out user.");
        setToken(null); 
        setUser(null);
        toast.success("You have been logged out.");
    };

    return (
        <AuthContext.Provider value={{ token, user, loading, login, signup, logout, setUser }}>
            {children}
        </AuthContext.Provider>
    );
};
```

`src/hooks/useAuth.jsx`

```javascript
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
```

`src/hooks/useTextToSpeech.js`

```javascript
// src/hooks/useTextToSpeech.js
import { useState, useEffect, useCallback, useRef } from 'react';
import { marked } from 'marked'; // To parse markdown for plain text

// Configure marked (if not already globally configured for this specific use)
// It's generally better if marked is configured once, e.g. in MessageBubble or a central place.
// Assuming marked is available and configured.

const getPlainTextFromMarkdown = (markdown) => {
  if (!markdown) return '';
  try {
    // A simpler approach for plain text extraction for TTS:
    // Render to a temporary element and get its text content.
    // This handles complex markdown structures reasonably well for speech.
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = marked.parse(markdown); // marked.parse() is synchronous
    let text = tempDiv.textContent || tempDiv.innerText || '';
    
    // Basic cleanup: remove excessive newlines/spaces that might make speech awkward
    text = text.replace(/\n+/g, ' '); // Replace newlines with spaces
    text = text.replace(/\s\s+/g, ' '); // Replace multiple spaces with single
    return text.trim();
  } catch (error) {
    console.error("Error parsing markdown for TTS:", error);
    return markdown; // Fallback to raw markdown if parsing fails
  }
};


export const useTextToSpeech = () => {
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isSupported, setIsSupported] = useState(false);
    const utteranceRef = useRef(null);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.speechSynthesis) {
            setIsSupported(true);
        }

        const handleEnd = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        
        const synth = window.speechSynthesis;
        if (synth) {
            // Add event listeners if needed, but onend on utterance is usually sufficient
        }

        return () => {
            if (synth) {
                synth.cancel(); // Cancel any speech on component unmount or hook cleanup
            }
        };
    }, []);

    const speak = useCallback(({ text, lang = 'en-US', voiceURI = null, rate = 1, pitch = 1, volume = 1 }) => {
        if (!isSupported || !text) return;

        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel(); // Stop any currently playing speech
        }
        
        const plainText = getPlainTextFromMarkdown(text);
        if (!plainText) {
            console.warn("TTS: No text content to speak after parsing markdown.");
            return;
        }

        const newUtterance = new SpeechSynthesisUtterance(plainText);
        newUtterance.lang = lang;
        newUtterance.rate = rate;
        newUtterance.pitch = pitch;
        newUtterance.volume = volume;

        if (voiceURI) {
            const voices = synth.getVoices();
            const selectedVoice = voices.find(voice => voice.voiceURI === voiceURI);
            if (selectedVoice) {
                newUtterance.voice = selectedVoice;
            }
        }
        
        newUtterance.onstart = () => {
            setIsSpeaking(true);
        };
        newUtterance.onend = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        newUtterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            setIsSpeaking(false);
            utteranceRef.current = null;
        };

        utteranceRef.current = newUtterance;
        synth.speak(newUtterance);
    }, [isSupported]);

    const cancel = useCallback(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel();
        }
        // onend should fire and set isSpeaking to false.
        // If it doesn't (e.g. cancel is abrupt), manually reset:
        if (isSpeaking) {
            setIsSpeaking(false);
            utteranceRef.current = null;
        }
    }, [isSupported, isSpeaking]);

    // Optional: Get available voices
    const getVoices = useCallback(() => {
        if (!isSupported) return [];
        return window.speechSynthesis.getVoices();
    }, [isSupported]);

    // Voices might load asynchronously. Listen for 'voiceschanged' event.
    useEffect(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        const loadVoices = () => {
            // You might want to store voices in state if your UI allows voice selection
            // console.log("Voices loaded:", synth.getVoices());
        };
        synth.addEventListener('voiceschanged', loadVoices);
        // Initial load if voices are already available
        if (synth.getVoices().length > 0) {
            loadVoices();
        }
        return () => synth.removeEventListener('voiceschanged', loadVoices);
    }, [isSupported]);


    return {
        speak,
        cancel,
        isSpeaking,
        isSupported,
        getVoices,
        currentlySpeakingUtterance: utteranceRef.current
    };
};
```

`src/hooks/useTheme.js`

```javascript
// import { useContext } from 'react';
// import { AppStateContext } from '../contexts/AppStateContext'; // Assuming theme is in AppStateContext

// export const useTheme = () => {
//     const context = useContext(AppStateContext);
//     if (!context) {
//         throw new Error('useTheme must be used within an AppStateProvider');
//     }
//     return { theme: context.theme, toggleTheme: context.toggleTheme };
// };


import { useContext } from 'react';
import { AppStateContext } from '../contexts/AppStateContext.jsx'; // Correct named import for the context object

export const useTheme = () => {
    const context = useContext(AppStateContext); // Use the imported context object
    if (!context) {
        throw new Error('useTheme must be used within an AppStateProvider');
    }
    return { theme: context.theme, toggleTheme: context.toggleTheme };
};
```

`src/hooks/useTypingEffect.js`

```javascript
// frontend/src/hooks/useTypingEffect.js
import { useState, useEffect, useRef } from 'react';

/**
 * A custom hook to create a typing animation effect for text.
 * @param {string} textToType The full string that should be typed out.
 * @param {number} [speed=20] The delay in milliseconds between each character.
 * @param {function} [onComplete] An optional callback to run when typing is finished.
 * @returns {string} The currently displayed text (which grows over time).
 */
export const useTypingEffect = (textToType, speed = 20, onComplete) => {
    const [displayedText, setDisplayedText] = useState('');
    const index = useRef(0);
    const onCompleteRef = useRef(onComplete);

    // Keep the onComplete callback reference fresh
    useEffect(() => {
        onCompleteRef.current = onComplete;
    }, [onComplete]);

    useEffect(() => {
        // Reset the typing effect when the text to type changes
        setDisplayedText('');
        index.current = 0;

        const intervalId = setInterval(() => {
            if (index.current < textToType.length) {
                setDisplayedText(prev => prev + textToType.charAt(index.current));
                index.current++;
            } else {
                clearInterval(intervalId);
                if (onCompleteRef.current) {
                    onCompleteRef.current(); // Call the onComplete callback
                }
            }
        }, speed);

        return () => clearInterval(intervalId);
    }, [textToType, speed]);

    return displayedText;
};
```

`src/hooks/useWebSpeech.js`

```javascript
// src/hooks/useWebSpeech.js
import { useState, useEffect, useCallback } from 'react';

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

export const useWebSpeech = () => {
    const [transcript, setTranscript] = useState('');
    const [listening, setListening] = useState(false);
    const [recognitionInstance, setRecognitionInstance] = useState(null);
    const [error, setError] = useState(null); // Added error state
    const isSpeechSupported = !!SpeechRecognition;

    useEffect(() => {
        if (!isSpeechSupported) {
            console.warn("Web Speech API is not supported by this browser.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = false; // Set to true if you want it to keep listening
        recognition.interimResults = false; // Set to true for live results
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            const currentTranscript = Array.from(event.results)
                .map(result => result[0])
                .map(result => result.transcript)
                .join('');
            setTranscript(currentTranscript);
            setError(null); // Clear error on successful result
            // console.log("Voice input result:", currentTranscript);
        };

        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            let errorMessage = event.error;
            if (event.error === 'no-speech') errorMessage = "No speech detected. Please try again.";
            else if (event.error === 'audio-capture') errorMessage = "Audio capture failed. Check microphone.";
            else if (event.error === 'not-allowed') errorMessage = "Microphone permission denied.";
            else if (event.error === 'network') errorMessage = "Network error during speech recognition.";
            // Add more specific error messages as needed
            
            setError(errorMessage);
            setListening(false);
        };

        recognition.onend = () => {
            setListening(false);
            // console.log("Speech recognition ended.");
        };
        
        setRecognitionInstance(recognition);

        // Cleanup
        return () => {
            if (recognition) {
                recognition.abort(); // Use abort to stop and discard results if component unmounts
            }
        };
    }, [isSpeechSupported]);

    const startListening = useCallback(() => {
        if (recognitionInstance && !listening) {
            try {
                setTranscript(''); // Clear previous transcript
                setError(null); // Clear previous errors
                recognitionInstance.start();
                setListening(true);
                // console.log("Speech recognition started.");
            } catch (e) {
                // This catch might be for synchronous errors during .start() call,
                // most errors are handled by recognition.onerror
                console.error("Error starting speech recognition:", e);
                setError("Could not start voice input.");
                setListening(false); // Ensure listening state is correct
            }
        }
    }, [recognitionInstance, listening]);

    const stopListening = useCallback(() => {
        if (recognitionInstance && listening) {
            recognitionInstance.stop(); // Stop and process any captured audio
            // setListening(false) will be called by onend event
            // console.log("Speech recognition stopped manually.");
        }
    }, [recognitionInstance, listening]);

    const resetTranscript = useCallback(() => {
        setTranscript('');
    }, []);


    return {
        transcript,
        listening,
        isSpeechSupported,
        startListening,
        stopListening,
        resetTranscript,
        error // Expose error state
    };
};
```

`src/index.css`

```css
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html, body, #root { /* Apply to html, body, AND your React root div */
    @apply h-full overflow-hidden; /* Force full height and no scroll on these */
  }

  html {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    scroll-behavior: smooth; /* This is fine, affects internal scrolls */
  }

  body {
    @apply bg-background-light text-text-light transition-colors duration-300;
    font-family: theme('fontFamily.sans');
    /* overflow-hidden is now applied via the html, body, #root rule above */
  }

  html.dark body {
    @apply bg-background-dark text-text-dark;
  }
  html.light body {
    @apply bg-background-light text-text-light;
  }

  .custom-scrollbar {
     @apply scrollbar-thin scrollbar-thumb-secondary dark:scrollbar-thumb-secondary-dark scrollbar-track-surface-light dark:scrollbar-track-gray-800 scrollbar-thumb-rounded-full scrollbar-track-rounded-full;
  }

  /* --- Enhanced Prose Styles --- */
  .prose {
    @apply max-w-none text-text-light dark:text-text-dark;
  }
  .prose, .prose-sm {
    /* Headings */
    h1 { @apply text-2xl sm:text-3xl font-extrabold mb-6 mt-2 text-text-light dark:text-text-dark; }
    h2 { @apply text-xl sm:text-2xl font-bold mb-4 mt-8 border-b border-border-light dark:border-border-dark pb-2; }
    h3 { @apply text-lg sm:text-xl font-semibold mb-3 mt-6; }
    h4 { @apply text-base sm:text-lg font-semibold mb-2 mt-4; }

    /* Paragraphs */
    p { @apply mb-4 leading-relaxed; }

    /* Links */
    a { @apply text-primary dark:text-primary-light hover:underline font-medium; }
    pre a, pre code a { @apply text-inherit no-underline hover:text-inherit; }

    /* Lists */
    ul, ol { @apply pl-5 mb-4 space-y-1; }
    ul { @apply list-disc; }
    ol { @apply list-decimal; }
    li { @apply mb-1; }
    ul ul, ol ol, ul ol, ol ul { @apply pl-5 mt-1 mb-1; }
    li::marker { @apply text-text-muted-light dark:text-text-muted-dark; }

    /* --- GFM Task List Checkboxes - Custom GREEN Styling --- */
    li:has(> input[type="checkbox"]) {
      @apply flex items-center;
      list-style-type: none;
      margin-left: -1.25rem; /* Adjust as needed for alignment */
      padding-left: 0;
    }

    li > input[type="checkbox"] {
      @apply opacity-0 w-0 h-0 absolute;
    }

    li:has(> input[type="checkbox"])::before {
      content: "";
      @apply inline-block w-4 h-4 border-2 rounded-sm mr-2 align-middle flex-shrink-0;
      @apply bg-surface-light dark:bg-gray-700;
      @apply border-border-light dark:border-border-dark;
      transition: all 0.15s ease-in-out;
    }

    li:has(> input[type="checkbox"]:checked)::before {
      @apply bg-green-500 dark:bg-green-600 border-green-500 dark:border-green-600;
      background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
      background-size: 70% 70%;
      background-position: center;
      background-repeat: no-repeat;
    }

    li:has(> input[type="checkbox"]:disabled:not(:checked))::before {
      @apply opacity-60 cursor-not-allowed;
      @apply bg-gray-100 dark:bg-gray-600 border-gray-300 dark:border-gray-500;
    }

    li:has(> input[type="checkbox"]:checked:disabled)::before {
      @apply bg-green-500/70 dark:bg-green-600/70 border-green-500/70 dark:border-green-600/70;
      opacity: 0.75;
      cursor: not-allowed;
    }


    /* Blockquotes */
    blockquote {
      @apply border-l-4 border-primary dark:border-primary-light pl-4 py-2 my-4 italic text-text-muted-light dark:text-text-muted-dark bg-surface-light dark:bg-gray-800/30 rounded-r-md;
    }
    blockquote p { @apply mb-0; }

    /* Horizontal Rules */
    hr { @apply my-8 border-t border-border-light dark:border-border-dark; }

    /* Tables */
    table { @apply w-full my-6 text-sm border-collapse; }
    thead { @apply border-b-2 border-border-light dark:border-border-dark; }
    th {
      @apply px-4 py-2.5 text-left font-semibold text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700/50;
      @apply border border-border-light dark:border-border-dark;
    }
    tbody tr { @apply border-b border-border-light dark:border-border-dark; }
    tbody tr:last-child { @apply border-b-0; }
    tbody tr:nth-child(even) { @apply bg-gray-50 dark:bg-gray-800/20; }
    td { @apply px-4 py-2.5 text-left border-x border-border-light dark:border-border-dark; }
    td code { @apply text-xs; }
    td strong { @apply font-semibold; }

    /* --- Code Styling --- */
    code:not(pre code) {
      @apply px-1.5 py-0.5 bg-primary/10 dark:bg-primary-dark/20 text-primary dark:text-primary-light rounded-md text-xs font-mono break-words;
    }
    code:not(pre code)::before, code:not(pre code)::after { content: ''; }

    pre {
      @apply bg-[#282c34] dark:bg-[#21252b] p-4 rounded-lg shadow-md overflow-x-auto custom-scrollbar my-5;
    }
    pre code {
      @apply bg-transparent p-0 font-mono text-sm leading-relaxed;
      color: #abb2bf;
      white-space: pre-wrap;
      word-break: break-all;
    }

    strong { @apply font-semibold text-text-light dark:text-text-dark; }
  }
}

@layer components {
  /* ... your existing btn, input-field, form-checkbox, card styles ... */
  /* The li:has(> input[type="checkbox"]) from your paste was misplaced, it should be within .prose */

  /* I will keep your existing .form-checkbox rules here as they might be used by other non-prose forms */
  .btn {
    @apply font-semibold py-2 px-4 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2 disabled:opacity-60 disabled:cursor-not-allowed;
  }
  html.dark .btn { @apply focus:ring-offset-background-dark; }
  html:not(.dark) .btn { @apply focus:ring-offset-background-light; }

  .btn-primary { @apply btn bg-primary text-white hover:bg-primary-dark focus:ring-primary; }
  .btn-secondary { @apply btn bg-secondary text-white hover:bg-secondary-dark focus:ring-secondary; }
  .btn-ghost { @apply btn text-text-muted-light dark:text-text-muted-dark hover:bg-gray-500 hover:bg-opacity-10 focus:ring-primary; }

  .input-field {
    @apply block w-full px-3 py-2 bg-surface-light dark:bg-gray-700 border border-border-light dark:border-border-dark rounded-md text-sm shadow-sm placeholder-text-muted-light dark:placeholder-text-muted-dark
           focus:outline-none focus:border-primary dark:focus:border-primary-light focus:ring-1 focus:ring-primary dark:focus:ring-primary-light;
  }
  .form-input, .form-textarea, .form-select, .form-multiselect { @apply input-field; }

  .form-checkbox, .form-radio {
    @apply rounded shadow-sm border-border-light dark:border-border-dark text-primary focus:ring-primary dark:focus:ring-primary-light;
    @apply bg-surface-light dark:bg-gray-600;
  }
  .form-checkbox:disabled, .form-radio:disabled {
    @apply opacity-70 bg-gray-200 dark:bg-gray-700 border-gray-300 dark:border-gray-600;
  }

  .card-base {
    @apply border rounded-panel shadow-panel;
    @apply bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark;
  }
  .card-header-base {
    @apply px-4 py-3 text-sm font-semibold border-b;
    @apply text-text-light dark:text-text-dark border-border-light dark:border-border-dark;
  }
    .panel-resize-handle {
      @apply relative bg-transparent;
    }
  
    .panel-resize-handle::after {
      content: '';
      @apply absolute inset-0 transition-colors duration-200;
    }
  
    .panel-resize-handle[data-active='true']::after {
      @apply bg-primary/50;
    }
}
```

`src/main.jsx`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppWrapper from './App.jsx';
import { AuthProvider } from './contexts/AuthContext.jsx'; // For regular users
import { AppStateProvider } from './contexts/AppStateContext.jsx';
import { Toaster } from 'react-hot-toast';
import './index.css';

import 'prismjs/themes/prism-okaidia.css';
import 'katex/dist/katex.min.css';
import Prism from 'prismjs'; 
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup'; 
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-java';


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <AppStateProvider>
        <AppWrapper />
      </AppStateProvider>
    </AuthProvider>
  </React.StrictMode>,
);
```

`src/services/adminApi.js`

```javascript
    // frontend/src/services/adminApi.js
    import axios from 'axios';

    // Get base URL for admin document endpoints
    const ADMIN_DOCS_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin/documents`;

    // Get fixed admin credentials from .env (prefixed with VITE_ for frontend access)
    const ADMIN_USERNAME_FRONTEND = import.meta.env.VITE_ADMIN_USERNAME || 'admin';
    const ADMIN_PASSWORD_FRONTEND = import.meta.env.VITE_ADMIN_PASSWORD || 'admin123';

    const adminApiClient = axios.create({
        baseURL: ADMIN_DOCS_API_BASE_URL,
    });

    export const getFixedAdminAuthHeaders = () => {
        if (!ADMIN_USERNAME_FRONTEND || !ADMIN_PASSWORD_FRONTEND) {
            console.error("Admin credentials not found in VITE_ADMIN_USERNAME or VITE_ADMIN_PASSWORD .env variables for frontend.");
            return {};
        }
        const basicAuthToken = btoa(`${ADMIN_USERNAME_FRONTEND}:${ADMIN_PASSWORD_FRONTEND}`);
        return { 'Authorization': `Basic ${basicAuthToken}` };
    };

    const makeAdminApiRequest = async (method, endpoint, data = null, authHeaders = {}) => {
        if (!authHeaders.Authorization) {
            const errorMsg = "Admin authentication headers are missing. Cannot make admin API request.";
            console.error(errorMsg);
            throw new Error(errorMsg);
        }
        try {
            const config = {
                method,
                url: endpoint,
                headers: {
                    ...authHeaders,
                    'Content-Type': data instanceof FormData ? 'multipart/form-data' : 'application/json',
                },
            };
            if (data) {
                config.data = data;
            }
            const response = await adminApiClient(config);
            return response.data;
        } catch (error) {
            let errorMessage = 'Admin API request failed.';
            if (error.response) {
                errorMessage = error.response.data?.message || error.response.statusText || `Server error: ${error.response.status}`;
                console.error(`Admin API Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}): Status ${error.response.status}`, error.response.data);
            } else if (error.request) {
                errorMessage = 'No response from admin API server. Check network or server status.';
                console.error(`Admin API Network Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}):`, error.request);
            } else {
                errorMessage = error.message || 'Error setting up admin API request.';
                console.error(`Admin API Setup Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}):`, error.message);
            }
            throw new Error(errorMessage);
        }
    };

    export const uploadAdminDocument = async (formData, adminAuthHeaders) => {
        return makeAdminApiRequest('post', '/upload', formData, adminAuthHeaders);
    };

    export const getAdminDocuments = async (adminAuthHeaders) => {
        return makeAdminApiRequest('get', '/', null, adminAuthHeaders);
    };

    export const deleteAdminDocument = async (serverFilename, adminAuthHeaders) => {
        return makeAdminApiRequest('delete', `/${serverFilename}`, null, adminAuthHeaders);
    };

    export const getAdminDocumentAnalysis = async (serverFilename, adminAuthHeaders) => {
        return makeAdminApiRequest('get', `/${serverFilename}/analysis`, null, adminAuthHeaders);
    };

    // --- NEW FUNCTION FOR STEP 2 ---
    export const getAdminDocumentAnalysisByOriginalName = async (originalName, adminAuthHeaders) => {
        // This function fetches the analysis object for an admin document using its originalName.
        // The backend route will be '/by-original-name/:originalName/analysis' relative to ADMIN_DOCS_API_BASE_URL.
        // It expects a response like:
        // { originalName, serverFilename, analysis: {faq, topics, mindmap}, analysisUpdatedAt }
        return makeAdminApiRequest('get', `/by-original-name/${encodeURIComponent(originalName)}/analysis`, null, adminAuthHeaders);
    };

    export const getApiKeyRequests = async (adminAuthHeaders) => {
        // Note: This endpoint is on /api/admin, not /api/admin/documents
        const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;
        try {
            const response = await axios.get(`${ADMIN_API_BASE_URL}/key-requests`, { headers: adminAuthHeaders });
            return response.data;
        } catch (error) {
            throw new Error(error.response?.data?.message || 'Failed to fetch API key requests.');
        }
    };

    export const approveApiKeyRequest = async (userId, adminAuthHeaders) => {
        const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;
        try {
            const response = await axios.post(`${ADMIN_API_BASE_URL}/key-requests/approve`, { userId }, { headers: adminAuthHeaders });
            return response.data;
        } catch (error) {
            throw new Error(error.response?.data?.message || 'Failed to approve request.');
        }
    };

    export const rejectApiKeyRequest = async (userId, adminAuthHeaders) => {
        const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;
        try {
            const response = await axios.post(`${ADMIN_API_BASE_URL}/key-requests/reject`, { userId }, { headers: adminAuthHeaders });
            return response.data;
        } catch (error) {
            throw new Error(error.response?.data?.message || 'Failed to reject request.');
        }
    };  
```

`src/services/api.js`

```javascript
// frontend/src/services/api.js
import axios from "axios";
import toast from "react-hot-toast";

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api",
});

apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      console.error("API Interceptor: Received 401 Unauthorized. Token might be invalid or expired.");
    }
    return Promise.reject(error);
  }
);

function parseAnalysisOutput(rawOutput) {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
}

const api = {
  login: async (credentials) => {
    const response = await apiClient.post("/auth/signin", credentials);
    return response.data;
  },
  signup: async (userData) => {
    const response = await apiClient.post("/auth/signup", userData);
    return response.data;
  },
  getMe: async () => {
    const response = await apiClient.get("/auth/me");
    return response.data;
  },
  sendMessage: async (payload) => {
    const response = await apiClient.post("/chat/message", payload);
    return response.data;
  },
  getChatHistory: async (sessionId) => {
    const response = await apiClient.get(`/chat/session/${sessionId}`);
    return response.data;
  },
  getChatSessions: async () => {
    const response = await apiClient.get("/chat/sessions");
    return response.data;
  },
  startNewSession: async (previousSessionId) => {
    const response = await apiClient.post("/chat/history", {
      previousSessionId,
    });
    return response.data;
  },
  deleteChatSession: async (sessionId) => {
    const response = await apiClient.delete(`/chat/session/${sessionId}`);
    return response.data;
  },
  uploadFile: async (formData, onUploadProgress) => {
    const response = await apiClient.post("/upload", formData, {
      headers: { "Content-Type": "multipart/form-data" },
      onUploadProgress,
    });
    return response.data;
  },
  getFiles: async () => {
    const response = await apiClient.get("/files");
    return response.data;
  },
  deleteFile: async (serverFilename) => {
    const response = await apiClient.delete(`/files/${serverFilename}`);
    return response.data;
  },
  updateUserLLMConfig: async (configData) => {
    console.log("[Frontend API] Sending LLM config update:", configData);
    const response = await apiClient.put("/llm/config", configData);
    return response.data;
  },
  getOrchestratorStatus: async () => {
    try {
      const response = await apiClient.get("/network/ip");
      return {
        status: "ok",
        message: `Backend Online at ${response.data.ips[0]}`,
      };
    } catch (e) {
      return { status: "error", message: "Backend Unreachable" };
    }
  },
  getUserProfile: async () => {
    const response = await apiClient.get("/user/profile");
    return response.data;
  },
  updateUserProfile: async (profileData) => {
    const response = await apiClient.put("/user/profile", profileData);
    return response.data;
  },
  getSubjects: async () => {
    const response = await apiClient.get("/subjects");
    return response.data;
  },
  requestAnalysis: async (payload) => {
    const { filename, analysis_type } = payload;
    if (!filename || !analysis_type) {
      throw new Error("Filename and analysis type are required.");
    }
    const toastId = toast.loading(
      `Generating ${analysis_type} for "${filename}"...`
    );
    try {
      const response = await apiClient.get(
        `/analysis/${encodeURIComponent(filename)}`
      );
      const fullAnalysisObject = response.data;
      const rawOutput = fullAnalysisObject[analysis_type];
      if (
        !rawOutput ||
        typeof rawOutput !== "string" ||
        rawOutput.trim() === ""
      ) {
        toast.success(`No stored ${analysis_type} found for "${filename}".`, {
          id: toastId,
        });
        return {
          content: `Notice: Analysis for '${analysis_type}' has not been generated yet or was empty.`,
          thinking: "No analysis data found in the database for this type.",
        };
      }
      const { content, thinking } = parseAnalysisOutput(rawOutput);
      toast.success(
        `Successfully generated ${analysis_type} for "${filename}".`,
        { id: toastId }
      );
      return { content, thinking };
    } catch (error) {
      const errorMessage =
        error.response?.data?.message || error.message || "Unknown error";
      toast.error(`Error generating ${analysis_type}: ${errorMessage}`, {
        id: toastId,
      });
      throw error;
    }
  },
  generateDocument: async ({
    markdownContent,
    docType,
    sourceDocumentName,
  }) => {
    const response = await apiClient.post(
      "/generate/document",
      { markdownContent, docType, sourceDocumentName },
      { responseType: "blob" }
    );
    const contentDisposition = response.headers["content-disposition"];
    let filename = `generated-document.${docType}`;
    if (contentDisposition) {
      const filenameMatch = contentDisposition.match(/filename="?(.+)"?/);
      if (filenameMatch && filenameMatch.length > 1) {
        filename = filenameMatch[1];
      }
    }
    return { fileBlob: response.data, filename: filename };
  },
  generatePodcast: async ({
    analysisContent,
    sourceDocumentName,
    podcastOptions,
  }) => {
    const response = await apiClient.post(
      "/export/podcast",
      { analysisContent, sourceDocumentName, podcastOptions },
      { responseType: "blob" }
    );
    return { audioBlob: response.data, sourceDocumentName };
  },
  getKnowledgeGraph: async (documentName) => {
    const response = await apiClient.get(
      `/kg/visualize/${encodeURIComponent(documentName)}`
    );
    return response.data;
  },
  executeCode: async (payload) => {
    const response = await apiClient.post("/tools/execute", payload);
    return response.data; // The data should be { results: [...] }
  },
  analyzeCode: async (payload) => {
    const response = await apiClient.post("/tools/analyze-code", payload);
    return response.data; // Should be { analysis: "..." }
  },
  generateTestCases: async (payload) => {
    const response = await apiClient.post(
      "/tools/generate-test-cases",
      payload
    );
    return response.data; // Should be { testCases: [...] }
  },
  explainError: async (payload) => {
    const response = await apiClient.post("/tools/explain-error", payload);
    return response.data; // Should be { explanation: "..." }
  },
};

export default api;
```

`src/utils/helpers.js`

```javascript
// Debounce function: Limits the rate at which a function can fire.

export const debounce = (func, delay) => {
    let timeoutId;
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(context, args), delay);
    };
};

// Throttle function: Ensures a function is called at most once in a specified time period.
export const throttle = (func, limit) => {
    let inThrottle;
    let lastFunc;
    let lastRan;
    return function(...args) {
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            lastRan = Date.now();
            inThrottle = true;
            setTimeout(() => {
                inThrottle = false;
                if (lastFunc) {
                    lastFunc.apply(context, args); // Call with latest args if throttled
                    lastRan = Date.now();
                }
            }, limit);
        } else {
            lastFunc = func; // Store the latest call
        }
    };
};

// Simple function to format file size
export const formatFileSize = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

// Function to generate a simple unique ID (for client-side list keys, etc.)
export const generateUniqueId = (prefix = 'id') => {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Function to safely get nested property
export const getNestedValue = (obj, path, defaultValue = undefined) => {
    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
    return value === undefined ? defaultValue : value;
};

// Basic HTML escape (can be more comprehensive)
export const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

// You can add more utility functions here as your project grows.
// For example, date formatting, string manipulation, etc.

// Example: Truncate text
export const truncateText = (text, maxLength = 100) => {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
};
```

`src/utils/markdownUtils.jsx`

```javascript
// src/utils/markdownUtils.jsx
import katex from 'katex';
import DOMPurify from 'dompurify';

const decodeHtmlEntities = (encodedString) => {
  if (typeof encodedString !== 'string') return encodedString;

  const textarea = document.createElement('textarea');
  textarea.innerHTML = encodedString;
  return textarea.value;
};

export const renderMathInHtml = (htmlString) => {
  if (!htmlString || typeof htmlString !== 'string') return htmlString;

  let processedString = htmlString;
  processedString = processedString.replace(/(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$/g, (match, rawExpression) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: true, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"} 
      });
      return DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } });
    } catch (e) { 
      console.warn(`KaTeX (display) error: ${e.message} for expression: ${expression}`); 
      return match; 
    }
  });

  processedString = processedString.replace(/(^|[^$\\])\$(?![\s$])([^$\n]+?)(?<![\s\\])\$([^\$]|$)/g, (fullMatch, prefix, rawExpression, suffix) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    if (!expression) return fullMatch; 
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: false, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"}
      });
      return prefix + DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } }) + suffix;
    } catch (e) { 
      console.warn(`KaTeX (inline) error: ${e.message} for expression: ${expression}`);
      return fullMatch; 
    }
  });
  
  return processedString;
};
```

`tailwind.config.js`

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  safelist: [
    'prose',
    'prose-sm',
    'dark:prose-invert',
  ],
  theme: {
    extend: {
      colors: {
        'primary': { light: '#60a5fa', DEFAULT: '#3b82f6', dark: '#2563eb' },
        'secondary': { light: '#9ca3af', DEFAULT: '#6b7280', dark: '#4b5563' },
        'accent': '#2dd4bf',
        'background-dark': '#0F172A', 'surface-dark': '#1E293B', 'border-dark': '#334155', 'text-dark': '#E2E8F0', 'text-muted-dark': '#94A3B8',
        'background-light': '#F8FAFC', 'surface-light': '#FFFFFF', 'border-light': '#E2E8F0', 'text-light': '#0F172A', 'text-muted-light': '#64748B',
      },
      fontFamily: {
        sans: ['"Inter var"', 'Inter', 'system-ui', 'sans-serif'],
      },
      boxShadow: {
        'main': '0 4px 15px -5px rgba(0,0,0,0.07), 0 2px 8px -6px rgba(0,0,0,0.07)',
        'panel': '0 8px 20px -5px rgba(0,0,0,0.1), 0 4px 10px -6px rgba(0,0,0,0.08)',
        'card-hover': '0 6px 18px -4px rgba(0,0,0,0.1), 0 3px 10px -5px rgba(0,0,0,0.1)',
      },
      borderRadius: { 'xl': '0.75rem', '2xl': '1rem', 'panel': '0.75rem' },
      keyframes: {
        fadeIn: { '0%': { opacity: '0', transform: 'translateY(5px)' }, '100%': { opacity: '1', transform: 'translateY(0px)' } },
        slideUp: { '0%': { transform: 'translateY(10px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } },
        pulseDots: {
          '0%, 100%': { opacity: '0.3', transform: 'scale(0.8)' },
          '50%': { opacity: '1', transform: 'scale(1)' },
        }
      },
      animation: {
        fadeIn: 'fadeIn 0.3s ease-out forwards',
        slideUp: 'slideUp 0.4s ease-out forwards',
        pulseDot1: 'pulseDots 1.4s infinite 0s ease-in-out',
        pulseDot2: 'pulseDots 1.4s infinite 0.2s ease-in-out',
        pulseDot3: 'pulseDots 1.4s infinite 0.4s ease-in-out',
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms')({ strategy: 'class' }),
    require('tailwind-scrollbar')({ nocompatible: true }),
    require('@tailwindcss/typography'),
  ],
}
```

`vite.config.js`

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  // --- ADD THIS SECTION TO FIX THE "global is not defined" ERROR ---
  define: {
    'global': {},
  }
})

```


```

`frontend/eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

`frontend/index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI TUTOR</title>

    <script src="https://cdn.jsdelivr.net/npm/d3@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-lib@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-view@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest/dist/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js"></script>
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        if (typeof mermaid !== 'undefined') {
          mermaid.initialize({ startOnLoad: false, theme: 'neutral' }); 
          console.log("Mermaid.js initialized globally with 'neutral' theme via index.html.");
        } else {
          console.error("Mermaid.js not found on window after script load. Mermaid diagrams may not render.");
        }
      });
    </script>

  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

`frontend/o.txt`

```

```

`frontend/postcss.config.js`

```javascript
export default {
  plugins: {
    'postcss-nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

`frontend/src/App.css`

```css
/* #root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
} */

```

`frontend/src/App.jsx`

```javascript
// frontend/src/App.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate, useLocation } from 'react-router-dom';
import { useAuth as useRegularAuth } from './hooks/useAuth.jsx';
import { useAppState } from './contexts/AppStateContext.jsx';
import AuthModal from './components/auth/AuthModal.jsx';
import TopNav from './components/layout/TopNav.jsx';
import LeftPanel from './components/layout/LeftPanel.jsx';
import CenterPanel from './components/layout/CenterPanel.jsx';
import RightPanel from './components/layout/RightPanel.jsx';
import LeftCollapsedNav from './components/layout/LeftCollapsedNav.jsx';
import RightCollapsedNav from './components/layout/RightCollapsedNav.jsx';
import ChatHistoryModal from './components/chat/ChatHistoryModal.jsx';
import AdminDashboardPage from './components/admin/AdminDashboardPage.jsx';
import AdminProtectedRoute from './components/admin/AdminProtectedRoute.jsx';
import CodeExecutorPage from './components/tools/CodeExecutorPage.jsx';
import StudyPlanPage from './components/learning/StudyPlanPage.jsx';
import QuizGeneratorPage from './components/tools/QuizGeneratorPage.jsx';
import api from './services/api.js';
import toast from 'react-hot-toast';
import { GraduationCap } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from './components/core/Button.jsx';

function SessionLoadingModal() {
    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-[9999]">
            <motion.div
                key="session-loading-modal"
                initial={{ opacity: 0, scale: 0.9 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.9 }}
                className="bg-surface-light dark:bg-surface-dark rounded-xl shadow-2xl p-8 w-full max-w-md text-center"
            >
                <div className="flex justify-center items-center mb-4">
                    <div className="animate-spin rounded-full h-10 w-10 border-t-4 border-b-4 border-primary"></div>
                </div>
                <h2 className="text-xl font-bold text-text-light dark:text-text-dark mb-2">Finalizing Session...</h2>
                <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                    Summarizing key points and identifying topics for your future recommendations.
                </p>
            </motion.div>
        </div>
    );
}

function MainAppLayout({ orchestratorStatus, navigate, handleNewChat, isSessionLoading, initialPromptForNewSession, setInitialPromptForNewSession, initialActivityForNewSession, setInitialActivityForNewSession, messages, setMessages }) {
    const { user: regularUser, logout: regularUserLogout } = useRegularAuth();
    const {
        currentSessionId,
        isLeftPanelOpen,
        isRightPanelOpen,
        setSessionId: setGlobalSessionId,
    } = useAppState();
    const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false);
    const [isChatProcessing, setIsChatProcessing] = useState(false);
    
    const handleChatProcessingStatusChange = (isLoading) => {
        setIsChatProcessing(isLoading);
    };

    const handleRegularUserLogout = () => {
        regularUserLogout();
        setGlobalSessionId(null);
    };

    const handleSelectSessionFromHistory = (sessionId) => {
        if (sessionId && sessionId !== currentSessionId) {
            setGlobalSessionId(sessionId);
            toast.success(`Loading session...`);
        }
        setIsHistoryModalOpen(false);
    };

    return (
    <>
        <AnimatePresence>
            {isSessionLoading && <SessionLoadingModal />}
        </AnimatePresence>

        <TopNav 
            user={regularUser} 
            onLogout={handleRegularUserLogout} 
            onNewChat={() => handleNewChat(messages)} // Pass messages here
            onHistoryClick={() => setIsHistoryModalOpen(true)} 
            orchestratorStatus={orchestratorStatus}
            isChatProcessing={isChatProcessing}
        />
        <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark">
            <AnimatePresence mode="wait">
                {isLeftPanelOpen ? (
                    <motion.aside key="left-panel-main" initial={{ x: '-100%' }} animate={{ x: '0%' }} exit={{ x: '-100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                        <LeftPanel />
                    </motion.aside>
                ) : ( <LeftCollapsedNav /> )}
            </AnimatePresence>
            <main className={`flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4 transition-all duration-300 ease-in-out ${isLeftPanelOpen ? 'lg:ml-0' : 'lg:ml-16 md:ml-14'} ${isRightPanelOpen ? 'lg:mr-0' : 'lg:mr-16 md:mr-14'}`}>
                <CenterPanel 
                    messages={messages} 
                    setMessages={setMessages} 
                    currentSessionId={currentSessionId}
                    onChatProcessingChange={handleChatProcessingStatusChange}
                    initialPromptForNewSession={initialPromptForNewSession}
                    setInitialPromptForNewSession={setInitialPromptForNewSession}
                    initialActivityForNewSession={initialActivityForNewSession}
                    setInitialActivityForNewSession={setInitialActivityForNewSession}
                />
            </main>
            <AnimatePresence mode="wait">
                {isRightPanelOpen ? (
                    <motion.aside key="right-panel-main" initial={{ x: '100%' }} animate={{ x: '0%' }} exit={{ x: '100%' }} transition={{ type: 'spring', stiffness: 300, damping: 30 }} className="hidden md:flex md:flex-col md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar">
                        <RightPanel />
                    </motion.aside>
                ) : ( <RightCollapsedNav /> )}
            </AnimatePresence>
        </div>
        <ChatHistoryModal isOpen={isHistoryModalOpen} onClose={() => setIsHistoryModalOpen(false)} onSelectSession={handleSelectSessionFromHistory} />
    </>
    );
}

function App() {
    const { token: regularUserToken, user: regularUser, loading: regularUserAuthLoading, setUser: setRegularUserInAuthContext } = useRegularAuth();
    const { 
        theme, 
        setSessionId: setGlobalSessionId, 
        currentSessionId, 
        isAdminSessionActive,
        initialPromptForNewSession,      
        setInitialPromptForNewSession, 
        initialActivityForNewSession,    
        setInitialActivityForNewSession
    } = useAppState();
    const navigate = useNavigate();
    const location = useLocation();
    const [appInitializing, setAppInitializing] = useState(true);
    const [showAuthModal, setShowAuthModal] = useState(false);
    const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });
    const [isSessionLoading, setIsSessionLoading] = useState(false);

    // --- NEW LOGIC MOVED HERE FROM MainAppLayout ---
    const [appStateMessages, setAppStateMessages] = useState([]);

        const handleNewChat = useCallback(async (callbackOrMessages) => {
        const messages = Array.isArray(callbackOrMessages) ? callbackOrMessages : [];
        const callback = typeof callbackOrMessages === 'function' ? callbackOrMessages : null;

        if (messages.length === 0 && currentSessionId) {
            toast('This is already a new chat!', { icon: '✨' });
            return;
        }

        setIsSessionLoading(true);
        try {
            const data = await api.startNewSession(currentSessionId); 
            if (data && data.newSessionId) {
                setGlobalSessionId(data.newSessionId);
                toast.success("New chat started!");

                if (data.studyPlanSuggestion) {
                    const { topic, reason } = data.studyPlanSuggestion;
                    toast.custom((t) => (
                        <motion.div
                            initial={{ opacity: 0, y: -20 }}
                            animate={{ opacity: 1, y: 0 }}
                            exit={{ opacity: 0, y: -20 }}
                            className="bg-surface-light dark:bg-surface-dark shadow-lg rounded-lg p-4 w-96 border border-border-light dark:border-border-dark"
                        >
                            <div className="flex items-start">
                                <div className="flex-shrink-0 pt-0.5">
                                    <GraduationCap className="h-6 w-6 text-primary" />
                                </div>
                                <div className="ml-3 flex-1">
                                    <p className="text-sm font-semibold text-text-light dark:text-text-dark">Personalized Study Plan Suggestion</p>
                                    <p className="mt-1 text-sm text-text-muted-light dark:text-text-muted-dark">{reason}</p>
                                    <div className="mt-4 flex gap-2">
                                        <Button
                                            size="sm"
                                            onClick={() => {
                                                navigate('/study-plan', { state: { prefilledGoal: topic } });
                                                toast.dismiss(t.id);
                                            }}
                                        >
                                            Create Plan for "{topic}"
                                        </Button>
                                        <Button size="sm" variant="secondary" onClick={() => toast.dismiss(t.id)}>
                                            Dismiss
                                        </Button>
                                    </div>
                                </div>
                            </div>
                        </motion.div>
                    ), {
                        id: `study-plan-toast-${topic}`,
                        duration: Infinity,
                    });
                }
                
                if (callback) callback(data.newSessionId);

            } else {
                toast.error(data.message || "Could not start new chat session.");
            }
        } catch (error) {
            toast.error(`Failed to start new chat: ${error.message}`);
        } finally {
            setIsSessionLoading(false);
        }
    }, [currentSessionId, setGlobalSessionId, navigate]);
    
    const fetchChatHistory = useCallback(async (sid) => {
        if (!sid || !regularUserToken) {
            setAppStateMessages([]);
            return;
        }
        try {
            const sessionData = await api.getChatHistory(sid);
            setAppStateMessages(Array.isArray(sessionData.messages) ? sessionData.messages : []);
        } catch (error) {
            toast.error(`History load failed: ${error.message}`);
            if (error.response && error.response.status === 404) {
                console.warn("Stale session ID found. Starting a new session.");
                handleNewChat();
            }
        }
    }, [regularUserToken, handleNewChat]);

    useEffect(() => {
        if (currentSessionId && regularUserToken) {
            fetchChatHistory(currentSessionId);
        } else if (!regularUserToken) {
            setAppStateMessages([]);
        }
    }, [currentSessionId, regularUserToken, fetchChatHistory]);
    // --- END OF MOVED LOGIC ---

    useEffect(() => { document.documentElement.className = theme; }, [theme]);
    useEffect(() => { api.getOrchestratorStatus().then(setOrchestratorStatus); }, []);
    
    useEffect(() => {
        if (isAdminSessionActive) {
            setAppInitializing(false);
            setShowAuthModal(false);
            if (!location.pathname.startsWith('/admin')) {
                navigate('/admin/dashboard', { replace: true });
            }
            return;
        }
        if (regularUserAuthLoading) {
            setAppInitializing(true);
            return;
        }
        setAppInitializing(false);
        if (regularUserToken && regularUser) {
            setShowAuthModal(false);
            if (location.pathname.startsWith('/admin')) {
                navigate('/', { replace: true });
            } else if (!currentSessionId && !location.pathname.startsWith('/tools') && !location.pathname.startsWith('/study-plan')) { 
                handleNewChat();
            }
        } else if (!location.pathname.startsWith('/admin')) {
            setShowAuthModal(true);
        }
    }, [regularUserAuthLoading, regularUserToken, regularUser, isAdminSessionActive, currentSessionId, navigate, location.pathname, setGlobalSessionId, handleNewChat]);

    const handleAuthSuccess = (authData) => {
        setShowAuthModal(false);
        if (authData && !authData.isAdminLogin && authData.token) {
            handleNewChat();
            if (authData.email && authData._id) {
                setRegularUserInAuthContext({ id: authData._id, email: authData.email });
            }
        }
    };

    if (appInitializing) {
        return (
            <div className="fixed inset-0 flex items-center justify-center bg-background-light dark:bg-background-dark">
                <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary"></div>
            </div>
        );
    }

    return (
        <div className="flex flex-col h-screen overflow-hidden font-sans">
            <AnimatePresence>
                {showAuthModal && <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />}
            </AnimatePresence>
            <Routes>
                
                 <Route path="/tools/code-executor" element={(regularUserToken && regularUser) ? 
                    <CodeExecutorPage /> : <Navigate to="/" />} 
                />
                <Route
                    path="/study-plan"
                    element={(regularUserToken && regularUser) ? <StudyPlanPage handleNewChat={handleNewChat} /> : <Navigate to="/" />}
                />
                 <Route path="/tools/quiz-generator" element={(regularUserToken && regularUser) ? 
                    <QuizGeneratorPage /> : <Navigate to="/" />} 
                />
                
                <Route path="/admin/dashboard" element={<AdminProtectedRoute><AdminDashboardPage /></AdminProtectedRoute>} />
                <Route path="/*" element={isAdminSessionActive ? <Navigate to="/admin/dashboard" replace /> : (regularUserToken && regularUser) ? <MainAppLayout 
                    orchestratorStatus={orchestratorStatus} 
                    navigate={navigate} 
                    handleNewChat={handleNewChat} 
                    isSessionLoading={isSessionLoading}
                    initialPromptForNewSession={initialPromptForNewSession}
                    setInitialPromptForNewSession={setInitialPromptForNewSession}
                    initialActivityForNewSession={initialActivityForNewSession}
                    setInitialActivityForNewSession={setInitialActivityForNewSession}
                    messages={appStateMessages}
                    setMessages={setAppStateMessages}
                /> : null} />
                </Routes>
        </div>
    );
}

function AppWrapper() {
    return (
        <Router>
            <App />
        </Router>
    );
}

export default AppWrapper;
```

`frontend/src/components/admin/AdminDashboardPage.jsx`

```javascript
// frontend/src/components/admin/AdminDashboardPage.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import * as adminApi from '../../services/adminApi.js';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import ApiKeyRequestManager from './ApiKeyRequestManager.jsx';
import UserChatManager from './UserChatManager.jsx';
import AdminInsights from './AdminInsights.jsx';
import { UploadCloud, Trash2, Eye, LogOut, Loader2, AlertTriangle, CheckCircle, RefreshCw, Shield, Users, Lightbulb, HelpCircle } from 'lucide-react';
import toast from 'react-hot-toast';
import { format } from 'date-fns';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

// Helper functions
const localParseAnalysisOutput = (rawOutput) => { 
    if (!rawOutput || typeof rawOutput !== 'string') return { content: '' };
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let mainContent = rawOutput;
    if (thinkingMatch && thinkingMatch[1]) {
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent };
};
const createMarkup = (markdownText) => { 
    if (!markdownText) return { __html: '' };
    const html = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(html, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

// AdminDocumentUpload Component
function AdminDocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const fileInputRef = useRef(null);
    const handleFileChange = (e) => { if (isUploading) return; const file = e.target.files && e.target.files[0]; if (file) setSelectedFile(file); else setSelectedFile(null); };
    const handleUpload = async () => {
        if (!selectedFile) { toast.error("Please select a file to upload."); return; }
        setIsUploading(true);
        const toastId = toast.loading(`Uploading "${selectedFile.name}"...`);
        const formData = new FormData();
        formData.append('file', selectedFile);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.uploadAdminDocument(formData, authHeaders);
            toast.success(response.message || `Admin document "${selectedFile.name}" uploaded.`, { id: toastId });
            onUploadSuccess();
            setSelectedFile(null);
            if (fileInputRef.current) fileInputRef.current.value = null;
        } catch (error) {
            toast.error(error.message || `Failed to upload "${selectedFile.name}".`, { id: toastId });
        } finally {
            setIsUploading(false);
        }
    };
    return (
        <div className="card-base p-4">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark">Upload New Subject Document</h2>
            <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
                <input type="file" ref={fileInputRef} onChange={handleFileChange} className="input-field flex-grow text-sm p-2.5 min-h-[44px]" accept=".pdf,.docx,.txt,.md" disabled={isUploading} />
                <Button onClick={handleUpload} isLoading={isUploading} disabled={!selectedFile || isUploading} leftIcon={<UploadCloud size={16} />} size="md" className="w-full sm:w-auto !py-2.5">Upload</Button>
            </div>
            {selectedFile && !isUploading && <p className="text-xs mt-2 text-text-muted-light dark:text-text-muted-dark">Selected: {selectedFile.name} ({(selectedFile.size / 1024).toFixed(1)} KB)</p>}
        </div>
    );
}

// Main AdminDashboardPage Component
function AdminDashboardPage() {
    const { setIsAdminSessionActive } = useAppState();
    const navigate = useNavigate();

    const [documents, setDocuments] = useState([]);
    const [keyRequests, setKeyRequests] = useState([]);
    const [usersWithChats, setUsersWithChats] = useState([]);
    const [dashboardStats, setDashboardStats] = useState({});
    const [isInitialLoading, setIsInitialLoading] = useState(true);
    const [loadingError, setLoadingError] = useState('');
    const [isAnalysisModalOpen, setIsAnalysisModalOpen] = useState(false);
    const [currentDocForModal, setCurrentDocForModal] = useState(null);
    const [analysisContent, setAnalysisContent] = useState(null);
    const [isLoadingAnalysis, setIsLoadingAnalysis] = useState(false);
    const [isSecurityModalOpen, setIsSecurityModalOpen] = useState(false);
    const [isUserChatsModalOpen, setIsUserChatsModalOpen] = useState(false);

    const adminLogoutHandler = () => {
        setIsAdminSessionActive(false);
        toast.success("Admin logged out.");
        navigate('/');
    };

    const fetchAdminData = useCallback(async (isRefresh = false) => {
        let toastId;
        if (isRefresh) {
            toastId = toast.loading("Refreshing all admin data...");
        } else {
            setIsInitialLoading(true);
        }
        setLoadingError('');
        
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const [docsResponse, requestsResponse, usersResponse, statsResponse] = await Promise.all([
                adminApi.getAdminDocuments(authHeaders),
                adminApi.getApiKeyRequests(authHeaders),
                adminApi.getUsersAndChats(authHeaders),
                adminApi.getDashboardStats(authHeaders)
            ]);

            setDocuments(Array.isArray(docsResponse.documents) ? docsResponse.documents : []);
            setKeyRequests(Array.isArray(requestsResponse) ? requestsResponse : []);
            setUsersWithChats(Array.isArray(usersResponse) ? usersResponse : []);
            setDashboardStats(statsResponse || {});

            if (isRefresh) toast.success("Admin data refreshed.", { id: toastId });
        } catch (err) {
            const errorMessage = err.message || "Failed to fetch admin data.";
            setLoadingError(errorMessage);
            if (isRefresh) toast.error(errorMessage, { id: toastId });
            else toast.error(errorMessage);
        } finally {
            if (!isRefresh) setIsInitialLoading(false);
        }
    }, []);

    useEffect(() => { fetchAdminData(); }, [fetchAdminData]);

    const handleDeleteDocument = async (serverFilename, originalName) => {
        if (!window.confirm(`Are you sure you want to delete admin document "${originalName}"?`)) return;
        const toastId = toast.loading(`Deleting "${originalName}"...`);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            await adminApi.deleteAdminDocument(serverFilename, authHeaders);
            toast.success(`Document "${originalName}" deleted.`, { id: toastId });
            fetchAdminData(true);
            if (isAnalysisModalOpen && currentDocForModal?.serverFilename === serverFilename) {
                setIsAnalysisModalOpen(false);
            }
        } catch (err) {
            toast.error(err.message || `Failed to delete "${originalName}".`, { id: toastId });
        }
    };
    
    const handleViewAnalysis = async (doc) => {
        setCurrentDocForModal(doc);
        setAnalysisContent(null);
        setIsAnalysisModalOpen(true);
        setIsLoadingAnalysis(true);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.getAdminDocumentAnalysis(doc.serverFilename, authHeaders);
            setAnalysisContent(response.analysis);
        } catch (err) {
            toast.error(`Failed to load analysis: ${err.message}`);
            setAnalysisContent({ error: `Failed to load analysis: ${err.message}` });
        } finally {
            setIsLoadingAnalysis(false);
        }
    };
    
    const renderAnalysisModalContent = () => {
        if (isLoadingAnalysis) {
            return (
                <div className="flex justify-center items-center h-48">
                    <Loader2 size={32} className="animate-spin text-primary" />
                    <p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p>
                </div>
            );
        }
        if (!analysisContent || analysisContent.error) {
            return <p className="p-4 text-center text-red-500 dark:text-red-400">{analysisContent?.error || "No analysis content available or an error occurred."}</p>;
        }
        const hasContent = analysisContent.faq?.trim() || analysisContent.topics?.trim() || analysisContent.mindmap?.trim();
        if (!hasContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">Analysis has not been generated for this document, or all analysis fields are empty.</p>;
        }
        return (
            <div className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark space-y-6 p-1 custom-scrollbar">
                {analysisContent.faq?.trim() && ( <div><h3 className="text-base font-semibold border-b border-border-light dark:border-border-dark pb-1 mb-2">Frequently Asked Questions</h3><div dangerouslySetInnerHTML={createMarkup(localParseAnalysisOutput(analysisContent.faq).content)} /></div>)}
                {analysisContent.topics?.trim() && ( <div><h3 className="text-base font-semibold border-b border-border-light dark:border-border-dark pb-1 mb-2">Key Topics</h3><div dangerouslySetInnerHTML={createMarkup(localParseAnalysisOutput(analysisContent.topics).content)} /></div>)}
                {analysisContent.mindmap?.trim() && (<div><h3 className="text-base font-semibold border-b border-border-light dark:border-border-dark pb-1 mb-2">Mind Map (Mermaid Code)</h3><pre className="bg-gray-100 dark:bg-gray-800 p-2 rounded-md text-xs whitespace-pre-wrap overflow-x-auto custom-scrollbar"><code>{localParseAnalysisOutput(analysisContent.mindmap).content}</code></pre></div>)}
            </div>
        );
    };

    return (
        <div className="min-h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark p-4 sm:p-6">
            <header className="flex items-center justify-between mb-6 pb-3 border-b border-border-light dark:border-border-dark">
                <h1 className="text-2xl font-bold">Professor's Dashboard</h1>
                <div className="flex items-center gap-2">
                    <IconButton icon={RefreshCw} onClick={() => fetchAdminData(true)} title="Refresh Admin Data" variant="ghost" size="md" className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"/>
                    <IconButton icon={Shield} onClick={() => setIsSecurityModalOpen(true)} title="Security Center & API Requests" variant="ghost" size="md" className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"/>
                    <IconButton icon={Users} onClick={() => setIsUserChatsModalOpen(true)} title="User Management & Chats" variant="ghost" size="md" className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"/>
                    <Button onClick={adminLogoutHandler} variant="danger" size="sm" leftIcon={<LogOut size={16}/>}> Logout Admin </Button>
                </div>
            </header>

            <AdminInsights stats={dashboardStats} isLoading={isInitialLoading} error={loadingError} />

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div className="space-y-6">
                    <AdminDocumentUpload onUploadSuccess={() => fetchAdminData(true)} />

                    <div className="card-base p-0 sm:p-4">
                        <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">Uploaded Subject Documents</h2>
                        {isInitialLoading && !documents.length && ( <div className="flex items-center justify-center p-6"> <Loader2 size={24} className="animate-spin text-primary mr-2" /> Loading documents... </div> )}
                        {loadingError && !documents.length && ( <div className="p-3 my-3 mx-4 sm:mx-0 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2"> <AlertTriangle size={18} /> {loadingError} <button onClick={() => fetchAdminData(true)} className="ml-auto text-xs underline hover:text-red-400">Retry</button> </div> )}
                        {!isInitialLoading && documents.length === 0 && !loadingError && ( <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0"> No subject documents uploaded yet. </p> )}
                        {documents.length > 0 && (
                            <div className="overflow-x-auto custom-scrollbar">
                                <table className="w-full text-sm text-left">
                                    <thead className="bg-gray-50 dark:bg-gray-800">
                                        <tr>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium">Original Name</th>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium hidden md:table-cell">Uploaded</th>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium">Analysis Status</th>
                                            <th className="px-3 sm:px-4 py-2.5 font-medium text-center">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {documents.map((doc) => (
                                            <tr key={doc.serverFilename} className="border-b border-border-light dark:border-border-dark hover:bg-gray-50/50 dark:hover:bg-gray-700/30 transition-colors">
                                                <td className="px-3 sm:px-4 py-2 truncate max-w-[150px] sm:max-w-xs" title={doc.originalName}>{doc.originalName}</td>
                                                <td className="px-3 sm:px-4 py-2 whitespace-nowrap hidden md:table-cell"> {doc.uploadedAt ? format(new Date(doc.uploadedAt), 'MMM d, yyyy HH:mm') : 'N/A'} </td>
                                                <td className="px-3 sm:px-4 py-2"> {(doc.hasFaq || doc.hasTopics || doc.hasMindmap) ? ( <span className="flex items-center text-green-600 dark:text-green-400 text-xs"><CheckCircle size={14} className="mr-1"/> Generated</span> ) : (doc.analysisUpdatedAt ? <span className="text-gray-500 dark:text-gray-400 text-xs">Empty/Skipped</span> : <span className="text-yellow-500 dark:text-yellow-400 text-xs">Pending</span>)} </td>
                                                <td className="px-1 sm:px-4 py-2 text-center whitespace-nowrap">
                                                    <IconButton icon={Eye} title="View Analysis" size="sm" variant="ghost" className="text-primary hover:text-primary-dark mr-0.5 sm:mr-1" onClick={() => handleViewAnalysis(doc)} disabled={isLoadingAnalysis && currentDocForModal?.serverFilename === doc.serverFilename} />
                                                    <IconButton icon={Trash2} title="Delete Document" size="sm" variant="ghost" className="text-red-500 hover:text-red-700" onClick={() => handleDeleteDocument(doc.serverFilename, doc.originalName)} />
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>
                </div>

                <div className="space-y-6">
                    <div className="card-base p-4">
                        <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark flex items-center gap-2">
                            <HelpCircle size={20} className="text-accent" /> Content Gap Analysis
                        </h2>
                        <div className="text-center py-8 px-4 border-2 border-dashed border-border-light dark:border-border-dark rounded-lg">
                            <p className="text-sm text-text-muted-light dark:text-text-muted-dark">This panel will show student questions that the chatbot could not answer from your documents.</p>
                            <p className="text-xs mt-1 text-text-muted-light/70 dark:text-text-muted-dark/70">(Feature Coming Soon)</p>
                        </div>
                    </div>
                    <div className="card-base p-4">
                         <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark flex items-center gap-2">
                            <Lightbulb size={20} className="text-accent" /> Frequently Asked Topics
                        </h2>
                        <div className="text-center py-8 px-4 border-2 border-dashed border-border-light dark:border-border-dark rounded-lg">
                            <p className="text-sm text-text-muted-light dark:text-text-muted-dark">This panel will show a word cloud or list of the most common topics students ask about.</p>
                            <p className="text-xs mt-1 text-text-muted-light/70 dark:text-text-muted-dark/70">(Feature Coming Soon)</p>
                        </div>
                    </div>
                </div>
            </div>

            {/* Modals */}
            <Modal isOpen={isAnalysisModalOpen} onClose={() => setIsAnalysisModalOpen(false)} title={`Analysis Results: ${currentDocForModal?.originalName || 'Document'}`} size="2xl">
                {renderAnalysisModalContent()}
            </Modal>
            <Modal isOpen={isSecurityModalOpen} onClose={() => setIsSecurityModalOpen(false)} title="Security Center" size="3xl">
                {isInitialLoading ? (
                    <div className="flex justify-center items-center p-8"> <Loader2 size={24} className="animate-spin text-primary inline-block mr-2" /> Loading Security Data... </div>
                ) : ( <ApiKeyRequestManager requests={keyRequests} onAction={() => fetchAdminData(true)} /> )}
            </Modal>
            <Modal isOpen={isUserChatsModalOpen} onClose={() => setIsUserChatsModalOpen(false)} title="User Session Summaries" size="4xl">
                {isInitialLoading ? (
                     <div className="flex justify-center items-center p-8"> <Loader2 size={24} className="animate-spin text-primary inline-block mr-2" /> Loading User Chat Data... </div>
                ) : ( <UserChatManager usersWithChats={usersWithChats} /> )}
            </Modal>
        </div>
    );
}

export default AdminDashboardPage;
```

`frontend/src/components/admin/AdminInsights.jsx`

```javascript
// frontend/src/components/admin/AdminInsights.jsx
import React from 'react';
import { Users, FileText, MessageSquare, KeyRound, AlertTriangle } from 'lucide-react';

const InsightCard = ({ title, value, icon: Icon, colorClass = 'text-primary' }) => (
    <div className="card-base p-4 flex items-start gap-4">
        <div className={`mt-1 flex-shrink-0 w-10 h-10 rounded-full flex items-center justify-center ${colorClass.replace('text-', 'bg-')}/10`}>
            <Icon size={20} className={colorClass} />
        </div>
        <div>
            <p className="text-sm font-medium text-text-muted-light dark:text-text-muted-dark">{title}</p>
            <p className="text-2xl font-bold text-text-light dark:text-text-dark">{value}</p>
        </div>
    </div>
);

function AdminInsights({ stats, isLoading, error }) {
    if (isLoading) {
        return (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
                {Array(4).fill(0).map((_, i) => (
                    <div key={i} className="card-base p-4 h-24 bg-gray-200 dark:bg-gray-700 animate-pulse"></div>
                ))}
            </div>
        );
    }
    
    if (error) {
        return (
            <div className="mb-6 p-4 bg-red-500/10 text-red-600 dark:text-red-300 rounded-lg flex items-center gap-3">
                <AlertTriangle size={24} />
                <div>
                    <p className="font-semibold">Could not load dashboard insights.</p>
                    <p className="text-sm">{error}</p>
                </div>
            </div>
        )
    }

    return (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
            <InsightCard title="Total Students" value={stats.totalUsers ?? 'N/A'} icon={Users} colorClass="text-blue-500" />
            <InsightCard title="Admin Documents" value={stats.totalAdminDocs ?? 'N/A'} icon={FileText} colorClass="text-green-500" />
            <InsightCard title="Total Chat Sessions" value={stats.totalSessions ?? 'N/A'} icon={MessageSquare} colorClass="text-indigo-500" />
            <InsightCard title="Pending API Requests" value={stats.pendingApiKeys ?? 'N/A'} icon={KeyRound} colorClass="text-yellow-500" />
        </div>
    );
}

export default AdminInsights;
```

`frontend/src/components/admin/AdminProtectedRoute.jsx`

```javascript
// frontend/src/components/admin/AdminProtectedRoute.jsx
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // Using AppStateContext
import toast from 'react-hot-toast'; // Optional: for a message if redirecting

function AdminProtectedRoute({ children }) { // Accept children for different react-router-dom versions
    const { isAdminSessionActive } = useAppState(); // Get the admin session flag
    const location = useLocation();

    if (!isAdminSessionActive) {
        // If admin session is not active, redirect the user.
        // Redirecting to the main page ('/') is a common approach.
        // The main App component's logic will then likely show the AuthModal
        // if no regular user is logged in either.
        console.log("AdminProtectedRoute: Admin session not active. Redirecting from", location.pathname);
        toast.error("Admin access required. Please log in as admin."); // Optional feedback
        return <Navigate to="/" state={{ from: location }} replace />;
    }

    // If admin session is active, render the child components (the protected route's content)
    return children ? children : <Outlet />; // Outlet is for v6 nested routes, children for direct wrapping
}

export default AdminProtectedRoute;
```

`frontend/src/components/admin/ApiKeyRequestManager.jsx`

```javascript
// frontend/src/components/admin/ApiKeyRequestManager.jsx
import React, { useState } from 'react';
import { formatDistanceToNow } from 'date-fns';
import { Check, X, Loader2 } from 'lucide-react';
import toast from 'react-hot-toast';
import * as adminApi from '../../services/adminApi.js';
import IconButton from '../core/IconButton.jsx';

function ApiKeyRequestManager({ requests, onAction }) {
    const [loadingStates, setLoadingStates] = useState({});

    const handleAction = async (userId, action) => {
        setLoadingStates(prev => ({ ...prev, [userId]: true }));
        const toastId = toast.loading(`${action === 'approve' ? 'Approving' : 'Rejecting'} request...`);
        
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            let response;
            if (action === 'approve') {
                response = await adminApi.approveApiKeyRequest(userId, authHeaders);
            } else {
                response = await adminApi.rejectApiKeyRequest(userId, authHeaders);
            }
            toast.success(response.message, { id: toastId });
            onAction(); // Trigger a refresh in the parent component
        } catch (error) {
            toast.error(error.message, { id: toastId });
        } finally {
            setLoadingStates(prev => ({ ...prev, [userId]: false }));
        }
    };

    return (
        <div className="card-base p-0 sm:p-4 mt-6">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">
                Pending API Key Requests
            </h2>
            {requests.length === 0 ? (
                <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                    No pending requests.
                </p>
            ) : (
                <div className="overflow-x-auto custom-scrollbar">
                    <table className="w-full text-sm text-left">
                        <thead className="bg-gray-50 dark:bg-gray-800">
                            <tr>
                                <th className="px-4 py-2.5 font-medium">User Email</th>
                                <th className="px-4 py-2.5 font-medium hidden md:table-cell">Name</th>
                                <th className="px-4 py-2.5 font-medium hidden lg:table-cell">Requested</th>
                                <th className="px-4 py-2.5 font-medium text-center">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            {requests.map((req) => (
                                <tr key={req._id} className="border-b border-border-light dark:border-border-dark">
                                    <td className="px-4 py-2 font-mono text-xs" title={req.email}>{req.email}</td>
                                    <td className="px-4 py-2 hidden md:table-cell">{req.profile?.name || 'N/A'}</td>
                                    <td className="px-4 py-2 hidden lg:table-cell" title={new Date(req.createdAt).toLocaleString()}>
                                        {formatDistanceToNow(new Date(req.createdAt), { addSuffix: true })}
                                    </td>
                                    <td className="px-4 py-2 text-center whitespace-nowrap">
                                        {loadingStates[req._id] ? (
                                            <Loader2 size={16} className="animate-spin text-primary inline-block" />
                                        ) : (
                                            <>
                                                <IconButton
                                                    icon={Check}
                                                    title="Approve Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-green-500 hover:text-green-700 dark:hover:text-green-400"
                                                    onClick={() => handleAction(req._id, 'approve')}
                                                />
                                                <IconButton
                                                    icon={X}
                                                    title="Reject Request"
                                                    size="sm"
                                                    variant="ghost"
                                                    className="text-red-500 hover:text-red-700 dark:hover:text-red-400"
                                                    onClick={() => handleAction(req._id, 'reject')}
                                                />
                                            </>
                                        )}
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            )}
        </div>
    );
}

export default ApiKeyRequestManager;
```

`frontend/src/components/admin/UserChatManager.jsx`

```javascript
// frontend/src/components/admin/UserChatManager.jsx
import React, { useState, useMemo } from 'react';
import { format, formatDistanceToNow } from 'date-fns';
import { User, MessageSquare, Clock, ChevronDown, AlertTriangle, Search } from 'lucide-react';

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        const date = new Date(dateString);
        return `${format(date, 'MMM d, yyyy HH:mm')} (${formatDistanceToNow(date, { addSuffix: true })})`;
    } catch (e) {
        return 'Invalid Date';
    }
};

function UserChatManager({ usersWithChats }) {
    const [searchTerm, setSearchTerm] = useState('');

    const filteredUsers = useMemo(() => {
        if (!searchTerm.trim()) {
            return usersWithChats;
        }
        const lowercasedFilter = searchTerm.toLowerCase();
        return usersWithChats.filter(({ user }) => 
            (user.name && user.name.toLowerCase().includes(lowercasedFilter)) ||
            (user.email && user.email.toLowerCase().includes(lowercasedFilter))
        );
    }, [usersWithChats, searchTerm]);

    return (
        <div className="card-base p-0 sm:p-4">
            <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3 px-4 sm:px-0 pt-4 sm:pt-0 gap-3">
                <h2 className="text-lg font-semibold text-text-light dark:text-text-dark flex-shrink-0">
                    User Chat Sessions
                </h2>
                <div className="relative w-full sm:w-auto sm:max-w-xs">
                    <input
                        type="text"
                        placeholder="Search by name or email..."
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                        className="input-field !py-2 !pl-9 !pr-3 text-sm w-full"
                    />
                    <Search className="absolute left-2.5 top-1/2 -translate-y-1/2 h-4 w-4 text-text-muted-light dark:text-text-muted-dark" />
                </div>
            </div>

            {filteredUsers.length === 0 ? (
                <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                    {searchTerm ? `No users found matching "${searchTerm}".` : "No user chat data available."}
                </p>
            ) : (
                <div className="space-y-3">
                    {filteredUsers.map(({ user, sessions }) => {
                        return (
                            <details key={user._id} className="group bg-surface-light dark:bg-gray-800/50 border border-border-light dark:border-border-dark rounded-lg overflow-hidden transition-all duration-200 open:shadow-lg open:ring-1 open:ring-primary/50">
                                <summary className="flex items-center justify-between p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700/50 transition-colors">
                                    <div className="flex items-center gap-3">
                                        <User className="text-primary" size={18} />
                                        <div>
                                            <p className="font-semibold text-sm text-text-light dark:text-text-dark">{user.name || 'Unnamed User'}</p>
                                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark">{user.email}</p>
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <span className="text-xs font-mono bg-gray-200 dark:bg-gray-700 px-2 py-0.5 rounded-full">{sessions.length} sessions</span>
                                        <ChevronDown size={20} className="group-open:rotate-180 transition-transform" />
                                    </div>
                                </summary>
                                <div className="border-t border-border-light dark:border-border-dark p-3 space-y-2 bg-white dark:bg-gray-800">
                                    {sessions.length > 0 ? sessions.map(session => {
                                        const hasValidSummary = session.summary && !session.summary.startsWith('Summary generation failed:');
                                        const isErrorSummary = session.summary && session.summary.startsWith('Summary generation failed:');

                                        return (
                                            <div key={session.sessionId} className={`p-2.5 border rounded-md ${isErrorSummary ? 'border-red-500/30 bg-red-500/5' : 'border-border-light dark:border-border-dark bg-gray-50 dark:bg-gray-900/50'}`}>
                                                
                                                {hasValidSummary && (
                                                    <p className="text-xs font-medium text-text-light dark:text-text-dark italic" title={session.summary}>
                                                        "{session.summary}"
                                                    </p>
                                                )}
                                                
                                                {isErrorSummary && (
                                                     <div className="flex items-start gap-2 text-red-600 dark:text-red-400">
                                                        <AlertTriangle size={14} className="mt-0.5 flex-shrink-0" />
                                                        <p className="text-xs font-semibold" title={session.summary}>
                                                            {session.summary}
                                                        </p>
                                                     </div>
                                                )}

                                                {!session.summary && (
                                                    <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark italic">
                                                        This session has not been summarized yet.
                                                    </p>
                                                )}

                                                <div className="flex items-center justify-between text-xs text-text-muted-light dark:text-text-muted-dark mt-2 pt-2 border-t border-dashed">
                                                    <span className="flex items-center gap-1"><MessageSquare size={12} /> {session.messageCount} msgs</span>
                                                    <span className="flex items-center gap-1"><Clock size={12} /> {formatDate(session.updatedAt)}</span>
                                                </div>
                                            </div>
                                        )
                                    }) : <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark p-2">This user has no chat sessions.</p>}
                                </div>
                            </details>
                        )
                    })}
                </div>
            )}
        </div>
    );
}

export default UserChatManager;
```

`frontend/src/components/analysis/AnalysisTool.jsx`

```javascript
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js'; // For user documents
import * as adminApi from '../../services/adminApi.js'; // For admin documents
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.", // Added for admin docs
    "Retrieved stored admin analysis." // Added for admin docs
];

// Added isTargetAdminDoc prop
function AnalysisTool({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => { // Reset when selected document changes
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => { // Prism for modal content
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => { // Prism for AI reasoning
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                console.log(`AnalysisToolRunner: Fetching ADMIN analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const authHeaders = adminApi.getFixedAdminAuthHeaders(); // Get admin auth
                // Fetches { originalName, serverFilename, analysis: {faq, topics, mindmap}, analysisUpdatedAt }
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                        // Content for this specific analysis type is empty or null
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}". The admin might not have generated this specific analysis type yet, or it was empty.`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc "${selectedDocumentFilename}".`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title} for "${selectedDocumentFilename}"!`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found or response format invalid for document "${selectedDocumentFilename}".`);
                }
            } else { // User document
                console.log(`AnalysisToolRunner: Requesting USER analysis for "${selectedDocumentFilename}", type: ${toolType}`);
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload); // This uses the mock/frontend API for user docs
                // The success toast for user docs is handled inside api.requestAnalysis mock for now.
                // If it were a real API, we might add toast.success here.
                // For consistency with admin path:
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated for "${selectedDocumentFilename}"!`, { id: toastId });
                } else {
                    toast.dismiss(toastId); // Dismiss loading if there was an issue caught below
                }
            }

            // Common response processing
            if (response) {
                if (response.content && response.content.trim() !== "" && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content && (response.content.startsWith("Error:") || response.content.startsWith("Notice:"))) {
                    // If it's an error or notice, display it as content but also set error state
                    setAnalysisContent(response.content); // Display the error/notice in the content area
                    setError(response.content); // Also set the error state for styling/logging
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else { // No content, but not an explicit error/notice in response.content
                    setAnalysisContent(`No content was returned for ${title}.`); // Display this
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content was generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content was generated for ${title}.`);
                }

                if (response.thinking && response.thinking.trim() !== "") {
                    setAiReasoning(response.thinking);
                } else {
                    setAiReasoning(response.content ? "Retrieved analysis. No detailed AI reasoning provided." : "AI reasoning not available.");
                }
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to generate or fetch ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`); // Display error in content area too
            toast.error(errorMessage);
            console.error(`Run ${title} Analysis Error:`, err);
            setIsDropdownOpen(false);
        } finally {
            setIsLoading(false);
        }
    };

    const handleDownloadMindmap = async (format = 'svg') => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    if (saveSvgAsPng) {
                        saveSvgAsPng(svgElement, filename, {
                            scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF'
                        });
                        toast.success("PNG download started!", { id: pngToastId });
                    } else { throw new Error("saveSvgAsPng function not found."); }
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48">
                       <Loader2 size={32} className="animate-spin text-primary" />
                       <p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p>
                   </div>;
        }
        // Display error directly if it's set and no other content (or if content is the error itself)
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center">
                       <MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} />
                   </div>;
        }
        return <div ref={modalAnalysisContentRef}
                    className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed"
                    dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div
                    className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors"
                    onClick={() => setIsSectionOpen(!isSectionOpen)}
                    aria-expanded={isSectionOpen}
                >
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button
                        onClick={handleRunAnalysis} variant="primary" size="sm"
                        className="!px-3 !py-1 text-xs" isLoading={isLoading}
                        disabled={!selectedDocumentFilename || isLoading}
                        title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}
                    >
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton
                        icon={isSectionOpen ? ChevronUp : ChevronDown}
                        onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost"
                        className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"}
                        disabled={isLoading && isSectionOpen}
                    />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div
                        key="tool-section-content" initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.25, ease: "easeInOut" }}
                        className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden"
                    >
                        {isLoading && (
                            <div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn">
                                <Loader2 size={14} className="animate-spin"/> {currentEngagementText}
                            </div>
                        )}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && ( // Show error only if no other content or content is the error
                            <div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1">
                                <AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}
                            </div>
                        )}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div
                                key="analysis-dropdown" initial={{ opacity: 0, y: -10 }}
                                animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }}
                                transition={{ duration: 0.2 }} className="mt-2 space-y-2"
                            >
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md">
                                            <span className="flex items-center gap-1.5 font-medium">
                                                <Sparkles size={14} className="text-accent" /> AI Reasoning
                                            </span>
                                            <ChevronDown size={16} className="group-open:rotate-180 transition-transform" />
                                        </summary>
                                        <div ref={aiReasoningContentRef}
                                            className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md"
                                            dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && (!error || analysisContent !== error) && ( // Show view button if content is not the error message itself
                                     <Button
                                        onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth
                                        leftIcon={<Eye size={14}/>}
                                        className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10"
                                    >View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">
                                {selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}
                            </p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={<>
                        {toolType === 'mindmap' && analysisContent && (
                            <><Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                             <div className="flex-grow"></div></>
                        )}
                        <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs">Close</Button>
                    </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisTool;
```

`frontend/src/components/analysis/AnalysisToolRunner.jsx`

```javascript
// frontend/src/components/analysis/AnalysisToolRunner.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js';
import * as adminApi from '../../services/adminApi.js';
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download, FileText, FileBarChart2 } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html);
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true },
        ADD_TAGS: ['iframe'],
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const localParseAnalysisOutput = (rawOutput) => {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content.",
    "Retrieved stored admin analysis entry, but content for this type was empty.",
    "Retrieved stored admin analysis."
];

function AnalysisToolRunner({ toolType, title, iconName, selectedDocumentFilename, isTargetAdminDoc }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');
    const [generatingDocType, setGeneratingDocType] = useState(null);

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null);
    const { theme: appTheme } = useAppState();

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => {
        if (!selectedDocumentFilename) {
            setIsLoading(false); setError(''); setAnalysisContent(null);
            setAiReasoning(null); setIsDropdownOpen(false);
        } else {
             setAnalysisContent(null); setAiReasoning(null);
             setIsDropdownOpen(false); setError(''); setIsLoading(false);
        }
    }, [selectedDocumentFilename]);

    useEffect(() => {
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => {
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true); setError(''); setAnalysisContent(null);
        setAiReasoning(null); setIsDropdownOpen(false);

        const toastMessage = isTargetAdminDoc
            ? `Fetching stored ${title.toLowerCase()} for "${selectedDocumentFilename}"...`
            : `Generating ${title.toLowerCase()} for "${selectedDocumentFilename}"...`;
        const toastId = toast.loading(toastMessage);

        try {
            let response;
            if (isTargetAdminDoc) {
                const authHeaders = adminApi.getFixedAdminAuthHeaders();
                const adminAnalysisData = await adminApi.getAdminDocumentAnalysisByOriginalName(selectedDocumentFilename, authHeaders);

                if (adminAnalysisData && adminAnalysisData.analysis && adminAnalysisData.analysis[toolType] !== undefined) {
                    const rawOutput = adminAnalysisData.analysis[toolType];
                    if (rawOutput === null || typeof rawOutput !== 'string' || rawOutput.trim() === "") {
                         response = {
                            content: `Notice: No stored ${toolType} analysis found for admin document "${selectedDocumentFilename}".`,
                            thinking: "Retrieved stored admin analysis entry, but content for this type was empty."
                        };
                        toast.success(`No stored ${toolType} found for admin doc.`, { id: toastId });
                    } else {
                        const parsed = localParseAnalysisOutput(rawOutput);
                        response = { content: parsed.content, thinking: parsed.thinking || "Retrieved stored admin analysis." };
                        toast.success(`Retrieved stored admin ${title}.`, { id: toastId });
                    }
                } else {
                    throw new Error(`Admin analysis for type '${toolType}' not found.`);
                }
            } else {
                const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
                response = await api.requestAnalysis(payload);
                if (response && response.content && !response.content.startsWith("Error:")) {
                    toast.success(`${title} generated!`, { id: toastId });
                } else {
                    toast.dismiss(toastId);
                }
            }

            if (response) {
                if (response.content && !response.content.startsWith("Error:") && !response.content.startsWith("Notice:")) {
                    setAnalysisContent(response.content);
                } else if (response.content) {
                    setAnalysisContent(response.content);
                    setError(response.content);
                    if (response.content.startsWith("Error:")) {
                         if (toast.isActive(toastId)) toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`, { id: toastId });
                         else toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                    }
                } else {
                    setAnalysisContent(`No content was returned for ${title}.`);
                    setError(`No content returned for ${title}.`);
                    if (toast.isActive(toastId)) toast.warn(`No content generated for ${title}.`, { id: toastId });
                    else toast.warn(`No content generated for ${title}.`);
                }
                setAiReasoning(response.thinking || "AI reasoning not available.");
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty or invalid response from analysis service.");
            }
        } catch (err) {
            if (toast.isActive(toastId)) toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to process ${title}.`;
            setError(errorMessage);
            setAnalysisContent(`Error: ${errorMessage}`);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };

    const handleGenerateDocument = async (docType) => {
        if (!analysisContent || generatingDocType) {
            return;
        }

        setGeneratingDocType(docType);
        const toastId = toast.loading(`Generating ${docType.toUpperCase()} document...`);

        try {
            const fullMarkdownContent = `## ${title}\n\n**Source Document:** \`${selectedDocumentFilename}\`\n\n---\n\n${analysisContent}`;
            
            const { fileBlob, filename } = await api.generateDocument({
                markdownContent: fullMarkdownContent,
                docType: docType,
                sourceDocumentName: selectedDocumentFilename
            });
            
            const url = window.URL.createObjectURL(fileBlob);
            const link = document.createElement('a');
            link.href = url;
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);

            toast.success(`${docType.toUpperCase()} document downloaded.`, { id: toastId });

        } catch (err) {
            toast.error(`Failed to generate document: ${err.message}`, { id: toastId });
        } finally {
            setGeneratingDocType(null);
        }
    };

    const handleDownloadMindmap = async (format) => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }
            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;
            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url; link.download = filename; document.body.appendChild(link);
                link.click(); document.body.removeChild(link); URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    saveSvgAsPng(svgElement, filename, { scale: 2, backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF' });
                    toast.success("PNG download started!", { id: pngToastId });
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer not ready or SVG not available.");
        }
    };

    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return <div className="flex items-center justify-center h-48"><Loader2 size={32} className="animate-spin text-primary" /><p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p></div>;
        }
        if (error && (!analysisContent || analysisContent === error)) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }
        if (toolType === 'mindmap') {
            return <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center"><MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} /></div>;
        }
        return <div ref={modalAnalysisContentRef} className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed" dangerouslySetInnerHTML={createMarkup(analysisContent)} />;
    };

    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors" onClick={() => setIsSectionOpen(!isSectionOpen)} aria-expanded={isSectionOpen}>
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button onClick={handleRunAnalysis} variant="primary" size="sm" className="!px-3 !py-1 text-xs" isLoading={isLoading} disabled={!selectedDocumentFilename || isLoading} title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}>
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton icon={isSectionOpen ? ChevronUp : ChevronDown} onClick={() => setIsSectionOpen(!isSectionOpen)} size="sm" variant="ghost" className="p-1" aria-label={isSectionOpen ? "Collapse section" : "Expand section"} disabled={isLoading && isSectionOpen} />
                </div>
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div key="tool-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.25, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        {isLoading && (<div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn"><Loader2 size={14} className="animate-spin"/> {currentEngagementText}</div>)}
                        {error && !isLoading && (!analysisContent || analysisContent === error) && (<div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1"><AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}</div>)}
                        {!isLoading && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div key="analysis-dropdown" initial={{ opacity: 0, y: -10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -10 }} transition={{ duration: 0.2 }} className="mt-2 space-y-2">
                                {showReasoning && aiReasoning && (
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md"><span className="flex items-center gap-1.5 font-medium"><Sparkles size={14} className="text-accent" /> AI Reasoning</span><ChevronDown size={16} className="group-open:rotate-180 transition-transform" /></summary>
                                        <div ref={aiReasoningContentRef} className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md" dangerouslySetInnerHTML={createMarkup(aiReasoning)} />
                                    </details>
                                )}
                                {analysisContent && !error && (
                                     <Button onClick={() => setIsModalOpen(true)} variant="outline" size="sm" fullWidth leftIcon={<Eye size={14}/>} className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10">View Full {title}</Button>
                                )}
                            </motion.div>
                        )}
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">{selectedDocumentFilename ? `Click "Run" to ${isTargetAdminDoc ? 'fetch stored' : 'generate'} ${title.toLowerCase()} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}</p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>
            <Modal
                isOpen={isModalOpen} onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={
                <>
                    {toolType === 'mindmap' && analysisContent && !error && (
                        <Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                    )}
                    
                    {toolType !== 'mindmap' && analysisContent && !error && (
                        <>
                           <Button 
                                onClick={() => handleGenerateDocument('pptx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileBarChart2 size={14}/>}
                                isLoading={generatingDocType === 'pptx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'pptx' ? 'Generating...' : 'Generate PPTX'}
                            </Button>
                           <Button 
                                onClick={() => handleGenerateDocument('docx')} 
                                variant="outline" size="sm" className="text-xs" 
                                leftIcon={<FileText size={14}/>}
                                isLoading={generatingDocType === 'docx'}
                                disabled={!!generatingDocType}
                            >
                                {generatingDocType === 'docx' ? 'Generating...' : 'Generate DOCX'}
                            </Button>
                        </>
                    )}

                    <div className="flex-grow"></div>
                    <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs" disabled={!!generatingDocType}>
                        Close
                    </Button>
                </>}
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}

export default AnalysisToolRunner;
```

`frontend/src/components/analysis/KnowledgeGraphViewer.jsx`

```javascript
// frontend/src/components/analysis/KnowledgeGraphViewer.jsx
import React, { useEffect, useState, useMemo } from 'react';
import Graph from 'react-vis-network-graph';
import { Loader2, AlertTriangle, ZoomIn, ZoomOut, Maximize } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';
import IconButton from '../core/IconButton.jsx';

const KnowledgeGraphViewer = ({ graphData }) => {
    const { theme } = useTheme();

    // --- FIX START: Add state to hold the network instance ---
    const [network, setNetwork] = useState(null);
    // --- FIX END ---

    // Memoize options to prevent re-renders
    const options = useMemo(() => {
        const isDark = theme === 'dark';
        return {
            layout: {
                hierarchical: {
                    enabled: true,
                    direction: 'UD', // Up-Down
                    sortMethod: 'directed',
                    levelSeparation: 150,
                    nodeSpacing: 200,
                },
            },
            nodes: {
                shape: 'box',
                borderWidth: 1.5,
                font: {
                    color: isDark ? '#E2E8F0' : '#0F172A',
                    size: 14,
                    face: 'Inter',
                },
                color: {
                    border: isDark ? '#4B5563' : '#9CA3AF',
                    background: isDark ? '#1E293B' : '#FFFFFF',
                    highlight: {
                        border: '#3b82f6',
                        background: isDark ? '#2563eb' : '#60a5fa',
                    },
                },
                shadow: true,
            },
            edges: {
                color: {
                    color: isDark ? '#64748B' : '#9CA3AF',
                    highlight: '#3b82f6',
                },
                arrows: {
                    to: { enabled: true, scaleFactor: 0.7 },
                },
                font: {
                    color: isDark ? '#94A3B8' : '#6B7280',
                    size: 10,
                    align: 'middle',
                    strokeWidth: 2,
                    strokeColor: isDark ? '#1E293B' : '#FFFFFF',
                },
                smooth: {
                    type: 'cubicBezier',
                    forceDirection: 'vertical',
                    roundness: 0.4,
                },
            },
            physics: {
                enabled: true,
                hierarchicalRepulsion: {
                    centralGravity: 0.0,
                    springLength: 100,
                    springConstant: 0.01,
                    nodeDistance: 200,
                    damping: 0.09,
                },
                solver: 'hierarchicalRepulsion',
            },
            interaction: {
                dragNodes: true,
                dragView: true,
                zoomView: true,
                tooltipDelay: 200,
            },
            height: '100%',
            width: '100%',
        };
    }, [theme]);

    const formattedGraph = useMemo(() => {
        if (!graphData || !graphData.nodes || !graphData.edges) {
            return { nodes: [], edges: [] };
        }
        const nodes = graphData.nodes.map(node => ({
            id: node.id,
            label: node.id,
            title: `Type: ${node.type}\nParent: ${node.parent || 'N/A'}\n\n${node.description}`,
            color: node.type === 'major' 
                ? { border: '#3b82f6', background: theme === 'dark' ? '#1E3A8A' : '#BFDBFE' } 
                : undefined,
        }));
        const edges = graphData.edges.map(edge => ({
            from: edge.from,
            to: edge.to,
            label: edge.relationship.replace(/_/g, ' '),
        }));
        return { nodes, edges };
    }, [graphData, theme]);

    // --- FIX START: These handlers will now work because 'network' is in state ---
    const handleZoomIn = () => network?.zoomIn();
    const handleZoomOut = () => network?.zoomOut();
    const handleFit = () => network?.fit();
    // --- FIX END ---

    if (!graphData) {
        return (
            <div className="flex items-center justify-center h-full">
                <Loader2 className="animate-spin text-primary mr-2" /> Loading graph data...
            </div>
        );
    }

    if (graphData.error) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-red-500">
                <AlertTriangle size={32} className="mb-2" />
                <p className="font-semibold">Failed to load Knowledge Graph</p>
                <p className="text-xs">{graphData.error}</p>
            </div>
        );
    }
    
    if (formattedGraph.nodes.length === 0) {
        return (
             <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark">
                <AlertTriangle size={32} className="mb-2" />
                <p>No graph data found for this document.</p>
             </div>
        );
    }

    return (
        <div className="relative w-full h-[70vh] border border-border-light dark:border-border-dark rounded-md bg-gray-50 dark:bg-gray-800/50">
            <Graph
                key={theme}
                graph={formattedGraph}
                options={options}
                // --- FIX START: Use the 'getNetwork' callback to update our state ---
                getNetwork={net => setNetwork(net)}
                // --- FIX END ---
            />
            <div className="absolute top-2 right-2 flex flex-col gap-1.5 bg-surface-light dark:bg-surface-dark p-1.5 rounded-md shadow-lg border border-border-light dark:border-border-dark">
                <IconButton icon={ZoomIn} onClick={handleZoomIn} title="Zoom In" size="sm" />
                <IconButton icon={ZoomOut} onClick={handleZoomOut} title="Zoom Out" size="sm" />
                <IconButton icon={Maximize} onClick={handleFit} title="Fit to View" size="sm" />
            </div>
        </div>
    );
};

export default KnowledgeGraphViewer;
```

`frontend/src/components/analysis/MindmapViewer.jsx`

```javascript
// frontend/src/components/analysis/MindmapViewer.jsx
import React, { useEffect, useRef, useState, useImperativeHandle, forwardRef } from 'react';
import toast from 'react-hot-toast';
import { escapeHtml } from '../../utils/helpers.js';

const MindmapViewer = forwardRef(({ mermaidCode }, ref) => {
    const svgContainerRef = useRef(null);
    const [error, setError] = useState(null);
    const [isMermaidReady, setIsMermaidReady] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [uniqueId] = useState(() => `mermaid-graph-${Math.random().toString(36).substr(2, 9)}`);

    useImperativeHandle(ref, () => ({
        getSvgElement: () => {
            return svgContainerRef.current?.querySelector('svg');
        }
    }));

    useEffect(() => {
        if (typeof window.mermaid !== 'undefined') {
            setIsMermaidReady(true);
        } else {
            const intervalId = setInterval(() => {
                if (typeof window.mermaid !== 'undefined') {
                    setIsMermaidReady(true);
                    clearInterval(intervalId);
                }
            }, 100);
            return () => clearInterval(intervalId);
        }
    }, []);

    useEffect(() => {
        if (!isMermaidReady || !mermaidCode || !svgContainerRef.current) {
            if (svgContainerRef.current) svgContainerRef.current.innerHTML = '';
            setError(null);
            setIsLoading(false);
            return;
        }

        const renderMermaidDiagram = async () => {
            setIsLoading(true);
            setError(null);
            if (!svgContainerRef.current) {
                setIsLoading(false);
                return;
            }
            svgContainerRef.current.innerHTML = '<div class="flex justify-center items-center h-full w-full text-sm text-text-muted-light dark:text-text-muted-dark"><div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-primary mr-2"></div>Rendering diagram...</div>';
            
            let codeToRender = mermaidCode.trim();
            
            // --- THIS IS THE FIX ---
            // New, more robust regex to find the diagram code.
            // It looks for a code block that CONTAINS a known diagram type (e.g., 'graph', 'mindmap').
            // It is no longer anchored to the start (^) of the string, so it can find the
            // block even if there's leading garbage or extra backticks from the LLM.
            const fenceRegex = /```(?:mermaid)?\s*([\s\S]*?(?:graph|mindmap|flowchart|sequenceDiagram)[\s\S]*?)\s*```/i;
            const match = codeToRender.match(fenceRegex);

            if (match && match[1]) {
                // If we found a fenced block, use its content.
                codeToRender = match[1].trim();
            } else {
                // Fallback for cases where LLM might forget the fences entirely.
                // We still trim to remove potential whitespace.
                codeToRender = codeToRender.trim();
            }
            // --- END OF FIX ---

            try {
                if (typeof window.mermaid === 'undefined') {
                    throw new Error("Mermaid library failed to load or initialize properly.");
                }

                const { svg, bindFunctions } = await window.mermaid.render(uniqueId, codeToRender);
                
                if (svgContainerRef.current) {
                    svgContainerRef.current.innerHTML = svg;
                    if (bindFunctions) {
                        bindFunctions(svgContainerRef.current);
                    }
                    const svgElement = svgContainerRef.current.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto'; 
                        svgElement.style.maxWidth = '100%'; 
                        svgElement.style.display = 'block';
                    }
                }
            } catch (e) {
                console.error("Error rendering Mermaid diagram with input:", codeToRender, e);
                const errorMsg = e.message || "Failed to render mind map. Invalid Mermaid syntax?";
                setError(errorMsg);
                if (svgContainerRef.current) {
                    const codeSnippet = escapeHtml(codeToRender.substring(0, 200) + (codeToRender.length > 200 ? "..." : ""));
                    svgContainerRef.current.innerHTML = `<div class="p-4 text-center text-red-500 dark:text-red-400 text-xs break-all"><strong>Error rendering:</strong> ${escapeHtml(errorMsg)}<br><strong class='mt-2 block'>Input Code (first 200 chars):</strong><pre class='text-left text-xs bg-gray-100 dark:bg-gray-700 p-2 rounded mt-1 whitespace-pre-wrap'>${codeSnippet}</pre></div>`;
                }
            } finally {
                setIsLoading(false);
            }
        };

        const timer = setTimeout(renderMermaidDiagram, 100); 
        return () => clearTimeout(timer);
        
    }, [mermaidCode, uniqueId, isMermaidReady]);

    if (!isMermaidReady && !error) {
      return <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark text-xs">Waiting for Mermaid.js library...</div>;
    }
    if (error && (!isLoading || (svgContainerRef.current && svgContainerRef.current.innerHTML.includes('Error rendering')))) {
        return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
                {/* Error message will be injected by useEffect's catch block */}
               </div>;
    }
    
    if (isLoading) { 
         return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
            {/* Loading message is set by renderMermaidDiagram's initial innerHTML write */}
         </div>;
    }

    if (!mermaidCode && !error && isMermaidReady) { 
        return <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark p-4">No mind map data to display.</p>;
    }
    
    return (
        <div 
            ref={svgContainerRef} 
            className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md"
        >

        </div>
    );
});

export default MindmapViewer;

```

`frontend/src/components/analysis/PodcastGenerator.jsx`

```javascript
// frontend/src/components/analysis/PodcastGenerator.jsx
import React, { useState } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { Headphones, ChevronDown, ChevronUp } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion, AnimatePresence } from 'framer-motion';

function PodcastGenerator({ selectedDocumentFilename }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isLoading, setIsLoading] = useState(false);
    const [podcastPurpose, setPodcastPurpose] = useState('review');
    const [podcastLength, setPodcastLength] = useState('standard');

    const handleGeneratePodcast = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true);
        const toastId = toast.loading("Generating high-quality podcast script & audio. This may take a moment...");
        try {
            const { audioBlob, sourceDocumentName } = await api.generatePodcast({
                analysisContent: `A study session on: ${selectedDocumentFilename}`,
                sourceDocumentName: selectedDocumentFilename,
                podcastOptions: { studyPurpose: podcastPurpose, sessionLength: podcastLength }
            });
            
            toast.success("High-Quality Podcast is ready for download!", { id: toastId, duration: 5000 });

            const url = window.URL.createObjectURL(audioBlob);
            const link = document.createElement('a');
            const safeFilename = sourceDocumentName.split('.')[0].replace(/[^a-zA-Z0-9]/g, '_');
            link.href = url;
            link.setAttribute('download', `AI_Podcast_${safeFilename}.mp3`);
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            window.URL.revokeObjectURL(url);
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || "Failed to generate podcast.";
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between cursor-pointer" onClick={() => setIsSectionOpen(!isSectionOpen)}>
                <div className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark">
                    <Headphones size={16} className="text-accent" />
                    <span className="flex-grow">HQ Podcast Generator</span>
                </div>
                {isSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </div>
            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden">
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-3">
                            Generate a high-quality, conversational audio study session from the selected document.
                        </p>
                        <div className="flex flex-col sm:flex-row gap-2 mb-3">
                            <div className="flex-1">
                                <label htmlFor="podcast-purpose" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Purpose</label>
                                <select id="podcast-purpose" value={podcastPurpose} onChange={(e) => setPodcastPurpose(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="review">General Review</option>
                                    <option value="introduction">Introduction</option>
                                    <option value="exam_prep">Exam Prep</option>
                                    <option value="deep_dive">Deep Dive</option>
                                </select>
                            </div>
                            <div className="flex-1">
                                <label htmlFor="podcast-length" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Length</label>
                                <select id="podcast-length" value={podcastLength} onChange={(e) => setPodcastLength(e.target.value)} className="input-field !text-xs !py-1.5 !px-2 w-full" disabled={isLoading}>
                                    <option value="quick">Quick (~5-7m)</option>
                                    <option value="standard">Standard (~10-15m)</option>
                                    <option value="comprehensive">Comprehensive (~15-25m)</option>
                                </select>
                            </div>
                        </div>
                        <Button
                            onClick={handleGeneratePodcast}
                            variant="primary"
                            size="sm"
                            fullWidth
                            isLoading={isLoading}
                            disabled={!selectedDocumentFilename || isLoading}
                            title={!selectedDocumentFilename ? "Select a document first" : "Generate Podcast"}
                        >
                           {isLoading ? 'Generating Audio...' : 'Generate High-Quality Podcast'}
                        </Button>
                    </motion.div>
                )}
            </AnimatePresence>
        </div>
    );
}

export default PodcastGenerator;
// This code defines a React component for generating podcasts from selected documents.

```

`frontend/src/components/analysis/RealtimeKgPanel.jsx`

```javascript
// frontend/src/components/analysis/RealtimeKgPanel.jsx
import React, { useEffect, useState, useCallback } from 'react';
import ReactFlow, { MiniMap, Controls, Background, useNodesState, useEdgesState } from 'reactflow';
import 'reactflow/dist/style.css';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import api from '../../services/api.js';
import { Loader2, AlertTriangle, RefreshCw } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';

const layoutNodes = (nodes, edges) => {
    const nodeMap = new Map(nodes.map(n => [n.id, n]));
    const childrenMap = new Map();
    edges.forEach(edge => {
        if (!childrenMap.has(edge.source)) childrenMap.set(edge.source, []);
        childrenMap.get(edge.source).push(edge.target);
    });

    const positionedNodes = new Set();

    const positionNode = (nodeId, x, level) => {
        if (positionedNodes.has(nodeId)) return;
        const node = nodeMap.get(nodeId);
        if (!node) return;
        
        node.position = { x: x + (Math.random() * 50 - 25), y: level * 150 };
        positionedNodes.add(nodeId);
        
        const children = childrenMap.get(nodeId) || [];
        const childWidth = children.length > 0 ? 300 * children.length : 0;
        let currentX = x - childWidth / 2 + 150;

        children.forEach(childId => {
            positionNode(childId, currentX, level + 1);
            currentX += 300;
        });
    };
    
    const targetNodes = new Set(edges.map(e => e.target));
    const rootNodes = nodes.filter(n => !targetNodes.has(n.id));
    
    let currentX = 0;
    rootNodes.forEach(root => {
        positionNode(root.id, currentX, 0);
        currentX += (childrenMap.get(root.id)?.length || 1) * 300;
    });

    return nodes;
};

const RealtimeKgPanel = () => {
    const { currentSessionId } = useAppState();
    const [nodes, setNodes, onNodesChange] = useNodesState([]);
    const [edges, setEdges, onEdgesChange] = useEdgesState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState('');

    const fetchAndLayoutGraph = useCallback(async () => {
        if (!currentSessionId) {
            setError("No active session found.");
            setIsLoading(false);
            return;
        }
        setIsLoading(true);
        setError('');
        try {
            const graphData = await api.getSessionKnowledgeGraph(currentSessionId);
            if (graphData && graphData.nodes && graphData.edges) {
                if (graphData.nodes.length === 0) {
                     setNodes([]);
                     setEdges([]);
                     return;
                }
                const reactFlowNodes = graphData.nodes.map(n => ({
                    id: n.id,
                    data: { label: n.id },
                    position: { x: 0, y: 0 }
                }));
                const reactFlowEdges = graphData.edges.map((e, i) => ({
                    id: `e${i}-${e.from}-${e.to}`,
                    source: e.from,
                    target: e.to,
                    label: e.relationship.replace(/_/g, ' '),
                    animated: true
                }));
                
                const laidOutNodes = layoutNodes(reactFlowNodes, reactFlowEdges);
                setNodes(laidOutNodes);
                setEdges(reactFlowEdges);
            }
        } catch (err) {
            setError(err.message || 'Failed to fetch knowledge graph.');
        } finally {
            setIsLoading(false);
        }
    }, [currentSessionId, setNodes, setEdges]);

    useEffect(() => {
        fetchAndLayoutGraph();
    }, [fetchAndLayoutGraph]);

    // The component now returns the graph canvas directly, without extra headers or borders.
    return (
        <div className="h-full w-full relative bg-gray-50 dark:bg-gray-800/50 rounded-md">
            {isLoading && <Loader2 className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 animate-spin text-primary z-10" />}
            {error && <div className="p-4 text-center text-red-500 text-sm"><AlertTriangle className="mx-auto mb-2"/>{error}</div>}
            
            {!isLoading && !error && nodes.length === 0 && (
                <div className="flex items-center justify-center h-full text-center text-text-muted-light dark:text-text-muted-dark">
                    <p>No concepts have been mapped from this conversation yet. <br/> Continue chatting to build the map!</p>
                </div>
            )}

            {!isLoading && !error && nodes.length > 0 && (
                <ReactFlow
                    nodes={nodes}
                    edges={edges}
                    onNodesChange={onNodesChange}
                    onEdgesChange={onEdgesChange}
                    fitView
                    className="bg-background-light dark:bg-background-dark"
                >
                    <Controls />
                    <MiniMap />
                    <Background variant="dots" gap={12} size={1} />
                </ReactFlow>
            )}
             <IconButton 
                icon={RefreshCw} 
                onClick={fetchAndLayoutGraph} 
                size="sm" 
                title="Refresh Graph" 
                isLoading={isLoading}
                className="absolute top-2 right-2 z-10 bg-surface-light dark:bg-surface-dark shadow-md"
            />
        </div>
    );
};

export default RealtimeKgPanel;
```

`frontend/src/components/analysis/RightPanel.jsx`

```javascript
// // frontend/src/components/layout/RightPanel.jsx
// import React, { useState } from 'react';
// import { useAppState } from '../../contexts/AppStateContext';
// import AnalysisTool from '../analysis/AnalysisTool.jsx'; // Added .jsx
// import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
// import IconButton from '../core/IconButton.jsx'; // Added .jsx
// import { motion } from 'framer-motion';

// function RightPanel() {
//     const { setIsRightPanelOpen, selectedDocumentForAnalysis } = useAppState();
//     const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

//     const currentSelectedDocFilename = selectedDocumentForAnalysis?.originalName || null;

//     return (
//         <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
//             <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
//                 <h2 className="text-base font-semibold">Advanced Analyzer</h2>
//                 <IconButton 
//                     icon={PanelRightClose} 
//                     onClick={() => setIsRightPanelOpen(false)} 
//                     title="Close Analyzer Panel"
//                     variant="ghost"
//                     size="sm"
//                     className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
//                 />
//             </div>
            
//             <button 
//                 onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
//                 className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
//             >
//                 <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
//                 {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
//             </button>

//             {isAnalyzerOpen && (
//                 <motion.div 
//                     initial={{ height: 0, opacity: 0 }} 
//                     animate={{ height: 'auto', opacity: 1 }} 
//                     exit={{ height: 0, opacity: 0 }}
//                     transition={{ duration: 0.2, ease: "easeInOut" }}
//                     className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
//                 >
//                     {!currentSelectedDocFilename && (
//                         <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
//                             <p>Select a document from the left panel to enable analysis tools.</p>
//                         </div>
//                     )}
//                     <AnalysisTool toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} />
//                     <AnalysisTool toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} />
//                 </motion.div>
//             )}
//         </div>
//     );
// }
// export default RightPanel;











// frontend/src/components/analysis/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
// FIX: Use the new, more capable AnalysisToolRunner component
import AnalysisToolRunner from './AnalysisToolRunner.jsx'; // FIX: Corrected relative import path
import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

function RightPanel() {
    // FIX: Get selectedSubject to determine if the document is an admin document
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    // FIX: Logic corrected to handle filename string directly
    const currentSelectedDocFilename = selectedDocumentForAnalysis || null;
    // FIX: Add logic to determine if the selected document is a "Subject" (admin doc)
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    return (
        <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                <IconButton
                    icon={PanelRightClose}
                    onClick={() => setIsRightPanelOpen(false)}
                    title="Close Analyzer Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>

            <button
                onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
                className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
            >
                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </button>

            {isAnalyzerOpen && (
                <motion.div
                    initial={{ height: 0, opacity: 0 }}
                    animate={{ height: 'auto', opacity: 1 }}
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
                >
                    {!currentSelectedDocFilename && (
                        <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable analysis tools.</p>
                        </div>
                    )}
                    {/* FIX: Use AnalysisToolRunner and pass the isTargetAdminDoc prop */}
                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                </motion.div>
            )}
        </div>
    );
}
export default RightPanel;
```

`frontend/src/components/auth/AuthModal.jsx`

```javascript
// frontend/src/components/auth/AuthModal.jsx
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../hooks/useAuth.jsx';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import LLMSelection from './LLMSelection.jsx';
import toast from 'react-hot-toast';
import { LogIn, UserPlus, X, KeyRound, AtSign, AlertCircle, HardDrive, CheckSquare, Square, User, School, Hash, Award, Wrench, Calendar, Lightbulb, Goal, ChevronDown } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';


const yearOptions = {
    "Bachelor's": ["1st Year", "2nd Year", "3rd Year", "4th Year"],
    "Master's": ["1st Year", "2nd Year"],
    "PhD": ["Coursework", "Research Phase", "Writing Phase"],
    "Diploma": ["1st Year", "2nd Year", "3rd Year"]
};

const getYearOptions = (degree) => {
    return yearOptions[degree] || ["1st Year", "2nd Year", "3rd Year", "4th Year", "Graduated"];
};


function AuthModal({ isOpen, onClose }) {
    const { login, signup } = useAuth();
const { setIsAdminSessionActive, switchLLM: setGlobalLLM, selectedLLM } = useAppState();

const [isLoginView, setIsLoginView] = useState(true);
    const [step, setStep] = useState(1); // For signup pagination
    const [formData, setFormData] = useState({
        email: '',
        password: '',
        localSelectedLLM: 'gemini',
        apiKey: '',
        ollamaUrl: '',
        requestKeyFromAdmin: false,
        name: '',
        college: '',
        universityNumber: '',
        degreeType: 'Bachelors',
        branch: 'Computer Science',
        year: '1st Year',
        learningStyle: 'Visual',
        currentGoals: ''
    });

    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);

    const emailRegex = /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/;

    useEffect(() => {
        if (isOpen) {
            setError('');
            setStep(1); // Reset to first step on open
            setFormData({ // Reset all form data
                email: '',
                password: '',
                localSelectedLLM: selectedLLM || 'gemini',
                apiKey: '',
                ollamaUrl: '',
                requestKeyFromAdmin: false,
                name: '',
                college: '',
                universityNumber: '',
                degreeType: 'Bachelors',
                branch: 'Computer Science',
                year: '1st Year',
                learningStyle: 'Visual',
                currentGoals: ''
            });
        } else {
            setIsLoginView(true);
        }
    }, [isOpen, selectedLLM]);



const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => {
        const newState = { ...prev, [name]: type === 'checkbox' ? checked : value };
        if (name === 'degreeType') {
            const newYearOptions = getYearOptions(value);
            newState.year = newYearOptions[0];
        }
        return newState;
    });
};


const handleNext = () => {
    setError('');
    // --- Step 1 Validation ---
    if (step === 1) {
        if (!emailRegex.test(formData.email)) {
            return setError("Please enter a valid email address.");
        }
        if (formData.password.length < 6) {
            return setError("Password must be at least 6 characters long.");
        }
    }
    // --- Step 2 Validation (can be expanded) ---
    if (step === 2) {
         if (!formData.name.trim() || !formData.college.trim() || !formData.universityNumber.trim()) {
            return setError("Please fill out all academic profile fields.");
         }
    }
    setStep(prev => prev + 1);
};

const handleBack = () => {
    setError('');
    setStep(prev => prev - 1);
};

// --- Helper for consistent input styling ---
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm w-full";
    const selectFieldStyledClass = "input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none";

    // --- Renders content for Step 1: Account Credentials ---
    const renderStep1 = () => (
        <div className="space-y-5">
            <div className={inputWrapperClass}>
                <AtSign className={inputIconClass} />
                <input type="text" name="email" className={inputFieldStyledClass} placeholder="Email Address" value={formData.email} onChange={handleChange} required disabled={loading} />
            </div>
            <div className={inputWrapperClass}>
                <KeyRound className={inputIconClass} />
                <input type="password" name="password" className={inputFieldStyledClass} placeholder="Password (min. 6 characters)" value={formData.password} onChange={handleChange} required minLength="6" disabled={loading} />
            </div>
        </div>
    );

    // --- Renders content for Step 2: Academic Profile ---
    const renderStep2 = () => (
        <div className="space-y-4">
            <p className="text-sm text-center text-text-muted-light dark:text-text-muted-dark">Tell us a bit about your academic background.</p>
            <div className={inputWrapperClass}>
                <User className={inputIconClass} />
                <input type="text" name="name" value={formData.name} onChange={handleChange} placeholder="Full Name" className={inputFieldStyledClass} required />
            </div>
            <div className={inputWrapperClass}>
                <School className={inputIconClass} />
                <input type="text" name="college" value={formData.college} onChange={handleChange} placeholder="College / Institution" className={inputFieldStyledClass} required />
            </div>
            <div className={inputWrapperClass}>
                <Hash className={inputIconClass} />
                <input type="text" name="universityNumber" value={formData.universityNumber} onChange={handleChange} placeholder="University Number" className={inputFieldStyledClass} required />
            </div>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                <div className={inputWrapperClass}>
                    <Award className={inputIconClass} />
                    <select name="degreeType" value={formData.degreeType} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                        <option>Bachelor's</option><option>Master's</option><option>PhD</option><option>Diploma</option>
                    </select>
                    <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
                <div className={inputWrapperClass}>
                    <Wrench className={inputIconClass} />
                    <select name="branch" value={formData.branch} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                        <option>Computer Science</option><option>Mechanical</option><option>Electrical</option><option>Civil</option><option>Electronics</option><option>Other</option>
                    </select>
                    <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
                <div className={inputWrapperClass}>
                    <Calendar className={inputIconClass} />
                    <select name="year" value={formData.year} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                        {getYearOptions(formData.degreeType).map(option => (
                            <option key={option} value={option}>{option}</option>
                        ))}
                    </select>
                    <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
            </div>
        </div>
    );

    // --- Renders content for Step 3: Learning & AI Preferences ---
    const renderStep3 = () => (
        <div className="space-y-4">
            <div className="space-y-2">
                <label className="block text-sm font-medium text-text-light dark:text-text-dark">How do you learn best?</label>
                <div className={inputWrapperClass}>
                    <Lightbulb className={inputIconClass} />
                    <select name="learningStyle" value={formData.learningStyle} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                        <option>Visual (diagrams, mind maps)</option>
                        <option>Auditory (podcasts, explanations)</option>
                        <option>Reading/Writing (detailed text)</option>
                        <option>Kinesthetic (hands-on examples, code)</option>
                    </select>
                    <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
            </div>
            <div className="space-y-2">
                <label className="block text-sm font-medium text-text-light dark:text-text-dark">What are your current learning goals? (Optional)</label>
                <div className={inputWrapperClass}>
                    <Goal className={inputIconClass} />
                    <textarea name="currentGoals" value={formData.currentGoals} onChange={handleChange} placeholder="e.g., 'Prepare for my AI exam', 'Understand thermodynamics basics'" className={`${inputFieldStyledClass} !h-24 resize-none`} maxLength="500"></textarea>
                </div>
            </div>
            <div className="!mt-6">
                <LLMSelection selectedLLM={formData.localSelectedLLM} onLlmChange={(llm) => handleChange({ target: { name: 'localSelectedLLM', value: llm }})} disabled={loading} />
            </div>
            {/* The rest of the LLM logic will be handled in the main return statement */}
        </div>
    );
    
    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');
        setLoading(true);

        if (isLoginView) {
            const toastId = toast.loading('Logging in...');
            try {
                const { email, password } = formData;
                if (!emailRegex.test(email) && !(email === (import.meta.env.VITE_ADMIN_USERNAME || 'admin@admin.com'))) {
                    throw new Error("Please enter a valid email address.");
                }
                const authDataResponse = await login({ email, password });
                if (authDataResponse.isAdminLogin) {
                    toast.success("Admin login successful!", { id: toastId });
                    setIsAdminSessionActive(true); 
                    onClose({ isAdminLogin: true });
                } else {
                    toast.success(authDataResponse.message || 'Login Successful!', { id: toastId });
                    onClose(authDataResponse);
                }
            } catch (err) {
                const errorMessage = err.response?.data?.message || err.message;
                setError(errorMessage);
                toast.error(errorMessage, { id: toastId });
            } finally {
                setLoading(false);
            }
        } else { // Handle multi-step signup submission
            const toastId = toast.loading('Creating your account...');
            // Final validation for Step 3
            if (formData.localSelectedLLM === 'gemini' && !formData.apiKey.trim() && !formData.requestKeyFromAdmin) {
                setLoading(false);
                toast.dismiss(toastId);
                return setError("Gemini API Key is required, or request one from the admin.");
            }
            if (formData.localSelectedLLM === 'ollama' && !formData.ollamaUrl.trim()) {
                setLoading(false);
                toast.dismiss(toastId);
                return setError("Ollama URL is required.");
            }
            
            try {
                // Consolidate data for the API
                const signupData = {
                    email: formData.email,
                    password: formData.password,
                    preferredLlmProvider: formData.localSelectedLLM,
                    requestAdminKey: formData.requestKeyFromAdmin,
                    apiKey: formData.apiKey,
                    ollamaUrl: formData.ollamaUrl,
                    name: formData.name,
                    college: formData.college,
                    universityNumber: formData.universityNumber,
                    degreeType: formData.degreeType,
                    branch: formData.branch,
                    year: formData.year,
                    learningStyle: formData.learningStyle.split(' ')[0], // Send just "Visual", etc.
                    currentGoals: formData.currentGoals
                };
                
                const authDataResponse = await signup(signupData);
                setGlobalLLM(formData.localSelectedLLM);
                toast.success(authDataResponse.message || 'Signup Successful!', { id: toastId });
                onClose(authDataResponse);
            } catch (err) {
                const errorMessage = err.response?.data?.message || err.message;
                setError(errorMessage);
                toast.error(errorMessage, { id: toastId });
            } finally {
                setLoading(false);
            }
        }
    };


    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-fadeIn">
            <motion.div 
                key="auth-modal-content"
                initial={{ opacity: 0, scale: 0.95, y: -10 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.95, y: 10 }}
                className="card-base p-6 sm:p-8 w-full max-w-lg" // Increased max-width for profile form
            >
                <div className="flex justify-between items-start mb-4">
                    <div>
                        <h2 className="text-xl sm:text-2xl font-bold">{isLoginView ? 'Welcome Back' : 'Create Your Account'}</h2>
                        {!isLoginView && <p className="text-sm text-text-muted-light dark:text-text-muted-dark">Step {step} of 3</p>}
                    </div>
                    <IconButton icon={X} onClick={() => onClose(null)} variant="ghost" size="sm" title="Close" />
                </div>

                {/* --- Progress Bar for Signup --- */}
                {!isLoginView && (
                    <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5 mb-6">
                        <motion.div
                            className="bg-primary h-1.5 rounded-full"
                            initial={{ width: '0%' }}
                            animate={{ width: `${(step / 3) * 100}%` }}
                            transition={{ ease: "easeInOut", duration: 0.5 }}
                        />
                    </div>
                )}
                
                {error && (
                    <div className="mb-4 p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                        <AlertCircle size={16}/>{error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-5">
                    {/* --- Conditional Rendering Based on View/Step --- */}
                    <AnimatePresence mode="wait">
                        <motion.div
                            key={isLoginView ? 'login' : `step${step}`}
                            initial={{ opacity: 0, x: 20 }}
                            animate={{ opacity: 1, x: 0 }}
                            exit={{ opacity: 0, x: -20 }}
                            transition={{ duration: 0.2 }}
                        >
                            {isLoginView ? (
                                <div className="space-y-5">
                                    <div className={inputWrapperClass}>
                                        <AtSign className={inputIconClass} />
                                        <input type="text" name="email" className={inputFieldStyledClass} placeholder="Email Address" value={formData.email} onChange={handleChange} required disabled={loading} />
                                    </div>
                                    <div className={inputWrapperClass}>
                                        <KeyRound className={inputIconClass} />
                                        <input type="password" name="password" className={inputFieldStyledClass} placeholder="Password" value={formData.password} onChange={handleChange} required disabled={loading} />
                                    </div>
                                </div>
                            ) : (
                                <>
                                    {step === 1 && renderStep1()}
                                    {step === 2 && renderStep2()}
                                    {step === 3 && renderStep3()}
                                </>
                            )}
                        </motion.div>
                    </AnimatePresence>
                    
                    {/* --- Renders Gemini/Ollama specific fields only on the last step of signup --- */}
                    {!isLoginView && step === 3 && (
                        <div className="space-y-4 pt-2 animate-fadeIn">
                            <div style={{ display: formData.localSelectedLLM === 'gemini' ? 'block' : 'none' }}>
                                <motion.div key="gemini-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <div className="flex items-center mb-3">
                                        <button type="button" onClick={() => handleChange({ target: { name: 'requestKeyFromAdmin', type: 'checkbox', checked: !formData.requestKeyFromAdmin }})} className="flex items-center text-sm text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light" disabled={loading}>
                                            {formData.requestKeyFromAdmin ? <CheckSquare size={16} className="text-primary mr-2" /> : <Square size={16} className="mr-2" />}
                                            Request API Key from Admin
                                        </button>
                                    </div>
                                    <AnimatePresence>
                                        {!formData.requestKeyFromAdmin && (
                                            <motion.div key="api-key-field" initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }} className="overflow-hidden">
                                                <label htmlFor="api-key-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Gemini API Key <span className="text-red-500">*</span></label>
                                                <div className={inputWrapperClass}>
                                                    <KeyRound className={inputIconClass} />
                                                    <input type="password" name="apiKey" id="api-key-input" className={inputFieldStyledClass} placeholder="Enter your Gemini API Key" value={formData.apiKey} onChange={handleChange} required={!formData.requestKeyFromAdmin && formData.localSelectedLLM === 'gemini'} disabled={loading} />
                                                </div>
                                            </motion.div>
                                        )}
                                    </AnimatePresence>
                                </motion.div>
                            </div>
                            <div style={{ display: formData.localSelectedLLM === 'ollama' ? 'block' : 'none' }}>
                                <motion.div key="ollama-input" initial={{ opacity: 0 }} animate={{ opacity: 1 }}>
                                    <label htmlFor="ollama-url-input" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Ollama URL <span className="text-red-500">*</span></label>
                                    <div className={inputWrapperClass}>
                                        <HardDrive className={inputIconClass} />
                                        <input type="text" name="ollamaUrl" id="ollama-url-input" className={inputFieldStyledClass} placeholder="e.g., http://localhost:11434" value={formData.ollamaUrl} onChange={handleChange} required={formData.localSelectedLLM === 'ollama'} disabled={loading} />
                                    </div>
                                </motion.div>
                            </div>
                        </div>
                    )}
                    
                    {/* --- Dynamic Button Rendering --- */}
                    <div className="pt-2 flex items-center gap-3">
                        {!isLoginView && step > 1 && (
                            <Button type="button" variant="secondary" onClick={handleBack} disabled={loading}>
                                Back
                            </Button>
                        )}
                        <div className="flex-grow">
                            {isLoginView ? (
                                <Button type="submit" fullWidth isLoading={loading} leftIcon={<LogIn size={18}/>} className="py-2.5 !text-base">Login</Button>
                            ) : step < 3 ? (
                                <Button type="button" fullWidth onClick={handleNext} disabled={loading} className="py-2.5 !text-base">Continue</Button>
                            ) : (
                                <Button type="submit" fullWidth isLoading={loading} leftIcon={<UserPlus size={18}/>} className="py-2.5 !text-base">Create Account</Button>
                            )}
                        </div>
                    </div>
                </form>

                <p className="mt-6 text-center text-sm">
                    <button onClick={() => { setIsLoginView(!isLoginView); setError(''); setStep(1); }} className="font-medium text-primary hover:underline" disabled={loading}>
                        {isLoginView ? "Don't have an account? Sign Up" : "Already have an account? Login"}
                    </button>
                </p>
            </motion.div>
        </div>
    );
}
export default AuthModal;
```

`frontend/src/components/auth/LLMSelection.jsx`

```javascript
// frontend/src/components/auth/LLMSelection.jsx
import React from 'react';
import { HardDrive, Cloud } from 'lucide-react';

function LLMSelection({ selectedLLM, onLlmChange, disabled = false }) {
    const llms = [
        { id: 'ollama', name: 'Ollama LLM', description: 'Local & Private. Requires Ollama running.', Icon: HardDrive },
        { id: 'gemini', name: 'Gemini LLM', description: 'Cloud-based by Google. API Key may be required.', Icon: Cloud },
    ];

    return (
        <div>
            <label className="block text-sm font-medium text-text-light dark:text-text-dark mb-2">
                Choose Your LLM Provider
            </label>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {llms.map((llm) => {
                    const isSelected = selectedLLM === llm.id;
                    return (
                        <button
                            key={llm.id}
                            type="button"
                            onClick={() => onLlmChange(llm.id)}
                            disabled={disabled}
                            className={`p-4 border rounded-lg text-left transition-all duration-150 focus:outline-none group focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-surface-dark focus:ring-primary
                                ${isSelected 
                                    ? 'bg-primary dark:bg-primary border-primary dark:border-primary-dark ring-2 ring-primary dark:ring-primary-dark shadow-lg' 
                                    : 'bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark hover:border-primary-light dark:hover:border-primary-dark hover:shadow-md'
                                }
                                ${disabled ? 'opacity-70 cursor-not-allowed' : ''}
                            `}
                        >
                            <div className="flex items-center mb-1">
                                <llm.Icon size={20} className={`mr-2 transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-blue-100' // High contrast for selected
                                        : 'text-text-muted-light dark:text-text-muted-dark group-hover:text-primary dark:group-hover:text-primary-light'}`} />
                                <span className={`font-semibold transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-white' // High contrast for selected
                                        : 'text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light'}`}>
                                    {llm.name}
                                </span>
                            </div>
                            <p className={`text-xs transition-colors 
                                ${isSelected 
                                    ? 'text-blue-100 dark:text-blue-200' // High contrast for selected
                                    : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                {llm.description}
                            </p>
                        </button>
                    );
                })}
            </div>
        </div>
    );
}

export default LLMSelection;
```

`frontend/src/components/chat/ChatHistory.jsx`

```javascript
// frontend/src/components/chat/ChatHistory.jsx
import React, { useRef, useEffect } from 'react';
import MessageBubble from './MessageBubble';
import { motion, AnimatePresence } from 'framer-motion';

function ChatHistory({ messages, onCueClick }) {
    
    const chatHistoryRef = useRef(null);
    useEffect(() => {
        if (chatHistoryRef.current) {
            chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
        }
    }, [messages]);

    return (
        <div ref={chatHistoryRef} className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
            <AnimatePresence initial={false}>
                {messages.map((msg) => (
                    <motion.div
                        key={msg.id}
                        layout
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10, transition: { duration: 0.15 } }}
                        transition={{ duration: 0.3, ease: "easeOut" }}
                    >
                        <MessageBubble
                            id={msg.id}
                            sender={msg.sender}
                            text={msg.text}
                            thinking={msg.thinking}
                            references={msg.references}
                            timestamp={msg.timestamp}
                            sourcePipeline={msg.source_pipeline}
                            isStreaming={msg.isStreaming}
                            criticalThinkingCues={msg.criticalThinkingCues}
                            onCueClick={onCueClick}
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
        </div>
    );
}

export default ChatHistory;
```

`frontend/src/components/chat/ChatHistoryModal.jsx`

```javascript
// src/components/chat/ChatHistoryModal.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { X, MessageSquareText, Loader2, AlertTriangle, Trash2 } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import IconButton from '../core/IconButton.jsx';

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString(undefined, { 
            month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' 
        });
    } catch (e) {
        return 'Invalid Date';
    }
};

function ChatHistoryModal({ isOpen, onClose, onSelectSession }) {
    const [sessions, setSessions] = useState([]);
    const [selectedSessionId, setSelectedSessionId] = useState(null);
    const [sessionMessages, setSessionMessages] = useState([]);
    const [loadingSessions, setLoadingSessions] = useState(false);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState('');

    const fetchSessions = useCallback(async () => {
        if (!isOpen) return; 
        setLoadingSessions(true);
        setError('');
        try {
            const data = await api.getChatSessions();
            setSessions(Array.isArray(data) ? data : []);
        } catch (err) {
            toast.error("Failed to load chat sessions.");
            setError(err.message || "Could not fetch sessions.");
        } finally {
            setLoadingSessions(false);
        }
    }, [isOpen]);

    useEffect(() => {
        if (isOpen) {
            fetchSessions();
            setSelectedSessionId(null); 
            setSessionMessages([]);
        }
    }, [isOpen, fetchSessions]); 

    const handleSessionSelectForPreview = async (sessionId) => {
        if (selectedSessionId === sessionId && sessionMessages.length > 0) return; 

        setSelectedSessionId(sessionId);
        setLoadingMessages(true);
        setSessionMessages([]);
        setError(''); 
        try {
            const sessionData = await api.getChatHistory(sessionId);
            
            // --- THIS IS THE CORRECTED LOGIC ---
            // We trust the API to send correctly formatted data with the 'sender' property.
            const messagesArray = Array.isArray(sessionData.messages) ? sessionData.messages : [];
            setSessionMessages(messagesArray);
            // --- END OF CORRECTION ---

        } catch (err) {
            toast.error("Failed to load messages for this session.");
            setError(`Error loading messages: ${err.message}`);
        } finally {
            setLoadingMessages(false);
        }
    };

    const handleLoadSessionAndClose = () => {
        if (selectedSessionId) {
            onSelectSession(selectedSessionId); 
            onClose();
        } else {
            toast.error("Please select a session to load.");
        }
    };
    
    const handleDeleteSession = async (sessionIdToDelete, e) => {
        e.stopPropagation();
        if (!window.confirm(`Are you sure you want to delete this session? This action cannot be undone.`)) return;
        
        const toastId = toast.loading(`Deleting session...`);
        try {
            await api.deleteChatSession(sessionIdToDelete);
            toast.success(`Session deleted.`, { id: toastId });
            setSessions(prev => prev.filter(s => s.sessionId !== sessionIdToDelete)); 
            if (selectedSessionId === sessionIdToDelete) {
                setSelectedSessionId(null);
                setSessionMessages([]);
            }
        } catch (err) {
            toast.error(`Delete failed: ${err.response?.data?.message || err.message}`, { id: toastId });
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Chat History" size="2xl">
            <div className="flex flex-col md:flex-row gap-4 max-h-[70vh] h-[70vh]">
                <div className="w-full md:w-1/3 border-r border-border-light dark:border-border-dark pr-0 md:pr-2 overflow-y-auto custom-scrollbar">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark px-1">Your Sessions</h3>
                    {loadingSessions && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24}/></div>}
                    {!loadingSessions && !sessions.length && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">No past sessions found.</p>}
                    <ul className="space-y-1">
                        {sessions.map(session => (
                            <li key={session.sessionId} onClick={() => handleSessionSelectForPreview(session.sessionId)}
                                className={`p-2.5 rounded-md cursor-pointer text-xs transition-colors group relative hover:shadow-md
                                            ${selectedSessionId === session.sessionId ? 'bg-primary text-white' : 'bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700'}`} >
                                <div className="font-medium truncate" title={session.preview}>{session.preview || `Session ${session.sessionId.substring(0,8)}`}</div>
                                <div className={`text-[0.7rem] ${selectedSessionId === session.sessionId ? 'text-blue-200' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                    {formatDate(session.updatedAt)} - {session.messageCount} msgs
                                </div>
                                <IconButton icon={Trash2} size="sm" variant="ghost" title="Delete session"
                                    className="absolute top-1 right-1 p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100"
                                    onClick={(e) => handleDeleteSession(session.sessionId, e)} />
                            </li>
                        ))}
                    </ul>
                </div>

                <div className="w-full md:w-2/3 flex flex-col overflow-hidden mt-4 md:mt-0">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark">Preview</h3>
                    <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md overflow-y-auto custom-scrollbar border border-border-light dark:border-border-dark">
                        {loadingMessages && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24} /></div>}
                        
                        <div className="space-y-3 flex flex-col">
                            {sessionMessages.map(msg => {
                                const isUser = msg.sender === 'user';
                                return (
                                    <div key={msg.id} className={`flex w-full ${isUser ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`p-2.5 rounded-lg shadow-sm w-fit max-w-[90%] text-xs
                                            ${isUser 
                                                ? 'bg-blue-500 text-white' 
                                                : 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100'
                                            }`}>
                                            <p className="font-semibold text-[0.7rem] mb-0.5">{isUser ? 'You' : 'AI Tutor'}</p>
                                            <p className="whitespace-pre-wrap break-words">{msg.text}</p>
                                            <p className={`text-[0.65rem] mt-1 text-right ${isUser ? 'opacity-70' : 'opacity-50'}`}>{formatDate(msg.timestamp)}</p>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {!loadingMessages && !selectedSessionId && (
                            <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark text-sm">
                                <MessageSquareText size={40} className="mb-3 opacity-50" />
                                <p>Select a session to view its messages.</p>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            <div className="mt-6 pt-4 border-t border-border-light dark:border-border-dark flex justify-end gap-3">
                <button onClick={onClose} className="btn-secondary !text-xs !py-1.5 !px-3">Cancel</button>
                <button onClick={handleLoadSessionAndClose} className="btn-primary !text-xs !py-1.5 !px-3" disabled={!selectedSessionId || loadingMessages || loadingSessions}>Load Session</button>
            </div>
        </Modal>
    );
}
export default ChatHistoryModal;
```

`frontend/src/components/chat/ChatInput.jsx`

```javascript
// frontend/src/components/chat/ChatInput.jsx
import { useAppState } from '../../contexts/AppStateContext.jsx';
import React, { useState, useEffect, useRef } from 'react';
import api from '../../services/api.js';
import { Send, Mic, Plus, Brain, Zap, Globe, BookMarked, Sparkles } from 'lucide-react';
import { useWebSpeech } from '../../hooks/useWebSpeech';
import Button from '../core/Button.jsx'; 
import IconButton from '../core/IconButton.jsx';
import toast from 'react-hot-toast';
import blueBrain from "./../../assets/blueBrain.svg";
import { motion, AnimatePresence } from 'framer-motion';

function ChatInput({ 
    onSendMessage, 
    isLoading,
    useWebSearch,
    setUseWebSearch,
    useAcademicSearch,
    setUseAcademicSearch,
    criticalThinkingEnabled,
    setCriticalThinkingEnabled,
    initialPrompt,
    setInitialPromptForNewSession,
    openCoachModalWithData,
    setCoachModalOpen
}) {
    const [inputValue, setInputValue] = useState('');
    const { transcript, listening, isSpeechSupported, startListening, stopListening, resetTranscript } = useWebSpeech();
    const textareaRef = useRef(null);
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const menuRef = useRef(null);

    // --- SIMPLIFIED COACH LOGIC ---
    const [isCoaching, setIsCoaching] = useState(false);

    const handleRequestPromptCoaching = async () => {
        const trimmedInput = inputValue.trim();

        // --- NEW: Frontend Validation ---
        if (!trimmedInput) return; // General check to prevent action on empty input
        
        if (trimmedInput.length < 3) {
            toast("Prompt is too short for coaching. Please provide a bit more detail.", {
                icon: '❤️',
                style: {
                    background: '#FBBF24',
                    color: '#ffffff',
                },
            });
            return; // Stop the function here
        }
        // --- END: Frontend Validation ---
        
        if (isCoaching) return;

        setIsCoaching(true);
        const toastId = toast.loading('Asking the coach for advice...');
        try {
            const response = await api.analyzePrompt(trimmedInput);
            // Tell the parent to open the modal with the new data
            openCoachModalWithData({
                original: trimmedInput,
                improved: response.improvedPrompt,
                explanation: response.explanation
            });
            setCoachModalOpen(true);
            toast.success('Suggestion received!', { id: toastId });
        } catch (error) {
            toast.error(error.message || "The Prompt Coach is unavailable.", { id: toastId });
        } finally {
            setIsCoaching(false);
        }
    };

    useEffect(() => {
    if (initialPrompt) {
        console.log("[ChatInput] Received initial prompt via props:", initialPrompt);
        setInputValue(initialPrompt); // Set the text in the input box
        setInitialPromptForNewSession(null); // Clear the global state immediately
    }
    }, [initialPrompt, setInitialPromptForNewSession]);

    useEffect(() => {
        if (transcript) {
            setInputValue(prev => prev + (prev ? " " : "") + transcript);
            resetTranscript(); 
        }
    }, [transcript, resetTranscript]);
    
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 128)}px`;
        }
    }, [inputValue]);

    useEffect(() => {
        function handleClickOutside(event) {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                setIsMenuOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
    }, [menuRef]);

    const handleSubmit = (e) => {
        e.preventDefault();
        if (inputValue.trim() && !isLoading) {
            onSendMessage(inputValue.trim());
            setInputValue('');
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !isLoading) {
            e.preventDefault();
            handleSubmit(e);
        }
    };
    
    const handleWebSearchToggle = () => {
        const newWebSearchState = !useWebSearch;
        setUseWebSearch(newWebSearchState);
        toast(newWebSearchState ? "Web Search enabled." : "Web Search disabled.", { icon: newWebSearchState ? "🌐" : "📄" });
        setIsMenuOpen(false);
    };

    const handleAcademicSearchToggle = () => {
        const newState = !useAcademicSearch;
        setUseAcademicSearch(newState);
        toast(newState ? "Academic Search enabled." : "Academic Search disabled.", { icon: newState ? "🎓" : "📄" });
        setIsMenuOpen(false);
    };

    const icon = criticalThinkingEnabled ? () => <img src={blueBrain} alt="Blue Brain" className="w-5 h-5" /> : Brain;

    return (
        <div className="p-2 sm:p-3 bg-surface-light dark:bg-surface-dark/50 backdrop-blur-sm rounded-b-lg shadow-inner">
            <form onSubmit={handleSubmit} className="flex items-end gap-2">
                <div className="relative" ref={menuRef}>
                    <IconButton
                        icon={Plus}
                        title="More Options"
                        onClick={() => setIsMenuOpen(!isMenuOpen)}
                        variant="ghost"
                        size="md" 
                        className="p-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                        disabled={isLoading}
                    />
                    <AnimatePresence>
                    {isMenuOpen && (
                        <motion.div
                            initial={{ opacity: 0, y: 10, scale: 0.95 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: 10, scale: 0.95 }}
                            className="absolute bottom-full left-0 mb-2 w-56 bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl border border-border-light dark:border-border-dark p-1 z-10"
                        >
                            <button
                                onClick={handleWebSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useWebSearch
                                    ? 'bg-primary/10 text-primary dark:bg-primary-dark/20 dark:text-primary-light'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <Globe size={16} />
                                {useWebSearch ? 'Disable Web Search' : 'Enable Web Search'}
                            </button>
                            <button
                                onClick={handleAcademicSearchToggle}
                                className={`w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md transition-colors ${
                                    useAcademicSearch
                                    ? 'bg-purple-500/10 text-purple-600 dark:bg-purple-400/20 dark:text-purple-300'
                                    : 'text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700'
                                }`}
                            >
                                <BookMarked size={16} />
                                {useAcademicSearch ? 'Disable Academic Search' : 'Enable Academic Search'}
                            </button>
                             <button
                                onClick={() => {toast("File attachment coming soon!", { icon: "📎" }); setIsMenuOpen(false);}}
                                className="w-full text-left flex items-center gap-2 px-3 py-2 text-sm rounded-md text-text-muted-light dark:text-text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700"
                            >
                                <Zap size={16} />
                                Attach File (soon)
                            </button>
                        </motion.div>
                    )}
                    </AnimatePresence>
                </div>
                <textarea
                    ref={textareaRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder={isLoading ? "Waiting for response..." : "Type your message or ask a question..."}
                    className="input-field flex-1 p-2.5 resize-none min-h-[44px] max-h-32 custom-scrollbar text-sm" 
                    rows="1"
                    disabled={isLoading}
                />

                {isSpeechSupported && (
                    <IconButton
                        icon={Mic}
                        onClick={() => listening ? stopListening() : startListening()}
                        title={listening ? "Stop listening" : "Start voice input"}
                        variant={listening ? "danger" : "ghost"} 
                        size="md"
                        className={`p-2 ${listening ? 'text-red-500 animate-pulse' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        disabled={isLoading}
                    />
                )}
                
                {/* --- NEW BUTTON --- */}
                <IconButton
                    icon={Sparkles}
                    onClick={handleRequestPromptCoaching}
                    title="Ask Prompt Coach for Improvement"
                    variant="ghost"
                    size="md"
                    className="p-2 text-amber-500 hover:text-amber-600 dark:text-amber-400 dark:hover:text-amber-300"
                    isLoading={isCoaching}
                    disabled={isLoading || isCoaching || !inputValue.trim()}
                />

               <IconButton
                    icon={icon}
                    onClick={() => setCriticalThinkingEnabled(!criticalThinkingEnabled)}
                    title={criticalThinkingEnabled ? "Disable Critical Thinking (KG)" : "Enable Critical Thinking (KG)"}
                    variant="ghost"
                    size="md"
                    className={`p-2 ${criticalThinkingEnabled ? 'text-purple-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                    disabled={isLoading}
                />

                <Button 
                    type="submit"
                    variant="primary"
                    size="md" 
                    className="!p-2.5" 
                    disabled={isLoading || !inputValue.trim()}
                    isLoading={isLoading && !!inputValue.trim()} 
                    title="Send message"
                >
                    {(!isLoading || !inputValue.trim()) ? <Send size={20} /> : null}
                </Button>
            </form>
            
            <div className="flex flex-wrap items-center justify-center mt-2 px-2 text-center h-4 gap-x-4">
                <AnimatePresence>
                    {useWebSearch && (
                        <motion.p
                            key="web-search-indicator"
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-blue-500 dark:text-blue-400 flex items-center gap-1.5 font-medium"
                        >
                            <Globe size={12} /> Web Search is ON
                        </motion.p>
                    )}
                    {useAcademicSearch && (
                        <motion.p
                            key="academic-search-indicator"
                            initial={{ opacity: 0, y: -5 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0, y: -5 }}
                            className="text-xs text-purple-500 dark:text-purple-400 flex items-center gap-1.5 font-medium"
                        >
                            <BookMarked size={12} /> Academic Search is ON
                        </motion.p>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default ChatInput;
```

`frontend/src/components/chat/MessageBubble.jsx`

```javascript
// src/components/chat/MessageBubble.jsx
import React, { useEffect, useRef, useState, useCallback } from 'react';
import { marked } from 'marked';
import Prism from 'prismjs';
import { motion, AnimatePresence } from 'framer-motion';
import { ChevronDown, Link as LinkIcon, Zap, Server, Volume2, StopCircle, ServerCrash, Copy, Check, Lightbulb } from 'lucide-react';
import ThinkingDropdown from './ThinkingDropdown.jsx';
import TypingIndicator from './TypingIndicator.jsx';
import { useTextToSpeech } from '../../hooks/useTextToSpeech.js';
import IconButton from '../core/IconButton.jsx';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { getPlainTextFromMarkdown } from '../../utils/helpers.js';
import DOMPurify from 'dompurify';
import { useTypingEffect } from '../../hooks/useTypingEffect.js';

marked.setOptions({ breaks: true, gfm: true });

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let rawHtml = marked.parse(markdownText);
    rawHtml = renderMathInHtml(rawHtml);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true, mathMl: true, svg: true } });
    return { __html: cleanHtml };
};

const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, `"`).replace(/'/g, "'");
};

const AnimatedThinking = ({ content }) => {
    const [completedTyping, setCompletedTyping] = useState('');
    const [currentTyping, setCurrentTyping] = useState('');
    const [isWaiting, setIsWaiting] = useState(true);
    const lastContentRef = useRef('');

    useEffect(() => {
        if (content && content.length > lastContentRef.current.length) {
            const newChunk = content.substring(lastContentRef.current.length);
            setCurrentTyping(newChunk);
            setIsWaiting(false);
            lastContentRef.current = content;
        }
    }, [content]);

    const onTypingComplete = useCallback(() => {
        setCompletedTyping(prev => prev + currentTyping);
        setCurrentTyping('');
        setIsWaiting(true);
    }, [currentTyping]);

    const animatedChunk = useTypingEffect(currentTyping, 4, onTypingComplete);
    const combinedText = completedTyping + animatedChunk;

    return (
        <div className="prose prose-xs dark:prose-invert max-w-none text-text-muted-light dark:text-text-muted-dark">
            <div dangerouslySetInnerHTML={createMarkup(combinedText)} />
            {isWaiting && <span className="animate-pulse"> Thinking...</span>}
        </div>
    );
};

function MessageBubble({ sender, text, thinking, references, timestamp, sourcePipeline, isStreaming, criticalThinkingCues, onCueClick }) {
    const isUser = sender === 'user';
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const contentRef = useRef(null);
    const [isCopied, setIsCopied] = useState(false);
    const { speak, cancel, isSpeaking } = useTextToSpeech();

    const mainContent = text || '';
    const thinkingContent = thinking;
    const showThinkingDropdown = !isUser && thinkingContent !== null;

    useEffect(() => {
        if (!isStreaming && mainContent) {
            const timer = setTimeout(() => {
                if (contentRef.current) Prism.highlightAllUnder(contentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isStreaming, mainContent]);
    
    const handleCopy = () => {
        if (isCopied) return;
        const plainTextToCopy = getPlainTextFromMarkdown(mainContent);
        navigator.clipboard.writeText(plainTextToCopy).then(() => {
            setIsCopied(true);
            setTimeout(() => setIsCopied(false), 1000);
        });
    };
    
    const formatTimestamp = (ts) => new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const getPipelineIcon = () => {
        if (!sourcePipeline) return null;
        const lower = sourcePipeline.toLowerCase();
        if (lower.includes('ollama')) return <Zap size={12} className="text-green-400" title="Ollama" />;
        if (lower.includes('gemini')) return <Server size={12} className="text-blue-400" title="Gemini" />;
        if (lower.includes('rag')) return <Zap size={12} className="text-purple-400" title="RAG" />;
        if (lower.includes('error')) return <ServerCrash size={12} className="text-red-400" title="Error" />;
        return null;
    };
    
    return (
        <div className={`flex flex-col ${isUser ? 'items-end' : 'items-start'} w-full group`}>
            <div className={`message-bubble-wrapper max-w-[85%] md:max-w-[75%] ${isStreaming ? 'w-full' : ''}`}>
                {showThinkingDropdown && (
                    <div className="mb-1.5">
                        <ThinkingDropdown
                            isOpen={isDropdownOpen}
                            setIsOpen={setIsDropdownOpen}
                            isStreaming={isStreaming}
                        >
                            {isStreaming 
                                ? <AnimatedThinking content={thinkingContent} /> 
                                : <div className="prose prose-xs dark:prose-invert max-w-none text-text-muted-light dark:text-text-muted-dark" dangerouslySetInnerHTML={createMarkup(thinkingContent)} />
                            }
                        </ThinkingDropdown>
                    </div>
                )}

                {isStreaming ? (
                    <TypingIndicator />
                ) : (
                    <div className={`message-bubble relative p-3 rounded-2xl shadow-md break-words ${
                        isUser 
                        ? 'bg-surface-light text-text-light border border-border-light dark:bg-primary-dark dark:text-white dark:border-transparent rounded-br-lg' 
                        : 'bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark rounded-bl-lg border border-border-light dark:border-border-dark'
                    }`}>
                        <div ref={contentRef} className="prose prose-sm dark:prose-invert max-w-none message-content leading-relaxed" dangerouslySetInnerHTML={createMarkup(mainContent)} />
                        <div className="flex items-center justify-end mt-1.5 text-xs gap-1">
                            <button onClick={handleCopy} title={isCopied ? 'Copied!' : 'Copy content'} disabled={isCopied} className="p-1 rounded-md text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 opacity-0 group-hover:opacity-100 transition-all duration-200 focus:outline-none">
                                <AnimatePresence mode="wait" initial={false}>
                                    <motion.div key={isCopied ? 'check' : 'copy'} initial={{ scale: 0.6, opacity: 0, rotate: -30 }} animate={{ scale: 1, opacity: 1, rotate: 0 }} exit={{ scale: 0.6, opacity: 0, rotate: 30 }} transition={{ duration: 0.15 }}>
                                        {isCopied ? <Check size={16} className="text-green-500" /> : <Copy size={16} />}
                                    </motion.div>
                                </AnimatePresence>
                            </button>
                            <div className="flex items-center gap-2 pl-1 opacity-70">
                                {!isUser && getPipelineIcon() && <span className="mr-1">{getPipelineIcon()}</span>}
                                <span>{formatTimestamp(timestamp)}</span>
                                {!isUser && (
                                    <IconButton icon={isSpeaking ? StopCircle : Volume2} onClick={() => isSpeaking ? cancel() : speak({ text: mainContent })} title={isSpeaking ? "Stop reading" : "Read aloud"} size="sm" variant="ghost" className={`p-0.5 ${isSpeaking ? 'text-red-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`} />
                                )}
                            </div>
                        </div>
                    </div>
                )}
            </div>

            {!isStreaming && !isUser && references && references.length > 0 && (
                <div className="message-metadata-container max-w-[85%] md:max-w-[75%] mt-1.5 pl-2">
                     {/* ... details block for references ... */}
                </div>
            )}
            
            {!isStreaming && !isUser && criticalThinkingCues && (
                <div className="max-w-[85%] md:max-w-[75%] w-full mt-2 pl-2 animate-fadeIn">
                    <div className="border-t border-dashed border-border-light dark:border-border-dark pt-2">
                        <h4 className="text-xs font-semibold text-text-muted-light dark:text-text-muted-dark flex items-center gap-1.5 mb-2">
                            <Lightbulb size={14} />
                            Critical Thinking Prompts
                        </h4>
                        <div className="flex flex-wrap gap-2">
                            {criticalThinkingCues.verificationPrompt && (
                                <button
                                    onClick={() => onCueClick(criticalThinkingCues.verificationPrompt)}
                                    className="text-xs bg-sky-500/10 text-sky-700 dark:bg-sky-500/20 dark:text-sky-300 px-2.5 py-1 rounded-full hover:bg-sky-500/20 dark:hover:bg-sky-500/30 transition-colors"
                                >
                                    {criticalThinkingCues.verificationPrompt}
                                </button>
                            )}
                            {criticalThinkingCues.alternativePrompt && (
                                <button
                                    onClick={() => onCueClick(criticalThinkingCues.alternativePrompt)}
                                    className="text-xs bg-amber-500/10 text-amber-700 dark:bg-amber-500/20 dark:text-amber-400 px-2.5 py-1 rounded-full hover:bg-amber-500/20 dark:hover:bg-amber-500/30 transition-colors"
                                >
                                    {criticalThinkingCues.alternativePrompt}
                                </button>
                            )}
                            {criticalThinkingCues.applicationPrompt && (
                                <button
                                    onClick={() => onCueClick(criticalThinkingCues.applicationPrompt)}
                                    className="text-xs bg-emerald-500/10 text-emerald-700 dark:bg-emerald-500/20 dark:text-emerald-400 px-2.5 py-1 rounded-full hover:bg-emerald-500/20 dark:hover:bg-emerald-500/30 transition-colors"
                                >
                                    {criticalThinkingCues.applicationPrompt}
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
}

export default MessageBubble;
```

`frontend/src/components/chat/PromptCoachModal.jsx`

```javascript
// frontend/src/components/chat/PromptCoachModal.jsx
import React from 'react';
import Modal from '../core/Modal';
import Button from '../core/Button';
import { Sparkles, Check } from 'lucide-react';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

// This function will safely render the Markdown explanation from the AI
const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const PromptCoachModal = ({ isOpen, onClose, onApply, data }) => {
    if (!isOpen || !data) return null;

    const { original, improved, explanation } = data;

    const handleApply = () => {
        onApply(improved);
        onClose();
    };

    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title="Prompt Coach Suggestion"
            size="xl"
            footerContent={
                <>
                    <Button variant="secondary" onClick={onClose}>Keep Original</Button>
                    <Button onClick={handleApply} leftIcon={<Check size={16} />}>Use Suggestion</Button>
                </>
            }
        >
            <div className="max-h-[60vh] overflow-y-auto custom-scrollbar pr-2">
                <div className="space-y-4">
                    <div>
                        <label className="text-sm font-semibold text-text-muted-light dark:text-text-muted-dark">Your Original Prompt</label>
                        <p className="mt-1 p-3 bg-gray-100 dark:bg-gray-800 rounded-md text-sm italic">
                            "{original}"
                        </p>
                    </div>
                    
                    <div>
                        <label className="text-sm font-semibold text-primary dark:text-primary-light flex items-center gap-1.5">
                            <Sparkles size={16} />
                            Suggested Improvement
                        </label>
                        <p className="mt-1 p-3 bg-primary/10 dark:bg-primary/20 border border-primary/30 rounded-md text-sm font-medium">
                            "{improved}"
                        </p>
                    </div>
                    
                    <div>
                        <label className="text-sm font-semibold text-text-muted-light dark:text-text-muted-dark">Reasoning</label>
                        <div
                            className="prose prose-sm dark:prose-invert max-w-none mt-1 text-text-light dark:text-text-dark text-sm"
                            dangerouslySetInnerHTML={createMarkup(explanation)}
                        />
                    </div>
                </div>
            </div>
        </Modal>
    );
};

export default PromptCoachModal;
```

`frontend/src/components/chat/StreamingResponse.jsx`

```javascript
import React, { useState, useEffect, useRef, useCallback } from 'react';
import ThinkingDropdown from './ThinkingDropdown';
import TypingIndicator from './TypingIndicator';
import { useTypingEffect } from '../../hooks/useTypingEffect';

function StreamingResponse({ streamingResponse }) {
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [thoughtChunks, setThoughtChunks] = useState([]);       
  const [queuedChunks, setQueuedChunks] = useState([]);         
  const [currentTyping, setCurrentTyping] = useState('');       
  const isTyping = useRef(false);                               
  const lastProcessed = useRef('');                             

  // 🔓 Open dropdown when thinking begins
  useEffect(() => {
    if (streamingResponse?.thinking && !isDropdownOpen) {
      setIsDropdownOpen(true);
    }
  }, [streamingResponse?.thinking, isDropdownOpen]);

  // 🧠 Queue new streamed chunks (append-only)
  useEffect(() => {
    const fullText = streamingResponse?.thinking || '';
    if (!fullText || fullText === lastProcessed.current) return;

    const allChunks = fullText.split('\n\n').filter(Boolean);
    const newChunks = allChunks.slice(thoughtChunks.length + queuedChunks.length);
    if (newChunks.length > 0) {
      setQueuedChunks(prev => [...prev, ...newChunks]);
    }

    lastProcessed.current = fullText;
  }, [streamingResponse?.thinking, thoughtChunks.length, queuedChunks.length]);

  // ✅ Start next typing only when current finishes
  const handleTypingComplete = useCallback(() => {
  if (currentTyping.trim()) {
    setThoughtChunks(prev => [...prev, currentTyping.trim()]);
  }
  setCurrentTyping('');
  isTyping.current = false;

  // ✅ Immediately start next typing
  if (queuedChunks.length > 0) {
    const next = queuedChunks[0];
    isTyping.current = true;
    setCurrentTyping(next);
    setQueuedChunks(prev => prev.slice(1));
  }
}, [currentTyping, queuedChunks]);


  // 🔁 Initial trigger when first chunk is available
  useEffect(() => {
    if (!isTyping.current && currentTyping === '' && queuedChunks.length > 0) {
      const next = queuedChunks[0];
      isTyping.current = true;
      setCurrentTyping(next);
      setQueuedChunks(prev => prev.slice(1));
    }
  }, [queuedChunks, currentTyping]);

  const animatedCurrentChunk = useTypingEffect(currentTyping, 4, handleTypingComplete);

  const { isThinkingStreaming } = streamingResponse || {};
  const showThinking = thoughtChunks.length > 0 || currentTyping || isThinkingStreaming;

  return (
    <div className="flex flex-col items-start w-full group space-y-1.5">
      {showThinking && (
        <div className="max-w-[85%] md:max-w-[75%] w-full">
          <ThinkingDropdown
            isOpen={isDropdownOpen}
            setIsOpen={setIsDropdownOpen}
            isStreaming={isThinkingStreaming}
          >
            <pre className="text-xs text-text-muted-light dark:text-text-muted-dark whitespace-pre-wrap font-sans leading-relaxed">
              {[...thoughtChunks, animatedCurrentChunk].filter(Boolean).join('\n\n')}
              {(!animatedCurrentChunk && isThinkingStreaming) && (
                <span className="animate-pulse"> Thinking...</span>
              )}
            </pre>
          </ThinkingDropdown>
        </div>
      )}
      <TypingIndicator />
    </div>
  );
}

export default StreamingResponse;

```

`frontend/src/components/chat/ThinkingDropdown.jsx`

```javascript
// frontend/src/components/chat/ThinkingDropdown.jsx
import React from 'react';
import { ChevronDown, BrainCircuit } from 'lucide-react';
import { motion } from 'framer-motion';

function ThinkingDropdown({ children, isOpen, setIsOpen, isStreaming }) {
    return (
        <div className="w-full">
            <button
                onClick={() => setIsOpen(!isOpen)}
                className="inline-flex items-center gap-1.5 text-xs font-medium text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-400 transition-colors py-1 group"
                aria-expanded={isOpen}
            >
                <BrainCircuit size={14} className="text-gray-400 dark:text-gray-500 group-hover:text-gray-500 dark:group-hover:text-gray-400 transition-colors" />

                <span className={isStreaming ? 'shimmer-text !text-transparent' : ''}>
                    Thinking Process
                </span>

                <ChevronDown size={16} className={`transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`} />
            </button>

            {/* ✅ Always render motion.div, but animate visibility */}
            <motion.div
                animate={isOpen ? 'open' : 'collapsed'}
                variants={{
                    open: { opacity: 1, height: 'auto', marginTop: '0.25rem' },
                    collapsed: { opacity: 0, height: 0, marginTop: '0' }
                }}
                transition={{ duration: 0.3, ease: 'easeInOut' }}
                className="overflow-hidden"
            >
                <div className="pl-4 border-l-2 border-gray-300 dark:border-gray-600">
                    {children}
                </div>
            </motion.div>
        </div>
    );
}

export default ThinkingDropdown;

```

`frontend/src/components/chat/TypingIndicator.jsx`

```javascript
// frontend/src/components/chat/TypingIndicator.jsx
import React from 'react';

function TypingIndicator() {
  return (
    <div className="flex items-center justify-start w-full group">
      <div className="flex items-center space-x-1.5 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-2xl shadow-md px-4 py-3">
        <div className="w-2 h-2 bg-text-muted-light dark:bg-text-muted-dark rounded-full animate-pulseDot1"></div>
        <div className="w-2 h-2 bg-text-muted-light dark:bg-text-muted-dark rounded-full animate-pulseDot2"></div>
        <div className="w-2 h-2 bg-text-muted-light dark:bg-text-muted-dark rounded-full animate-pulseDot3"></div>
      </div>
    </div>
  );
}

export default TypingIndicator;
```

`frontend/src/components/common/ThemeToggle.jsx`

```javascript
import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="p-2 rounded-full text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
            aria-label={theme === 'light' ? 'Switch to dark theme' : 'Switch to light theme'}
        >
            {theme === 'light' ? <Moon size={20} /> : <Sun size={20} />}
        </button>
    );
}

export default ThemeToggle;
```

`frontend/src/components/core/Button.jsx`

```javascript
// src/components/core/Button.jsx
import React from 'react';
import { Loader2 } from 'lucide-react'; // For loading spinner

const Button = ({
    children,
    onClick,
    type = 'button',
    variant = 'primary', // 'primary', 'secondary', 'danger', 'outline', 'ghost'
    size = 'md', // 'sm', 'md', 'lg'
    leftIcon,
    rightIcon,
    isLoading = false,
    disabled = false,
    fullWidth = false,
    className = '',
    ...props
}) => {
    const baseStyles = "font-semibold rounded-lg focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2";

    const variantStyles = {
        primary: "bg-primary hover:bg-primary-dark text-white focus:ring-primary",
        secondary: "bg-secondary hover:bg-secondary-dark text-white focus:ring-secondary",
        danger: "bg-red-500 hover:bg-red-600 text-white focus:ring-red-500",
        outline: "border border-primary text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
        ghost: "text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
    };

    const sizeStyles = {
        sm: "px-3 py-1.5 text-xs",
        md: "px-4 py-2 text-sm",
        lg: "px-6 py-3 text-base",
    };

    const widthStyle = fullWidth ? "w-full" : "";
    const isDisabled = disabled || isLoading;
    const finalDisabledStyle = isDisabled ? "opacity-60 cursor-not-allowed" : "cursor-pointer";

    const spinnerSize = size === 'sm' ? 14 : (size === 'lg' ? 20 : 16);
    
    return (
        <button
            type={type}
            onClick={onClick}
            disabled={isDisabled} // Use the corrected variable
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${widthStyle} ${finalDisabledStyle} ${className}`}
            {...props}
        >
            {isLoading && (
                <Loader2 size={spinnerSize} className="animate-spin" />
            )}
            {!isLoading && leftIcon && <span className="icon-left">{leftIcon}</span>}

            <span className={isLoading ? 'ml-2' : ''}>{children}</span>

            {!isLoading && rightIcon && <span className="icon-right">{rightIcon}</span>}
        </button>
    );
};

export default Button;
```

`frontend/src/components/core/IconButton.jsx`

```javascript
import React from 'react';
import { Loader2 } from 'lucide-react';

const IconButton = ({
    icon: Icon, // Pass the Lucide icon component directly
    onClick,
    variant = 'ghost', // 'ghost', 'outline', 'subtle'
    size = 'md', // 'sm', 'md', 'lg'
    isLoading = false,
    disabled = false,
    className = '',
    title, // For accessibility and tooltips
    ariaLabel,
    ...props
}) => {
    const baseStyles = "rounded-md focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-colors duration-150 flex items-center justify-center";

    const variantStyles = {
        ghost: "text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:ring-primary",
        outline: "border border-gray-300 dark:border-gray-600 text-text-muted-light dark:text-text-muted-dark hover:border-primary hover:text-primary focus:ring-primary",
        subtle: "bg-gray-100 dark:bg-gray-700 text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-600 focus:ring-primary",
        danger: "text-red-500 hover:bg-red-100 dark:hover:bg-red-900 focus:ring-red-500"
    };

    const sizeStyles = {
        sm: "p-1.5", // Icon size typically 14-16px
        md: "p-2",   // Icon size typically 18-20px
        lg: "p-2.5", // Icon size typically 22-24px
    };
    
    const iconSizeMap = {
        sm: 16,
        md: 20,
        lg: 24,
    };

    const disabledStyle = (disabled || isLoading) ? "opacity-50 cursor-not-allowed" : "cursor-pointer";

    return (
        <button
            type="button"
            onClick={onClick}
            disabled={disabled || isLoading}
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${disabledStyle} ${className}`}
            title={title}
            aria-label={ariaLabel || title}
            {...props}
        >
            {isLoading ? (
                <Loader2 size={iconSizeMap[size]} className="animate-spin" />
            ) : (
                Icon && <Icon size={iconSizeMap[size]} />
            )}
        </button>
    );
};

export default IconButton;
```

`frontend/src/components/core/Modal.jsx`

```javascript
// src/components/core/Modal.jsx
import React, { useEffect, useRef } from 'react';
import { X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const Modal = ({
    isOpen,
    onClose,
    title,
    children,
    footerContent,
    size = 'md', // 'sm', 'md', 'lg', 'xl', '2xl', '3xl', '4xl', '5xl', 'full'
    closeOnOverlayClick = true,
    initialFocusRef, // Optional ref for focusing an element inside the modal on open
}) => {
    const modalRef = useRef(null);

    // Handle Escape key for closing
    useEffect(() => {
        const handleEscapeKey = (event) => {
            if (event.key === 'Escape' && isOpen) {
                onClose();
            }
        };
        if (isOpen) {
            document.addEventListener('keydown', handleEscapeKey);
        }
        return () => {
            document.removeEventListener('keydown', handleEscapeKey);
        };
    }, [isOpen, onClose]);

    // Handle focus trapping and initial focus
    useEffect(() => {
        if (isOpen) {
            // Set focus to the initialFocusRef or the modal itself
            if (initialFocusRef && initialFocusRef.current) {
                initialFocusRef.current.focus();
            } else if (modalRef.current) {
                modalRef.current.focus(); // Fallback to modal itself
            }

            // Basic focus trapping (can be made more robust with a library)
            const focusableElements = modalRef.current?.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements && focusableElements.length > 0) {
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                const onKeyDown = (e) => {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) { // Shift + Tab
                            if (document.activeElement === firstElement) {
                                lastElement.focus();
                                e.preventDefault();
                            }
                        } else { // Tab
                            if (document.activeElement === lastElement) {
                                firstElement.focus();
                                e.preventDefault();
                            }
                        }
                    }
                };
                modalRef.current?.addEventListener('keydown', onKeyDown);
                return () => modalRef.current?.removeEventListener('keydown', onKeyDown);
            }
        }
    }, [isOpen, initialFocusRef]);


    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl',
        '3xl': 'max-w-3xl',
        '4xl': 'max-w-4xl',
        '5xl': 'max-w-5xl',
        full: 'max-w-full h-full rounded-none sm:rounded-lg sm:max-h-[95vh]', // Special case for full screen like
    };

    const backdropVariants = {
        visible: { opacity: 1, transition: { duration: 0.2, ease: "easeOut" } },
        hidden: { opacity: 0, transition: { duration: 0.15, ease: "easeIn" } },
    };

    const modalVariants = {
        hidden: { y: "-30px", opacity: 0, scale: 0.98, transition: { duration: 0.15, ease: "easeIn" } },
        visible: { y: "0", opacity: 1, scale: 1, transition: { type: "spring", stiffness: 400, damping: 30, duration: 0.3 } },
        exit: { y: "30px", opacity: 0, scale: 0.98, transition: { duration: 0.2, ease: "easeIn" } }
    };

    if (!isOpen) return null;

    return (
        <AnimatePresence mode="wait">
            {isOpen && (
                <motion.div
                    key="modal-backdrop"
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 dark:bg-black/80 backdrop-blur-sm"
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    variants={backdropVariants}
                    onClick={closeOnOverlayClick ? onClose : undefined}
                    aria-labelledby="modal-title" // For screen readers
                    role="dialog" // Role for the backdrop itself, more specific roles on content
                    aria-modal="true" // Indicate it's a modal overlaying other content
                >
                    <motion.div
                        key="modal-content-wrapper" // Changed key for potential AnimatePresence behavior
                        ref={modalRef}
                        tabIndex={-1} // Make the modal itself focusable for fallback
                        className={`bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl w-full ${sizeClasses[size]} flex flex-col overflow-hidden
                                    ${size === 'full' ? '' : 'max-h-[90vh] sm:max-h-[85vh]'}`} 
                                    // Apply max-h unless it's 'full' size
                        role="document" // The actual dialog content
                        aria-modal="true"
                        aria-labelledby={title ? "modal-title-text" : undefined} // Point to title if exists
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        variants={modalVariants}
                        onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside modal
                    >
                        {/* Modal Header */}
                        <div className="flex items-center justify-between px-5 py-3.5 border-b border-border-light dark:border-border-dark sticky top-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                            {title && (
                                <h2 id="modal-title-text" className="text-lg font-semibold text-text-light dark:text-text-dark truncate pr-4">
                                    {title}
                                </h2>
                            )}
                            <button
                                onClick={onClose}
                                className="p-1.5 rounded-full text-text-muted-light dark:text-text-muted-dark 
                                           hover:bg-gray-200/80 dark:hover:bg-gray-700/80 
                                           hover:text-red-500 dark:hover:text-red-400 
                                           focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary-light focus:ring-offset-1 dark:focus:ring-offset-surface-dark"
                                aria-label="Close modal"
                            >
                                <X size={20} />
                            </button>
                        </div>

                        {/* Modal Body */}
                        <div className="px-5 py-4 overflow-y-auto flex-grow custom-scrollbar">
                            {children}
                        </div>

                        {/* Modal Footer */}
                        {footerContent && (
                            <div className="px-5 py-3.5 border-t border-border-light dark:border-border-dark flex justify-end gap-3 sticky bottom-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                                {footerContent}
                            </div>
                        )}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

export default Modal;
```

`frontend/src/components/documents/DocumentList.jsx`

```javascript


// frontend/src/components/documents/DocumentList.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api.js'; // Mocked for V1
import toast from 'react-hot-toast';
import { FileText, Edit3, Trash2, Loader2, AlertTriangle, CheckCircle } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Make sure IconButton is imported
import { useAuth } from '../../hooks/useAuth.jsx';

// Props from LeftPanel: onSelectDocument is selectDocumentForAnalysis from AppStateContext
// selectedDocument is selectedDocumentForAnalysis from AppStateContext
function DocumentList({ onSelectDocument, selectedDocument }) {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const fetchFiles = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      
      const response = await api.getFiles(); // Returns { filenames: ["A.txt", "B.pdf"] }
      const filenames = Array.isArray(response.filenames) ? response.filenames : [];
      setFiles(filenames);
      
    } catch (err) {
      console.error("Failed to fetch files:", err);
      setError(err.message || "Failed to fetch files.");
      toast.error("Could not load documents.");
    } finally {
      setLoading(false);
    }
  }, []);



  useEffect(() => {
    fetchFiles();
  }, [fetchFiles]);

  const handleDelete = async (filename) => {
    if (!window.confirm(`Are you sure you want to delete "${filename}"?`)) return;
    const toastId = toast.loading(`Deleting ${filename}...`);
    try {
      await api.deleteFile(filename); // Assumes this works with filename
      toast.success(`${filename} deleted.`, { id: toastId });
      fetchFiles();
      if (selectedDocument === filename) {
        onSelectDocument(null);
      }
    } catch (err) {
      toast.error(`Delete failed: ${err.message}`, { id: toastId });
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark">
        <Loader2 size={20} className="animate-spin mr-2" /> Loading documents...
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
        <AlertTriangle size={18} /> {error}
        <button onClick={fetchFiles} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
      </div>
    );
  }

  if (files.length === 0) {
    return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-4">No documents uploaded.</p>;
  }

  return (
    <div className="space-y-1.5 text-xs custom-scrollbar pr-1">
      {files.map(filename => {
        const isSelected = selectedDocument === filename;

        return (
          <div
            key={filename}
            onClick={() => onSelectDocument(isSelected ? null : filename)}
            className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                        ${isSelected
                          ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                          : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
            title={`Select ${filename}`}
          >
            <div className="flex items-center gap-2 truncate">
              {isSelected ? (
                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
              ) : (
                <FileText size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
              )}
              <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                {filename}
              </span>
            </div>
            <div className="flex-shrink-0 flex items-center gap-0.5">
              <IconButton
                icon={Trash2}
                size="sm"
                variant="ghost"
                title="Delete"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete(filename);
                }}
                className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"
              />
            </div>
          </div>
        );
      })}
    </div>
  );
}


export default DocumentList;
```

`frontend/src/components/documents/DocumentUpload.jsx`

```javascript


// frontend/src/components/documents/DocumentUpload.jsx
import React, { useState, useRef, useEffect } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { UploadCloud, FileText, XCircle, Paperclip, Link as LinkIcon } from 'lucide-react';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';

// Define the stages for our static simulation
const RAG_STAGES = [
    { name: "Uploading", duration: 1500, message: "Transferring your document to the server..." },
    { name: "Processing", duration: 2000, message: "Validating file format and structure..." },
    { name: "Extracting", duration: 3000, message: "Extracting text and content from your document..." },
    { name: "Chunking", duration: 1500, message: "Breaking document into manageable segments..." },
    { name: "Embedding", duration: 4000, message: "Converting content to searchable vectors..." },
    { name: "Analyzing", duration: 3000, message: "Indexing content for optimal retrieval..." },
];
// MODIFIED: Renamed 'onUploadSuccess' prop to 'onSourceAdded'
function DocumentUpload({ onSourceAdded }) { 
    const [selectedFile, setSelectedFile] = useState(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const [progress, setProgress] = useState(0);
    const [currentStage, setCurrentStage] = useState('');
    const [stageMessage, setStageMessage] = useState('');
    const [errorMessage, setErrorMessage] = useState('');
    const [dragActive, setDragActive] = useState(false);
    const [urlInput, setUrlInput] = useState('');
    const [isIngestingUrl, setIsIngestingUrl] = useState(false);

    const fileInputRef = useRef(null);
    const processingTimeoutRef = useRef(null);
    
    useEffect(() => {
        return () => {
            if (processingTimeoutRef.current) {
                clearTimeout(processingTimeoutRef.current);
            }
        };
    }, []);

    const handleFileChange = (e) => {
        if (isProcessing) return;
        const file = e.target.files && e.target.files[0];
        if (file) {
            setSelectedFile(file);
            setErrorMessage('');
        }
    };

    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(e.type === "dragenter" || e.type === "dragover"); };
    const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(false); const file = e.dataTransfer.files && e.dataTransfer.files[0]; if (file) { setSelectedFile(file); setErrorMessage(''); }};

    const resetState = () => {
        setSelectedFile(null);
        setIsProcessing(false);
        setProgress(0);
        setCurrentStage('');
        setStageMessage('');
        setErrorMessage('');
        if (fileInputRef.current) fileInputRef.current.value = null;
    };
    
    const runProgressSimulation = (stageIndex = 0) => {
        if (stageIndex >= RAG_STAGES.length) return;

        const stage = RAG_STAGES[stageIndex];
        setCurrentStage(stage.name);
        setStageMessage(stage.message);
        
        const totalDuration = RAG_STAGES.reduce((acc, s) => acc + s.duration, 0);
        const elapsedDuration = RAG_STAGES.slice(0, stageIndex).reduce((acc, s) => acc + s.duration, 0);
        setProgress(Math.round((elapsedDuration / totalDuration) * 100));

        processingTimeoutRef.current = setTimeout(() => {
            runProgressSimulation(stageIndex + 1);
        }, stage.duration);
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            toast.error("Please select a file first.");
            return;
        }
        setIsProcessing(true);
        setErrorMessage('');
        runProgressSimulation(0);

        const formData = new FormData();
        formData.append("file", selectedFile);
        
        try {
            await api.uploadFile(formData);
            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            setProgress(100);
            toast.success(`'${selectedFile.name}' accepted! Processing has begun.`, { duration: 4000 });
            
            setTimeout(() => {
                resetState();
                if (onSourceAdded) onSourceAdded(); // Now correctly calls onSourceAdded
            }, 1500);

        } catch (error) {
            if (processingTimeoutRef.current) clearTimeout(processingTimeoutRef.current);
            const msg = error.response?.data?.message || error.message || "Upload failed.";
            setErrorMessage(msg);
            toast.error(`Upload failed: ${msg}`);
            setIsProcessing(false);
            setCurrentStage('Failed');
            setProgress(100);
        }
    };

    const handleIngestUrl = async () => {
        const url = urlInput.trim();
        if (!url) {
            toast.error("Please enter a valid URL.");
            return;
        }
        setIsIngestingUrl(true);
        const toastId = toast.loading(`Ingesting URL: ${url.substring(0, 30)}...`);
        try {
            await api.addUrlSource(url);
            toast.success("URL accepted! Processing has begun in the background.", { id: toastId });
            setUrlInput('');
            if (onSourceAdded) onSourceAdded(); // Now correctly calls onSourceAdded
        } catch (error) {
            const msg = error.response?.data?.message || error.message || "Failed to ingest URL.";
            toast.error(msg, { id: toastId });
        } finally {
            setIsIngestingUrl(false);
        }
    };

    if (isProcessing) {
        return (
            <div className="card-base p-4 mb-4">
                <h3 className="font-semibold text-text-light dark:text-text-dark">
                    📄 Processing: <span className="font-normal truncate">{selectedFile.name}</span>
                </h3>
                <div className="relative w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 my-2">
                    <motion.div
                        className={`h-2.5 rounded-full ${errorMessage ? 'bg-red-500' : 'bg-primary'}`}
                        initial={{ width: '0%' }}
                        animate={{ width: `${progress}%` }}
                        transition={{ duration: 0.5, ease: 'linear' }}
                    />
                </div>
                <div className="flex justify-between text-xs text-text-muted-light dark:text-text-muted-dark">
                    <span>{errorMessage ? 'Error' : `Stage: ${currentStage}`} ({progress}%)</span>
                </div>
                <p className="text-xs text-center mt-2 h-4">{errorMessage || stageMessage}</p>
                {errorMessage && (
                    <Button onClick={resetState} fullWidth variant="danger" size="sm" className="mt-3">
                        Close
                    </Button>
                )}
            </div>
        );
    }
    
    return (
        <div className="mb-4 space-y-4">
            {/* --- File Upload Section (Existing JSX, no changes needed) --- */}
            <div>
                <label
                    htmlFor="file-upload-input"
                    onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}
                    className={`flex flex-col items-center justify-center w-full h-28 px-4 transition-colors duration-200 ease-in-out bg-surface-light dark:bg-gray-800 border-2 border-dashed rounded-lg cursor-pointer border-border-light dark:border-border-dark hover:border-primary dark:hover:border-primary-light ${dragActive ? "border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light bg-primary/10 dark:bg-primary-dark/20" : ""}`}
                >
                    <div className="flex flex-col items-center justify-center text-center">
                        <Paperclip size={28} className={`mb-1 transition-colors ${dragActive ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark"><span className="font-semibold text-primary dark:text-primary-light">Upload a file</span> or drag & drop</p>
                        <p className="text-xs text-text-muted-light/70 dark:text-text-muted-dark/70">PDF, DOCX, TXT, Media, etc.</p>
                    </div>
                    <input ref={fileInputRef} id="file-upload-input" type="file" className="hidden" onChange={handleFileChange} accept=".pdf,.docx,.txt,.md,.mp3,.wav,.mp4,.mov,.png,.jpg,.jpeg" />
                </label>
                {selectedFile && ( <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm animate-fadeIn"> <div className="flex items-center gap-2 truncate"> <FileText size={18} className="text-primary flex-shrink-0" /> <span className="truncate text-text-light dark:text-text-dark" title={selectedFile.name}>{selectedFile.name}</span> <span className="text-text-muted-light dark:text-text-muted-dark text-xs whitespace-nowrap"> ({(selectedFile.size / 1024).toFixed(1)} KB) </span> </div> <button onClick={() => setSelectedFile(null)} className="text-red-500 hover:text-red-700 dark:hover:text-red-400 transition-colors p-1 rounded-full hover:bg-red-500/10"> <XCircle size={18} /> </button> </div> )}
                <Button onClick={handleUpload} fullWidth className="mt-2 text-sm" variant="primary" disabled={!selectedFile} leftIcon={<UploadCloud size={16} />}> Process File </Button>
            </div>

            {/* --- NEW URL INGESTION SECTION --- */}
            <div className="relative pt-4 border-t border-border-light dark:border-border-dark">
                <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark absolute -top-2.5 left-1/2 -translate-x-1/2 bg-surface-light dark:bg-surface-dark px-2">OR</p>
                <label htmlFor="url-input" className="block text-sm font-medium text-text-light dark:text-text-dark mb-1.5">Add from URL</label>
                <div className="flex items-center gap-2">
                    <div className="relative flex-grow">
                        <LinkIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-text-muted-light dark:text-text-muted-dark" />
                        <input
                            id="url-input"
                            type="url"
                            value={urlInput}
                            onChange={(e) => setUrlInput(e.target.value)}
                            placeholder="Enter YouTube or webpage URL..."
                            className="input-field !pl-9 !py-2 !text-sm w-full"
                            disabled={isIngestingUrl}
                        />
                    </div>
                    <Button
                        onClick={handleIngestUrl}
                        size="md"
                        className="!px-3 !py-2"
                        isLoading={isIngestingUrl}
                        disabled={!urlInput.trim() || isIngestingUrl}
                    >
                        Ingest
                    </Button>
                </div>
            </div>
        </div>
    );
}

export default DocumentUpload;
```

`frontend/src/components/documents/KnowledgeSourceList.jsx`

```javascript
// frontend/src/components/documents/KnowledgeSourceList.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import {
    FileText, CheckCircle, Loader2, AlertTriangle, Trash2,
    Youtube, Globe, Library
} from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { formatDistanceToNow } from 'date-fns';

const getSourceIcon = (sourceType) => {
    const icons = {
        'document': FileText, 'youtube': Youtube, 'webpage': Globe,
        'subject': Library, 'audio': FileText, 'video': FileText, 'image': FileText
    };
    return icons[sourceType] || FileText;
};

const formatRelativeTime = (dateString) => {
    if (!dateString) return 'date unknown';
    try {
        const date = new Date(dateString);
        if (isNaN(date.getTime())) return 'invalid date';
        return formatDistanceToNow(date, { addSuffix: true });
    } catch (e) {
        return 'date error';
    }
};

function KnowledgeSourceList({ onSelectSource, selectedSource, onRefreshNeeded }) {
    const [sources, setSources] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState('');
    const pollingIntervalRef = useRef(null);

    const fetchSources = useCallback(async (isPolling = false) => {
        if (!isPolling) setLoading(true);
        setError('');
        try {
            const response = await api.getKnowledgeSources();
            const fetchedSources = Array.isArray(response) ? response : [];
            const userOnlySources = fetchedSources.filter(source => source.sourceType !== 'subject');
            setSources(userOnlySources)
            // Check if there are any sources still processing to decide if we need to continue polling.
            const stillProcessing = fetchedSources.some(s => s.status && s.status.startsWith('processing'));
            
            if (pollingIntervalRef.current && !stillProcessing) {
                console.log("[Polling] All sources processed. Stopping polling.");
                clearInterval(pollingIntervalRef.current);
                pollingIntervalRef.current = null;
            }
        } catch (err) {
            setError(err.message || "Failed to fetch knowledge sources.");
            if (!isPolling) toast.error("Could not load knowledge base.");
            // Stop polling on error
            if (pollingIntervalRef.current) {
                clearInterval(pollingIntervalRef.current);
                pollingIntervalRef.current = null;
            }
        } finally {
            if (!isPolling) setLoading(false);
        }
    }, []);

    // Effect for initial load and manual refresh
    useEffect(() => {
        fetchSources();
    }, [fetchSources, onRefreshNeeded]);

    // --- NEW: Effect for automatic polling ---
    useEffect(() => {
        // Stop any existing polling interval when the component mounts or sources change
        if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current);
            pollingIntervalRef.current = null;
        }

        // Check if there are any sources currently in a processing state
        const isProcessing = sources.some(s => s.status && s.status.startsWith('processing'));

        if (isProcessing) {
            console.log("[Polling] Detected processing sources. Starting polling every 5 seconds.");
            pollingIntervalRef.current = setInterval(() => {
                console.log("[Polling] Fetching source statuses...");
                fetchSources(true); // `true` indicates this is a silent background poll
            }, 5000); // Poll every 5 seconds
        }

        // Cleanup function to clear the interval when the component unmounts
        // or when the dependencies (sources array) change.
        return () => {
            if (pollingIntervalRef.current) {
                clearInterval(pollingIntervalRef.current);
            }
        };
    }, [sources, fetchSources]); // This effect depends on the `sources` array

    const handleDelete = async (sourceId, sourceTitle, sourceType) => {
        // ... (handleDelete logic remains exactly the same) ...
        if (sourceType === 'subject') {
            toast.error("Admin-provided subjects cannot be deleted by users.");
            return;
        }
        if (!window.confirm(`Are you sure you want to delete "${sourceTitle}"? This will remove it and all its associated data.`)) return;
        
        const toastId = toast.loading(`Deleting ${sourceTitle}...`);
        try {
            await api.deleteKnowledgeSource(sourceId);
            toast.success(`"${sourceTitle}" deleted.`, { id: toastId });
            fetchSources();
            if (selectedSource === sourceTitle) {
                onSelectSource(null);
            }
        } catch (err) {
            toast.error(`Delete failed: ${err.message}`, { id: toastId });
        }
    };

    if (loading) {
        // ... (loading JSX remains the same) ...
        return (
            <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark">
                <Loader2 size={20} className="animate-spin mr-2" /> Loading knowledge base...
            </div>
        );
    }

    if (error) {
        // ... (error JSX remains the same) ...
        return (
            <div className="p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                <AlertTriangle size={18} /> {error}
                <button onClick={() => fetchSources()} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
            </div>
        );
    }

    if (sources.length === 0) {
        // ... (empty JSX remains the same) ...
        return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-4">Your knowledge base is empty.</p>;
    }

    return (
        // ... (the main return JSX with the list mapping remains exactly the same) ...
        <div className="space-y-1.5 text-xs custom-scrollbar pr-1">
            {sources.map(source => {
                const isSelected = selectedSource === source.title;
                const isProcessing = source.status && source.status.startsWith('processing');
                const isFailed = source.status === 'failed';
                const isSelectable = source.status === 'completed';
                const Icon = getSourceIcon(source.sourceType);

                return (
                    <div
                        key={source._id}
                        onClick={() => isSelectable && onSelectSource(isSelected ? null : source.title)}
                        className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between transition-all duration-150
                                    ${isSelectable ? 'cursor-pointer hover:shadow-md' : 'cursor-default opacity-80'}
                                    ${isSelected ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light' : 'border-border-light dark:border-border-dark'}`}
                        title={isSelectable ? `Select ${source.title}` : `Status: ${source.status} - ${source.failureReason || ''}`}
                    >
                        <div className="flex items-center gap-2 truncate">
                            {isSelected ? <CheckCircle size={16} className="text-green-500 flex-shrink-0" /> : <Icon size={16} className="text-primary dark:text-primary-light flex-shrink-0" />}
                            <div className="truncate">
                                <span className={`block truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>{source.title}</span>
                                <span className="text-[0.7rem] text-text-muted-light dark:text-text-muted-dark">
                                    {formatRelativeTime(source.createdAt)}
                                </span>
                            </div>
                        </div>
                        <div className="flex items-center gap-1.5 flex-shrink-0">
                             {isProcessing && <Loader2 size={14} className="animate-spin text-accent" title={`Processing... (${source.status})`} />}
                             {isFailed && <AlertTriangle size={14} className="text-red-500" title={`Processing failed: ${source.failureReason || 'Unknown error'}`} />}
                             {source.sourceType !== 'subject' && (
                                <IconButton icon={Trash2} size="sm" variant="ghost" title="Delete"
                                    onClick={(e) => { e.stopPropagation(); handleDelete(source._id, source.title, source.sourceType); }}
                                    className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"
                                />
                             )}
                        </div>
                    </div>
                );
            })}
        </div>
    );
}

export default KnowledgeSourceList;
```

`frontend/src/components/documents/SourceIngestion.jsx`

```javascript
// frontend/src/components/documents/SourceIngestion.jsx
import React, { useState, useRef } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { UploadCloud, FileText, XCircle, Paperclip, Link as LinkIcon } from 'lucide-react';
import Button from '../core/Button.jsx';

function SourceIngestion({ onSourceAdded }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const [dragActive, setDragActive] = useState(false);
    const [urlInput, setUrlInput] = useState('');
    const [isIngestingUrl, setIsIngestingUrl] = useState(false);
    const fileInputRef = useRef(null);

    const handleFileChange = (e) => {
        if (isUploading) return;
        const file = e.target.files?.[0];
        if (file) setSelectedFile(file);
    };

    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (isUploading) return; setDragActive(e.type === "dragenter" || e.type === "dragover"); };
    const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); if (isUploading) return; setDragActive(false); const file = e.dataTransfer.files?.[0]; if (file) setSelectedFile(file); };

    const handleUpload = async () => {
        if (!selectedFile) {
            toast.error("Please select a file to upload.");
            return;
        }
        setIsUploading(true);
        const toastId = toast.loading(`Uploading "${selectedFile.name}"... This may take a moment.`);
        
        const formData = new FormData();
        formData.append("file", selectedFile);
        
        try {
            await api.uploadFile(formData);
            toast.success(`'${selectedFile.name}' accepted! Processing has begun.`, { id: toastId, duration: 4000 });
            setSelectedFile(null);
            if (onSourceAdded) onSourceAdded();
        } catch (error) {
            const msg = error.response?.data?.message || error.message || "Upload failed.";
            toast.error(`Upload failed: ${msg}`, { id: toastId });
        } finally {
            setIsUploading(false);
        }
    };

    const handleIngestUrl = async () => {
        const url = urlInput.trim();
        if (!url) {
            toast.error("Please enter a valid URL.");
            return;
        }
        setIsIngestingUrl(true);
        const toastId = toast.loading(`Ingesting URL: ${url.substring(0, 30)}...`);
        try {
            await api.addUrlSource(url);
            toast.success("URL accepted! Processing has begun in the background.", { id: toastId });
            setUrlInput('');
            if (onSourceAdded) onSourceAdded();
        } catch (error) {
            const msg = error.response?.data?.message || error.message || "Failed to ingest URL.";
            toast.error(msg, { id: toastId });
        } finally {
            setIsIngestingUrl(false);
        }
    };

    return (
        <div className="space-y-4">
            {/* --- File Upload Section --- */}
            <div>
                <label
                    htmlFor="file-upload-input"
                    onDragEnter={handleDrag} onDragLeave={handleDrag} onDragOver={handleDrag} onDrop={handleDrop}
                    className={`flex flex-col items-center justify-center w-full h-28 px-4 transition-colors duration-200 ease-in-out bg-surface-light dark:bg-gray-800 border-2 border-dashed rounded-lg cursor-pointer border-border-light dark:border-border-dark hover:border-primary dark:hover:border-primary-light ${dragActive ? "border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light bg-primary/10 dark:bg-primary-dark/20" : ""}`}
                >
                    <div className="flex flex-col items-center justify-center text-center">
                        <Paperclip size={28} className={`mb-1 transition-colors ${dragActive ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark"><span className="font-semibold text-primary dark:text-primary-light">Upload a file</span> or drag & drop</p>
                        <p className="text-xs text-text-muted-light/70 dark:text-text-muted-dark/70">PDF, DOCX, Media, etc.</p>
                    </div>
                    <input ref={fileInputRef} id="file-upload-input" type="file" className="hidden" onChange={handleFileChange} accept=".pdf,.docx,.txt,.md,.mp3,.wav,.mp4,.mov,.png,.jpg,.jpeg" />
                </label>
                {selectedFile && (
                    <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm animate-fadeIn">
                        <div className="flex items-center gap-2 truncate">
                            <FileText size={18} className="text-primary flex-shrink-0" />
                            <span className="truncate text-text-light dark:text-text-dark" title={selectedFile.name}>{selectedFile.name}</span>
                        </div>
                        <button onClick={() => setSelectedFile(null)} className="p-1 rounded-full text-red-500 hover:text-red-700 dark:hover:text-red-400 transition-colors hover:bg-red-500/10">
                            <XCircle size={18} />
                        </button>
                    </div>
                )}
                <Button onClick={handleUpload} fullWidth className="mt-2 text-sm" variant="primary" isLoading={isUploading} disabled={!selectedFile || isUploading} leftIcon={<UploadCloud size={16} />}>
                    Process File
                </Button>
            </div>

            {/* --- URL Ingestion Section --- */}
            <div className="relative pt-4 border-t border-border-light dark:border-border-dark">
                <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark absolute -top-2.5 left-1/2 -translate-x-1/2 bg-surface-light dark:bg-surface-dark px-2">OR</p>
                <div className="flex items-center gap-2">
                    <div className="relative flex-grow">
                        <LinkIcon className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-text-muted-light dark:text-text-muted-dark" />
                        <input
                            id="url-input"
                            type="url"
                            value={urlInput}
                            onChange={(e) => setUrlInput(e.target.value)}
                            placeholder="Enter YouTube or webpage URL..."
                            className="input-field !pl-9 !py-2 !text-sm w-full"
                            disabled={isIngestingUrl}
                        />
                    </div>
                    <Button onClick={handleIngestUrl} size="md" className="!px-3 !py-2" isLoading={isIngestingUrl} disabled={!urlInput.trim() || isIngestingUrl}>
                        Ingest
                    </Button>
                </div>
            </div>
        </div>
    );
}

export default SourceIngestion;
```

`frontend/src/components/documents/SubjectList.jsx`

```javascript
// frontend/src/components/documents/SubjectList.jsx
import React from 'react';
import { Library, CheckCircle, Loader2, AlertTriangle } from 'lucide-react'; // Added AlertTriangle

function SubjectList({
    subjects,           // Array of subject name strings
    selectedSubject,    // Currently selected subject name (string or null)
    onSelectSubject,    // Function to call when a subject is selected (passes subjectName or null)
    isLoading,          // Boolean to indicate if subjects are being fetched
    error               // String error message if fetching failed
}) {
    if (isLoading) {
        return (
            <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark text-xs">
                <Loader2 size={16} className="animate-spin mr-2" /> Loading subjects...
            </div>
        );
    }

    if (error) {
        return (
            <div className="p-2 my-1 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center justify-center gap-1">
                <AlertTriangle size={14} /> {error}
            </div>
        );
    }

    if (!subjects || subjects.length === 0) {
        return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-3">No subjects configured by admin yet.</p>;
    }

    return (
        <div className="space-y-1.5 text-xs custom-scrollbar pr-1 max-h-60 overflow-y-auto"> {/* Added max-h and overflow */}
            {/* Option to deselect/choose general chat */}
            <div
                onClick={() => onSelectSubject(null)} // Pass null to deselect
                className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                            ${!selectedSubject // Highlighted if no subject is selected
                                ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                title="Select General Chat (No Specific Subject)"
            >
                <div className="flex items-center gap-2 truncate">
                    {!selectedSubject ? (
                        <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                    ) : (
                        // Using a generic icon, or you can use a different one for "none"
                        <Library size={16} className="text-gray-400 dark:text-gray-500 flex-shrink-0" />
                    )}
                    <span className={`truncate ${!selectedSubject ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                        -- General Chat --
                    </span>
                </div>
            </div>

            {/* List of available subjects */}
            {subjects.map(subjectName => {
                const isSelected = selectedSubject === subjectName;
                return (
                    <div
                        key={subjectName}
                        onClick={() => onSelectSubject(isSelected ? null : subjectName)} // Toggle selection
                        className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                                    ${isSelected
                                        ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                                        : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
                        title={`Select Subject: ${subjectName}`}
                    >
                        <div className="flex items-center gap-2 truncate">
                            {isSelected ? (
                                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
                            ) : (
                                <Library size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                            )}
                            <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                                {subjectName}
                            </span>
                        </div>
                        {/* No actions like delete for subjects from this view */}
                    </div>
                );
            })}
        </div>
    );
}

export default SubjectList;
```

`frontend/src/components/layout/CenterPanel.jsx`

```javascript
// frontend/src/components/layout/CenterPanel.jsx
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import ChatHistory from '../chat/ChatHistory';
import ChatInput from '../chat/ChatInput';
import PromptCoachModal from '../chat/PromptCoachModal.jsx';
import api from '../../services/api';
import { useAuth as useRegularAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import toast from 'react-hot-toast';
import { motion } from 'framer-motion';
import { Globe, BookMarked, Code, TestTubeDiagonal, Sparkles, ChevronRight, Flame } from 'lucide-react';

const features = [
    {
        icon: Globe,
        title: "Web Search Agent",
        description: "Get real-time answers and information from the web for up-to-the-minute topics.",
        status: 'active',
        glowColor: 'blue'
    },
    {
        icon: BookMarked,
        title: "Academic Search",
        description: "Find and synthesize information from academic papers and scholarly articles.",
        status: 'active',
        glowColor: 'purple'
    },
    {
        icon: Code,
        title: "Secure Code Executor",
        description: "Write, compile, and run code in a sandboxed environment with AI assistance.",
        status: 'active',
        glowColor: 'orange'
    },
    {
        icon: TestTubeDiagonal,
        title: "API Endpoint Tester",
        description: "A tool for testing and validating API endpoints will be available soon.",
        status: 'soon',
        glowColor: 'gray'
    }
];

const glowStyles = {
    blue: "hover:border-blue-400 dark:hover:border-blue-500 hover:shadow-[0_0_20px_theme(colors.blue.500/40%)]",
    purple: "hover:border-purple-400 dark:hover:border-purple-500 hover:shadow-[0_0_20px_theme(colors.purple.500/40%)]",
    orange: "hover:border-orange-400 dark:hover:border-orange-500 hover:shadow-[0_0_20px_theme(colors.orange.500/40%)]",
    gray: "" // No glow for disabled/soon cards
};

function CenterPanel({ messages, setMessages, currentSessionId, onChatProcessingChange, initialPromptForNewSession, setInitialPromptForNewSession, initialActivityForNewSession, setInitialActivityForNewSession }) {
    const { token: regularUserToken } = useRegularAuth();
    const { setSelectedSubject, systemPrompt, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const navigate = useNavigate();
    const location = useLocation();

    // Local state for toggles and component status
    const [useWebSearch, setUseWebSearch] = useState(false);
    const [useAcademicSearch, setUseAcademicSearch] = useState(false);
    const [criticalThinkingEnabled, setCriticalThinkingEnabled] = useState(false);
    const [isActuallySendingAPI, setIsActuallySendingAPI] = useState(false);
    const abortControllerRef = useRef(null);
    const [recommendations, setRecommendations] = useState([]);
    const [isLoadingRecs, setIsLoadingRecs] = useState(true);
    // const [promptFromNav, setPromptFromNav] = useState('');
    const [isCoachModalOpen, setIsCoachModalOpen] = useState(false);
    const [coachData, setCoachData] = useState(null);
    
    // --- STABLE FUNCTION DEFINITIONS ---

    const handleStreamingSendMessage = useCallback(async (inputText, placeholderId, options) => {
        const payload = {
            query: inputText.trim(), 
            sessionId: currentSessionId, 
            useWebSearch: options.useWebSearch, 
            useAcademicSearch: options.useAcademicSearch,
            systemPrompt, 
            criticalThinkingEnabled: options.criticalThinkingEnabled, 
            documentContextName: options.documentContextName,
        };

        const response = await fetch(`${import.meta.env.VITE_API_BASE_URL}/chat/message`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${regularUserToken}` },
            body: JSON.stringify(payload),
            signal: abortControllerRef.current.signal,
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.message || `Server error: ${response.status}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let finalBotMessageObject = null;
        let accumulatedThinking = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n\n').filter(line => line.startsWith('data: '));
            
            for (const line of lines) {
                const jsonString = line.replace('data: ', '');
                try {
                    const eventData = JSON.parse(jsonString);
                    if (eventData.type === 'thought') {
                        accumulatedThinking += eventData.content;
                        setMessages(prev => prev.map(msg => msg.id === placeholderId ? { ...msg, thinking: accumulatedThinking, _accumulatedContent: accumulatedThinking } : msg));
                    } else if (eventData.type === 'final_answer') {
                        finalBotMessageObject = eventData.content;
                    } else if (eventData.type === 'error') {
                        throw new Error(eventData.content);
                    }
                } catch (e) { 
                    console.error("Error parsing SSE chunk:", jsonString, e); 
                }
            }
        }
        
        if (finalBotMessageObject) {
            setMessages(prev => prev.map(msg => msg.id === placeholderId ? { ...finalBotMessageObject, id: placeholderId, sender: 'bot', isStreaming: false, thinking: accumulatedThinking || finalBotMessageObject.thinking } : msg));
        }
    }, [currentSessionId, systemPrompt, regularUserToken, setMessages]);

    const handleStandardSendMessage = useCallback(async (inputText, placeholderId, options) => {
        const response = await api.sendMessage({
            query: inputText.trim(), 
            history: messages.slice(0, -2),
            sessionId: currentSessionId,
            useWebSearch: options.useWebSearch,
            useAcademicSearch: options.useAcademicSearch, 
            systemPrompt, 
            documentContextName: options.documentContextName
        });

        if (response && response.reply) {
            setMessages(prev => prev.map(msg => msg.id === placeholderId ? { ...response.reply, id: placeholderId, isStreaming: false } : msg));
        } else {
            throw new Error("Invalid response from AI service.");
        }
    }, [messages, currentSessionId, systemPrompt, setMessages]);

    const handleSendMessage = useCallback(async (inputText, options = {}) => {
        if (!inputText.trim() || !regularUserToken || !currentSessionId || isActuallySendingAPI) return;

        const effectiveUseWebSearch = options.useWebSearch ?? useWebSearch;
        const effectiveUseAcademicSearch = options.useAcademicSearch ?? useAcademicSearch;
        const effectiveCriticalThinking = options.criticalThinkingEnabled ?? criticalThinkingEnabled;
        const effectiveDocumentContext = options.documentContextName ?? selectedSubject ?? selectedDocumentForAnalysis;

        abortControllerRef.current = new AbortController();

        const userMessage = {
            id: `user-${Date.now()}`,
            sender: 'user',
            text: inputText.trim(),
            timestamp: new Date().toISOString(),
        };

        const streamingPlaceholderId = `bot-streaming-${Date.now()}`;
        const placeholderMessage = {
            id: streamingPlaceholderId,
            sender: 'bot',
            text: '',
            thinking: effectiveCriticalThinking ? '' : null,
            isStreaming: true,
            timestamp: new Date().toISOString(),
            _accumulatedContent: ''
        };

        setMessages(prev => [...prev, userMessage, placeholderMessage]);
        onChatProcessingChange(true);
        setIsActuallySendingAPI(true);

        try {
            const handlerOptions = {
                useWebSearch: effectiveUseWebSearch,
                useAcademicSearch: effectiveUseAcademicSearch,
                criticalThinkingEnabled: effectiveCriticalThinking,
                documentContextName: effectiveDocumentContext
            };

            if (effectiveCriticalThinking) {
                await handleStreamingSendMessage(inputText, streamingPlaceholderId, handlerOptions);
            } else {
                await handleStandardSendMessage(inputText, streamingPlaceholderId, handlerOptions);
            }
        } catch (error) {
            console.error("Error in handleSendMessage:", error);
            setMessages(prev => prev.map(msg =>
                msg.id === streamingPlaceholderId
                ? { ...msg, isStreaming: false, text: `Error: ${error.message}` }
                : msg
            ));
            toast.error(error.message);
        } finally {
            setIsActuallySendingAPI(false);
            onChatProcessingChange(false);
            setUseWebSearch(false);
            setUseAcademicSearch(false);
        }
    }, [
        regularUserToken, currentSessionId, isActuallySendingAPI, useWebSearch, 
        useAcademicSearch, criticalThinkingEnabled, selectedSubject, 
        selectedDocumentForAnalysis, setMessages, onChatProcessingChange,
        handleStreamingSendMessage, handleStandardSendMessage, systemPrompt
    ]);
    
    // --- HOOKS ---

    useEffect(() => {
        const fetchRecommendations = async () => {
            if (messages.length === 0 && currentSessionId) {
                setIsLoadingRecs(true);
                try {
                    const data = await api.getRecommendations(currentSessionId);
                    setRecommendations(data.recommendations || []);
                } catch (error) {
                    console.error("Failed to fetch recommendations:", error);
                    setRecommendations([]);
                } finally {
                    setIsLoadingRecs(false);
                }
            }
        };
        fetchRecommendations();
    }, [currentSessionId, messages.length]);

    const handleFeatureClick = (title) => {
        switch (title) {
            case 'Web Search Agent':
                setUseWebSearch(true);
                toast.success("Web Search has been enabled for your next message.");
                break;
            case 'Academic Search':
                setUseAcademicSearch(true);
                toast.success("Academic Search has been enabled for your next message.");
                break;
            case 'Secure Code Executor':
                navigate('/tools/code-executor');
                break;
            case 'API Endpoint Tester':
                toast.info("The API Endpoint Tester is coming soon!");
                break;
            default:
                break;
        }
    };

    const handleRecommendationClick = async (rec) => {
        if (isActuallySendingAPI) return;
        setUseWebSearch(false);
        setUseAcademicSearch(false);

        // This is now an auto-sending action
        const options = {
            useWebSearch: rec.actionType === 'web_search',
            useAcademicSearch: rec.actionType === 'academic_search',
            documentContextName: null
        };
        
        let query = rec.topic;
        
        switch (rec.actionType) {
            case 'direct_answer':
                query = `Regarding the topic of "${rec.topic}", please provide a detailed explanation. Elaborate on the key concepts and provide clear examples.`;
                break;
            case 'web_search':
                query = `Search the web for the latest information on: ${rec.topic}`;
                break;
            case 'academic_search':
                query = `Find and summarize academic papers about: ${rec.topic}`;
                break;
            case 'document_review': {
                toast.loading(`Finding the best document for "${rec.topic}"...`, { id: 'doc-find-toast' });
                try {
                    const { documentName } = await api.findDocumentForTopic(rec.topic);
                    toast.success(`Focus set to document: ${documentName}`, { id: 'doc-find-toast' });
                    setSelectedSubject(documentName);
                    options.documentContextName = documentName;
                    query = `Based on the document "${documentName}", please explain "${rec.topic}".`;
                } catch (error) {
                    toast.error(error.message || `Could not find a document for "${rec.topic}".`, { id: 'doc-find-toast' });
                    return; // Stop execution if document not found
                }
                break;
            }
            default:
                toast.error(`Unknown recommendation type: ${rec.actionType}`);
                return; // Stop execution
        }
        
        toast.success(`Exploring "${rec.topic}" for you...`);
        handleSendMessage(query, options);
    };

    const RecommendationCard = ({ rec, index }) => (
        <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: index * 0.1, ease: "easeOut" }}
            className="relative p-[2px] rounded-lg group"
            style={{
                background: `conic-gradient(from var(--angle), #059669, #3b82f6, #9333ea, #059669)`,
                animation: 'spin-border 6s linear infinite',
            }}
        >
            <button
                onClick={() => handleRecommendationClick(rec)}
                disabled={isActuallySendingAPI}
                className="w-full h-full text-left bg-surface-light dark:bg-slate-800 rounded-[7px] p-4 flex flex-col justify-between transition-colors duration-300 hover:bg-gray-50 dark:hover:bg-slate-700 disabled:opacity-60"
            >
                <div>
                    <div className="flex items-center gap-2 mb-2">
                        <Sparkles size={16} className="text-primary dark:text-teal-400 flex-shrink-0 twinkling-text" />
                        <p className="text-sm font-semibold text-primary dark:text-primary-light uppercase tracking-wider truncate" title={rec.topic}>
                            {rec.topic}
                        </p>
                    </div>
                    <p className="text-sm text-text-muted-light dark:text-text-muted-dark mt-1 h-16">
                        {rec.suggestion_text}
                    </p>
                </div>
                <div className="mt-4 text-sm font-bold text-teal-500 dark:text-teal-400 self-start flex items-center gap-1.5 transition-transform duration-300 group-hover:translate-x-1">
                    Explore Now
                    <ChevronRight size={18} />
                </div>
            </button>
        </motion.div>
    );

    return (
        <div className="flex flex-col h-full bg-background-light dark:bg-background-dark rounded-lg shadow-inner">
            {messages.length === 0 && !isActuallySendingAPI && currentSessionId ? (
                <div className="flex-1 flex flex-col justify-center items-center p-4 sm:p-8 overflow-y-auto custom-scrollbar animate-fadeIn">
                    <div className="w-full max-w-4xl mx-auto">
                        <div className="text-center">
                            <h1 className="text-5xl md:text-7xl font-extrabold bg-gradient-to-r from-purple-500 to-blue-500 text-transparent bg-clip-text mb-4">
                                Welcome to iMentor
                            </h1>
                            <p className="text-lg md:text-xl text-text-muted-light dark:text-text-muted-dark font-medium">
                                Your personal AI-powered guide for learning and discovery.
                            </p>
                        </div>
                        
                        <hr className="border-border-light dark:border-border-dark my-8" />
                        
                        <div className="text-center">
                            <h2 className="text-2xl font-semibold mb-6 text-orange-500 animated-underline">
                                What's New
                            </h2>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-2xl mx-auto">
                                {features.map((feature, index) => (
                                    <button 
                                        key={index}
                                        onClick={() => handleFeatureClick(feature.title)}
                                        disabled={feature.status === 'soon'}
                                        className={`group relative text-left bg-surface-light dark:bg-surface-dark/50 border border-border-light dark:border-border-dark rounded-lg p-4 transition-all duration-300 ease-in-out hover:scale-105 disabled:opacity-60 disabled:cursor-not-allowed ${glowStyles[feature.glowColor]}`}
                                    >
                                        <div className="relative">
                                            {feature.title === 'Secure Code Executor' && (
                                                <div className="fire-tag-animation absolute -top-2.5 -right-2.5 flex items-center gap-1 bg-gradient-to-br from-red-500 to-orange-400 text-white text-[10px] font-bold px-2 py-0.5 rounded-full shadow-lg">
                                                    <Flame size={12} />
                                                    HOT
                                                </div>
                                            )}
                                            {feature.status === 'soon' && <span className="absolute -top-2 -right-2 text-xs bg-yellow-400/20 text-yellow-600 dark:text-yellow-400 font-semibold px-2 py-0.5 rounded-full">Coming Soon</span>}
                                            <div className="flex items-center gap-3 mb-2">
                                                <feature.icon className="w-6 h-6 text-primary dark:text-primary-light" />
                                                <h3 className="font-semibold text-text-light dark:text-text-dark">{feature.title}</h3>
                                            </div>
                                            <p className="text-sm text-text-muted-light dark:text-text-muted-dark">{feature.description}</p>
                                        </div>
                                    </button>
                                ))}
                            </div>
                        </div>

                        {!isLoadingRecs && recommendations.length > 0 && (
                            <motion.div 
                                initial={{ opacity: 0, y: 30 }}
                                animate={{ opacity: 1, y: 0 }}
                                transition={{ duration: 0.8, delay: 0.5, ease: "easeOut" }}
                                className="mt-12"
                            >
                                <div className="relative text-center mb-6">
                                    <hr className="border-border-light dark:border-border-dark" />
                                    <div className="absolute -top-4 left-1/2 -translate-x-1/2 bg-background-light dark:bg-background-dark px-4">
                                        <h3 className="text-xl font-bold flex items-center gap-2 bg-gradient-to-r from-accent to-green-400 text-transparent bg-clip-text twinkling-text">
                                            <Sparkles size={20} /> Recommended For You
                                        </h3>
                                    </div>
                                </div>
                                <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark mb-6">
                                    Based on your recent activity, here are a few suggestions to explore next.
                                </p>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 max-w-4xl mx-auto">
                                    {recommendations.map((rec, index) => (
                                        <RecommendationCard key={index} rec={rec} index={index} />
                                    ))}
                                </div>
                            </motion.div>
                        )}
                    </div>
                </div>
            ) : (
                <ChatHistory messages={messages} onCueClick={handleSendMessage} />
            )}
            
            <ChatInput
                onSendMessage={handleSendMessage} 
                isLoading={isActuallySendingAPI}
                useWebSearch={useWebSearch} 
                setUseWebSearch={setUseWebSearch}
                useAcademicSearch={useAcademicSearch} 
                setUseAcademicSearch={setUseAcademicSearch}
                criticalThinkingEnabled={criticalThinkingEnabled} 
                setCriticalThinkingEnabled={setCriticalThinkingEnabled}
                initialPrompt={initialPromptForNewSession}
                setInitialPromptForNewSession={setInitialPromptForNewSession}
                openCoachModalWithData={setCoachData}
                setCoachModalOpen={setIsCoachModalOpen}
            />
            <PromptCoachModal
                isOpen={isCoachModalOpen}
                onClose={() => setIsCoachModalOpen(false)}
                onApply={(improvedPrompt) => {
                    // This logic now lives here, where it can set the initial prompt state
                    setInitialPromptForNewSession(improvedPrompt);
                }}
                data={coachData}
            />
        </div>
        
    );
}

export default CenterPanel;
```

`frontend/src/components/layout/LeftCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/LeftCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { Edit3, UploadCloud, FileText, ChevronRight, Settings2 } from 'lucide-react'; // Settings2 for fallback
import IconButton from '../core/IconButton.jsx'; 
import { motion } from 'framer-motion';

// Mapping icon names (or IDs) to Lucide components
const iconMap = {
    prompt: Edit3,       // Icon for "Custom Prompt"
    upload: UploadCloud, // Icon for "Upload Document"
    docs: FileText,      // Icon for "Document List"
};

function LeftCollapsedNav() {
    const { setIsLeftPanelOpen } = useAppState();

    // Define the items for the collapsed navigation bar
    const navItems = [
        { 
            id: 'prompt', 
            label: 'Custom Prompt', 
            iconName: 'prompt', // Matches key in iconMap
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, also scroll to/focus the prompt section in LeftPanel
            } 
        },
        { 
            id: 'upload', 
            label: 'Upload Document', 
            iconName: 'upload', 
            action: () => { 
                setIsLeftPanelOpen(true);
                // TODO: Optionally, open LeftPanel and focus/highlight upload area
            } 
        },
        { 
            id: 'docs', 
            label: 'Document List', 
            iconName: 'docs', 
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, open LeftPanel scrolled to document list
            } 
        },
    ];

    return (
        <motion.aside
            key="left-collapsed-nav" // Unique key for AnimatePresence
            initial={{ x: '-100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '-100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            // Styling for the thin vertical bar
            className="fixed left-0 top-16 bottom-0 z-30 w-14 sm:w-16 
                       bg-surface-light dark:bg-surface-dark 
                       border-r border-border-light dark:border-border-dark 
                       shadow-lg flex flex-col items-center py-3 space-y-2 custom-scrollbar"
        >
            {/* Button to open the full LeftPanel - Placed at the top */}
            <IconButton 
                icon={ChevronRight} 
                onClick={() => setIsLeftPanelOpen(true)} 
                title="Open Assistant Panel"
                ariaLabel="Open Assistant Panel"
                variant="ghost" 
                size="lg" // Make it prominent
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />

            {/* Icons for different sections of LeftPanel */}
            {navItems.map(item => {
                const IconComponent = iconMap[item.iconName] || Settings2; // Fallback icon
                return (
                    <IconButton 
                        key={item.id}
                        icon={IconComponent}
                        onClick={item.action} // Action currently just opens the panel
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md" 
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
            {/* Add a flexible spacer if you want the open button pushed further down from items */}
            {/* <div className="flex-grow"></div> */}
        </motion.aside>
    );
}
export default LeftCollapsedNav;
```

`frontend/src/components/layout/LeftPanel.jsx`

```javascript
// frontend/src/components/layout/LeftPanel.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import DocumentUpload from '../documents/DocumentUpload.jsx';
import KnowledgeSourceList from '../documents/KnowledgeSourceList.jsx';
import SubjectList from '../documents/SubjectList.jsx';
import {
    PanelLeftClose, ChevronDown, ChevronUp, FilePlus, Settings2,
    Bot, BookOpen, Lightbulb, Library
} from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion';
import toast from 'react-hot-toast';
import api from '../../services/api.js';

const PROMPT_PRESETS = [
     { id: 'friendly_tutor', name: 'Friendly Tutor', icon: Bot, text: "You are a friendly, patient, and encouraging tutor specializing in engineering and scientific topics for PhD students. Explain concepts clearly, break down complex ideas, use analogies, and offer positive reinforcement. Ask follow-up questions to ensure understanding." },
     { id: 'concept_explorer', name: 'Concept Explorer', icon: BookOpen, text: "You are an expert academic lecturer introducing a new, complex engineering or scientific concept. Your goal is to provide a deep, structured explanation. Define terms rigorously, outline the theory, provide relevant mathematical formulations (using Markdown), illustrative examples, and discuss applications or limitations pertinent to PhD-level research." },
     { id: 'knowledge_check', name: 'Knowledge Check', icon: Lightbulb, text: "You are assessing understanding of engineering/scientific topics. Ask targeted questions to test knowledge, identify misconceptions, and provide feedback on the answers. Start by asking the user what topic they want to be quizzed on." },
     { id: 'custom', name: 'Custom Prompt', icon: Settings2, text: "You are a helpful AI engineering tutor." }
];

function LeftPanel() {
    const {
        setIsLeftPanelOpen,
        systemPrompt, setSystemPrompt,
        selectDocumentForAnalysis, selectedDocumentForAnalysis,
        selectedSubject, setSelectedSubject
    } = useAppState();

    const [isPromptSectionOpen, setIsPromptSectionOpen] = useState(true);
    const [isSubjectSectionOpen, setIsSubjectSectionOpen] = useState(true);
    const [isKnowledgeBaseOpen, setIsKnowledgeBaseOpen] = useState(true);

    const [selectedPresetId, setSelectedPresetId] = useState('custom');
    const [availableSubjects, setAvailableSubjects] = useState([]);
    const [isLoadingSubjects, setIsLoadingSubjects] = useState(false);
    const [subjectFetchError, setSubjectFetchError] = useState('');
    const [refreshKey, setRefreshKey] = useState(Date.now());

    useEffect(() => {
        const matchedPreset = PROMPT_PRESETS.find(p => p.text === systemPrompt);
        setSelectedPresetId(matchedPreset ? matchedPreset.id : 'custom');
    }, [systemPrompt]);

    const fetchSubjects = useCallback(async () => {
        setIsLoadingSubjects(true);
        setSubjectFetchError('');
        try {
            const response = await api.getSubjects();
            const subjects = Array.isArray(response.subjects) ? response.subjects : [];
            setAvailableSubjects(subjects);
        } catch (error) {
            const errorMsg = error.response?.data?.message || error.message || "Failed to load subjects.";
            toast.error(errorMsg);
            setSubjectFetchError(errorMsg);
        } finally {
            setIsLoadingSubjects(false);
        }
    }, []);

    useEffect(() => {
        fetchSubjects();
    }, [fetchSubjects]);

    const handlePresetChange = (event) => {
        const presetId = event.target.value;
        setSelectedPresetId(presetId);
        const selectedPreset = PROMPT_PRESETS.find(p => p.id === presetId);
        if (selectedPreset) setSystemPrompt(selectedPreset.text);
    };

    // This function will now be responsible for triggering a refresh for all source additions
    const handleSourceAdded = () => {
        toast.success("New source added! Refreshing list...", { id: 'refresh-toast' });
        setRefreshKey(Date.now()); // This triggers a re-render of KnowledgeSourceList
    };

    const SelectedPresetIcon = PROMPT_PRESETS.find(p => p.id === selectedPresetId)?.icon || Settings2;

    return (
        <div className="flex flex-col h-full">
            <div className="flex items-center justify-between mb-3 px-1 pt-1">
                <h2 className="text-sm font-semibold text-text-light dark:text-text-dark">Assistant Controls</h2>
                <IconButton
                    icon={PanelLeftClose}
                    onClick={() => setIsLeftPanelOpen(false)}
                    title="Close Assistant Panel"
                    variant="ghost" size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                />
            </div>

            {/* Custom Prompt Section */}
            <div className="mb-4">
                <button onClick={() => setIsPromptSectionOpen(!isPromptSectionOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark" aria-expanded={isPromptSectionOpen}>
                    <span className="flex items-center gap-2"><SelectedPresetIcon size={16} className="text-primary dark:text-primary-light" /> Custom Prompt</span>
                    {isPromptSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isPromptSectionOpen && (
                        <motion.div key="prompt-section-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden">
                             <label htmlFor="prompt-preset-select" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Prompt Mode:</label>
                             <select id="prompt-preset-select" value={selectedPresetId} onChange={handlePresetChange} className="input-field mb-2 text-xs py-1.5">
                                 {PROMPT_PRESETS.map(preset => (<option key={preset.id} value={preset.id}>{preset.name}</option>))}
                             </select>
                             <label htmlFor="system-prompt-area" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">System Prompt (Editable):</label>
                             <textarea id="system-prompt-area" value={systemPrompt} onChange={(e) => { setSystemPrompt(e.target.value); setSelectedPresetId('custom'); }} rows="5" className="input-field text-xs custom-scrollbar" placeholder="Enter system prompt..."/>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* Admin Subjects Section */}
            <div className="mb-4">
                <button onClick={() => setIsSubjectSectionOpen(!isSubjectSectionOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark" aria-expanded={isSubjectSectionOpen}>
                    <span className="flex items-center gap-2"><Library size={16} className="text-primary dark:text-primary-light" /> Admin Subjects</span>
                    {isSubjectSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isSubjectSectionOpen && (
                        <motion.div key="subject-select-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden">
                           <SubjectList
                                subjects={availableSubjects}
                                selectedSubject={selectedSubject}
                                onSelectSubject={setSelectedSubject}
                                isLoading={isLoadingSubjects}
                                error={subjectFetchError}
                           />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* User's Knowledge Base Section */}
            <div className="flex-grow flex flex-col overflow-hidden">
                <button onClick={() => setIsKnowledgeBaseOpen(!isKnowledgeBaseOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-2" aria-expanded={isKnowledgeBaseOpen}>
                    <span className="flex items-center gap-2"><FilePlus size={16} className="text-primary dark:text-primary-light" /> My Knowledge Base</span>
                    {isKnowledgeBaseOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isKnowledgeBaseOpen && (
                        <motion.div key="knowledge-base-content" initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="flex-grow flex flex-col overflow-hidden p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner">
                            {/* MODIFIED: Pass 'onSourceAdded' prop here */}
                            <DocumentUpload onSourceAdded={handleSourceAdded}  />
                            <div className="mt-3 flex-grow overflow-y-auto custom-scrollbar">
                                <KnowledgeSourceList
                                    key={refreshKey}
                                    onSelectSource={selectDocumentForAnalysis}
                                    selectedSource={selectedDocumentForAnalysis}
                                    onRefreshNeeded={refreshKey}
                                />
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default LeftPanel;
```

`frontend/src/components/layout/LLMSelectionModal.jsx`

```javascript
// frontend/src/components/layout/LLMSelectionModal.jsx
import React, { useState, useEffect } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { X, Save, KeyRound, AlertCircle, HardDrive } from 'lucide-react';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import LLMSelection from '../auth/LLMSelection.jsx';
import { motion } from 'framer-motion';

function LLMSelectionModal({ isOpen, onClose }) {
    const { selectedLLM: currentLLM, switchLLM: setGlobalLLMPreference } = useAppState();
    
    // State for the provider selection
    const [locallySelectedLLM, setLocallySelectedLLM] = useState(currentLLM);
    
    // Separate state for each input field
    const [geminiApiKeyInput, setGeminiApiKeyInput] = useState('');
    const [ollamaUrlInput, setOllamaUrlInput] = useState('');
    
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        // Reset state every time the modal opens
        if (isOpen) {
            setLocallySelectedLLM(currentLLM);
            setGeminiApiKeyInput(''); 
            setOllamaUrlInput(''); 
            setError('');
        }
    }, [isOpen, currentLLM]);

    const handleSavePreference = async () => {
        setLoading(true); 
        setError('');
        
        try {
            // Start with the provider selection
            const configData = { llmProvider: locallySelectedLLM };

            // Only add other fields if the user actually typed something into them
            if (geminiApiKeyInput.trim()) {
                configData.apiKey = geminiApiKeyInput.trim();
            }
            if (ollamaUrlInput.trim()) {
                configData.ollamaUrl = ollamaUrlInput.trim();
            }
            
            await api.updateUserLLMConfig(configData);
            setGlobalLLMPreference(locallySelectedLLM);
            
            toast.success(`LLM preference updated to ${locallySelectedLLM.toUpperCase()}.`);
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update preference.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark";
    const inputFieldStyledClass = "input-field pl-10 py-2 text-sm w-full";

    return (
         <Modal isOpen={isOpen} onClose={onClose} title="Switch LLM Provider & Credentials" size="lg"
            footerContent={
                <>
                    <Button onClick={onClose} variant="secondary" size="sm" className="text-xs">Cancel</Button>
                    <Button onClick={handleSavePreference} isLoading={loading} size="sm" className="text-xs">
                        <Save size={14} className="mr-1.5"/> Save Preference
                    </Button>
                </>
            }
        >
            <div className="space-y-5"> 
                <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                    Select your preferred LLM. You can also update your credentials here. <br/><strong>Leave a field blank to keep your existing setting.</strong>
                </p>
                <LLMSelection 
                    selectedLLM={locallySelectedLLM} 
                    onLlmChange={setLocallySelectedLLM}
                    disabled={loading}
                />
                
                <motion.div key="gemini-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalGeminiApiKey" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Gemini API Key (Optional)
                    </label>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input type="password" id="modalGeminiApiKey" className={inputFieldStyledClass} placeholder="Leave blank to keep existing key" value={geminiApiKeyInput} onChange={(e) => setGeminiApiKeyInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>
                
                <motion.div key="ollama-config-modal" className="mt-4 space-y-1">
                    <label htmlFor="modalOllamaUrl" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">
                        Update Ollama URL (Optional)
                    </label>
                     <div className={inputWrapperClass}>
                        <HardDrive className={inputIconClass} />
                        <input type="text" id="modalOllamaUrl" className={inputFieldStyledClass} placeholder="Leave blank to keep existing URL" value={ollamaUrlInput} onChange={(e) => setOllamaUrlInput(e.target.value)} disabled={loading} />
                    </div>
                </motion.div>

                {error && (
                    <div className="flex items-center gap-2 p-2 text-xs text-red-700 bg-red-100 dark:bg-red-900/30 dark:text-red-300 rounded-md">
                        <AlertCircle size={16} />
                        <span>{error}</span>
                    </div>
                )}
            </div>
        </Modal>
    );
}

export default LLMSelectionModal;
```

`frontend/src/components/layout/RightCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/RightCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { HelpCircle, GitFork, Tags, ChevronLeft } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

const iconMap = {
    HelpCircle: HelpCircle,
    Tags: Tags,
    GitFork: GitFork,
};

function RightCollapsedNav() {
    const { setIsRightPanelOpen } = useAppState();

    const navItems = [
        { id: 'faq', label: 'FAQ Generator', iconName: 'HelpCircle', action: () => { setIsRightPanelOpen(true); /* TODO: set analysis type contextually */ } },
        { id: 'topics', label: 'Key Topics Extractor', iconName: 'Tags', action: () => { setIsRightPanelOpen(true); } },
        { id: 'mindmap', label: 'Mind Map Creator', iconName: 'GitFork', action: () => { setIsRightPanelOpen(true); } },
    ];

    return (
        <motion.aside
            key="right-collapsed-nav"
            initial={{ x: '100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="fixed right-0 top-16 bottom-0 z-30 w-14 sm:w-16 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark shadow-lg flex-col items-center py-3 space-y-2 hidden md:flex"
        >
            {/* Open Panel Button AT THE TOP */}
            <IconButton 
                icon={ChevronLeft} 
                onClick={() => setIsRightPanelOpen(true)} 
                title="Open Analyzer Panel"
                ariaLabel="Open Analyzer Panel"
                variant="ghost" 
                size="lg"
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />
            {navItems.map(item => {
                 const Icon = iconMap[item.iconName] || HelpCircle;
                return (
                    <IconButton 
                        key={item.id}
                        icon={Icon}
                        onClick={item.action}
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
        </motion.aside>
    );
}
export default RightCollapsedNav;
```

`frontend/src/components/layout/RightPanel.jsx`

```javascript
// frontend/src/components/layout/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import AnalysisToolRunner from '../analysis/AnalysisToolRunner.jsx';
import PodcastGenerator from '../analysis/PodcastGenerator.jsx';
import KnowledgeGraphViewer from '../analysis/KnowledgeGraphViewer.jsx';
import RealtimeKgPanel from '../analysis/RealtimeKgPanel.jsx';
import api from '../../services/api.js';
import { PanelRightClose, ChevronDown, ChevronUp, Telescope, Radio, BrainCircuit, Share2 } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { motion } from 'framer-motion';
import toast from 'react-hot-toast';

function RightPanel() {
    const { setIsRightPanelOpen, selectedDocumentForAnalysis, selectedSubject } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);
    
    // --- THIS IS THE NEW STATE FOR THE LIVE KG MODAL ---
    const [isLiveKgModalOpen, setIsLiveKgModalOpen] = useState(false);

    // State for the static document KG modal (no change)
    const [isKgModalOpen, setIsKgModalOpen] = useState(false);
    const [kgData, setKgData] = useState(null);
    const [isLoadingKg, setIsLoadingKg] = useState(false);

    const currentSelectedDocFilename = selectedDocumentForAnalysis || selectedSubject || null;
    const isTargetAdminSubject = !!(selectedSubject && currentSelectedDocFilename && selectedSubject === currentSelectedDocFilename);

    const handleVisualizeKg = async () => {
        if (!currentSelectedDocFilename) return;
        setIsKgModalOpen(true);
        setIsLoadingKg(true);
        setKgData(null);
        try {
            const data = await api.getKnowledgeGraph(currentSelectedDocFilename);
            if(data.error) {
                toast.error(`KG Error: ${data.error}`);
                setKgData({ error: data.error });
            } else {
                setKgData(data);
            }
        } catch (error) {
            const errorMessage = error.response?.data?.error || "Could not fetch knowledge graph.";
            toast.error(errorMessage);
            setKgData({ error: errorMessage });
        } finally {
            setIsLoadingKg(false);
        }
    };

    return (
        <>
            <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
                <div className="flex items-center justify-between pb-2 border-b border-border-light dark:border-border-dark">
                    <h2 className="text-base font-semibold">Advanced Tools</h2>
                    <IconButton
                        icon={PanelRightClose}
                        onClick={() => setIsRightPanelOpen(false)}
                        title="Close Panel"
                        variant="ghost" size="sm"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                </div>
                
                <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-1 pt-4">
                    {/* --- THIS IS THE NEW BUTTON TO LAUNCH THE MODAL --- */}
                    <div className="card-base p-3">
                         <div className="flex items-center gap-2 text-sm font-medium mb-2">
                            <Share2 size={16} className="text-primary dark:text-primary-light" />
                            <span>Live Concept Map</span>
                        </div>
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-3">
                            Visualize concepts from your current conversation in real-time.
                        </p>
                        <Button onClick={() => setIsLiveKgModalOpen(true)} variant="primary" size="sm" fullWidth leftIcon={<Share2 size={16} />}>
                            Show Live Map
                        </Button>
                    </div>

                    {/* --- EXISTING STATIC ANALYSIS TOOLS (Conditional) --- */}
                    {currentSelectedDocFilename ? (
                        <>
                            <div>
                                <button onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)} className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark">
                                    <span className="flex items-center gap-2"><Telescope size={16} /> Document Analysis</span>
                                    {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                                </button>
                                {isAnalyzerOpen && (
                                    <motion.div initial={{ height: 0, opacity: 0 }} animate={{ height: 'auto', opacity: 1 }} exit={{ height: 0, opacity: 0 }} transition={{ duration: 0.2, ease: "easeInOut" }} className="mt-2 space-y-3 overflow-hidden">
                                        <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                        <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                        <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} isTargetAdminDoc={isTargetAdminSubject} />
                                    </motion.div>
                                )}
                            </div>
                            <div>
                                <div className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                                   <span className="flex items-center gap-2"><Radio size={16} /> Content Exporters</span>
                                </div>
                                 <div className="mt-2 space-y-3">
                                    <PodcastGenerator selectedDocumentFilename={currentSelectedDocFilename} />
                                    <Button onClick={handleVisualizeKg} variant="outline" size="sm" fullWidth isLoading={isLoadingKg} leftIcon={<BrainCircuit size={16} />}>
                                        Visualize Full Document KG
                                    </Button>
                                </div>
                            </div>
                        </>
                    ) : (
                         <div className="p-4 mt-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable static analysis tools.</p>
                        </div>
                    )}
                </div>
            </div>

            {/* --- MODAL FOR THE LIVE KG --- */}
            <Modal isOpen={isLiveKgModalOpen} onClose={() => setIsLiveKgModalOpen(false)} title="Live Concept Map (From Conversation)" size="5xl">
                <div className="h-[70vh]">
                   <RealtimeKgPanel />
                </div>
            </Modal>

            {/* --- MODAL FOR STATIC DOCUMENT KG (No change) --- */}
            <Modal isOpen={isKgModalOpen} onClose={() => setIsKgModalOpen(false)} title={`Full KG: ${currentSelectedDocFilename}`} size="5xl">
                <KnowledgeGraphViewer graphData={isLoadingKg ? null : kgData} />
            </Modal>
        </>
    );
}
export default RightPanel; 
```

`frontend/src/components/layout/TopNav.jsx`

```javascript
// frontend/src/components/layout/TopNav.jsx
import React, { useState, useEffect, useRef } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import ThemeToggle from '../common/ThemeToggle.jsx';
import LLMSelectionModal from './LLMSelectionModal.jsx';
import ProfileSettingsModal from '../profile/ProfileSettingsModal.jsx';
import { Link } from 'react-router-dom';
import { 
    LogOut, User, MessageSquare, History as HistoryIcon, Settings, Cpu, Zap, ServerCrash, Server, Wrench, GraduationCap 
} from 'lucide-react';
import ToolsModal from '../tools/ToolsModal.jsx'; 



function TopNav({ user: authUser, onLogout, onNewChat, onHistoryClick, orchestratorStatus, isChatProcessing  }) {
    const { selectedLLM, switchLLM } = useAppState();
    const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
    const [isToolsModalOpen, setIsToolsModalOpen] = useState(false); // <<< NEW STATE

    
    const [isProfileDropdownOpen, setIsProfileDropdownOpen] = useState(false);
    const profileDropdownRef = useRef(null);

    const getStatusIndicator = () => {
        if (!orchestratorStatus) return <div title="Status unavailable" className="w-4 h-4 bg-gray-400 rounded-full"></div>;
        if (orchestratorStatus.status === "ok") {
            return <Zap size={18} className="text-green-400 animate-pulse" title={`Backend Online: ${orchestratorStatus.message}`} />;
        } else if (orchestratorStatus.status === "loading") {
            return <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-yellow-400" title="Connecting..."></div>;
        } else {
            return <ServerCrash size={18} className="text-red-400" title={`Backend Offline: ${orchestratorStatus.message}`} />;
        }
    };
    
    useEffect(() => {
        function handleClickOutside(event) {
            if (profileDropdownRef.current && !profileDropdownRef.current.contains(event.target)) {
                setIsProfileDropdownOpen(false);
            }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => {
            document.removeEventListener("mousedown", handleClickOutside);
        };
    }, [profileDropdownRef]);

    return (
        <>
            <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark shadow-sm h-16 flex items-center justify-between px-2 sm:px-4">
                <div className="flex items-center gap-2">
                    <a href="/" className="flex items-center gap-1.5 sm:gap-2 text-lg sm:text-xl font-semibold text-text-light dark:text-text-dark">
                        <Server size={24} className="text-primary dark:text-primary-light" />
                        <span className="hidden sm:inline">AI Tutor</span>
                    </a>
                </div>

                <div className="flex-1 flex justify-center px-2">
                    <div className="flex items-center gap-1 sm:gap-2">
                         <button
                            onClick={onNewChat}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-sky-700 dark:text-sky-300 bg-sky-500/10 dark:bg-sky-500/20 hover:bg-sky-500/20 dark:hover:bg-sky-500/30 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Start a new chat session"
                        >
                            <MessageSquare size={14} /> <span className="hidden sm:inline">New Chat</span>
                        </button>
                        
                        <button
                            onClick={onHistoryClick}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-teal-700 dark:text-teal-300 bg-teal-500/10 dark:bg-teal-500/20 hover:bg-teal-500/20 dark:hover:bg-teal-500/30 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="View chat history"
                        >
                            <HistoryIcon size={14} /> <span className="hidden sm:inline">History</span>
                        </button>

                         <Link
                            to="/study-plan"
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-indigo-700 dark:text-indigo-300 bg-indigo-500/10 dark:bg-indigo-500/20 hover:bg-indigo-500/20 dark:hover:bg-indigo-500/30 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            onClick={(e) => isChatProcessing && e.preventDefault()}
                            title="Open your personalized Study Plan"
                        >
                            <GraduationCap size={14} /> <span className="hidden sm:inline">Study Plan</span>
                        </Link>

                        <button
                            onClick={() => setIsToolsModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-amber-700 dark:text-amber-400 bg-amber-400/20 dark:bg-amber-500/20 hover:bg-amber-400/30 dark:hover:bg-amber-500/30 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title="Open Tools"
                        >
                            <Wrench size={14} /> <span className="hidden sm:inline">Tools</span>
                        </button>

                        <button
                            onClick={() => setIsLLMModalOpen(true)}
                            className={`flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-slate-700 dark:text-slate-300 bg-slate-500/10 dark:bg-slate-500/20 hover:bg-slate-500/20 dark:hover:bg-slate-500/30 transition-colors ${isChatProcessing ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isChatProcessing}
                            title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
                        >
                            <Cpu size={14} /> <span className="hidden xs:inline">{selectedLLM.toUpperCase()}</span>
                        </button>
                    </div>
                </div>


                <div className="flex items-center gap-1.5 sm:gap-2">
                    <div className="w-8 h-8 flex items-center justify-center">
                        {getStatusIndicator()}
                    </div>
                    <ThemeToggle />
                    <div className="relative" ref={profileDropdownRef}>
                        <button 
                            onClick={() => setIsProfileDropdownOpen(prev => !prev)}
                            className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary"
                        >
                            <User size={18} />
                        </button>
                        <div 
                            className={`absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 transition-all duration-150 ease-in-out transform origin-top-right z-50
                                ${isProfileDropdownOpen 
                                    ? 'opacity-100 scale-100 visible' 
                                    : 'opacity-0 scale-95 invisible'
                                }`
                            }
                        >
                            <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-border-light dark:border-border-dark">
                                Signed in as <br/><strong>{authUser?.username || 'User'}</strong>
                            </div>
                            <button
                                onClick={() => { setIsProfileModalOpen(true); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
                            >
                                <Settings size={16} /> Profile
                            </button>
                            <button
                                onClick={() => { onLogout(); setIsProfileDropdownOpen(false); }}
                                className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
                            >
                                <LogOut size={16} /> Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
            <LLMSelectionModal 
                isOpen={isLLMModalOpen} 
                onClose={() => setIsLLMModalOpen(false)} 
                currentLLM={selectedLLM}
                onSelectLLM={(llm) => {
                    switchLLM(llm);
                    setIsLLMModalOpen(false);
                }}
            />
            <ProfileSettingsModal
                isOpen={isProfileModalOpen}
                onClose={() => setIsProfileModalOpen(false)}
            />
            {/* The ToolsModal is now correctly managed here */}
            <ToolsModal 
                isOpen={isToolsModalOpen} 
                onClose={() => setIsToolsModalOpen(false)} 
            />
        </>
    );
}
export default TopNav;
```

`frontend/src/components/learning/StudyPlanPage.jsx`

```javascript
// frontend/src/components/learning/StudyPlanPage.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { Home, Plus, Loader2, AlertTriangle, CheckCircle, Lock, Circle, GraduationCap, FileText, Globe, Code, BookMarked } from 'lucide-react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import Button from '../core/Button';
import { motion, AnimatePresence } from 'framer-motion';

const iconMap = {
    direct_answer: GraduationCap,
    document_review: FileText,
    web_search: Globe,
    academic_search: BookMarked,
    code_executor: Code,
};

// --- Module Checklist Item Component ---
const ModuleItem = ({ module, pathId, onModuleUpdate, isNextUp, handleNewChat }) => {
    const navigate = useNavigate();
    const [isUpdating, setIsUpdating] = useState(false);
    const { setInitialPromptForNewSession, setInitialActivityForNewSession } = useAppState();

    const handleStatusToggle = async () => {
        setIsUpdating(true);
        const newStatus = module.status === 'completed' ? 'not_started' : 'completed';
        try {
            await api.updateModuleStatus(pathId, module.moduleId, newStatus);
            toast.success(`Module '${module.title}' marked as ${newStatus}.`);
            onModuleUpdate(); // Trigger parent to refetch all paths
        } catch (error) {
            toast.error(`Failed to update module: ${error.message}`);
        } finally {
            setIsUpdating(false);
        }
    };

    const handleStartModule = () => {
        const { activity } = module;

        if (activity.type === 'code_executor') {
            navigate('/tools/code-executor');
            return;
        }
        
        // 1. Set the context state BEFORE starting the new chat and navigating
        console.log("[StudyPlanPage] Setting initial prompt and activity in context.", activity);
        setInitialPromptForNewSession(activity.suggestedPrompt);
        setInitialActivityForNewSession(activity);

        // 2. Call handleNewChat. The callback now only needs to navigate.
        handleNewChat((newSessionId) => {
            console.log(`New session ${newSessionId} created. Navigating to chat.`);
            navigate('/');
        });
    };

    const ActivityIcon = iconMap[module.activity.type] || GraduationCap;
    const isLocked = module.status === 'locked';
    const isCompleted = module.status === 'completed';

    return (
        <div className={`flex items-start gap-4 p-4 border-l-4 ${isCompleted ? 'border-green-500 bg-green-500/5' : isNextUp ? 'border-primary' : 'border-transparent'}`}>
            <div className="flex-shrink-0 mt-1">
                {isUpdating ? (
                    <Loader2 className="w-6 h-6 animate-spin text-primary" />
                ) : (
                    <button onClick={handleStatusToggle} disabled={isLocked} className="disabled:opacity-50 disabled:cursor-not-allowed">
                        {isLocked ? <Lock className="w-6 h-6 text-text-muted-light dark:text-text-muted-dark" /> :
                         isCompleted ? <CheckCircle className="w-6 h-6 text-green-500" /> :
                         <Circle className="w-6 h-6 text-text-muted-light dark:text-text-muted-dark hover:text-primary" />}
                    </button>
                )}
            </div>
            <div className="flex-grow">
                <h4 className={`font-semibold ${isCompleted ? 'line-through text-text-muted-light dark:text-text-muted-dark' : 'text-text-light dark:text-text-dark'}`}>
                    {module.title}
                </h4>
                <p className="text-sm text-text-muted-light dark:text-text-muted-dark mt-1 italic">"{module.objective}"</p>
                <div className="flex items-center gap-2 text-xs mt-2 text-text-muted-light dark:text-text-muted-dark">
                    <ActivityIcon size={14} />
                    <span>Activity: {module.activity.resourceName ? `${module.activity.type} (${module.activity.resourceName})` : module.activity.type}</span>
                </div>
            </div>
            {isNextUp && !isCompleted && (
                <div className="flex-shrink-0 self-center">
                    <Button size="sm" onClick={handleStartModule}>Start Module</Button>
                </div>
            )}
        </div>
    );
};

// --- Create New Plan Component (with Questionnaire and Prefill Logic) ---
const CreatePlan = ({ onPlanCreated }) => {
    const [goal, setGoal] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [questionnaire, setQuestionnaire] = useState(null);
    const [currentStep, setCurrentStep] = useState(0);
    const [answers, setAnswers] = useState([]);
    const location = useLocation();
    const navigate = useNavigate();

    const handleInitialGenerate = useCallback(async (e) => {
        if (e) e.preventDefault();
        const currentGoal = goal.trim();
        if (!currentGoal) {
            toast.error("Please enter a learning goal.");
            return;
        }
        setIsLoading(true);
        try {
            const response = await api.generateLearningPath(currentGoal);
            if (response.isQuestionnaire) {
                setQuestionnaire(response.questions);
                setAnswers(new Array(response.questions.length).fill(''));
                setCurrentStep(0);
            } else {
                toast.success("New study plan created successfully!");
                resetForm();
                onPlanCreated();
            }
        } catch (error) {
            toast.error(`Failed to start plan generation: ${error.message}`);
        } finally {
            setIsLoading(false);
        }
    }, [goal, onPlanCreated]);
    
    useEffect(() => {
        const locationState = location.state;
        if (locationState?.prefilledGoal) {
            const prefilledGoal = locationState.prefilledGoal;
            setGoal(prefilledGoal);
            
            setTimeout(() => {
                const form = document.getElementById('create-plan-form');
                if (form) {
                    const submitButton = form.querySelector('button[type="submit"]');
                    if (submitButton) {
                        submitButton.click();
                    }
                }
            }, 100);

            navigate(location.pathname, { replace: true, state: {} });
        }
    }, [location.state, navigate, handleInitialGenerate]);

    const handleAnswerChange = (index, value) => {
        const newAnswers = [...answers];
        newAnswers[index] = value;
        setAnswers(newAnswers);
    };

    const handleFinalSubmit = async () => {
        setIsLoading(true);
        const context = {
            clarificationAnswers: questionnaire.map((q, i) => ({
                question: q.questionText,
                answer: answers[i]
            }))
        };
        try {
            await api.generateLearningPath(goal.trim(), context);
            toast.success("Your personalized study plan has been created!");
            resetForm();
            onPlanCreated();
        } catch (error) {
            toast.error(`Failed to create personalized plan: ${error.message}`);
        } finally {
            setIsLoading(false);
        }
    };
    
    const resetForm = () => {
        setGoal('');
        setQuestionnaire(null);
        setCurrentStep(0);
        setAnswers([]);
    };

    if (questionnaire) {
        const question = questionnaire[currentStep];
        return (
            <div className="card-base p-6 mb-8">
                <AnimatePresence mode="wait">
                    <motion.div
                        key={currentStep}
                        initial={{ opacity: 0, x: 50 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: -50 }}
                        transition={{ duration: 0.3 }}
                    >
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark">Step {currentStep + 1} of {questionnaire.length}</p>
                        <h3 className="text-lg font-semibold my-2">{question.questionText}</h3>
                        {question.type === 'multiple_choice' ? (
                            <div className="space-y-2 mt-4">
                                {question.options.map(option => (
                                    <label key={option} className={`flex items-center p-3 border rounded-lg cursor-pointer transition-colors ${answers[currentStep] === option ? 'border-primary bg-primary/10' : 'border-border-light dark:border-border-dark'}`}>
                                        <input type="radio" name={`q-${currentStep}`} value={option} checked={answers[currentStep] === option} onChange={() => handleAnswerChange(currentStep, option)} className="form-radio" />
                                        <span className="ml-3">{option}</span>
                                    </label>
                                ))}
                            </div>
                        ) : (
                            <input type="text" value={answers[currentStep]} onChange={(e) => handleAnswerChange(currentStep, e.target.value)} className="input-field mt-4" />
                        )}
                        <div className="flex justify-between items-center mt-6">
                            <Button variant="secondary" onClick={() => currentStep > 0 ? setCurrentStep(s => s - 1) : resetForm()}>
                                {currentStep > 0 ? 'Back' : 'Cancel'}
                            </Button>
                            {currentStep < questionnaire.length - 1 ? (
                                <Button onClick={() => setCurrentStep(s => s + 1)} disabled={!answers[currentStep]}>Next</Button>
                            ) : (
                                <Button onClick={handleFinalSubmit} isLoading={isLoading} disabled={!answers[currentStep]}>Generate My Plan</Button>
                            )}
                        </div>
                    </motion.div>
                </AnimatePresence>
            </div>
        );
    }

    return (
        <div className="card-base p-6 mb-8">
            <h2 className="text-lg font-semibold text-center mb-4">Create a New Study Plan</h2>
            <form id="create-plan-form" onSubmit={handleInitialGenerate} className="flex flex-col sm:flex-row items-center gap-3">
                <input
                    type="text"
                    value={goal}
                    onChange={(e) => setGoal(e.target.value)}
                    placeholder="What is your learning goal? e.g., 'Master Python for data science'"
                    className="input-field flex-grow !py-2.5"
                    disabled={isLoading}
                />
                <Button type="submit" isLoading={isLoading} leftIcon={<Plus size={16} />} className="w-full sm:w-auto">
                    Generate Plan
                </Button>
            </form>
        </div>
    );
};

// --- Main Study Plan Page ---
const StudyPlanPage = ({ handleNewChat }) => {
    const [learningPaths, setLearningPaths] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState('');
    const [activePathId, setActivePathId] = useState(null);

    const fetchPaths = useCallback(async () => {
        setIsLoading(true);
        setError('');
        try {
            const paths = await api.getLearningPaths();
            setLearningPaths(paths);
            if (paths.length > 0 && (!activePathId || !paths.some(p => p._id === activePathId))) {
                setActivePathId(paths[0]._id);
            }
        } catch (err) {
            setError(err.message || 'Failed to fetch learning paths.');
            toast.error(err.message);
        } finally {
            setIsLoading(false);
        }
    }, [activePathId]);

    useEffect(() => {
        fetchPaths();
    }, [fetchPaths]);

    return (
        <div className="flex flex-col h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark font-sans">
            <header className="flex-shrink-0 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark h-16 flex items-center justify-between px-6 z-10">
                <h1 className="text-xl font-bold">My Study Plans</h1>
                <Link to="/" className="flex items-center gap-2 text-sm btn btn-ghost">
                    <Home size={16}/>
                    Back to Main App
                </Link>
            </header>

            <main className="flex-1 overflow-y-auto p-4 sm:p-6 md:p-8 custom-scrollbar">
                <div className="max-w-4xl mx-auto">
                    <CreatePlan onPlanCreated={fetchPaths} />

                    {isLoading && (
                        <div className="text-center p-8">
                            <Loader2 className="w-8 h-8 mx-auto animate-spin text-primary" />
                            <p className="mt-2 text-text-muted-light dark:text-text-muted-dark">Loading your plans...</p>
                        </div>
                    )}
                    {error && !isLoading && (
                        <div className="p-4 bg-red-500/10 text-red-500 rounded-md text-center">
                            <AlertTriangle className="w-6 h-6 mx-auto mb-2" />
                            <p>{error}</p>
                            <Button onClick={fetchPaths} size="sm" variant="outline" className="mt-4">Retry</Button>
                        </div>
                    )}
                    {!isLoading && !error && learningPaths.length === 0 && (
                        <div className="text-center py-12 text-text-muted-light dark:text-text-muted-dark">
                            <GraduationCap size={48} className="mx-auto opacity-50 mb-4" />
                            <h3 className="font-semibold text-lg">No Study Plans Found</h3>
                            <p>Create your first plan above to get started on a personalized learning journey!</p>
                        </div>
                    )}

                    {!isLoading && !error && learningPaths.length > 0 && (
                        <div className="space-y-4">
                            {learningPaths.map(path => {
                                const isExpanded = activePathId === path._id;
                                const nextUpModule = path.modules.find(m => m.status === 'not_started' || m.status === 'in_progress');
                                return (
                                    <div key={path._id} className="card-base overflow-hidden">
                                        <h2 onClick={() => setActivePathId(isExpanded ? null : path._id)} className="px-6 py-4 text-lg font-semibold cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors">
                                            {path.title}
                                        </h2>
                                        <AnimatePresence>
                                            {isExpanded && (
                                                <motion.div
                                                    initial={{ height: 0, opacity: 0 }}
                                                    animate={{ height: 'auto', opacity: 1 }}
                                                    exit={{ height: 0, opacity: 0 }}
                                                    transition={{ duration: 0.3, ease: 'easeInOut' }}
                                                    className="border-t border-border-light dark:border-border-dark"
                                                >
                                                    <div className="divide-y divide-border-light dark:divide-border-dark">
                                                        {path.modules.map(module => (
                                                            <ModuleItem
                                                                key={module.moduleId}
                                                                module={module}
                                                                pathId={path._id}
                                                                onModuleUpdate={fetchPaths}
                                                                isNextUp={nextUpModule?.moduleId === module.moduleId}
                                                                handleNewChat={handleNewChat}
                                                            />
                                                        ))}
                                                    </div>
                                                </motion.div>
                                            )}
                                        </AnimatePresence>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                </div>
            </main>
        </div>
    );
};

export default StudyPlanPage;
```

`frontend/src/components/profile/ProfileSettingsModal.jsx`

```javascript
// frontend/src/components/profile/ProfileSettingsModal.jsx
import React, { useState, useEffect } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import Modal from '../core/Modal.jsx';
import Button from '../core/Button.jsx';
import { Save, User, School, Hash, Award, Wrench, Calendar, Lightbulb, Goal, ChevronDown } from 'lucide-react';

const yearOptions = {
    "Bachelor's": ["1st Year", "2nd Year", "3rd Year", "4th Year"],
    "Master's": ["1st Year", "2nd Year"],
    "PhD": ["Coursework", "Research Phase", "Writing Phase"],
    "Diploma": ["1st Year", "2nd Year", "3rd Year"]
};

const getYearOptions = (degree) => {
    return yearOptions[degree] || ["1st Year", "2nd Year", "3rd Year", "4th Year", "Graduated"];
};

const ProfileSettingsModal = ({ isOpen, onClose }) => {
    const [profile, setProfile] = useState({
        name: '',
        college: '',
        universityNumber: '',
        degreeType: '',
        branch: '',
        year: ''
    });
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        if (isOpen) {
            const fetchProfile = async () => {
                setIsLoading(true);
                setError('');
                try {
                    const data = await api.getUserProfile();
                    // Set profile data, ensuring defaults for any missing fields
                    setProfile({
                        name: data.name || '',
                        college: data.college || '',
                        universityNumber: data.universityNumber || '',
                        degreeType: data.degreeType || "Bachelor's",
                        branch: data.branch || 'Computer Science',
                        year: data.year || '1st Year',
                        learningStyle: data.learningStyle || 'Visual', // Add new field with default
                        currentGoals: data.currentGoals || '' // Add new field with default
                    });
                } catch (err) {
                    toast.error('Failed to load profile data.');
                    setError(err.message || 'Could not fetch profile.');
                } finally {
                    setIsLoading(false);
                }
            };
            fetchProfile();
        }
    }, [isOpen]);

    const handleChange = (e) => {
        const { name, value } = e.target;
        setProfile(prev => {
            const newState = { ...prev, [name]: value };
            if (name === 'degreeType') {
                const newYearOptions = getYearOptions(value);
                newState.year = newYearOptions[0];
            }
            return newState;
        });
    };


    const handleSubmit = async (e) => {
        e.preventDefault();
        // Simple validation
        for (const key in profile) {
            if (!profile[key] || profile[key].trim() === '') {
                toast.error(`Please fill out the '${key.replace(/([A-Z])/g, ' $1').trim()}' field.`);
                return;
            }
        }
        setIsLoading(true);
        setError('');
        try {
            const response = await api.updateUserProfile(profile);
            toast.success(response.message || 'Profile updated successfully!');
            onClose();
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update profile.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setIsLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark pointer-events-none";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm";
    const selectFieldStyledClass = "input-field !pl-10 !pr-8 py-2.5 text-sm";

    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title="Student Profile Settings"
            size="lg"
            footerContent={
                <>
                    <Button variant="secondary" onClick={onClose} disabled={isLoading}>Cancel</Button>
                    <Button onClick={handleSubmit} isLoading={isLoading} leftIcon={<Save size={16} />}>
                        Save Changes
                    </Button>
                </>
            }
        >
            <form onSubmit={handleSubmit} className="space-y-4">
                {error && <p className="text-sm text-red-500">{error}</p>}
                
                {/* --- Academic Details Section --- */}
                <h3 className="text-sm font-semibold text-text-muted-light dark:text-text-muted-dark border-b border-border-light dark:border-border-dark pb-2">Academic Profile</h3>
                <div className={inputWrapperClass}>
                    <User className={inputIconClass} />
                    <input type="text" name="name" value={profile.name} onChange={handleChange} placeholder="Full Name" className={inputFieldStyledClass} required />
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className={inputWrapperClass}>
                        <School className={inputIconClass} />
                        <input type="text" name="college" value={profile.college} onChange={handleChange} placeholder="College / Institution" className={inputFieldStyledClass} required />
                    </div>
                    <div className={inputWrapperClass}>
                        <Hash className={inputIconClass} />
                        <input type="text" name="universityNumber" value={profile.universityNumber} onChange={handleChange} placeholder="University Number" className={inputFieldStyledClass} required />
                    </div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div className={inputWrapperClass}>
                        <Award className={inputIconClass} />
                        <select name="degreeType" value={profile.degreeType} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                            <option>Bachelor's</option><option>Master's</option><option>PhD</option><option>Diploma</option>
                        </select>
                        <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                    </div>
                    <div className={inputWrapperClass}>
                        <Wrench className={inputIconClass} />
                        <select name="branch" value={profile.branch} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                        <option>Computer Science</option><option>Mechanical</option><option>Electrical</option><option>Civil</option><option>Electronics</option><option>Other</option>
                        </select>
                        <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                    </div>
                    <div className={inputWrapperClass}>
                        <Calendar className={inputIconClass} />
                        <select name="year" value={profile.year} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                            {getYearOptions(profile.degreeType).map(option => (
                                <option key={option} value={option}>{option}</option>
                            ))}
                        </select>
                        <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                    </div>

                </div>

                {/* --- Learning Preferences Section --- */}
                <h3 className="text-sm font-semibold text-text-muted-light dark:text-text-muted-dark border-b border-border-light dark:border-border-dark pb-2 pt-4">Learning Preferences</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 items-start">
                    <div className="space-y-1">
                        <label className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Preferred Learning Style</label>
                        <div className={inputWrapperClass}>
                            <Lightbulb className={inputIconClass} />
                            <select name="learningStyle" value={profile.learningStyle} onChange={handleChange} className="input-field !pl-10 !pr-8 py-2.5 text-sm appearance-none text-left" required>
                                <option>Visual</option>
                                <option>Auditory</option>
                                <option>Reading/Writing</option>
                                <option>Kinesthetic</option>
                            </select>
                            <ChevronDown size={16} className="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                        </div>
                    </div>
                    <div className="space-y-1">
                        <label className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Current Learning Goals (Optional)</label>
                        <div className={inputWrapperClass}>
                            <Goal className={inputIconClass} />
                            <textarea name="currentGoals" value={profile.currentGoals} onChange={handleChange} placeholder="e.g., Prepare for my AI exam..." className={`${inputFieldStyledClass} !h-[42px] resize-none`} maxLength="500"></textarea>
                        </div>
                    </div>
                </div>
            </form>
        </Modal>
    );
};

export default ProfileSettingsModal;
```

`frontend/src/components/tools/AIAssistantBot.jsx`

```javascript
// frontend/src/components/tools/AIAssistantBot.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle, Sparkles, X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import IconButton from '../core/IconButton';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantBot = ({ code, language }) => {
    const [isOpen, setIsOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [analysis, setAnalysis] = useState('');
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (isOpen && analysis && contentRef.current) {
            const timer = setTimeout(() => Prism.highlightAllUnder(contentRef.current), 50);
            return () => clearTimeout(timer);
        }
    }, [isOpen, analysis]);
    
    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <>
            <div className="fixed bottom-6 right-6 z-50">
                <motion.button
                    whileHover={{ scale: 1.1, backgroundColor: "var(--color-primary-dark)" }}
                    whileTap={{ scale: 0.9 }}
                    onClick={() => setIsOpen(true)}
                    title="AI Assistant"
                    className="bg-primary text-white rounded-full p-4 shadow-lg flex items-center justify-center"
                    style={{'--color-primary-dark': '#2563eb'}} // For tailwind color access in motion
                >
                    <Bot size={28} />
                </motion.button>
            </div>

            <AnimatePresence>
                {isOpen && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4"
                        onClick={() => setIsOpen(false)}
                    >
                        <motion.div
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            onClick={(e) => e.stopPropagation()}
                            className="bg-surface-light dark:bg-surface-dark w-full max-w-2xl h-[70vh] rounded-lg shadow-2xl flex flex-col"
                        >
                            <header className="flex items-center justify-between p-4 border-b border-border-light dark:border-border-dark">
                                <h3 className="font-semibold flex items-center gap-2 text-text-light dark:text-text-dark">
                                    <Sparkles className="text-primary"/> AI Assistant
                                </h3>
                                <IconButton icon={X} onClick={() => setIsOpen(false)} title="Close" />
                            </header>

                            <div className="p-4 flex-shrink-0">
                                <Button onClick={handleAnalyze} size="sm" variant="primary" isLoading={isLoading} disabled={!code.trim()}>
                                    Analyze Current Code
                                </Button>
                            </div>
                            
                            <div className="flex-grow p-4 border-t border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                                {isLoading && (
                                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                                    </div>
                                )}
                                {error && !isLoading && (
                                    <div className="p-3 text-red-400 text-sm"><AlertTriangle className="inline mr-2" />{error}</div>
                                )}
                                {!isLoading && !error && !analysis && (
                                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                                        Click "Analyze Code" to get an AI-powered review.
                                    </div>
                                )}
                                {analysis && !isLoading && (
                                    <div 
                                        ref={contentRef}
                                        className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark"
                                        dangerouslySetInnerHTML={createMarkup(analysis)}
                                    />
                                )}
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

export default AIAssistantBot;
```

`frontend/src/components/tools/AIAssistantPanel.jsx`

```javascript
// frontend/src/components/tools/AIAssistantPanel.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Bot, Loader2, AlertTriangle } from 'lucide-react';
import Button from '../core/Button.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};

const AIAssistantPanel = ({ code, language }) => {
    const [analysis, setAnalysis] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const contentRef = useRef(null);

    useEffect(() => {
        if (analysis && contentRef.current) {
            const timer = setTimeout(() => {
                Prism.highlightAllUnder(contentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [analysis]);

    const handleAnalyze = async () => {
        if (!code.trim()) {
            toast.error("There is no code to analyze.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysis('');
        const toastId = toast.loading("AI is analyzing your code...");

        try {
            const response = await api.analyzeCode({ code, language });
            setAnalysis(response.analysis);
            toast.success("Code analysis complete!", { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || "Failed to get AI analysis.";
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="p-4 h-full flex flex-col bg-surface-light dark:bg-surface-dark">
            <h3 className="text-lg font-semibold mb-2 flex items-center justify-between">
                <span className="flex items-center gap-2">
                    <Bot className="text-primary"/> AI Assistant
                </span>
                <Button onClick={handleAnalyze} size="sm" variant="outline" isLoading={isLoading} disabled={!code.trim()}>
                    Analyze Code
                </Button>
            </h3>
            <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 rounded-md p-1 border border-border-light dark:border-border-dark overflow-y-auto custom-scrollbar">
                {isLoading && (
                    <div className="flex justify-center items-center h-full text-text-muted-light dark:text-text-muted-dark">
                        <Loader2 size={24} className="animate-spin mr-2" /> Analyzing...
                    </div>
                )}
                {error && !isLoading && (
                    <div className="p-3 text-red-400 text-sm">
                        <AlertTriangle className="inline mr-2" /> {error}
                    </div>
                )}
                {!isLoading && !error && !analysis && (
                     <div className="flex justify-center items-center h-full text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">
                        Click "Analyze Code" to get an AI-powered review of your code.
                    </div>
                )}
                {analysis && !isLoading && (
                    <div 
                        ref={contentRef}
                        className="prose prose-sm dark:prose-invert max-w-none p-3 text-text-light dark:text-text-dark"
                        dangerouslySetInnerHTML={createMarkup(analysis)}
                    />
                )}
            </div>
        </div>
    );
};

export default AIAssistantPanel;
```

`frontend/src/components/tools/CodeEditor.jsx`

```javascript
// frontend/src/components/tools/CodeEditor.jsx
import React from 'react';
import Editor from '@monaco-editor/react';
import { useTheme } from '../../hooks/useTheme';
import { Loader2 } from 'lucide-react';

const CodeEditor = ({ code, setCode, language }) => {
    const { theme } = useTheme();

    const handleEditorChange = (value) => {
        setCode(value || '');
    };

    return (
        <div className="h-full w-full border border-border-light dark:border-border-dark rounded-lg overflow-hidden shadow-inner">
            <Editor
                height="100%"
                language={language}
                value={code}
                onChange={handleEditorChange}
                theme={theme === 'dark' ? 'vs-dark' : 'light'}
                loading={<Loader2 className="animate-spin text-primary" />}
                options={{
                    fontSize: 14,
                    minimap: { enabled: true },
                    contextmenu: true,
                    scrollBeyondLastLine: false,
                    wordWrap: 'on',
                    automaticLayout: true,
                }}
            />
        </div>
    );
};

export default CodeEditor;
```

`frontend/src/components/tools/CodeEditorWrapper.jsx`

```javascript
// frontend/src/components/tools/CodeEditorWrapper.jsx
import React, { useState } from 'react';
import { Play, Copy, ChevronDown, Check } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import Button from '../core/Button';
import IconButton from '../core/IconButton';
import CodeEditor from './CodeEditor';
import toast from 'react-hot-toast';

const CodeEditorWrapper = ({ code, setCode, language, setLanguage, onExecute, isExecuting }) => {
    
    const [copied, setCopied] = useState(false);

    const handleCopy = () => {
        navigator.clipboard.writeText(code).then(() => {
            toast.success("Code copied to clipboard!");
            setCopied(true);
            setTimeout(() => setCopied(false), 2000); // Reset after 2 seconds
        }, () => {
            toast.error("Failed to copy code.");
        });
    };
    
    return (
        <div className="flex flex-col h-full bg-surface-light dark:bg-surface-dark rounded-lg border border-border-light dark:border-border-dark">
            <header className="flex items-center justify-between p-2 border-b border-border-light dark:border-border-dark flex-shrink-0">
                <div className="relative">
                    <select 
                        value={language}
                        onChange={(e) => setLanguage(e.target.value)}
                        className="input-field !text-xs !py-1 !pl-3 !pr-8 appearance-none"
                    >
                        <option value="python">Python</option>
                        <option value="java">Java</option>
                        <option value="c">C</option>
                        <option value="cpp">C++</option>
                    </select>
                    <ChevronDown size={14} className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none text-text-muted-light dark:text-text-muted-dark" />
                </div>
                <div className="flex items-center gap-2">
                    <IconButton 
                        icon={() => (
                            <AnimatePresence mode="wait" initial={false}>
                                <motion.span
                                    key={copied ? 'check' : 'copy'}
                                    initial={{ opacity: 0, scale: 0.8 }}
                                    animate={{ opacity: 1, scale: 1 }}
                                    exit={{ opacity: 0, scale: 0.8 }}
                                    transition={{ duration: 0.15 }}
                                >
                                    {copied ? <Check className="text-green-500" /> : <Copy />}
                                </motion.span>
                            </AnimatePresence>
                        )} 
                        size="sm" 
                        onClick={handleCopy} 
                        title="Copy Code" 
                    />
                    <Button onClick={onExecute} size="sm" leftIcon={<Play size={14}/>} isLoading={isExecuting}>
                        Run
                    </Button>
                </div>
            </header>
            <div className="flex-grow overflow-hidden">
                <CodeEditor code={code} setCode={setCode} language={language} />
            </div>
        </div>
    );
};

export default CodeEditorWrapper;
```

`frontend/src/components/tools/CodeExecutorPage.jsx`

```javascript
// frontend/src/components/tools/CodeExecutorPage.jsx
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { Home } from 'lucide-react';
import { Panel, PanelGroup, PanelResizeHandle } from 'react-resizable-panels';
import CodeEditorWrapper from './CodeEditorWrapper';
import TestCaseManager from './TestCaseManager';
import OutputDisplay from './OutputDisplay';
import AIAssistantBot from './AIAssistantBot';
import api from '../../services/api';
import toast from 'react-hot-toast';

const starterCode = {
    python: `# Welcome to the Code Executor!\n# Write your Python code here.\n\ndef main():\n    # Example: Read two numbers and print their sum\n    try:\n        line1 = input()\n        line2 = input()\n        print(int(line1) + int(line2))\n    except (ValueError, EOFError):\n        print("Invalid input.")\n\nif __name__ == "__main__":\n    main()\n`,
    java: `// Welcome to the Code Executor!\n// Your public class must be named "Main".\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        System.out.println(a + b);\n        sc.close();\n    }\n}\n`,
    c: `// Welcome to the Code Executor!\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    if (scanf("%d %d", &a, &b) == 2) {\n        printf("%d\\n", a + b);\n    }\n    return 0;\n}\n`,
    cpp: `// Welcome to the Code Executor!\n#include <iostream>\n\nint main() {\n    int a, b;\n    if (std::cin >> a >> b) {\n        std::cout << a + b << std::endl;\n    }\n    return 0;\n}\n`
};

const CodeExecutorPage = () => {
    const [language, setLanguage] = useState('python');
    const [code, setCode] = useState(starterCode.python);
    const [testCases, setTestCases] = useState([
        { input: '5\n10', expectedOutput: '15' }
    ]);
    const [results, setResults] = useState([]);
    const [compilationError, setCompilationError] = useState(null);
    const [isExecuting, setIsExecuting] = useState(false);
    const [executionId, setExecutionId] = useState(0); // State to force re-render of output

    const handleLanguageChange = (newLanguage) => {
        setLanguage(newLanguage);
        setCode(starterCode[newLanguage] || '');
    };

    const handleExecute = async () => {
        setExecutionId(prevId => prevId + 1); // Increment to reset child state
        setIsExecuting(true);
        setResults([]);
        setCompilationError(null);
        const toastId = toast.loading('Executing code...');

        try {
            const response = await api.executeCode({ language, code, testCases });
            
            if (response.compilationError) {
                setCompilationError(response.compilationError);
                toast.error("Code failed to compile.", { id: toastId });
            } else {
                setResults(response.results);
                const failures = response.results.filter(r => r.status !== 'pass').length;
                if (failures > 0) {
                    toast.error(`${failures} test case(s) failed or had errors.`, { id: toastId });
                } else {
                    toast.success('All test cases passed!', { id: toastId });
                }
            }

        } catch (error) {
            const errorMessage = error.response?.data?.message || "An unknown error occurred.";
            setCompilationError(errorMessage);
            toast.error(errorMessage, { id: toastId });
        } finally {
            setIsExecuting(false);
        }
    };

    return (
        <div className="flex flex-col h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark font-sans">
            <header className="flex-shrink-0 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark h-16 flex items-center justify-between px-6 z-10">
                <h1 className="text-xl font-bold">Secure Code Executor</h1>
                <Link to="/" className="flex items-center gap-2 text-sm btn btn-ghost">
                    <Home size={16}/>
                    Back to Main App
                </Link>
            </header>

            <div className="flex-1 overflow-hidden">
                <PanelGroup direction="horizontal">
                    <Panel defaultSize={65} minSize={30}>
                        <PanelGroup direction="vertical">
                            <Panel defaultSize={60} minSize={20}>
                                <div className="p-1 md:p-2 h-full">
                                    <CodeEditorWrapper
                                        code={code} setCode={setCode}
                                        language={language} setLanguage={handleLanguageChange}
                                        onExecute={handleExecute} isExecuting={isExecuting}
                                    />
                                </div>
                            </Panel>
                            <PanelResizeHandle className="h-2 panel-resize-handle" />
                            <Panel defaultSize={40} minSize={20}>
                                <OutputDisplay
                                    key={executionId} // Using key to force re-mount and state reset
                                    results={results}
                                    compilationError={compilationError}
                                    code={code}
                                    language={language}
                                />
                            </Panel>
                        </PanelGroup>
                    </Panel>
                    <PanelResizeHandle className="w-2 panel-resize-handle" />
                    <Panel defaultSize={35} minSize={25}>
                         <TestCaseManager 
                            testCases={testCases} 
                            setTestCases={setTestCases}
                            code={code}
                            language={language}
                        />
                    </Panel>
                </PanelGroup>
            </div>
            
            <AIAssistantBot code={code} language={language} />
        </div>
    );
};

export default CodeExecutorPage;
```

`frontend/src/components/tools/OutputDisplay.jsx`

```javascript
// frontend/src/components/tools/OutputDisplay.jsx
import React, { useState } from 'react';
import { CheckCircle, XCircle, AlertTriangle, Clock, Sparkles, Loader2 } from 'lucide-react';
import Button from '../core/Button';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { marked } from 'marked';
import DOMPurify from 'dompurify';

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml, { USE_PROFILES: { html: true } });
    return { __html: cleanHtml };
};


const OutputDisplay = ({ results, compilationError, code, language }) => {
    const [explanation, setExplanation] = useState(null);
    const [isLoadingExplanation, setIsLoadingExplanation] = useState(false);
    const [explanationFor, setExplanationFor] = useState(null); // 'compilation' or test case index

    const handleExplainError = async (errorContext, errorMessage) => {
        setIsLoadingExplanation(true);
        setExplanation(null);
        setExplanationFor(errorContext);
        try {
            const response = await api.explainError({ code, language, errorMessage });
            setExplanation(response.explanation);
        } catch (err) {
            toast.error(err.response?.data?.message || "Failed to get explanation.");
        } finally {
            setIsLoadingExplanation(false);
        }
    };

    if (compilationError) {
        return (
            <div className="p-4 bg-red-900/10 text-red-400 border-t border-red-500/30 h-full flex flex-col">
                <div className="flex justify-between items-center mb-2 flex-shrink-0">
                    <h3 className="text-lg font-semibold flex items-center gap-2"><AlertTriangle /> Compilation Error</h3>
                    {!explanation && (
                        <Button size="sm" variant="ghost" className="!text-xs" leftIcon={<Sparkles size={12}/>} onClick={() => handleExplainError('compilation', compilationError)} isLoading={isLoadingExplanation && explanationFor === 'compilation'}>
                            Explain Error
                        </Button>
                    )}
                </div>
                <pre className="flex-grow bg-red-900/20 p-4 rounded-md text-xs whitespace-pre-wrap font-mono overflow-auto custom-scrollbar">{compilationError}</pre>
                {isLoadingExplanation && explanationFor === 'compilation' && (
                    <div className="mt-2 p-3 text-sm text-center text-text-muted-light dark:text-text-muted-dark"><Loader2 className="animate-spin inline mr-2"/>AI is explaining the error...</div>
                )}
                {explanation && explanationFor === 'compilation' && (
                    <div className="mt-2 p-3 bg-primary/10 rounded-md border border-primary/30 flex-shrink-0">
                        <h5 className="font-bold text-sm mb-1 text-primary dark:text-primary-light flex items-center gap-1.5"><Sparkles size={14}/> AI Explanation</h5>
                        <div className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark" dangerouslySetInnerHTML={createMarkup(explanation)} />
                    </div>
                )}
            </div>
        );
    }
    
    if (!results || results.length === 0) {
        return (
            <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark border-t border-border-light dark:border-border-dark h-full flex items-center justify-center">
                <p>Run the code to see the output and test case results here.</p>
            </div>
        );
    }

    const getStatusIcon = (status) => {
        if (status === 'pass') return <CheckCircle className="text-green-500" />;
        if (status === 'fail') return <XCircle className="text-yellow-500" />;
        return <AlertTriangle className="text-red-500" />;
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark border-t border-border-light dark:border-border-dark h-full flex flex-col">
            <h3 className="text-lg font-semibold mb-3 flex-shrink-0">Execution Results</h3>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {results.map((res, index) => (
                    <div key={index} className="p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex justify-between items-center mb-2">
                            <h4 className="font-semibold flex items-center gap-2">
                                {getStatusIcon(res.status)}
                                Test Case #{index + 1}: <span className="uppercase">{res.status}</span>
                            </h4>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-xs">
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Input:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.input || '(empty)'}</pre>
                            </div>
                            <div>
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Expected Output:</strong>
                                <pre className="bg-gray-200 dark:bg-gray-900 p-2 rounded whitespace-pre-wrap font-mono">{res.expected || '(empty)'}</pre>
                            </div>
                            <div className="md:col-span-2">
                                <strong className="block mb-1 text-text-light dark:text-text-dark">Actual Output:</strong>
                                <pre className={`p-2 rounded whitespace-pre-wrap font-mono ${res.status === 'pass' ? 'bg-green-900/20' : 'bg-yellow-900/20'}`}>{res.output || '(empty)'}</pre>
                            </div>
                            {res.error && (
                                <div className="md:col-span-2">
                                    <div className="flex justify-between items-center">
                                        <strong className="block mb-1 text-red-500 dark:text-red-400">Error:</strong>
                                        {explanationFor !== index && (
                                            <Button size="sm" variant="ghost" className="!text-xs" leftIcon={<Sparkles size={12}/>} onClick={() => handleExplainError(index, res.error)} isLoading={isLoadingExplanation && explanationFor === index}>
                                                Explain Error
                                            </Button>
                                        )}
                                    </div>
                                    <pre className="bg-red-900/20 p-2 rounded text-red-400 whitespace-pre-wrap font-mono">{res.error}</pre>
                                </div>
                            )}
                            {isLoadingExplanation && explanationFor === index && (
                                <div className="md:col-span-2 p-3 text-sm text-center text-text-muted-light dark:text-text-muted-dark"><Loader2 className="animate-spin inline mr-2"/>AI is explaining the error...</div>
                            )}
                            {explanation && explanationFor === index && (
                                <div className="md:col-span-2 mt-2 p-3 bg-primary/10 rounded-md border border-primary/30">
                                    <h5 className="font-bold text-sm mb-1 text-primary dark:text-primary-light flex items-center gap-1.5"><Sparkles size={14}/> AI Explanation</h5>
                                    <div className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark" dangerouslySetInnerHTML={createMarkup(explanation)} />
                                </div>
                            )}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
};

export default OutputDisplay;
```

`frontend/src/components/tools/QuizGeneratorPage.jsx`

```javascript
// frontend/src/components/tools/QuizGeneratorPage.jsx
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { Home, Loader2, AlertTriangle } from 'lucide-react';
import QuizSetup from './QuizSetup';
import QuizInProgress from './QuizInProgress';
import QuizResults from './QuizResults';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { motion } from 'framer-motion';

// --- NEW: Simulated stages for the loading UI ---
const GENERATION_STAGES = [
    { name: "Analyzing Document", duration: 2500, message: "Reading and understanding the structure of your document..." },
    { name: "Identifying Key Concepts", duration: 3000, message: "Extracting the most important topics and facts..." },
    { name: "Formulating Questions", duration: 4000, message: "Crafting questions based on the key concepts..." },
    { name: "Crafting Distractors", duration: 2000, message: "Creating plausible incorrect answers for each question..." },
    { name: "Finalizing Quiz", duration: 1500, message: "Assembling the final quiz..." }
];

const QuizGeneratorPage = () => {
    const [quizState, setQuizState] = useState('setup'); // 'setup', 'generating', 'in_progress', 'finished'
    const [quizData, setQuizData] = useState([]);
    const [userAnswers, setUserAnswers] = useState([]);
    const [error, setError] = useState('');

    // --- NEW: State for the progress simulation ---
    const [progress, setProgress] = useState(0);
    const [currentStageMessage, setCurrentStageMessage] = useState('');

    // --- NEW: Effect to run the progress simulation ---
    useEffect(() => {
        let timeoutId;
        if (quizState === 'generating') {
            let elapsed = 0;
            const totalDuration = GENERATION_STAGES.reduce((acc, stage) => acc + stage.duration, 0);

            const runStage = (stageIndex = 0) => {
                if (stageIndex >= GENERATION_STAGES.length) {
                    setProgress(100);
                    setCurrentStageMessage("Waiting for AI response...");
                    return;
                }
                const stage = GENERATION_STAGES[stageIndex];
                setCurrentStageMessage(stage.message);
                
                const updateProgress = setInterval(() => {
                    elapsed += 100;
                    setProgress(Math.min(99, Math.floor((elapsed / totalDuration) * 100)));
                }, 100);

                timeoutId = setTimeout(() => {
                    clearInterval(updateProgress);
                    runStage(stageIndex + 1);
                }, stage.duration);
            };
            runStage(0);
        }
        return () => clearTimeout(timeoutId);
    }, [quizState]);

    const handleGenerateQuiz = async (file, quizOption) => {
        if (!file) {
            toast.error("Please select a file to generate the quiz from.");
            return;
        }
        setQuizState('generating');
        setError('');
        try {
            const data = await api.generateQuiz(file, quizOption);
            if (!data.quiz || data.quiz.length === 0) {
                throw new Error("The AI was unable to generate a quiz from this document.");
            }
            setQuizData(data.quiz);
            setUserAnswers(new Array(data.quiz.length).fill(null));
            setQuizState('in_progress');
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message;
            setError(errorMessage);
            setQuizState('setup');
            toast.error(errorMessage);
        }
    };

    const handleQuizSubmit = (finalAnswers) => {
        setUserAnswers(finalAnswers);
        setQuizState('finished');
    };

    const handleRestart = () => {
        setQuizState('setup');
        setQuizData([]);
        setUserAnswers([]);
        setError('');
    };

    const renderContent = () => {
        switch (quizState) {
            case 'generating':
                return (
                    <div className="flex flex-col items-center justify-center text-center p-8 bg-surface-light dark:bg-surface-dark rounded-lg shadow-panel">
                        <h2 className="text-xl font-semibold mb-4">Generating Your Quiz...</h2>
                        <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 my-2 max-w-md">
                            <motion.div
                                className="bg-primary h-2.5 rounded-full"
                                initial={{ width: '0%' }}
                                animate={{ width: `${progress}%` }}
                                transition={{ duration: 0.5, ease: 'linear' }}
                            />
                        </div>
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark mt-2 h-5 w-full">
                            {currentStageMessage || "Initializing..."}
                        </p>
                        {progress >= 99 && <Loader2 size={24} className="animate-spin text-primary my-4" />}
                    </div>
                );
            case 'in_progress':
                return <QuizInProgress quizData={quizData} onSubmit={handleQuizSubmit} />;
            case 'finished':
                return <QuizResults quizData={quizData} userAnswers={userAnswers} onRestart={handleRestart} />;
            case 'setup':
            default:
                return <QuizSetup onGenerate={handleGenerateQuiz} />;
        }
    };

    return (
        <div className="flex flex-col h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark font-sans">
            <header className="flex-shrink-0 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark h-16 flex items-center justify-between px-6 z-10">
                <h1 className="text-xl font-bold">AI Quiz Generator</h1>
                <Link to="/" className="flex items-center gap-2 text-sm btn btn-ghost">
                    <Home size={16} />
                    Back to Main App
                </Link>
            </header>
            <main className="flex-1 overflow-y-auto p-4 sm:p-6 md:p-8">
                <div className="max-w-4xl mx-auto">
                    {renderContent()}
                </div>
            </main>
        </div>
    );
};

export default QuizGeneratorPage;
```

`frontend/src/components/tools/QuizInProgress.jsx`

```javascript
// frontend/src/components/tools/QuizInProgress.jsx
import React, { useState, useEffect } from 'react';
import Button from '../core/Button';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const QuizInProgress = ({ quizData, onSubmit }) => {
    const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
    const [answers, setAnswers] = useState(new Array(quizData.length).fill(null));

    const currentQuestion = quizData[currentQuestionIndex];
    const totalQuestions = quizData.length;

    const handleSelectOption = (option) => {
        const newAnswers = [...answers];
        newAnswers[currentQuestionIndex] = option;
        setAnswers(newAnswers);
    };

    const goToNext = () => {
        if (currentQuestionIndex < totalQuestions - 1) {
            setCurrentQuestionIndex(prev => prev + 1);
        }
    };

    const goToPrevious = () => {
        if (currentQuestionIndex > 0) {
            setCurrentQuestionIndex(prev => prev - 1);
        }
    };
    
    const handleSubmit = () => {
        if (window.confirm("Are you sure you want to submit your answers?")) {
            onSubmit(answers);
        }
    };
    
    return (
        <div className="bg-surface-light dark:bg-surface-dark p-6 rounded-lg shadow-panel border border-border-light dark:border-border-dark">
            <div className="mb-4">
                <p className="text-sm font-semibold text-primary">Question {currentQuestionIndex + 1} of {totalQuestions}</p>
                <h3 className="text-xl font-bold mt-1">{currentQuestion.question}</h3>
            </div>

            <div className="space-y-3 my-6">
                {currentQuestion.options.map((option, index) => (
                    <button
                        key={index}
                        onClick={() => handleSelectOption(option)}
                        className={`w-full text-left p-4 border rounded-lg transition-all duration-150 flex items-center
                            ${answers[currentQuestionIndex] === option
                                ? 'bg-primary/20 border-primary ring-2 ring-primary'
                                : 'bg-gray-50 dark:bg-gray-800 border-border-light dark:border-border-dark hover:bg-primary/10 hover:border-primary/50'
                            }`}
                    >
                        <span className="font-bold mr-3 text-primary">{(index + 10).toString(36).toUpperCase()}</span>
                        <span>{option}</span>
                    </button>
                ))}
            </div>

            <div className="flex justify-between items-center mt-6 pt-4 border-t border-border-light dark:border-border-dark">
                <Button onClick={goToPrevious} disabled={currentQuestionIndex === 0} variant="outline" leftIcon={<ChevronLeft />}>
                    Previous
                </Button>

                {currentQuestionIndex === totalQuestions - 1 ? (
                    <Button onClick={handleSubmit} disabled={answers.some(a => a === null)}>
                        Submit Answers
                    </Button>
                ) : (
                    <Button onClick={goToNext} disabled={currentQuestionIndex === totalQuestions - 1} rightIcon={<ChevronRight />}>
                        Next
                    </Button>
                )}
            </div>
        </div>
    );
};

export default QuizInProgress;
```

`frontend/src/components/tools/QuizResults.jsx`

```javascript
// frontend/src/components/tools/QuizResults.jsx
import React, { useMemo } from 'react';
import { CheckCircle, XCircle, RefreshCw } from 'lucide-react';
import Button from '../core/Button';

const QuizResults = ({ quizData, userAnswers, onRestart }) => {
    const score = useMemo(() => {
        return userAnswers.reduce((acc, answer, index) => {
            return acc + (answer === quizData[index].correctAnswer ? 1 : 0);
        }, 0);
    }, [quizData, userAnswers]);

    const totalQuestions = quizData.length;
    const percentage = Math.round((score / totalQuestions) * 100);

    return (
        <div className="bg-surface-light dark:bg-surface-dark p-6 rounded-lg shadow-panel border border-border-light dark:border-border-dark">
            <h2 className="text-2xl font-bold text-center mb-2">Quiz Results</h2>
            <div className="text-center p-6 bg-primary/10 rounded-lg mb-6">
                <p className="text-lg">You Scored</p>
                <p className="text-6xl font-bold my-2 text-primary">{percentage}%</p>
                <p className="text-text-muted-light dark:text-text-muted-dark">{score} out of {totalQuestions} correct</p>
            </div>
            
            <h3 className="text-xl font-semibold mb-4">Review Your Answers</h3>
            <div className="space-y-4">
                {quizData.map((questionData, index) => {
                    const userAnswer = userAnswers[index];
                    const isCorrect = userAnswer === questionData.correctAnswer;
                    
                    return (
                        <div key={index} className={`p-4 border rounded-lg ${isCorrect ? 'border-green-500/50 bg-green-500/5' : 'border-red-500/50 bg-red-500/5'}`}>
                            <div className="flex items-start gap-3">
                                <div className="flex-shrink-0 mt-1">
                                    {isCorrect ? <CheckCircle className="text-green-500" /> : <XCircle className="text-red-500" />}
                                </div>
                                <div>
                                    <p className="font-semibold">{index + 1}. {questionData.question}</p>
                                    <p className={`text-sm mt-2 ${isCorrect ? 'text-green-700 dark:text-green-400' : 'text-red-700 dark:text-red-400'}`}>
                                        Your answer: <span className="font-semibold">{userAnswer}</span>
                                    </p>
                                    {!isCorrect && (
                                        <p className="text-sm mt-1 text-green-700 dark:text-green-400">
                                            Correct answer: <span className="font-semibold">{questionData.correctAnswer}</span>
                                        </p>
                                    )}
                                </div>
                            </div>
                        </div>
                    );
                })}
            </div>

            <div className="mt-8 text-center">
                <Button onClick={onRestart} variant="outline" leftIcon={<RefreshCw />}>
                    Create a New Quiz
                </Button>
            </div>
        </div>
    );
};

export default QuizResults;
```

`frontend/src/components/tools/QuizSetup.jsx`

```javascript
// frontend/src/components/tools/QuizSetup.jsx
import React, { useState, useRef } from 'react';
import { UploadCloud, FileText, XCircle } from 'lucide-react';
import Button from '../core/Button';

const QuizSetup = ({ onGenerate }) => {
    const [file, setFile] = useState(null);
    const [quizOption, setQuizOption] = useState('standard'); // <<< Changed state name and default
    const fileInputRef = useRef(null);

    const handleFileChange = (e) => {
        const selectedFile = e.target.files?.[0];
        if (selectedFile) {
            setFile(selectedFile);
        }
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        onGenerate(file, quizOption); // <<< Pass the option string
    };

    return (
        <div className="bg-surface-light dark:bg-surface-dark p-6 rounded-lg shadow-panel border border-border-light dark:border-border-dark">
            <h2 className="text-2xl font-bold text-center mb-2">Create a Quiz from Your Document</h2>
            <p className="text-center text-text-muted-light dark:text-text-muted-dark mb-6">Upload a document, and let our AI generate a multiple-choice quiz to test your knowledge.</p>
            
            <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                    <label className="block text-sm font-medium mb-2">1. Upload Document</label>
                    <div
                        className="flex justify-center items-center w-full h-32 px-6 transition bg-white dark:bg-gray-800 border-2 border-border-light dark:border-border-dark border-dashed rounded-md appearance-none cursor-pointer hover:border-primary/70"
                        onClick={() => fileInputRef.current?.click()}
                    >
                        <span className="flex items-center space-x-2">
                            <UploadCloud className="text-gray-400" />
                            <span className="font-medium text-gray-500 dark:text-gray-400">
                                {file ? 'File selected' : 'Drop file or click to upload'}
                            </span>
                        </span>
                        <input
                            ref={fileInputRef}
                            type="file"
                            name="file-upload"
                            className="hidden"
                            onChange={handleFileChange}
                            accept=".pdf,.doc,.docx,.txt,.md"
                        />
                    </div>
                    {file && (
                        <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm">
                            <div className="flex items-center gap-2 truncate">
                                <FileText size={18} className="text-primary flex-shrink-0" />
                                <span className="truncate" title={file.name}>{file.name}</span>
                            </div>
                            <button onClick={() => setFile(null)} type="button" className="text-red-500 hover:text-red-700">
                                <XCircle size={18} />
                            </button>
                        </div>
                    )}
                </div>

                <div>
                    <label htmlFor="quizOption" className="block text-sm font-medium mb-2">2. Select Quiz Length</label>
                    <select
                        id="quizOption"
                        value={quizOption}
                        onChange={(e) => setQuizOption(e.target.value)}
                        className="input-field w-full sm:w-48"
                    >
                        <option value="quick">Quick Check (5 Questions)</option>
                        <option value="standard">Standard Review (10 Questions)</option>
                        <option value="deep_dive">Deep Dive (15 Questions)</option>
                        <option value="comprehensive">Comprehensive Exam (20 Questions)</option>
                    </select>
                </div>

                <div className="pt-2">
                    <Button type="submit" fullWidth disabled={!file}>
                        Generate Quiz
                    </Button>
                </div>
            </form>
        </div>
    );
};

export default QuizSetup;
```

`frontend/src/components/tools/TestCaseManager.jsx`

```javascript
// frontend/src/components/tools/TestCaseManager.jsx
import React, { useState } from 'react';
import { Plus, Trash2, Sparkles } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import api from '../../services/api.js';
import toast from 'react-hot-toast';

const TestCaseManager = ({ testCases, setTestCases, code, language }) => {
    const [isGenerating, setIsGenerating] = useState(false);

    const addTestCase = () => {
        const lastTestCase = testCases[testCases.length - 1];
        if (testCases.length > 0 && lastTestCase.input.trim() === '' && lastTestCase.expectedOutput.trim() === '') {
            toast.error('Please fill out the current empty test case first.');
            return;
        }
        setTestCases([...testCases, { input: '', expectedOutput: '' }]);
    };

    const removeTestCase = (index) => {
        const newTestCases = testCases.filter((_, i) => i !== index);
        setTestCases(newTestCases);
    };

    const updateTestCase = (index, field, value) => {
        const newTestCases = [...testCases];
        newTestCases[index][field] = value;
        setTestCases(newTestCases);
    };

    const handleGenerateCases = async () => {
        if (!code.trim()) {
            toast.error("There is no code to generate test cases for.");
            return;
        }
        setIsGenerating(true);
        const toastId = toast.loading("AI is generating test cases...");
        try {
            const response = await api.generateTestCases({ code, language });
            if (response.testCases && Array.isArray(response.testCases) && response.testCases.length > 0) {
                setTestCases(response.testCases);
                toast.success('AI generated a new set of test cases!', { id: toastId });
            } else {
                toast.error("The AI could not generate valid test cases.", { id: toastId });
            }
        } catch (err) {
             const errorMessage = err.response?.data?.message || "Failed to generate test cases.";
             toast.error(errorMessage, { id: toastId });
        } finally {
            setIsGenerating(false);
        }
    };

    return (
        <div className="p-4 bg-surface-light dark:bg-surface-dark h-full flex flex-col">
            <div className="flex items-center justify-between mb-3 flex-shrink-0">
                <h3 className="text-lg font-semibold">Test Cases</h3>
                <div className="flex items-center gap-2">
                    <Button onClick={addTestCase} size="sm" variant="outline" leftIcon={<Plus size={14}/>}>
                        Add Case
                    </Button>
                    <Button onClick={handleGenerateCases} size="sm" variant="outline" leftIcon={<Sparkles size={14} />} isLoading={isGenerating} disabled={!code.trim()}>
                            Generate by AI
                    </Button>
                </div>
            </div>
            <div className="flex-grow space-y-4 overflow-y-auto custom-scrollbar pr-2">
                {testCases.map((tc, index) => (
                    <div key={index} className="flex flex-col md:flex-row gap-2 p-3 bg-gray-50 dark:bg-gray-800 rounded-md border border-border-light dark:border-border-dark">
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Input (stdin)</label>
                            <textarea
                                value={tc.input}
                                onChange={(e) => updateTestCase(index, 'input', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter input, separate lines with \n"
                            />
                        </div>
                        <div className="flex-1">
                            <label className="text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Expected Output (stdout)</label>
                            <textarea
                                value={tc.expectedOutput}
                                onChange={(e) => updateTestCase(index, 'expectedOutput', e.target.value)}
                                className="input-field mt-1 !text-xs font-mono"
                                rows="2"
                                placeholder="Enter expected exact output"
                            />
                        </div>
                        <div className="flex items-end">
                            <IconButton icon={Trash2} variant="danger" size="sm" onClick={() => removeTestCase(index)} title="Remove Test Case" />
                        </div>
                    </div>
                ))}
                {testCases.length === 0 && (
                    <div className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-8">
                        Add a test case to begin.
                    </div>
                )}
            </div>
        </div>
    );
};

export default TestCaseManager;
```

`frontend/src/components/tools/ToolsModal.jsx`

```javascript
// frontend/src/components/tools/ToolsModal.jsx
import React from 'react';
import { Link, useNavigate } from 'react-router-dom';
import Modal from '../core/Modal';
import { Code, FileQuestion } from 'lucide-react';
const availableTools = [
    {
    title: 'Secure Code Executor',
    description: 'Write, compile, and run code in a sandboxed environment with AI assistance.',
    icon: Code,
    path: '/tools/code-executor',
    status: 'active'
    },
     {
        title: 'AI Quiz Generator',
        description: 'Upload a document (PDF, DOCX, TXT) and generate a multiple-choice quiz to test your knowledge.',
        icon: FileQuestion,
        path: '/tools/quiz-generator',
        status: 'active'
    },

];
const ToolsModal = ({ isOpen, onClose }) => {
    const navigate = useNavigate();
    const handleNavigate = (path) => {
        if (path !== '#') {
            onClose();
            navigate(path);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Developer Tools" size="2xl">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {availableTools.map((tool) => (
                    <div
                        key={tool.title}
                        onClick={() => handleNavigate(tool.path)}
                        className={`p-4 border rounded-lg transition-all duration-150 group relative
                            ${tool.status === 'active' 
                                ? 'cursor-pointer hover:border-primary dark:hover:border-primary-light hover:shadow-lg' 
                                : 'opacity-50 cursor-not-allowed'
                            }
                            bg-surface-light dark:bg-gray-800 border-border-light dark:border-border-dark
                        `}
                    >
                        {tool.status === 'soon' && (
                            <span className="absolute top-2 right-2 text-xs bg-yellow-400/20 text-yellow-500 font-semibold px-2 py-0.5 rounded-full">
                                Coming Soon
                            </span>
                        )}
                        <div className="flex items-center mb-2">
                            <tool.icon size={22} className="mr-3 text-primary dark:text-primary-light" />
                            <h3 className="font-semibold text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light">
                                {tool.title}
                            </h3>
                        </div>
                        <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                            {tool.description}
                        </p>
                    </div>
                ))}
            </div>
        </Modal>
    );
};


export default ToolsModal;
```

`frontend/src/contexts/AppStateContext.jsx`

```javascript
import React, { createContext, useState, useContext, useEffect } from 'react';

export const AppStateContext = createContext(null);

export const useAppState = () => {
    const context = useContext(AppStateContext);
    if (!context) throw new Error('useAppState must be used within an AppStateProvider');
    return context;
};

const defaultSystemPromptText = "You are a helpful AI engineering tutor.";

export const AppStateProvider = ({ children }) => {
    const [theme, setThemeState] = useState(() => {
        const storedTheme = localStorage.getItem('theme') || 'dark';
        if (typeof window !== 'undefined') {
            document.documentElement.classList.remove('light', 'dark');
            document.documentElement.classList.add(storedTheme);
        }
        return storedTheme;
    });

    const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'gemini');
    const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
    const [isRightPanelOpen, setIsRightPanelOpen] = useState(true);

    const [currentSessionId, setCurrentSessionIdState] = useState(() => {
        return localStorage.getItem('aiTutorSessionId') || null;
    });
    const [systemPrompt, setSystemPromptState] = useState(
        localStorage.getItem('aiTutorSystemPrompt') || defaultSystemPromptText
    );

    const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null);
    const [selectedSubject, setSelectedSubjectState] = useState(
        localStorage.getItem('aiTutorSelectedSubject') || null
    );

    const [isAdminSessionActive, setIsAdminSessionActiveState] = useState(() => {
        return sessionStorage.getItem('isAdminSessionActive') === 'true';
    });

    const [initialPromptForNewSession, setInitialPromptForNewSession] = useState(null);
    const [initialActivityForNewSession, setInitialActivityForNewSession] = useState(null);

    const toggleTheme = () => {
        setThemeState(prevTheme => {
            const newTheme = prevTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            return newTheme;
        });
    };

    const switchLLM = (llm) => {
         setSelectedLLM(llm);
         localStorage.setItem('selectedLLM', llm);
         console.log("AppStateContext: Switched LLM to:", llm);
    };

    const setSessionId = (sessionId) => {
        if (sessionId) {
            localStorage.setItem('aiTutorSessionId', sessionId);
        } else {
            console.log("AppStateContext: Clearing session and related context (logout).");
            localStorage.removeItem('aiTutorSessionId');
            
            localStorage.removeItem('aiTutorSelectedSubject'); 
            setSelectedSubjectState(null);
            
            setSelectedDocumentForAnalysisState(null);
        }
        setCurrentSessionIdState(sessionId);
        console.log("AppStateContext: Regular user session ID updated to:", sessionId);
    };

    const setSystemPrompt = (promptText) => {
        setSystemPromptState(promptText);
        localStorage.setItem('aiTutorSystemPrompt', promptText);
    };

    const selectDocumentForAnalysis = (documentFilename) => {
        setSelectedDocumentForAnalysisState(documentFilename);
        console.log("AppStateContext: Document for analysis tools set to:", documentFilename || "None");
        if (documentFilename && selectedSubject !== documentFilename) {
            if (selectedSubject !== null) {
                console.log("AppStateContext: Clearing selected subject because a specific user document was chosen for analysis tools.");
                setSelectedSubjectState(null);
                localStorage.removeItem('aiTutorSelectedSubject');
            }
        }
    };

    const setSelectedSubject = (subjectName) => {
        const newSubject = subjectName === "none" || !subjectName ? null : subjectName;
        if (newSubject) {
            localStorage.setItem('aiTutorSelectedSubject', newSubject);
        } else {
            localStorage.removeItem('aiTutorSelectedSubject');
        }
        setSelectedSubjectState(newSubject);
        console.log("AppStateContext: Selected subject (for chat RAG) updated to:", newSubject || "None");

        setSelectedDocumentForAnalysisState(newSubject);
        if (newSubject) {
             console.log("AppStateContext: Also set document for analysis tools to (admin subject):", newSubject);
        } else {
            if (selectedDocumentForAnalysis === subjectName) {
                 setSelectedDocumentForAnalysisState(null);
                 console.log("AppStateContext: Cleared document for analysis tools as linked subject was cleared.");
            }
        }
    };

    const setIsAdminSessionActive = (isActive) => {
        if (isActive) {
            sessionStorage.setItem('isAdminSessionActive', 'true');
            setSessionId(null); 
        } else {
            sessionStorage.removeItem('isAdminSessionActive');
        }
        setIsAdminSessionActiveState(isActive);
        console.log("AppStateContext: Admin session active status set to:", isActive);
    };

    useEffect(() => {
        const rootHtmlElement = document.documentElement;
        rootHtmlElement.classList.remove('light', 'dark');
        rootHtmlElement.classList.add(theme);
        document.body.className = '';
        document.body.classList.add(theme === 'dark' ? 'bg-background-dark' : 'bg-background-light');
    }, [theme]);

    return (
        <AppStateContext.Provider value={{
            theme, toggleTheme,
            selectedLLM, switchLLM,
            isLeftPanelOpen, setIsLeftPanelOpen,
            isRightPanelOpen, setIsRightPanelOpen,
            currentSessionId, setSessionId,
            systemPrompt, setSystemPrompt,
            selectedDocumentForAnalysis, selectDocumentForAnalysis,
            selectedSubject, setSelectedSubject,
            isAdminSessionActive, setIsAdminSessionActive,
            initialPromptForNewSession, setInitialPromptForNewSession,
            initialActivityForNewSession, setInitialActivityForNewSession
        }}>
            {children}
        </AppStateContext.Provider>
    );

};
```

`frontend/src/contexts/AuthContext.jsx`

```javascript
// frontend/src/contexts/AuthContext.jsx
import React, { createContext, useState, useEffect, useCallback } from 'react';
import api from '../services/api.js'; 
import toast from 'react-hot-toast';

export const AuthContext = createContext(null);

export const DEV_MODE_ALLOW_DEV_LOGIN = false;

export const AuthProvider = ({ children }) => {
    const [token, setTokenState] = useState(localStorage.getItem('authToken'));
    const [user, setUserState] = useState(null);
    const [loading, setLoading] = useState(true);

    const setToken = (newToken) => {
        if (newToken) localStorage.setItem('authToken', newToken);
        else localStorage.removeItem('authToken');
        setTokenState(newToken);
    };

    const setUser = (newUser) => setUserState(newUser);
    
    const processAuthData = useCallback((authApiResponse) => {
        if (authApiResponse && authApiResponse.token && authApiResponse._id && authApiResponse.email) {
            setToken(authApiResponse.token);
            setUser({ id: authApiResponse._id, email: authApiResponse.email, username: authApiResponse.username });
             console.log("AuthContext: User and Token set.", { email: authApiResponse.email, username: authApiResponse.username });
            return authApiResponse; 
        } else {
            setToken(null);
            setUser(null);
            console.error("AuthContext: processAuthData received incomplete data for a regular user.", authApiResponse);
            throw new Error("Authentication response from server was incomplete for a regular user.");
        }
    }, []);

    useEffect(() => {
        const verifyTokenAndLoadUser = async () => {
            const storedToken = localStorage.getItem('authToken');
            if (storedToken) {
                setTokenState(storedToken);
                try {
                    const userDataFromMe = await api.getMe();
                    if (userDataFromMe && userDataFromMe._id && userDataFromMe.email) {
                        setUser({ id: userDataFromMe._id, email: userDataFromMe.email, username: userDataFromMe.username });
                    } else {
                        setToken(null);
                        setUser(null);
                    }
                } catch (error) {
                    setToken(null);
                    setUser(null);
                }
            }
            setLoading(false);
        };
        verifyTokenAndLoadUser();
    }, []);

    const login = async (credentials) => {
        setLoading(true);
        try {
            const data = await api.login(credentials);
            if (data && data.isAdminLogin) {
                return data;
            }
            return processAuthData(data);
        } catch (error) {
            setToken(null); 
            setUser(null);
            throw error; 
        } finally {
            setLoading(false);
        }
    };
    
    const signup = async (signupData) => {
        setLoading(true);
        try {
            const data = await api.signup(signupData);
            return processAuthData(data); 
        } catch (error) {
            setToken(null);
            setUser(null);
            throw error;
        } finally {
            setLoading(false);
        }
    };

    const logout = () => {
        console.log("AuthContext: Logging out user.");
        setToken(null); 
        setUser(null);
        toast.success("You have been logged out.");
    };

    return (
        <AuthContext.Provider value={{ token, user, loading, login, signup, logout, setUser }}>
            {children}
        </AuthContext.Provider>
    );
};
```

`frontend/src/hooks/useAuth.jsx`

```javascript
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
```

`frontend/src/hooks/useTextToSpeech.js`

```javascript
// src/hooks/useTextToSpeech.js
import { useState, useEffect, useCallback, useRef } from 'react';
import { marked } from 'marked'; // To parse markdown for plain text

// Configure marked (if not already globally configured for this specific use)
// It's generally better if marked is configured once, e.g. in MessageBubble or a central place.
// Assuming marked is available and configured.

const getPlainTextFromMarkdown = (markdown) => {
  if (!markdown) return '';
  try {
    // A simpler approach for plain text extraction for TTS:
    // Render to a temporary element and get its text content.
    // This handles complex markdown structures reasonably well for speech.
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = marked.parse(markdown); // marked.parse() is synchronous
    let text = tempDiv.textContent || tempDiv.innerText || '';
    
    // Basic cleanup: remove excessive newlines/spaces that might make speech awkward
    text = text.replace(/\n+/g, ' '); // Replace newlines with spaces
    text = text.replace(/\s\s+/g, ' '); // Replace multiple spaces with single
    return text.trim();
  } catch (error) {
    console.error("Error parsing markdown for TTS:", error);
    return markdown; // Fallback to raw markdown if parsing fails
  }
};


export const useTextToSpeech = () => {
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isSupported, setIsSupported] = useState(false);
    const utteranceRef = useRef(null);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.speechSynthesis) {
            setIsSupported(true);
        }

        const handleEnd = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        
        const synth = window.speechSynthesis;
        if (synth) {
            // Add event listeners if needed, but onend on utterance is usually sufficient
        }

        return () => {
            if (synth) {
                synth.cancel(); // Cancel any speech on component unmount or hook cleanup
            }
        };
    }, []);

    const speak = useCallback(({ text, lang = 'en-US', voiceURI = null, rate = 1, pitch = 1, volume = 1 }) => {
        if (!isSupported || !text) return;

        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel(); // Stop any currently playing speech
        }
        
        const plainText = getPlainTextFromMarkdown(text);
        if (!plainText) {
            console.warn("TTS: No text content to speak after parsing markdown.");
            return;
        }

        const newUtterance = new SpeechSynthesisUtterance(plainText);
        newUtterance.lang = lang;
        newUtterance.rate = rate;
        newUtterance.pitch = pitch;
        newUtterance.volume = volume;

        if (voiceURI) {
            const voices = synth.getVoices();
            const selectedVoice = voices.find(voice => voice.voiceURI === voiceURI);
            if (selectedVoice) {
                newUtterance.voice = selectedVoice;
            }
        }
        
        newUtterance.onstart = () => {
            setIsSpeaking(true);
        };
        newUtterance.onend = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        newUtterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            setIsSpeaking(false);
            utteranceRef.current = null;
        };

        utteranceRef.current = newUtterance;
        synth.speak(newUtterance);
    }, [isSupported]);

    const cancel = useCallback(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel();
        }
        // onend should fire and set isSpeaking to false.
        // If it doesn't (e.g. cancel is abrupt), manually reset:
        if (isSpeaking) {
            setIsSpeaking(false);
            utteranceRef.current = null;
        }
    }, [isSupported, isSpeaking]);

    // Optional: Get available voices
    const getVoices = useCallback(() => {
        if (!isSupported) return [];
        return window.speechSynthesis.getVoices();
    }, [isSupported]);

    // Voices might load asynchronously. Listen for 'voiceschanged' event.
    useEffect(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        const loadVoices = () => {
            // You might want to store voices in state if your UI allows voice selection
            // console.log("Voices loaded:", synth.getVoices());
        };
        synth.addEventListener('voiceschanged', loadVoices);
        // Initial load if voices are already available
        if (synth.getVoices().length > 0) {
            loadVoices();
        }
        return () => synth.removeEventListener('voiceschanged', loadVoices);
    }, [isSupported]);


    return {
        speak,
        cancel,
        isSpeaking,
        isSupported,
        getVoices,
        currentlySpeakingUtterance: utteranceRef.current
    };
};
```

`frontend/src/hooks/useTheme.js`

```javascript
// import { useContext } from 'react';
// import { AppStateContext } from '../contexts/AppStateContext'; // Assuming theme is in AppStateContext

// export const useTheme = () => {
//     const context = useContext(AppStateContext);
//     if (!context) {
//         throw new Error('useTheme must be used within an AppStateProvider');
//     }
//     return { theme: context.theme, toggleTheme: context.toggleTheme };
// };


import { useContext } from 'react';
import { AppStateContext } from '../contexts/AppStateContext.jsx'; // Correct named import for the context object

export const useTheme = () => {
    const context = useContext(AppStateContext); // Use the imported context object
    if (!context) {
        throw new Error('useTheme must be used within an AppStateProvider');
    }
    return { theme: context.theme, toggleTheme: context.toggleTheme };
};
```

`frontend/src/hooks/useTypingEffect.js`

```javascript
// frontend/src/hooks/useTypingEffect.js
import { useState, useEffect, useRef } from 'react';
import GraphemeSplitter from 'grapheme-splitter';

export const useTypingEffect = (textToType, speed = 20, onComplete) => {
    const [displayedText, setDisplayedText] = useState('');
    const onCompleteRef = useRef(onComplete);
    const animationFrameRef = useRef();

    useEffect(() => {
        onCompleteRef.current = onComplete;
    }, [onComplete]);

    useEffect(() => {
        if (textToType) {
            const splitter = new GraphemeSplitter();
            const graphemes = splitter.splitGraphemes(textToType);
            let startTime = null;

            const animate = (timestamp) => {
                if (startTime === null) {
                    startTime = timestamp;
                }

                const elapsedTime = timestamp - startTime;
                const charactersToShow = Math.min(
                    Math.floor(elapsedTime / speed),
                    graphemes.length
                );

                setDisplayedText(graphemes.slice(0, charactersToShow).join(''));
                
                if (charactersToShow < graphemes.length) {
                    animationFrameRef.current = requestAnimationFrame(animate);
                } else {
                    setDisplayedText(textToType); 
                    if (onCompleteRef.current) {
                        onCompleteRef.current();
                    }
                }
            };

            animationFrameRef.current = requestAnimationFrame(animate);

            return () => {
                if (animationFrameRef.current) {
                    cancelAnimationFrame(animationFrameRef.current);
                }
            };
        } else {
            setDisplayedText('');
        }
    }, [textToType, speed]);

    return displayedText;
};
```

`frontend/src/hooks/useWebSpeech.js`

```javascript
// src/hooks/useWebSpeech.js
import { useState, useEffect, useCallback } from 'react';

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

export const useWebSpeech = () => {
    const [transcript, setTranscript] = useState('');
    const [listening, setListening] = useState(false);
    const [recognitionInstance, setRecognitionInstance] = useState(null);
    const [error, setError] = useState(null); // Added error state
    const isSpeechSupported = !!SpeechRecognition;

    useEffect(() => {
        if (!isSpeechSupported) {
            console.warn("Web Speech API is not supported by this browser.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = false; // Set to true if you want it to keep listening
        recognition.interimResults = false; // Set to true for live results
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            const currentTranscript = Array.from(event.results)
                .map(result => result[0])
                .map(result => result.transcript)
                .join('');
            setTranscript(currentTranscript);
            setError(null); // Clear error on successful result
            // console.log("Voice input result:", currentTranscript);
        };

        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            let errorMessage = event.error;
            if (event.error === 'no-speech') errorMessage = "No speech detected. Please try again.";
            else if (event.error === 'audio-capture') errorMessage = "Audio capture failed. Check microphone.";
            else if (event.error === 'not-allowed') errorMessage = "Microphone permission denied.";
            else if (event.error === 'network') errorMessage = "Network error during speech recognition.";
            // Add more specific error messages as needed
            
            setError(errorMessage);
            setListening(false);
        };

        recognition.onend = () => {
            setListening(false);
            // console.log("Speech recognition ended.");
        };
        
        setRecognitionInstance(recognition);

        // Cleanup
        return () => {
            if (recognition) {
                recognition.abort(); // Use abort to stop and discard results if component unmounts
            }
        };
    }, [isSpeechSupported]);

    const startListening = useCallback(() => {
        if (recognitionInstance && !listening) {
            try {
                setTranscript(''); // Clear previous transcript
                setError(null); // Clear previous errors
                recognitionInstance.start();
                setListening(true);
                // console.log("Speech recognition started.");
            } catch (e) {
                // This catch might be for synchronous errors during .start() call,
                // most errors are handled by recognition.onerror
                console.error("Error starting speech recognition:", e);
                setError("Could not start voice input.");
                setListening(false); // Ensure listening state is correct
            }
        }
    }, [recognitionInstance, listening]);

    const stopListening = useCallback(() => {
        if (recognitionInstance && listening) {
            recognitionInstance.stop(); // Stop and process any captured audio
            // setListening(false) will be called by onend event
            // console.log("Speech recognition stopped manually.");
        }
    }, [recognitionInstance, listening]);

    const resetTranscript = useCallback(() => {
        setTranscript('');
    }, []);


    return {
        transcript,
        listening,
        isSpeechSupported,
        startListening,
        stopListening,
        resetTranscript,
        error // Expose error state
    };
};
```

`frontend/src/index.css`

```css
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {

  html,
  body,
  #root {
    /* Apply to html, body, AND your React root div */
    @apply h-full overflow-hidden;
    /* Force full height and no scroll on these */
  }

  html {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    scroll-behavior: smooth;
    /* This is fine, affects internal scrolls */
  }

  body {
    @apply bg-background-light text-text-light transition-colors duration-300;
    font-family: theme('fontFamily.sans');
    /* overflow-hidden is now applied via the html, body, #root rule above */
  }

  html.dark body {
    @apply bg-background-dark text-text-dark;
  }

  html.light body {
    @apply bg-background-light text-text-light;
  }

  .custom-scrollbar {
    @apply scrollbar-thin scrollbar-thumb-secondary dark:scrollbar-thumb-secondary-dark scrollbar-track-surface-light dark:scrollbar-track-gray-800 scrollbar-thumb-rounded-full scrollbar-track-rounded-full;
  }

  /* --- Enhanced Prose Styles --- */
  .prose {
    @apply max-w-none text-text-light dark:text-text-dark;
  }

  .prose,
  .prose-sm {

    /* Headings */
    h1 {
      @apply text-2xl sm:text-3xl font-extrabold mb-6 mt-2 text-text-light dark:text-text-dark;
    }

    h2 {
      @apply text-xl sm:text-2xl font-bold mb-4 mt-8 border-b border-border-light dark:border-border-dark pb-2;
    }

    h3 {
      @apply text-lg sm:text-xl font-semibold mb-3 mt-6;
    }

    h4 {
      @apply text-base sm:text-lg font-semibold mb-2 mt-4;
    }

    /* Paragraphs */
    p {
      @apply mb-4 leading-relaxed;
    }

    /* Links */
    a {
      @apply text-primary dark:text-primary-light hover:underline font-medium;
    }

    pre a,
    pre code a {
      @apply text-inherit no-underline hover:text-inherit;
    }

    /* Lists */
    ul,
    ol {
      @apply pl-5 mb-4 space-y-1;
    }

    ul {
      @apply list-disc;
    }

    ol {
      @apply list-decimal;
    }

    li {
      @apply mb-1;
    }

    ul ul,
    ol ol,
    ul ol,
    ol ul {
      @apply pl-5 mt-1 mb-1;
    }

    li::marker {
      @apply text-text-muted-light dark:text-text-muted-dark;
    }

    /* --- GFM Task List Checkboxes - Custom GREEN Styling --- */
    li:has(> input[type="checkbox"]) {
      @apply flex items-center;
      list-style-type: none;
      margin-left: -1.25rem;
      /* Adjust as needed for alignment */
      padding-left: 0;
    }

    li>input[type="checkbox"] {
      @apply opacity-0 w-0 h-0 absolute;
    }

    li:has(> input[type="checkbox"])::before {
      content: "";
      @apply inline-block w-4 h-4 border-2 rounded-sm mr-2 align-middle flex-shrink-0;
      @apply bg-surface-light dark:bg-gray-700;
      @apply border-border-light dark:border-border-dark;
      transition: all 0.15s ease-in-out;
    }

    li:has(> input[type="checkbox"]:checked)::before {
      @apply bg-green-500 dark:bg-green-600 border-green-500 dark:border-green-600;
      background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
      background-size: 70% 70%;
      background-position: center;
      background-repeat: no-repeat;
    }

    li:has(> input[type="checkbox"]:disabled:not(:checked))::before {
      @apply opacity-60 cursor-not-allowed;
      @apply bg-gray-100 dark:bg-gray-600 border-gray-300 dark:border-gray-500;
    }

    li:has(> input[type="checkbox"]:checked:disabled)::before {
      @apply bg-green-500/70 dark:bg-green-600/70 border-green-500/70 dark:border-green-600/70;
      opacity: 0.75;
      cursor: not-allowed;
    }


    /* Blockquotes */
    blockquote {
      @apply border-l-4 border-primary dark:border-primary-light pl-4 py-2 my-4 italic text-text-muted-light dark:text-text-muted-dark bg-surface-light dark:bg-gray-800/30 rounded-r-md;
    }

    blockquote p {
      @apply mb-0;
    }

    /* Horizontal Rules */
    hr {
      @apply my-8 border-t border-border-light dark:border-border-dark;
    }

    /* Tables */
    table {
      @apply w-full my-6 text-sm border-collapse;
    }

    thead {
      @apply border-b-2 border-border-light dark:border-border-dark;
    }

    th {
      @apply px-4 py-2.5 text-left font-semibold text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700/50;
      @apply border border-border-light dark:border-border-dark;
    }

    tbody tr {
      @apply border-b border-border-light dark:border-border-dark;
    }

    tbody tr:last-child {
      @apply border-b-0;
    }

    tbody tr:nth-child(even) {
      @apply bg-gray-50 dark:bg-gray-800/20;
    }

    td {
      @apply px-4 py-2.5 text-left border-x border-border-light dark:border-border-dark;
    }

    td code {
      @apply text-xs;
    }

    td strong {
      @apply font-semibold;
    }

    /* --- Code Styling --- */
    code:not(pre code) {
      @apply px-1.5 py-0.5 bg-primary/10 dark:bg-primary-dark/20 text-primary dark:text-primary-light rounded-md text-xs font-mono break-words;
    }

    code:not(pre code)::before,
    code:not(pre code)::after {
      content: '';
    }

    pre {
      @apply bg-[#282c34] dark:bg-[#21252b] p-4 rounded-lg shadow-md overflow-x-auto custom-scrollbar my-5;
    }

    pre code {
      @apply bg-transparent p-0 font-mono text-sm leading-relaxed;
      color: #abb2bf;
      white-space: pre-wrap;
      word-break: break-all;
    }

    strong {
      @apply font-semibold text-text-light dark:text-text-dark;
    }
  }
}

@layer components {
    .btn {
    @apply font-semibold py-2 px-4 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2 disabled:opacity-60 disabled:cursor-not-allowed;
  }

  html.dark .btn {
    @apply focus:ring-offset-background-dark;
  }

  html:not(.dark) .btn {
    @apply focus:ring-offset-background-light;
  }

  .btn-primary {
    @apply btn bg-primary text-white hover:bg-primary-dark focus:ring-primary;
  }

  .btn-secondary {
    @apply btn bg-secondary text-white hover:bg-secondary-dark focus:ring-secondary;
  }

  .btn-ghost {
    @apply btn text-text-muted-light dark:text-text-muted-dark hover:bg-gray-500 hover:bg-opacity-10 focus:ring-primary;
  }

  .input-field {
    @apply block w-full px-3 py-2 bg-surface-light dark:bg-gray-700 border border-border-light dark:border-border-dark rounded-md text-sm shadow-sm placeholder-text-muted-light dark:placeholder-text-muted-dark focus:outline-none focus:border-primary dark:focus:border-primary-light focus:ring-1 focus:ring-primary dark:focus:ring-primary-light;
  }

  .form-input,
  .form-textarea,
  .form-select,
  .form-multiselect {
    @apply input-field;
  }

  .form-checkbox,
  .form-radio {
    @apply rounded shadow-sm border-border-light dark:border-border-dark text-primary focus:ring-primary dark:focus:ring-primary-light;
    @apply bg-surface-light dark:bg-gray-600;
  }

  .form-checkbox:disabled,
  .form-radio:disabled {
    @apply opacity-70 bg-gray-200 dark:bg-gray-700 border-gray-300 dark:border-gray-600;
  }

  .card-base {
    @apply border rounded-panel shadow-panel;
    @apply bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark;
  }

  .card-header-base {
    @apply px-4 py-3 text-sm font-semibold border-b;
    @apply text-text-light dark:text-text-dark border-border-light dark:border-border-dark;
  }

  .panel-resize-handle {
      @apply relative bg-transparent;
  }
  
  .panel-resize-handle::after {
    content: '';
    @apply absolute inset-0 transition-colors duration-200;
  }

  .panel-resize-handle[data-active='true']::after {
    @apply bg-primary/50;
  }

  /* --- NEW: Twinkling Title Effect --- */
  .twinkling-title {
    animation: twinkle-effect 4s ease-in-out infinite;
  }
}

@layer utilities {
  /* --- NEW: Keyframes --- */
  @keyframes twinkle-effect {
    0%, 100% {
      opacity: 1;
      transform: scale(1);
      text-shadow: 0 0 8px theme('colors.orange.400' / 0.5);
    }
    50% {
      opacity: 0.85;
      transform: scale(0.98);
      text-shadow: 0 0 16px theme('colors.amber.400' / 0.7);
    }
  }
}


/* In frontend/src/index.css, add this at the end */

@layer utilities {
  /* Keyframes for the border rotation */
  @keyframes spin-border {
    0% {
      --angle: 0deg;
    }
    100% {
      --angle: 360deg;
    }
  }

  /* Keyframes for the twinkling/shining effect on text and icons */
  @keyframes twinkle-effect {
    0%, 100% {
      opacity: 1;
      text-shadow: 0 0 8px currentColor, 0 0 10px currentColor;
    }
    50% {
      opacity: 0.85;
      text-shadow: 0 0 12px currentColor, 0 0 16px currentColor;
    }
  }

  /* Utility class to apply the twinkling animation */
  .twinkling-text {
    animation: twinkle-effect 4s ease-in-out infinite;
  }

  /* 
    This is the core of the rotating border effect.
    We register '--angle' as a CSS property that can be animated.
    This is a modern CSS feature that makes this animation smooth and performant.
  */
  @property --angle {
    syntax: '<angle>';
    initial-value: 0deg;
    inherits: false;
  }

  @keyframes sweep-underline {
  from {
    transform: translateX(-101%); /* Start completely off-screen to the left */
  }
  to {
    transform: translateX(101%); /* End completely off-screen to the right */
  }
}

/* --- Utility class for the animated underline --- */
.animated-underline {
  position: relative;
  display: inline-block;
  padding-bottom: 4px;
  overflow: hidden; /* CRITICAL: This hides the gradient when it's off-screen */
}

/* REVISED PSEUDO-ELEMENT for a smooth sweep */
.animated-underline::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%; /* The gradient bar is the same width as the text */
  height: 2px;
  background: linear-gradient(
    90deg, 
    transparent, /* Start transparent */
    theme('colors.orange.500'),
    theme('colors.red.500'),
    theme('colors.amber.400'),
    transparent /* End transparent */
  );
  animation: sweep-underline 4s linear infinite;
}

/* --- Keyframes for the fiery "Hot" tag effect --- */
@keyframes fire-flicker {
  0%, 100% {
    transform: scale(1, 1);
    box-shadow: 0 0 4px 0px theme('colors.red.500'), 0 0 6px 0px theme('colors.orange.400');
  }
  50% {
    transform: scale(1.05, 1.05);
    box-shadow: 0 0 8px 2px theme('colors.red.500' / 0.7), 0 0 12px 3px theme('colors.orange.400' / 0.7);
  }
}

/* --- Utility class for the fire animation --- */
.fire-tag-animation {
  animation: fire-flicker 2.5s ease-in-out infinite;
}
}



@layer utilities {
  /* --- Keyframes for the sweeping underline effect --- */
  @keyframes sweep-underline {
    from {
      transform: translateX(-101%); /* Start completely off-screen to the left */
    }
    to {
      transform: translateX(101%); /* End completely off-screen to the right */
    }
  }

  /* --- Utility class for the animated underline --- */
  .animated-underline {
    position: relative;
    display: inline-block;
    padding-bottom: 4px;
    overflow: hidden; /* CRITICAL: This hides the gradient when it's off-screen */
  }

  .animated-underline::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%; /* The gradient bar is the same width as the text */
    height: 2px;
    background: linear-gradient(
      90deg, 
      transparent,
      theme('colors.orange.500'),
      theme('colors.red.500'),
      theme('colors.amber.400'),
      transparent
    );
    animation: sweep-underline 4s linear infinite;
  }

  /* --- Keyframes for the fiery "Hot" tag effect --- */
  @keyframes fire-flicker {
    0%, 100% {
      transform: scale(1, 1);
      box-shadow: 0 0 4px 0px theme('colors.red.500'), 0 0 6px 0px theme('colors.orange.400');
    }
    50% {
      transform: scale(1.05, 1.05);
      box-shadow: 0 0 8px 2px theme('colors.red.500' / 0.7), 0 0 12px 3px theme('colors.orange.400' / 0.7);
    }
  }

  /* --- Utility class for the fire animation --- */
  .fire-tag-animation {
    animation: fire-flicker 2.5s ease-in-out infinite;
  }
}

```

`frontend/src/main.jsx`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import AppWrapper from './App.jsx';
import { AuthProvider } from './contexts/AuthContext.jsx'; // For regular users
import { AppStateProvider } from './contexts/AppStateContext.jsx';
import { Toaster } from 'react-hot-toast';
import './index.css';

import 'prismjs/themes/prism-okaidia.css';
import 'katex/dist/katex.min.css';
import Prism from 'prismjs'; 
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup'; 
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-java';


// ReactDOM.createRoot(document.getElementById('root')).render(
//   <React.StrictMode>
//     <AuthProvider>
//       <AppStateProvider>
//         <AppWrapper />
//       </AppStateProvider>
//     </AuthProvider>
//   </React.StrictMode>,
// );


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <AppStateProvider>
        <Toaster
          position="top-center"
          reverseOrder={false}
          gutter={8}
          toastOptions={{
            // Define default options
            className: '',
            duration: 5000,
            style: {
              background: '#363636',
              color: '#fff',
            },
            // Default options for specific types
            success: {
              duration: 3000,
              theme: {
                primary: 'green',
                secondary: 'black',
              },
              style: {
                background: '#10B981', // green-500
                color: 'white',
              },
              iconTheme: {
                primary: 'white',
                secondary: '#10B981',
              },
            },
            error: {
              duration: 5000,
              style: {
                background: '#EF4444', // red-500
                color: 'white',
              },
              iconTheme: {
                primary: 'white',
                secondary: '#EF4444',
              },
            },
          }}
        />
        <AppWrapper />
      </AppStateProvider>
    </AuthProvider>
  </React.StrictMode>,
);
```

`frontend/src/services/adminApi.js`

```javascript
// frontend/src/services/adminApi.js
import axios from 'axios';

// --- CONFIGURATION ---
const ADMIN_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin`;
const ADMIN_USERNAME_FRONTEND = import.meta.env.VITE_ADMIN_USERNAME || 'admin@admin.com';
const ADMIN_PASSWORD_FRONTEND = import.meta.env.VITE_ADMIN_PASSWORD || 'admin123';

// --- DEDICATED AXIOS INSTANCE FOR ADMIN CALLS ---
// This creates a separate client specifically for admin routes, preventing any conflicts
// with the main app's interceptors or default settings.
const adminApiClient = axios.create({
    baseURL: ADMIN_API_BASE_URL,
});

// --- HELPER FUNCTIONS ---

export const getFixedAdminAuthHeaders = () => {
    if (!ADMIN_USERNAME_FRONTEND || !ADMIN_PASSWORD_FRONTEND) {
        console.error("Admin credentials not found in .env variables (VITE_ADMIN_USERNAME, VITE_ADMIN_PASSWORD).");
        return {};
    }
    const basicAuthToken = btoa(`${ADMIN_USERNAME_FRONTEND}:${ADMIN_PASSWORD_FRONTEND}`);
    return { 'Authorization': `Basic ${basicAuthToken}` };
};

// --- THIS IS THE REFINED AND SIMPLIFIED REQUEST HANDLER ---
// It now uses the dedicated `adminApiClient` instance.
const makeAdminApiRequest = async (method, endpoint, data = null, customHeaders = {}) => {
    try {
        const config = {
            method,
            url: endpoint, // The URL is relative to the `baseURL` of `adminApiClient`
            headers: {
                ...getFixedAdminAuthHeaders(), // Always include fresh auth headers
                ...customHeaders,
            },
        };
        if (data) {
            config.data = data;
        }
        if (data instanceof FormData) {
            config.headers['Content-Type'] = 'multipart/form-data';
        }

        const response = await adminApiClient(config);
        return response.data;
    } catch (error) {
        let errorMessage = 'Admin API request failed.';
        if (error.response) {
            errorMessage = error.response.data?.message || `Server error: ${error.response.status}`;
            console.error(`Admin API Error (${method.toUpperCase()} ${ADMIN_API_BASE_URL}${endpoint}): Status ${error.response.status}`, error.response.data);
        } else if (error.request) {
            errorMessage = 'No response from admin API server. Check network or server status.';
        } else {
            errorMessage = error.message || 'Error setting up admin API request.';
        }
        throw new Error(errorMessage);
    }
};

// --- EXPORTED API FUNCTIONS (Now using the reliable handler) ---

export const getDashboardStats = () => makeAdminApiRequest('get', '/dashboard-stats');

export const uploadAdminDocument = (formData) => makeAdminApiRequest('post', '/documents/upload', formData);
export const getAdminDocuments = () => makeAdminApiRequest('get', '/documents');
export const deleteAdminDocument = (serverFilename) => makeAdminApiRequest('delete', `/documents/${serverFilename}`);
export const getAdminDocumentAnalysis = (serverFilename) => makeAdminApiRequest('get', `/documents/${serverFilename}/analysis`);
export const getAdminDocumentAnalysisByOriginalName = (originalName) => makeAdminApiRequest('get', `/documents/by-original-name/${encodeURIComponent(originalName)}/analysis`);

export const getApiKeyRequests = () => makeAdminApiRequest('get', '/key-requests');
export const approveApiKeyRequest = (userId) => makeAdminApiRequest('post', '/key-requests/approve', { userId });
export const rejectApiKeyRequest = (userId) => makeAdminApiRequest('post', '/key-requests/reject', { userId });

export const getUsersAndChats = () => makeAdminApiRequest('get', '/users-with-chats');
```

`frontend/src/services/api.js`

```javascript
// frontend/src/services/api.js
import axios from "axios";
import toast from "react-hot-toast";

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api",
});

apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      console.error("API Interceptor: Received 401 Unauthorized. Token might be invalid or expired.");
    }
    return Promise.reject(error);
  }
);

function parseAnalysisOutput(rawOutput) {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
}

const api = {
  login: async (credentials) => {
    const response = await apiClient.post("/auth/signin", credentials);
    return response.data;
  },
  signup: async (userData) => {
    const response = await apiClient.post("/auth/signup", userData);
    return response.data;
  },
  getMe: async () => {
    const response = await apiClient.get("/auth/me");
    return response.data;
  },
  sendMessage: async (payload) => {
    const response = await apiClient.post("/chat/message", payload);
    return response.data;
  },
  getChatHistory: async (sessionId) => {
    const response = await apiClient.get(`/chat/session/${sessionId}`);
    return response.data;
  },
  getChatSessions: async () => {
    const response = await apiClient.get("/chat/sessions");
    return response.data;
  },
  startNewSession: async (previousSessionId) => {
    const response = await apiClient.post("/chat/history", {
      previousSessionId,
    });
    return response.data;
  },
  deleteChatSession: async (sessionId) => {
    const response = await apiClient.delete(`/chat/session/${sessionId}`);
    return response.data;
  },
  uploadFile: async (formData, onUploadProgress) => {
    const response = await apiClient.post("/upload", formData, {
      headers: { "Content-Type": "multipart/form-data" },
      onUploadProgress,
    });
    return response.data;
  },
  // getFiles: async () => {
  //   const response = await apiClient.get("/files");
  //   return response.data;
  // },
  // deleteFile: async (serverFilename) => {
  //   const response = await apiClient.delete(`/files/${serverFilename}`);
  //   return response.data;
  // },
  getKnowledgeSources: async () => {
    const response = await apiClient.get("/knowledge-sources");
    return response.data;
  },
  deleteKnowledgeSource: async (sourceId) => {
    const response = await apiClient.delete(`/knowledge-sources/${sourceId}`);
    return response.data;
  },
  addUrlSource: async (url) => {
    const response = await apiClient.post("/knowledge-sources", {
      type: "url",
      content: url,
    });
    return response.data; // Returns the initial source object with "processing" status
  },
  updateUserLLMConfig: async (configData) => {
    console.log("[Frontend API] Sending LLM config update:", configData);
    const response = await apiClient.put("/llm/config", configData);
    return response.data;
  },
  getOrchestratorStatus: async () => {
    try {
      const response = await apiClient.get("/network/ip");
      return {
        status: "ok",
        message: `Backend Online at ${response.data.ips[0]}`,
      };
    } catch (e) {
      return { status: "error", message: "Backend Unreachable" };
    }
  },
  getUserProfile: async () => {
    const response = await apiClient.get("/user/profile");
    return response.data;
  },
  updateUserProfile: async (profileData) => {
    const response = await apiClient.put("/user/profile", profileData);
    return response.data;
  },
  getSubjects: async () => {
    const response = await apiClient.get("/subjects");
    return response.data;
  },
  requestAnalysis: async (payload) => {
    const { filename, analysis_type } = payload;
    if (!filename || !analysis_type) {
      throw new Error("Filename and analysis type are required.");
    }
    const toastId = toast.loading(
      `Generating ${analysis_type} for "${filename}"...`
    );
    try {
      const response = await apiClient.get(
        `/analysis/${encodeURIComponent(filename)}`
      );
      const fullAnalysisObject = response.data;
      const rawOutput = fullAnalysisObject[analysis_type];
      if (
        !rawOutput ||
        typeof rawOutput !== "string" ||
        rawOutput.trim() === ""
      ) {
        toast.success(`No stored ${analysis_type} found for "${filename}".`, {
          id: toastId,
        });
        return {
          content: `Notice: Analysis for '${analysis_type}' has not been generated yet or was empty.`,
          thinking: "No analysis data found in the database for this type.",
        };
      }
      const { content, thinking } = parseAnalysisOutput(rawOutput);
      toast.success(
        `Successfully generated ${analysis_type} for "${filename}".`,
        { id: toastId }
      );
      return { content, thinking };
    } catch (error) {
      const errorMessage =
        error.response?.data?.message || error.message || "Unknown error";
      toast.error(`Error generating ${analysis_type}: ${errorMessage}`, {
        id: toastId,
      });
      throw error;
    }
  },
  generateDocument: async ({
    markdownContent,
    docType,
    sourceDocumentName,
  }) => {
    const response = await apiClient.post(
      "/generate/document",
      { markdownContent, docType, sourceDocumentName },
      { responseType: "blob" }
    );
    const contentDisposition = response.headers["content-disposition"];
    let filename = `generated-document.${docType}`;
    if (contentDisposition) {
      const filenameMatch = contentDisposition.match(/filename="?(.+)"?/);
      if (filenameMatch && filenameMatch.length > 1) {
        filename = filenameMatch[1];
      }
    }
    return { fileBlob: response.data, filename: filename };
  },
  generatePodcast: async ({
    analysisContent,
    sourceDocumentName,
    podcastOptions,
  }) => {
    const response = await apiClient.post(
      "/export/podcast",
      { analysisContent, sourceDocumentName, podcastOptions },
      { responseType: "blob" }
    );
    return { audioBlob: response.data, sourceDocumentName };
  },
  getKnowledgeGraph: async (documentName) => {
    const response = await apiClient.get(
      `/kg/visualize/${encodeURIComponent(documentName)}`
    );
    return response.data;
  },
  getSessionKnowledgeGraph: async (sessionId) => {
    const response = await apiClient.get(
      `/kg/session/${encodeURIComponent(sessionId)}`
    );
    return response.data;
  },
  executeCode: async (payload) => {
    const response = await apiClient.post("/tools/execute", payload);
    return response.data; // The data should be { results: [...] } or { compilationError: "..." }
  },
  analyzeCode: async (payload) => {
    const response = await apiClient.post("/tools/analyze-code", payload);
    return response.data; // Should be { analysis: "..." }
  },
  generateTestCases: async (payload) => {
    const response = await apiClient.post(
      "/tools/generate-test-cases",
      payload
    );
    return response.data; // Should be { testCases: [...] }
  },
  explainError: async (payload) => {
    const response = await apiClient.post("/tools/explain-error", payload);
    return response.data; // Should be { explanation: "..." }
  },
  getRecommendations: async (sessionId) => {
    const response = await apiClient.get(
      `/learning/recommendations/${sessionId}`
    );
    return response.data; // Should be { recommendations: [...] }
  },

  findDocumentForTopic: async (topic) => {
    const response = await apiClient.post("/learning/find-document", { topic });
    return response.data; // Should be { documentName: "..." }
  },
  getLearningPaths: async () => {
    const response = await apiClient.get("/learning/paths");
    return response.data; // Should be an array of learning path objects
  },

  generateLearningPath: async (goal, context = null) => {
    const response = await apiClient.post("/learning/paths/generate", {
      goal,
      context,
    });
    return response.data; // Should be the newly created learning path object
  },

  updateModuleStatus: async (pathId, moduleId, status) => {
    const response = await apiClient.put(
      `/learning/paths/${pathId}/modules/${moduleId}`,
      { status }
    );
    return response.data; // Should be the entire updated learning path object
  },

  generateQuiz: async (file, quizOption) => {
    const formData = new FormData();
    formData.append("file", file);
    formData.append("quizOption", quizOption); // <<< Send the descriptive string

    const response = await apiClient.post("/tools/generate-quiz", formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
      timeout: 300000,
    });
    return response.data; // Should be { quiz: [...] }
  },
  analyzePrompt: async (promptText) => {
<<<<<<< HEAD
    const response = await apiClient.post("/chat/analyze-prompt", {
      prompt: promptText,
    });
    return response.data; // Expects { improvedPrompt, explanation }
  },
=======
    const response = await apiClient.post('/chat/analyze-prompt', { prompt: promptText });
    return response.data; // Expects { improvedPrompt, explanation }
  },

>>>>>>> 458645dd4bb632680f0b033a4ca7dc99642d1798
};

export default api;
```

`frontend/src/utils/helpers.js`

```javascript
// Debounce function: Limits the rate at which a function can fire.
import { marked } from 'marked';

export const getPlainTextFromMarkdown = (markdown) => {
  if (!markdown) return '';
  try {
    const html = marked.parse(markdown);
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    // .textContent correctly extracts text and preserves line breaks from block elements
    return tempDiv.textContent || '';
  } catch (error) {
    console.error("Error converting markdown to plain text:", error);
    return markdown; // Fallback to raw markdown on error
  }
};


export const debounce = (func, delay) => {
    let timeoutId;
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(context, args), delay);
    };
};

// Throttle function: Ensures a function is called at most once in a specified time period.
export const throttle = (func, limit) => {
    let inThrottle;
    let lastFunc;
    let lastRan;
    return function(...args) {
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            lastRan = Date.now();
            inThrottle = true;
            setTimeout(() => {
                inThrottle = false;
                if (lastFunc) {
                    lastFunc.apply(context, args); // Call with latest args if throttled
                    lastRan = Date.now();
                }
            }, limit);
        } else {
            lastFunc = func; // Store the latest call
        }
    };
};

// Simple function to format file size
export const formatFileSize = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

// Function to generate a simple unique ID (for client-side list keys, etc.)
export const generateUniqueId = (prefix = 'id') => {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Function to safely get nested property
export const getNestedValue = (obj, path, defaultValue = undefined) => {
    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
    return value === undefined ? defaultValue : value;
};

// Basic HTML escape (can be more comprehensive)
export const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, `"`)
         .replace(/'/g, "'");
};

// You can add more utility functions here as your project grows.
// For example, date formatting, string manipulation, etc.

// Example: Truncate text
export const truncateText = (text, maxLength = 100) => {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
};
```

`frontend/src/utils/markdownUtils.jsx`

```javascript
// src/utils/markdownUtils.jsx
import katex from 'katex';
import DOMPurify from 'dompurify';

const decodeHtmlEntities = (encodedString) => {
  if (typeof encodedString !== 'string') return encodedString;

  const textarea = document.createElement('textarea');
  textarea.innerHTML = encodedString;
  return textarea.value;
};

export const renderMathInHtml = (htmlString) => {
  if (!htmlString || typeof htmlString !== 'string') return htmlString;

  let processedString = htmlString;
  processedString = processedString.replace(/(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$/g, (match, rawExpression) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: true, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"} 
      });
      return DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } });
    } catch (e) { 
      console.warn(`KaTeX (display) error: ${e.message} for expression: ${expression}`); 
      return match; 
    }
  });

  processedString = processedString.replace(/(^|[^$\\])\$(?![\s$])([^$\n]+?)(?<![\s\\])\$([^\$]|$)/g, (fullMatch, prefix, rawExpression, suffix) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    if (!expression) return fullMatch; 
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: false, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"}
      });
      return prefix + DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } }) + suffix;
    } catch (e) { 
      console.warn(`KaTeX (inline) error: ${e.message} for expression: ${expression}`);
      return fullMatch; 
    }
  });
  
  return processedString;
};
```

`frontend/tailwind.config.js`

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  safelist: [
    'prose',
    'prose-sm',
    'dark:prose-invert',
  ],
  theme: {
    extend: {
      colors: {
        'primary': { light: '#60a5fa', DEFAULT: '#3b82f6', dark: '#2563eb' },
        'secondary': { light: '#9ca3af', DEFAULT: '#6b7280', dark: '#4b5563' },
        'accent': '#2dd4bf',
        'background-dark': '#0F172A', 'surface-dark': '#1E293B', 'border-dark': '#334155', 'text-dark': '#E2E8F0', 'text-muted-dark': '#94A3B8',
        'background-light': '#F8FAFC', 'surface-light': '#FFFFFF', 'border-light': '#E2E8F0', 'text-light': '#0F172A', 'text-muted-light': '#64748B',
      },
      fontFamily: {
        sans: ['"Inter var"', 'Inter', 'system-ui', 'sans-serif'],
      },
      boxShadow: {
        'main': '0 4px 15px -5px rgba(0,0,0,0.07), 0 2px 8px -6px rgba(0,0,0,0.07)',
        'panel': '0 8px 20px -5px rgba(0,0,0,0.1), 0 4px 10px -6px rgba(0,0,0,0.08)',
        'card-hover': '0 6px 18px -4px rgba(0,0,0,0.1), 0 3px 10px -5px rgba(0,0,0,0.1)',
      },
      borderRadius: { 'xl': '0.75rem', '2xl': '1rem', 'panel': '0.75rem' },
      keyframes: {
        fadeIn: { '0%': { opacity: '0', transform: 'translateY(5px)' }, '100%': { opacity: '1', transform: 'translateY(0px)' } },
        slideUp: { '0%': { transform: 'translateY(10px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } },
        // --- ADDED THIS KEYFRAME ---
        pulseDots: {
          '0%, 100%': { opacity: '0.3', transform: 'scale(0.8)' },
          '50%': { opacity: '1', transform: 'scale(1)' },
        }
      },
      animation: {
        fadeIn: 'fadeIn 0.3s ease-out forwards',
        slideUp: 'slideUp 0.4s ease-out forwards',
        // --- ADDED THESE ANIMATIONS ---
        pulseDot1: 'pulseDots 1.4s infinite 0s ease-in-out',
        pulseDot2: 'pulseDots 1.4s infinite 0.2s ease-in-out',
        pulseDot3: 'pulseDots 1.4s infinite 0.4s ease-in-out',
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms')({ strategy: 'class' }),
    require('tailwind-scrollbar')({ nocompatible: true }),
    require('@tailwindcss/typography'),
  ],
}
```

`frontend/vite.config.js`

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  // --- ADD THIS SECTION TO FIX THE "global is not defined" ERROR ---
  define: {
    'global': {},
  }
})

```

`server/.env`

```
PORT=5001
MONGO_URI="mongodb://localhost:27017/chatbot_gemini"
JWT_SECRET="your_super_strong_and_secret_jwt_key_12345"
GEMINI_API_KEY="AIzaSyCHuH6_DJuxGawHM2QqU5YNM8Zpp0xVl_I"
PROMPT_COACH_GEMINI_MODEL=gemini-1.5-flash-latest
PROMPT_COACH_OLLAMA_MODEL=phi3:mini-instruct
PYTHON_RAG_SERVICE_URL="http://127.0.0.1:5000"
OLLAMA_API_BASE_URL="https://angels-himself-fixtures-unknown.trycloudflare.com"
OLLAMA_DEFAULT_MODEL="qwen2.5:14b-instruct"
ENCRYPTION_SECRET=583c0c57ffbb993163e28273671daebf880eb972d6d1402613be9da09a5297e2
REDIS_URL="redis://localhost:6379"
FIXED_ADMIN_USERNAME=admin@admin.com
FIXED_ADMIN_PASSWORD=admin123

```

`server/config/db.js`

```javascript
const mongoose = require('mongoose');
// const dotenv = require('dotenv'); // Removed dotenv

// dotenv.config(); // Removed dotenv

// Modified connectDB to accept the URI as an argument
const connectDB = async (mongoUri) => {
  if (!mongoUri) {
      console.error('MongoDB Connection Error: URI is missing.');
      process.exit(1);
  }
  try {
    // console.log(`Attempting MongoDB connection to: ${mongoUri}`); // Debug: Careful logging URI
    const conn = await mongoose.connect(mongoUri, {
      // Mongoose 6+ uses these defaults, so they are not needed
      // useNewUrlParser: true,
      // useUnifiedTopology: true,
      // serverSelectionTimeoutMS: 5000 // Example: Optional: Timeout faster
    });

    console.log(`✓ MongoDB Connected Successfully`); // Simpler success message
    return conn; // Return connection object if needed elsewhere
  } catch (error) {
    console.error('MongoDB Connection Error:', error.message);
    // Exit process with failure
    process.exit(1);
  }
};

module.exports = connectDB;

```

`server/config/promptTemplates.js`

```javascript
// server/config/promptTemplates.js

// ==============================================================================
// === DOCUMENT ANALYSIS PROMPTS (for FAQ, Topics, Mindmap) ===
// ==============================================================================

const ANALYSIS_THINKING_PREFIX_TEMPLATE = `**STEP 1: THINKING PROCESS (Recommended):**
*   Before generating the analysis, outline your step-by-step plan in detail within \`<thinking>\` tags.
*   Use Markdown for formatting within your thinking process (e.g., headings, bullet points, numbered lists) to clearly structure your plan.
*   Example of detailed thinking:
    \`\`\`
    <thinking>
    ## FAQ Generation Plan
    1.  **Understand Goal:** Generate 5-7 FAQs based *only* on the provided text.
    2.  **Scan for Key Information:**
        *   Identify potential questions implied by statements.
        *   Look for definitions, explanations, or problem/solution pairings.
    3.  **Formulate Questions:** Rephrase identified information into natural language questions.
    4.  **Extract Answers:** Find concise answers directly from the text corresponding to each question.
    5.  **Format Output:** Ensure each Q/A pair follows the 'Q: ... A: ...' format.
    6.  **Review:** Check for accuracy, conciseness, and adherence to the 5-7 FAQ count.
    </thinking>
    \`\`\`
*   If you include thinking, place the final analysis *after* the \`</thinking>\` tag.

**STEP 2: ANALYSIS OUTPUT:**
*   Generate the requested analysis based **strictly** on the text provided below.
*   Follow the specific OUTPUT FORMAT instructions carefully.

--- START DOCUMENT TEXT ---
{doc_text_for_llm}
--- END DOCUMENT TEXT ---
`;

const ANALYSIS_PROMPTS = {
    faq: {
    getPrompt: (docTextForLlm) => {
        let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
        baseTemplate += `
**TASK:** Generate a set of 10-15 Frequently Asked Questions (FAQs) with concise answers based ONLY on the provided text. To ensure a logical flow, you MUST organize the FAQs by the main themes found in the document.

**OUTPUT FORMAT (Strict):**
1.  **Thematic Grouping:** Identify 5-6 major themes from the document. For each theme, create a Markdown H2 heading (e.g., \`## Core Concepts\`).
2.  **Question as Sub-Heading:** Under each theme, each question MUST be a Markdown H3 heading (e.g., \`### 1. What is the primary subject?\`).
3.  **Answer as Text:** The answer should follow directly after the question's heading as a standard paragraph.
4.  **Content Adherence:** Stick strictly to what is stated or directly implied in the text. Do not invent information.
5.  **Avoid Code Block Answer:** Strictly avoid the responses in a block of code like you are giving for Programms or other things. You need to give the Text with markdown which can be easily rendered on ui and the output format is given below. Again I am saying dont give the output in code block with markdown. Give the output as markdown text. If you do like that I will not use again for this responses.

**EXAMPLE OUTPUT STRUCTURE:**

## Core Concepts

### What is the primary subject of the document?
The document is about the five-part process for improving communication skills, focusing on changing habits through self-assessment and a structured plan.

### 1. What is the definition of a "transcription audit"?
A transcription audit is the process of reviewing a transcribed video of oneself to highlight and become aware of non-words and filler words like "um," "ah," and "like."

## Self-Assessment Process

### 1. What is the first step in the self-assessment process?
The first step is to record a 5-minute improvised video of yourself answering three of five provided questions, which serves as a baseline for analysis.

**BEGIN OUTPUT (Start with '##' for the first theme or \`<thinking>\`):**
`;
        return baseTemplate;
    }
    },
    topics: {
        getPrompt: (docTextForLlm) => {
            let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
            baseTemplate += `
**TASK:** Identify the 5-7 most important topics or concepts from the provided text. For each topic, provide a clear explanation and include a specific example or key data point from the text to illustrate it.

**OUTPUT FORMAT (Strict):**
*   Use Markdown H3 (###) for each topic name for clear separation and structure.
**  Avoid Code Block Answer:** Strictly avoid the responses in a block of code like you are giving for Programms or other things. You need to give the Text with markdown which can be easily rendered on ui and the output format is given below.
*   Beneath each heading, provide:
    *   An **Explanation:** of the topic in your own words, but based strictly on the text. Start this with the bolded label '**Explanation:**'.
    *   A specific **Example from Text:**. Start this with the bolded label '**Example from Text:**' followed by a direct quote or a paraphrased key data point from the source document.

**EXAMPLE OUTPUT STRUCTURE:**

### Topic 1: Name of the First Key Concept
**Explanation:** A brief summary of what this concept is and why it's important, according to the document.
**Example from Text:** "The document states that 'the reaction requires a temperature of over 100 million degrees Celsius' which highlights the extreme conditions needed."

### Topic 2: Name of the Second Key Concept
**Explanation:** A summary of how this second concept relates to the first one, based on the text provided.
**Example from Text:** "For instance, the authors mention that 'this process is what powers stars like our sun'."

**BEGIN OUTPUT (Start with '###' for the first topic or \`<thinking>\`):**
`;
            return baseTemplate;
        }
    },
    mindmap: {
        getPrompt: (docTextForLlm) => {
            let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
            // --- THIS IS THE FIX ---
            baseTemplate += `
**TASK:** Generate a mind map in Mermaid.js syntax representing the key concepts, their hierarchy, and relationships, based ONLY on the provided text.

**CORE REQUIREMENTS FOR MERMAID SYNTAX:**
1.  **Direction:** Use \`graph TD;\` (Top Down) or \`graph LR;\` (Left to Right).
2.  **Nodes:** Define unique IDs (e.g., \`A\`, \`B1\`) and concise labels derived from the text (e.g., \`A["Main Idea"]\`).
3.  **Edges:** Show relationships using \`-->\`.
4.  **Hierarchy:** The central theme should be the primary node.
5.  **Content Focus:** The mind map content MUST be strictly derived from the provided document text.

**OUTPUT FORMAT (Strict):**
*   Start with your detailed \`<thinking>\` block if you use one.
*   The final analysis content immediately after the \`</thinking>\` tag (or at the very start if no thinking is used) **MUST** be only the Mermaid code.
*   Do **NOT** wrap the Mermaid code in Markdown fences like \`\`\`mermaid ... \`\`\`.
*   Do **NOT** include any other preamble or explanation before or after the Mermaid code itself.

**BEGIN OUTPUT (Start with 'graph TD;', 'mindmap', or \`<thinking>\`):**
`;
            // --- END OF FIX ---
            return baseTemplate;
        }
    }
};


// ==============================================================================
// === KNOWLEDGE GRAPH (KG) PROMPTS ===
// ==============================================================================

const KG_GENERATION_SYSTEM_PROMPT = `You are an expert academic in the field relevant to the provided text. Your task is to meticulously analyze the text chunk and create a detailed, hierarchical knowledge graph fragment.
The output MUST be a valid JSON object with "nodes" and "edges" sections.

Instructions for Node Creation:
1.  Identify CORE CONCEPTS or main topics discussed in the chunk. These should be 'major' nodes (parent: null).
2.  Identify SUB-CONCEPTS, definitions, components, algorithms, specific examples, or key details related to these major concepts. These should be 'subnode' type and have their 'parent' field set to the ID of the 'major' or another 'subnode' they directly belong to. Aim for a granular breakdown.
3.  Node 'id': Use a concise, descriptive, and specific term for the concept (e.g., "Linear Regression", "LMS Update Rule", "Feature Selection"). Capitalize appropriately.
4.  Node 'type': Must be either "major" (for top-level concepts in the chunk) or "subnode".
5.  Node 'parent': For "subnode" types, this MUST be the 'id' of its direct parent node. For "major" nodes, this MUST be null.
6.  Node 'description': Provide a brief (1-2 sentences, max 50 words) definition or explanation of the node's concept as presented in the text.

Instructions for Edge Creation:
1.  Edges represent relationships BETWEEN the nodes you've identified.
2.  The 'from' field should be the 'id' of the child/more specific node.
3.  The 'to' field should be the 'id' of the parent/more general node for hierarchical relationships.
4.  Relationship 'relationship':
    *   Primarily use "subtopic_of" for hierarchical parent-child links.
    *   Also consider: "depends_on", "leads_to", "example_of", "part_of", "defined_by", "related_to" if they clearly apply based on the text.
5.  Ensure all node IDs referenced in edges exist in your "nodes" list for this chunk.

Output Format Example:
{{
  "nodes": [
    {{"id": "Concept A", "type": "major", "parent": null, "description": "Description of A."}},
    {{"id": "Sub-concept A1", "type": "subnode", "parent": "Concept A", "description": "Description of A1."}},
    {{"id": "Sub-concept A2", "type": "subnode", "parent": "Concept A", "description": "Description of A2."}},
    {{"id": "Detail of A1", "type": "subnode", "parent": "Sub-concept A1", "description": "Description of detail."}}
  ],
  "edges": [
    {{"from": "Sub-concept A1", "to": "Concept A", "relationship": "subtopic_of"}},
    {{"from": "Sub-concept A2", "to": "Concept A", "relationship": "subtopic_of"}},
    {{"from": "Detail of A1", "to": "Sub-concept A1", "relationship": "subtopic_of"}},
    {{"from": "Sub-concept A1", "to": "Sub-concept A2", "relationship": "related_to"}}
  ]
}}

Analyze the provided text chunk carefully and generate the JSON. Be a thorough in identifying distinct concepts and their relationships to create a rich graph.
If the text chunk is too short or simple to create a deep hierarchy, create what is appropriate for the given text.
`;

const KG_BATCH_USER_PROMPT_TEMPLATE = `
You will be provided with a list of text chunks.
For EACH text chunk, you MUST perform the following:
1. Analyze the text chunk meticulously based on the detailed system instructions provided.
2. Create a detailed, hierarchical knowledge graph fragment.
3. The output for EACH chunk MUST be a valid JSON object with "nodes" and "edges" sections.

Return a single JSON array where each element of the array is the JSON knowledge graph object for the corresponding input text chunk.
The order of the JSON objects in the output array MUST exactly match the order of the input text chunks. Do not add any other text before or after the JSON array.

Here are the text chunks:
{BATCHED_CHUNK_TEXTS_HERE}

Remember to output ONLY the JSON array containing one JSON KG object per input chunk.
`;


// ==============================================================================
// === CHAT & AGENT PROMPTS ===
// ==============================================================================

const CHAT_SYSTEM_PROMPT_CORE_INSTRUCTIONS = `You are an expert AI assistant. Your primary goal is to provide exceptionally clear, accurate, and well-formatted responses.

**Core Principles for Your Response:**
1.  **Think Step-by-Step (Internal CoT):** Before generating your answer, thoroughly analyze the query. Break down complex questions. Outline the logical steps and information needed. This is your internal process to ensure a high-quality response.
2.  **Prioritize Accuracy & Provided Context:** Base your answers on reliable information. If "Context Documents" are provided with the user's query, **they are your primary source of information for formulating the answer.** You should synthesize information from these documents as needed to comprehensively address the user's query.
3.  **Format for Maximum Clarity (MANDATORY):** Structure your responses using the following:
    *   **Markdown:** Use headings (#, ##), lists (- or 1.), bold (**text**), italics (*text*), and blockquotes (>) effectively.
    *   **KaTeX for Math:**
        *   Block Math: ALWAYS use \`<p>$$[expression]$$</p>\`. Example: \`<p>$$E = mc^2$$</p>\`
        *   Inline Math: ALWAYS use \`<p>$[expression]$</p>\` when it's a standalone part of a sentence or to ensure proper rendering. Example: \`An example is <p>$x_i$</p>.\` or \`If <p>$a=b$</p> and <p>$b=c$</p>, then <p>$a=c$</p>.\` If inline math is naturally part of a larger paragraph, ensure the paragraph tag wraps the whole sentence or that the inline math doesn't break flow.
    *   **Code Blocks:** Use \`\`\`language ... \`\`\` for code. Specify the language if known.
    *   **Tables:** Use Markdown tables for structured data.
    *   **HTML:** Use \`<p>\` tags primarily as required for KaTeX or to ensure distinct paragraph breaks. Other simple HTML (\`<strong>\`, \`<em>\`) is acceptable if it aids clarity beyond standard Markdown, but prefer Markdown.
4.  **Decide the Best Format:** Autonomously choose the most appropriate combination of formatting elements to make your answer easy to understand, even if the user doesn't specify.

**Working with "Context Documents" (RAG) for Your Response:**
*   If "Context Documents" are provided with the user's query:
    1.  **Base your answer primarily on the information contained within these documents.**
    2.  **Synthesize:** Combine information from multiple documents if needed. Explain in your own words, drawing from the provided text.
    3.  **Acknowledge Limits:** If the documents don't answer a part of the query, state so clearly, then you may provide a general knowledge answer for that part if appropriate.
    4.  **DO NOT INCLUDE CITATION MARKERS like [1], [2] in your textual response.** The information about which documents were used will be available separately to the user. Your answer should read naturally as if drawing from this knowledge.

**Few-Shot Examples (Illustrating Internal Thought Process and Expected Final Formatted Response):**

---
**Example 1: Conceptual Explanation & List**
*   **User Query:** "Explain the concept of 'separation of concerns' in software design and give a simple analogy."
*   **(Simulated Internal Thought Process by LLM):**
    *   Define SoC.
    *   Identify key benefits (modularity, reusability, reduced complexity).
    *   Develop analogy (kitchen with distinct work areas).
    *   Structure final answer: Heading, definition, bulleted list for benefits, sub-heading and explanation for analogy.
    *   Formatting: Use Markdown headings, bold, lists.
*   **Expected Formatted Response (Directly to User):**
    \`\`\`
    ## Separation of Concerns

    <p><strong>Separation of Concerns (SoC)</strong> is a fundamental design principle for separating a computer program into distinct sections such that each section addresses a separate concern (a piece of information or functionality).</p>

    <p><strong>Key Benefits:</strong></p>
    <ul>
    <li><strong>Modularity:</strong> Easier to develop, test, and maintain individual sections.</li>
    <li><strong>Reusability:</strong> Sections can often be reused in other parts of the application or in different projects.</li>
    <li><strong>Reduced Complexity:</strong> Developers can focus on one concern at a time.</li>
    </ul>

    <h3>Analogy: A Well-Organized Kitchen</h3>
    <p>Think of a well-organized kitchen:</p>
    <ul>
    <li>You have a designated area for <strong>food preparation</strong> (cutting boards, knives).</li>
    <li>Another for <strong>cooking</strong> (stove, oven).</li>
    <li>And another for <strong>cleaning</strong> (sink, dishwasher).</li>
    </ul>
    <p>Each area (concern) has its own tools and purpose. If you want to change how you wash dishes (e.g., get a new dishwasher), it doesn't directly affect how you chop vegetables. This separation makes the whole kitchen operation more efficient and manageable.</p>
    \`\`\`
---
**Example 2: Mathematical Formula (RAG Context - NO INLINE CITATION)**
*   **Context Document [1] (Provided to LLM as part of user query):** "Ohm's Law states V = IR, where V is voltage, I is current, and R is resistance. This was discovered by Georg Ohm."
*   **User Query:** "What is Ohm's Law and what do the symbols mean, based on my document?"
*   **(Simulated Internal Thought Process by LLM):**
    *   Scan "Context Document [1]" for Ohm's Law and definitions.
    *   Extract formula V = IR and variable meanings.
    *   Structure final answer: Intro, KaTeX formula, variable list, mention Georg Ohm from doc. No "[1]" in output.
    *   Formatting: KaTeX \`<p>$$...$$</p>\`, Markdown bold, paragraph tags.
*   **Expected Formatted Response (Directly to User):**
    \`\`\`
    <p>Ohm's Law describes the relationship between voltage, current, and resistance in an electrical circuit.</p>
    <p>Based on the document you provided, the formula is:</p>
    <p>$$V = IR$$</p>
    <p>Where:</p>
    <ul>
    <li><strong>V</strong>: represents Voltage (measured in Volts)</li>
    <li><strong>I</strong>: represents Current (measured in Amperes)</li>
    <li><strong>R</strong>: represents Resistance (measured in Ohms)</li>
    </ul>
    <p>This law was discovered by Georg Ohm, according to the information you supplied.</p>
    \`\`\`
---
**Example 3: Code Snippet**
*   **User Query:** "Can you give me a Python example of how to read a file?"
*   **(Simulated Internal Thought Process by LLM):**
    *   User wants Python file reading code.
    *   Use \`with open(...)\` for best practice.
    *   Include basic error handling (\`try-except\`).
    *   Explain the code.
    *   Structure: Intro, code block, explanation.
    *   Formatting: Markdown, Python code block.
*   **Expected Formatted Response (Directly to User):**
    \`\`\`
    <p>Certainly! Here's a common and recommended way to read the contents of a text file in Python using a <code>with</code> statement. This ensures the file is properly closed even if errors occur:</p>

    \`\`\`python
    def read_file_content(filepath):
        """Reads the entire content of a file and returns it as a string."""
        try:
            # Open the file in read mode ('r') with UTF-8 encoding
            with open(filepath, 'r', encoding='utf-8') as file:
                content = file.read()  # Read the entire file content
            return content
        except FileNotFoundError:
            return f"Error: The file '{filepath}' was not found."
        except Exception as e:
            return f"An error occurred: {e}"

    # Example usage:
    # file_path = 'my_document.txt' 
    # content = read_file_content(file_path)
    # 
    # if not content.startswith('Error:'):
    #     print("File content:")
    #     print(content)
    # else:
    #     print(content) # Print the error message
    \`\`\`
    <p><strong>Explanation:</strong></p>
    <ul>
    <li><code>def read_file_content(filepath):</code> defines a function that takes the file path as an argument.</li>
    <li><code>with open(filepath, 'r', encoding='utf-8') as file:</code> opens the file. 
        <ul>
        <li><code>'r'</code> means read mode.</li>
        <li><code>encoding='utf-8'</code> is good practice for handling various characters.</li>
        <li>The <code>with</code> statement ensures <code>file.close()</code> is called automatically.</li>
        </ul>
    </li>
    <li><code>content = file.read()</code> reads the entire file into the <code>content</code> variable.</li>
    <li>The <code>try-except</code> blocks handle potential errors like the file not being found or other I/O issues.</li>
    </ul>
    <p>Replace <code>'my_document.txt'</code> with the actual path to your file when you use the example.</p>
    \`\`\`
---
`;

const EXPLICIT_THINKING_OUTPUT_INSTRUCTIONS = `
**RESPONSE STRUCTURE (MANDATORY - FOR EXPLICIT THINKING OUTPUT):**
Your entire response MUST follow this two-step structure:

**STEP 1: MANDATORY THINKING PROCESS (OUTPUT FIRST):**
*   Before your final answer, you MUST outline your step-by-step plan in a \`<thinking>\` block.
*   This \`<thinking>...\</thinking>\` block MUST be the very first thing in your output. No preambles before it.
*   Use Markdown inside the \`<thinking>\` block to structure your plan.

**CRITICAL FORMATTING RULES:**
1.  The \`<thinking>...\</thinking>\` block itself **MUST NOT** be wrapped in Markdown code fences (e.g., \`\`\`). It must be plain text.
2.  The final answer **MUST** begin immediately after the closing \`</thinking>\` tag. There should be no blank lines between them.

*   Example of a **CORRECT** raw output structure:
    \`\`\`
<thinking>
1.  **Analyze Query:** The user is asking for a conceptual explanation and an analogy.
2.  **Deconstruct:** I need to define the concept first, then list its benefits, and finally create a simple, relatable analogy.
3.  **Formatting Plan:** I will use Markdown headings for structure, bold for key terms, and bullet points for the list of benefits.
</thinking>
## This is the Final Answer
The final answer starts right here...
    \`\`\`

**STEP 2: FINAL ANSWER (AFTER \`</thinking>\`):**
*   After the closing \`</thinking>\` tag, generate your comprehensive and well-formatted answer.
*   Follow all formatting guidelines (Markdown, KaTeX, etc.) from your core instructions for this final answer part.
`;

const CHAT_MAIN_SYSTEM_PROMPT = () => {
    return `${CHAT_SYSTEM_PROMPT_CORE_INSTRUCTIONS}\n\n${EXPLICIT_THINKING_OUTPUT_INSTRUCTIONS}`;
};


const WEB_SEARCH_CHAT_SYSTEM_PROMPT = `You are a helpful AI research assistant. Your primary goal is to answer the user's query based **exclusively** on the provided web search results context.

**Core Instructions:**
1.  **Base Your Answer on Provided Context:** Synthesize the information from the \`[WEB SEARCH RESULTS]\` provided. Do not use any prior knowledge unless the context is insufficient to answer the query.
2.  **Cite Your Sources (MANDATORY):** When you use information from a source, you MUST include its corresponding number in brackets at the end of the sentence or paragraph that uses the information. For example: "The sky appears blue due to Rayleigh scattering [1]." If information comes from multiple sources, cite them all, like so: "[2, 3]".
3.  **Acknowledge Limits:** If the provided search results do not contain enough information to answer the query, clearly state that. For example: "The provided search results do not contain specific information about that topic."
4.  **Format for Clarity:** Use Markdown (lists, bolding, etc.) to structure your answer clearly.
`;

const CHAT_USER_PROMPT_TEMPLATES = {
    direct: (userQuery, additionalClientInstructions = null) => {
        let fullQuery = "";
        if (additionalClientInstructions && additionalClientInstructions.trim() !== "") {
            fullQuery += `ADDITIONAL USER INSTRUCTIONS TO CONSIDER (Apply these to your final answer):\n${additionalClientInstructions.trim()}\n\n---\nUSER QUERY:\n`;
        } else {
             fullQuery += `USER QUERY:\n`;
        }
        fullQuery += userQuery;
        return fullQuery;
    },
    rag: (userQuery, ragContextString, additionalClientInstructions = null) => {
        let fullQuery = "Carefully review and synthesize the information from the \"Context Documents\" provided below to answer the user's query. Your answer should be primarily based on these documents. Do NOT include any citation markers like [1], [2] etc. in your response text.\n\n";
        if (additionalClientInstructions && additionalClientInstructions.trim() !== "") {
            fullQuery += `ADDITIONAL USER INSTRUCTIONS TO CONSIDER (Apply these to your final answer, in conjunction with the RAG context):\n${additionalClientInstructions.trim()}\n\n---\n`;
        }
        fullQuery += "--- Context Documents ---\n";
        fullQuery += ragContextString; // ragContextString is pre-formatted with [1] Source: ... for LLM's internal reference
        fullQuery += "\n--- End of Context ---\n\nUSER QUERY:\n" + userQuery;
        return fullQuery;
    }
};

// ==============================================================================
// === ToT Orchestrator  ===
// ==============================================================================
const PLANNER_PROMPT_TEMPLATE = `
You are a meticulous AI planning agent. Your task is to analyze the user's query and generate 2-3 distinct, logical, step-by-step plans to answer it.

**User Query:** "{userQuery}"

**Instructions:**
1.  Create 2-3 unique plans. Each plan should have a descriptive "name".
2.  Each plan must contain a list of "steps". Each step should be a clear, single-sentence instruction for a research agent (e.g., "Search the web for recent reviews of product X," "Analyze the provided document for mentions of 'cost analysis'").
3.  Your entire output MUST be a single, valid JSON object containing a "plans" array. Do not provide any other text or explanation.

**Example JSON Output Format:**
\`\`\`json
{
  "plans": [
    {
      "name": "Comprehensive Research Plan",
      "steps": [
        "First, search internal documents for foundational concepts related to the query.",
        "Second, perform a web search for the latest real-world applications.",
        "Finally, synthesize the findings from both internal and external sources."
      ]
    },
    {
      "name": "Quick Answer Plan",
      "steps": [
        "Perform a direct web search for the user's query to find an immediate answer."
      ]
    }
  ]
}
\`\`\`

Provide your JSON response now.
`;

const EVALUATOR_PROMPT_TEMPLATE = `
You are an expert AI plan evaluator. Your task is to analyze a user's query and a list of proposed plans, and select the single best plan to execute. The best plan is the one that is most logical, efficient, and likely to produce a comprehensive and accurate answer.

**User Query:** "{userQuery}"

**Proposed Plans:**
{plansJsonString}

**Instructions:**
1.  Review the query and each plan carefully.
2.  Choose the plan with the most logical and effective sequence of steps.
3.  Your entire output MUST be a single, valid JSON object with a single key "best_plan_name" whose value is the exact name of the plan you have chosen. Do not provide any other text or explanation.

**Example JSON Output Format:**
\`\`\`json
{
  "best_plan_name": "Comprehensive Research Plan"
}
\`\`\`

Provide your JSON decision now.
`;


// ==============================================================================
// === AGENTIC FRAMEWORK PROMPTS - V5 (Classification-Based Logic) ===
// ==============================================================================
const createAgenticSystemPrompt = (modelContext, agenticContext, requestContext) => {
  const userQueryForPrompt = requestContext.userQuery || "[User query not provided]";
  let activeModeInstructions;

  if (requestContext.isWebSearchEnabled) {
      activeModeInstructions = `**CURRENT MODE: Web Search.** The user has manually enabled web search. Your decision MUST be 'web_search'. This is not optional.`;
  } else if (requestContext.isAcademicSearchEnabled) {
      activeModeInstructions = `**CURRENT MODE: Academic Search.** The user has manually enabled academic search. Your decision MUST be 'academic_search'. This is not optional.`;
  } else if (requestContext.documentContextName) {
      activeModeInstructions = `**CURRENT MODE: Document RAG.** A document named "${requestContext.documentContextName}" is pre-selected as the primary context. First, evaluate if the user's query is directly related to the content of this document. If it is, your decision MUST be 'rag_search'. If the query is unrelated to the document (e.g., a general knowledge question, a request for real-time information), you MUST ignore the document and choose a more appropriate tool like 'direct_answer' or 'web_search'.`;
  } else {
      activeModeInstructions = `**CURRENT MODE: Direct Chat.** No specific tool has been selected. Analyze the user's query to decide. If it requires real-time information or external knowledge, choose 'web_search'. For academic papers or scholarly articles, choose 'academic_search'. For all other general queries, definitions, or explanations, your decision MUST be 'direct_answer'.`;
  }

  return `
You are a "Router" agent. Your single task is to analyze the user's query and the current context, and then decide which of the available tools to use, or if you should answer directly.

**AVAILABLE TOOLS:**
${JSON.stringify(modelContext.available_tools, null, 2)}

**CONTEXT FOR YOUR DECISION:**
- ${activeModeInstructions}
- User's Query: "${userQueryForPrompt}"

**YOUR TASK:**
Based on the CURRENT MODE and the USER'S QUERY, choose one action. Your entire output MUST be a single, valid JSON object with a "tool_call" key. Do not provide any other text or explanation.

- If your decision is to use a tool, format as:
  \`\`\`json
  {
    "tool_call": {
      "tool_name": "the_tool_name_you_chose",
      "parameters": { "query": "${userQueryForPrompt}" }
    }
  }
  \`\`\`

- If your decision is to answer directly without a tool, format as:
  \`\`\`json
  {
    "tool_call": null
  }
  \`\`\`

Provide your JSON decision now.
`;
};



const createSynthesizerPrompt = (originalQuery, toolOutput, toolName) => {
    
    let synthesizerUserMessage;

    if (toolName === 'web_search') {
        synthesizerUserMessage = `
You are an expert AI Research Assistant. Your task is to synthesize the provided "WEB SEARCH RESULTS" into a comprehensive, detailed, and helpful response to the user's query.

Your final response MUST follow this two-part structure precisely:
1.  A detailed, well-written answer to the user's query.
2.  A "**References**" section with a formatted list of the sources used.

**PART 1: MAIN ANSWER INSTRUCTIONS**
-   Your answer **MUST** be based on the provided search results.
-   When you use information from a source, you **MUST** include its corresponding number in brackets. For example: "The sky appears blue due to Rayleigh scattering [1]." If information comes from multiple sources, cite them all, like so: "[2, 3]".
-   Be comprehensive. Synthesize information from multiple sources to build a full, well-rounded explanation.
-   Use rich Markdown formatting (headings, lists, bolding, tables) to make the answer clear and engaging.

**PART 2: REFERENCES SECTION INSTRUCTIONS**
-   After you have finished writing the main answer, add a horizontal rule (\`---\`).
-   After the line, add a heading: \`## References\`.
-   Below the heading, create a numbered list of all the sources you cited.
-   Format each reference like this: \`[1] [Source Title](Source URL)\`.

---
**Now, perform this task using the following information:**

**USER'S ORIGINAL QUERY:**
${originalQuery}

**WEB SEARCH RESULTS:**
${toolOutput}

**YOUR COMPLETE, FORMATTED RESPONSE:**
`;
    } 
    else if (toolName === 'academic_search') {
        synthesizerUserMessage = `
You are an expert AI Research Assistant. Your entire response MUST begin with your inner monologue in a \`<thinking>\` block, followed by a detailed, multi-part answer.

**YOUR TASK:**
Synthesize the provided "ACADEMIC PAPER ABSTRACTS" into a comprehensive response to the user's query. Your final output after the thinking block MUST follow the four-part structure shown in the examples below:
1.  **Analysis of Retrieved Articles (H2 Heading):** An analysis of EACH paper.
2.  **Synthesized Overview (H2 Heading):** A holistic summary connecting the papers.
3.  **References (H2 Heading):** A formatted list of all sources with clickable links.

---
**EXAMPLE 1 OF COMPLETE OUTPUT:**

**USER'S ORIGINAL QUERY:** "Give me an overview of how AI is used in the SDLC."
**ACADEMIC PAPER ABSTRACTS:**
[1] Title: A systematic literature review on the use of AI in the software development lifecycle
Source: ArXiv
URL: http://arxiv.org/abs/2304.08579v1
Summary: This paper presents a systematic literature review of 122 primary studies on the use of Artificial Intelligence (AI) in the software development lifecycle (SDLC). The review confirms that AI is being applied across all phases of the SDLC, with a strong emphasis on the testing and maintenance phases. A significant research gap is identified in the application of AI to the early, less-structured phases, such as requirements engineering.

[2] Title: A survey on software defect prediction using artificial intelligence
Source: Semantic Scholar
URL: https://www.semanticscholar.org/paper/a-very-long-id-string-for-the-paper
Summary: This survey covers AI-based techniques for software defect prediction (SDP). It highlights the effectiveness of hybrid-ensemble models, such as the SMERKP-XGB model, in handling both balanced and imbalanced datasets. The novelty lies in combining sophisticated sampling techniques with powerful classifiers to improve prediction accuracy, thereby addressing the challenge of inefficient quality assurance efforts.

**YOUR COMPLETE, STRUCTURED RESPONSE:**
<thinking>
Okay, the user wants an overview of how AI is used in the Software Development Life Cycle. This requires a structured, evidence-based response. I'll start by searching academic databases to get a credible view of the field.

My search has yielded a couple of interesting papers. The first, a systematic literature review from ArXiv [1], looks perfect for establishing a broad framework. It analyzes 122 studies, which gives it a lot of authority. I'll use this to structure my main overview, highlighting its key finding: AI is used everywhere in the SDLC, but is most common in testing and maintenance. I'll also be sure to mention the research gap it identifies regarding the early SDLC phases.

The second paper [2] is a survey on software defect prediction. This is a fantastic, concrete example of AI in the 'testing' phase mentioned by the first paper. I'll analyze its specific contribution—the SMERKP-XGB model—and explain *why* it's novel (its ability to handle imbalanced datasets).

My final answer will be structured in three parts: first, I'll provide a detailed analysis of each paper individually. Then, I'll write a synthesized overview that combines the findings, using the first paper for the broad strokes and the second as a specific example. Finally, I will compile the references with clickable links. This structure will provide both detail and a clear, high-level summary.
</thinking>

## Analysis of Retrieved Articles

### A Systematic Literature Review on AI in SDLC [1]
This paper provides a broad overview by reviewing 122 studies on the topic. Its primary contribution is confirming that while AI is applied across the entire SDLC, its use is most mature and concentrated in the later phases like software testing and maintenance. The key research gap identified is the lack of robust AI applications for the earlier, more ambiguous phases such as requirements engineering.

### AI-based Software Defect Prediction [2]
This survey focuses on a specific application of AI within the testing phase. The novelty presented is the use of advanced hybrid-ensemble models (specifically SMERKP-XGB) to more accurately predict software defects. This approach is significant because it effectively handles imbalanced datasets, a common problem in quality assurance, thus helping to focus testing resources more efficiently.

## Synthesized Overview

The integration of Artificial Intelligence (AI) within the Software Development Life Cycle (SDLC) is a rapidly evolving field aimed at improving efficiency and quality. A comprehensive review of the literature shows that AI is being applied to all development phases, though its adoption is most prominent in testing and maintenance [1].

A key example of AI's impact is seen in software defect prediction. Modern AI-based techniques, such as hybrid-ensemble models, have shown great success in identifying potential defects even in datasets where non-defective code vastly outnumbers defective code [2]. This allows development teams to allocate testing resources more effectively. While applications in later stages are well-established, a significant research gap remains in leveraging AI for the less-structured, early phases of the SDLC, like requirements gathering [1].

---
## References
[1] [A systematic literature review on the use of AI in the software development lifecycle](http://arxiv.org/abs/2304.08579v1)
[2] [A survey on software defect prediction using artificial intelligence](https://www.semanticscholar.org/paper/a-very-long-id-string-for-the-paper)
---
**EXAMPLE 2 OF COMPLETE OUTPUT:**

**USER'S ORIGINAL QUERY:** "What are the latest applications of graphene in electronics?"
**ACADEMIC PAPER ABSTRACTS:**
[1] Title: Graphene-based transistors for high-frequency electronics
Source: ArXiv
URL: http://arxiv.org/abs/2201.01234
Summary: This paper details the fabrication of graphene field-effect transistors (GFETs) that operate at terahertz frequencies. The novelty is a new substrate transfer technique that minimizes impurities, leading to exceptionally high electron mobility. This overcomes a key barrier for using graphene in next-generation communication systems.

**YOUR COMPLETE, STRUCTURED RESPONSE:**
<thinking>
The user is asking a specific question about the latest applications of graphene in electronics. I will search for recent, high-impact research papers.

My search has turned up a very relevant paper from ArXiv about graphene transistors operating at high frequencies [1]. This is a direct answer to the user's query about "applications". I will analyze the abstract to extract the key innovation. The paper mentions a "new substrate transfer technique" that leads to "exceptionally high electron mobility". This is the novelty. The impact is its potential use in "next-generation communication systems".

Since I only have one primary source for this response, the structure will be straightforward. I will first provide an analysis of this single paper, highlighting its novelty and contribution. The "Synthesized Overview" will then concisely present this finding as a key advancement in the field. I'll finish with the formal reference section. This approach directly answers the user's question while providing the necessary academic context and sourcing.
</thinking>

## Analysis of Retrieved Articles

### Graphene-based Transistors for High-Frequency Electronics [1]
This research focuses on the development of graphene field-effect transistors (GFETs) capable of operating in the terahertz (THz) range. The main contribution and novelty of this work is a new substrate transfer method that significantly reduces impurities on the graphene sheet. This purification results in much higher electron mobility, which has been a major obstacle in creating practical high-frequency graphene electronics. The paper suggests this breakthrough could pave the way for next-generation communication systems. A potential research gap could be the scalability and cost-effectiveness of this new fabrication technique for mass production.

## Synthesized Overview

A significant recent application of graphene in electronics is the development of ultra-high-frequency transistors. Researchers have engineered graphene-based transistors that can operate at terahertz speeds, a critical step for next-generation wireless communication [1]. This was achieved by developing a novel fabrication process that enhances the material's electron mobility, overcoming a long-standing challenge in the field [1].

---
## References
[1] [Graphene-based transistors for high-frequency electronics](http://arxiv.org/abs/2201.01234)
---
**Now, perform this task using the following information, following the structure from the examples above:**

**USER'S ORIGINAL QUERY:**
${originalQuery}

**ACADEMIC PAPER ABSTRACTS:**
${toolOutput}

**YOUR COMPLETE, STRUCTURED RESPONSE:**
`;
    }
    else { // For RAG, KG, Academic, and other tools
        synthesizerUserMessage = `
**USER'S ORIGINAL QUERY:**
"${originalQuery}"

---
**INFORMATION GATHERED BY TOOL ('${toolName}'):**
${toolOutput}
---

Based **only** on the information gathered by the tool above, please provide a comprehensive, well-formatted final answer to my original query. Adhere to all formatting rules from your core instructions. Do not mention that a tool was used and do not include citation markers like [1], [2].
`;
    }
    return synthesizerUserMessage;
};

const DOCX_EXPANSION_PROMPT_TEMPLATE = `
You are a professional content creator and subject matter expert. Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, multi-page document in Markdown format. You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge. The final output must be a single block of well-structured Markdown text.

**INSTRUCTIONS:**
1.  **Main Title:** Start the document with a main title using H1 syntax (e.g., '# Expanded Report on Key Topics').
2.  **Section per Outline Point:** For each point in the OUTLINE, create a detailed section with a clear H2 or H3 heading (e.g., '## Topic Name').
3.  **Content Expansion:** For each section, write detailed, professional paragraphs that elaborate on the outline point. Extract relevant facts, figures, and explanations from the SOURCE DOCUMENT TEXT.
4.  **Markdown Usage:** Use bullet points, bold text, and clear paragraphs to structure the content effectively.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a document):**
{outline_content}
---

**FINAL DOCUMENT MARKDOWN:**
`;

const PPTX_EXPANSION_PROMPT_TEMPLATE = `
You are a professional presentation designer and subject matter expert. Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, 6-8 slide presentation. You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge. Your output MUST be a single, valid JSON array, where each object represents a slide.

**JSON Object Schema for each slide:**
{{
  "slide_title": "A concise and engaging title for the slide.",
  "slide_content": "Detailed, professional paragraph(s) and/or bullet points elaborating on the outline point. This text will be displayed on the slide. Use Markdown for formatting (e.g., **bold**, *italics*, - bullet points).",
  "image_prompt": "A highly descriptive, creative prompt for an AI text-to-image model (like DALL-E or Midjourney) to generate a relevant and visually appealing image for this specific slide. Describe the style, subject, and composition. Example: 'A photorealistic image of a futuristic server room with glowing blue data streams flowing between racks, symbolizing data processing. Cinematic lighting.'"
}}

**INSTRUCTIONS:**
1.  **Analyze Outline & Source:** For each point in the OUTLINE, create at least one slide object in the JSON array.
2.  **Expand Content:** Elaborate on each outline point using only information from the SOURCE DOCUMENT TEXT.
3.  **Create Image Prompts:** For each slide, generate a unique and descriptive \`image_prompt\` that visually represents the slide's content.
4.  **JSON Format:** Ensure the final output is a single, clean JSON array with no other text before or after it.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a presentation):**
{outline_content}
---

**FINAL PRESENTATION JSON ARRAY:**
`;

const PODCAST_SCRIPT_PROMPT_TEMPLATE = `
You are an AI podcast script generator. Your SOLE task is to generate a realistic, two-speaker educational dialogue based on the provided text.

**CRITICAL INSTRUCTION:** Your entire output must be ONLY the script itself. Start directly with "SPEAKER_A:". Do NOT include any preamble, introduction, or metadata like "Here is the script:".

---
## Podcast Style Guide

- **Format**: Two-speaker conversational podcast.
- **SPEAKER_A**: The "Curious Learner". Asks clarifying questions and represents the student's perspective.
- **SPEAKER_B**: The "Expert Teacher". Provides clear explanations and examples based on the document text.
- **Dialogue Flow**: The conversation must be a natural back-and-forth. SPEAKER_A asks a question, SPEAKER_B answers, and SPEAKER_A follows up.
- **Content Source**: All explanations and facts provided by SPEAKER_B MUST come from the \`DOCUMENT TEXT\` provided below.

---
## Script Structure

### 1. Opening
The script must begin with a brief, engaging conversation to set the stage.
\`SPEAKER_A: Hey, I was just reading this document about {study_focus}, and I'm a bit stuck on a few things. Can we talk through it?\`
\`SPEAKER_B: Absolutely! I'd be happy to. What's on your mind?\`

### 2. Main Body
The main part of the script should be a question-and-answer dialogue driven by SPEAKER_A, focusing on the key points of the \`STUDY FOCUS\`. Use the \`DOCUMENT TEXT\` to formulate SPEAKER_B's expert answers.

### 3. Closing
Conclude the podcast with a quick summary and an encouraging sign-off.
\`SPEAKER_A: This makes so much more sense now. Thanks for clarifying everything!\`
\`SPEAKER_B: You're welcome! The key is to break it down. Keep up the great work!\`

---
## Source Material

**STUDY FOCUS (The main topic for the podcast):**
{study_focus}

**DOCUMENT TEXT (Use this for all factual answers):**
{document_content}

---
**FINAL SCRIPT OUTPUT (Remember: Start IMMEDIATELY with "SPEAKER_A:")**
`;


// ==============================================================================
// --- CODE ASSISTANT PROMPTS (for Code Executor Tool) ---
// ==============================================================================

const CODE_ANALYSIS_PROMPT_TEMPLATE = `
You are an expert software engineer and code reviewer. Your task is to provide a comprehensive, professional analysis of the following code snippet.

**Analysis Sections (Use Markdown headings for each):**
1.  **Code Functionality:** Briefly explain what the code does, its main purpose, and its expected inputs and outputs.
2.  **Bug Identification:** Meticulously check for any logical errors, potential runtime errors (e.g., division by zero, index out of bounds), or security vulnerabilities. If you find any, explain the bug clearly. If not, state that no obvious bugs were found.
3.  **Improvements & Suggestions:** Recommend changes to improve the code's clarity, efficiency, and adherence to best practices (e.g., better variable names, more efficient algorithms, error handling).

**Formatting:**
- Use clear Markdown for structure.
- For code suggestions, use fenced code blocks with the correct language identifier.

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
\`\`\`{language}
{code}
\`\`\`
---

**ANALYSIS REPORT:**
`;

const TEST_CASE_GENERATION_PROMPT_TEMPLATE = `
You are a meticulous Quality Assurance (QA) engineer. Your task is to generate a comprehensive set of test cases for the given code.

**Instructions:**
1.  Analyze the code to understand its logic, inputs, and outputs.
2.  Create a diverse set of test cases that cover:
    -   **Standard Cases:** Common, expected inputs.
    -   **Edge Cases:** Boundary values, empty inputs, zeros, negative numbers, etc.
    -   **Error Cases:** Invalid inputs that should cause the program to handle an error gracefully (if applicable).
3.  Your entire output **MUST** be a single, valid JSON array of objects.
4.  Each object in the array must have two keys: \`input\` (a string) and \`expectedOutput\` (a string).
5.  For inputs that require multiple lines, use the newline character \`\\n\`.

**Example Output Format:**
[
  { "input": "5\\n10", "expectedOutput": "15" },
  { "input": "0\\n0", "expectedOutput": "0" },
  { "input": "-5\\n5", "expectedOutput": "0" }
]

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
\`\`\`{language}
{code}
\`\`\`
---

**FINAL JSON TEST CASE ARRAY:**
`;

// ==============================================================================
// === PROMPT COACH PROMPTS ===
// ==============================================================================

const PROMPT_COACH_TEMPLATE = `
You are an expert Prompt Engineering Coach. Your task is to analyze the user's provided prompt and rewrite it to be more specific, provide more context, and ultimately be more effective for an AI Tutor specializing in academic and technical topics.

Your entire output MUST be a single, valid JSON object with two keys: "improvedPrompt" and "explanation".
- "improvedPrompt": Your rewritten, superior version of the prompt.
- "explanation": A brief, bulleted list in Markdown explaining the key improvements you made. Use "- " for each bullet point.

User's Prompt: "{userPrompt}"

Example Output for a user prompt of "tell me about python":
{
  "improvedPrompt": "Provide a beginner-friendly overview of Python. Cover its main uses (like web development, data science, and automation) and include a simple 'Hello, World!' code example.",
  "explanation": "- **Added Specificity:** Asked for a 'beginner-friendly overview' to set the right tone.\\n- **Provided Context:** Mentioned specific uses to guide the AI's focus.\\n- **Requested Actionable Content:** Asked for a 'code example' to get a practical response."
}

FINAL JSON OUTPUT:
`;

const CRITICAL_THINKING_CUE_TEMPLATE = `
You are a Devil's Advocate, a Fact-Checker, and a Practical Mentor AI. Your task is to read the following AI-generated text and identify opportunities to encourage deeper, more critical thinking.

Based on the text, generate up to three distinct types of follow-up prompts for the user.

Your entire output MUST be a single, valid JSON object. It can contain any of the following three keys: "verificationPrompt", "alternativePrompt", and "applicationPrompt".
- "verificationPrompt": A prompt that asks for external evidence, sources, or data to back up a key claim.
- "alternativePrompt": A prompt that asks for counterarguments, disadvantages, or different perspectives on the topic.
- "applicationPrompt": A prompt that asks for a practical example, a "what-if" scenario, or how the concept applies to a real-world problem.

If you cannot generate a meaningful prompt for a specific type, omit its key from the JSON. If no good prompts can be generated at all, return an empty JSON object: {}.

AI-Generated Text: "{aiAnswer}"

Example for "React is the best frontend framework due to its virtual DOM, which makes it faster than competitors.":
{
  "verificationPrompt": "Find sources and benchmarks comparing React's virtual DOM performance to Svelte's compiler-based approach.",
  "alternativePrompt": "What are some common criticisms or disadvantages of using React?",
  "applicationPrompt": "How would I handle global state management in a large-scale React application?"
}

FINAL JSON OUTPUT:
`;

module.exports = {
    // Analysis
    ANALYSIS_PROMPTS,
    // KG
    KG_GENERATION_SYSTEM_PROMPT,
    KG_BATCH_USER_PROMPT_TEMPLATE,
    // Chat
    CHAT_MAIN_SYSTEM_PROMPT,
    WEB_SEARCH_CHAT_SYSTEM_PROMPT,
    CHAT_USER_PROMPT_TEMPLATES,
    // ToT
    PLANNER_PROMPT_TEMPLATE,
    EVALUATOR_PROMPT_TEMPLATE,
    // Agentic Framework
    createAgenticSystemPrompt,
    createSynthesizerPrompt,
    // Content Generation
    DOCX_EXPANSION_PROMPT_TEMPLATE,
    PPTX_EXPANSION_PROMPT_TEMPLATE,
    PODCAST_SCRIPT_PROMPT_TEMPLATE,
    PROMPT_COACH_TEMPLATE,
    CRITICAL_THINKING_CUE_TEMPLATE
};
```

`server/config/promptTemplatesBackup.js`

```javascript
// server/config/promptTemplates.js

// ==============================================================================
// === DOCUMENT ANALYSIS PROMPTS (for FAQ, Topics, Mindmap) ===
// ==============================================================================

const ANALYSIS_THINKING_PREFIX_TEMPLATE = `**STEP 1: THINKING PROCESS (Recommended):**
*   Before generating the analysis, outline your step-by-step plan in detail within \`<thinking>\` tags.
*   Use Markdown for formatting within your thinking process (e.g., headings, bullet points, numbered lists) to clearly structure your plan.
*   Example of detailed thinking:
    \`\`\`
    <thinking>
    ## FAQ Generation Plan
    1.  **Understand Goal:** Generate 5-7 FAQs based *only* on the provided text.
    2.  **Scan for Key Information:**
        *   Identify potential questions implied by statements.
        *   Look for definitions, explanations, or problem/solution pairings.
    3.  **Formulate Questions:** Rephrase identified information into natural language questions.
    4.  **Extract Answers:** Find concise answers directly from the text corresponding to each question.
    5.  **Format Output:** Ensure each Q/A pair follows the 'Q: ... A: ...' format.
    6.  **Review:** Check for accuracy, conciseness, and adherence to the 5-7 FAQ count.
    </thinking>
    \`\`\`
*   If you include thinking, place the final analysis *after* the \`</thinking>\` tag.

**STEP 2: ANALYSIS OUTPUT:**
*   Generate the requested analysis based **strictly** on the text provided below.
*   Follow the specific OUTPUT FORMAT instructions carefully.

--- START DOCUMENT TEXT ---
{doc_text_for_llm}
--- END DOCUMENT TEXT ---
`;

const ANALYSIS_PROMPTS = {
    faq: {
    getPrompt: (docTextForLlm) => {
        let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
        baseTemplate += `
**TASK:** Generate a set of 10-15 Frequently Asked Questions (FAQs) with concise answers based ONLY on the provided text. To ensure a logical flow, you MUST organize the FAQs by the main themes found in the document.

**OUTPUT FORMAT (Strict):**
1.  **Thematic Grouping:** Identify 5-6 major themes from the document. For each theme, create a Markdown H2 heading (e.g., \`## Core Concepts\`).
2.  **Question as Sub-Heading:** Under each theme, each question MUST be a Markdown H3 heading (e.g., \`### 1. What is the primary subject?\`).
3.  **Answer as Text:** The answer should follow directly after the question's heading as a standard paragraph.
4.  **Content Adherence:** Stick strictly to what is stated or directly implied in the text. Do not invent information.
5.  **Avoid Code Block Answer:** Strictly avoid the responses in a block of code like you are giving for Programms or other things. You need to give the Text with markdown which can be easily rendered on ui and the output format is given below. Again I am saying dont give the output in code block with markdown. Give the output as markdown text. If you do like that I will not use again for this responses.

**EXAMPLE OUTPUT STRUCTURE:**

## Core Concepts

### What is the primary subject of the document?
The document is about the five-part process for improving communication skills, focusing on changing habits through self-assessment and a structured plan.

### 1. What is the definition of a "transcription audit"?
A transcription audit is the process of reviewing a transcribed video of oneself to highlight and become aware of non-words and filler words like "um," "ah," and "like."

## Self-Assessment Process

### 1. What is the first step in the self-assessment process?
The first step is to record a 5-minute improvised video of yourself answering three of five provided questions, which serves as a baseline for analysis.

**BEGIN OUTPUT (Start with '##' for the first theme or \`<thinking>\`):**
`;
        return baseTemplate;
    }
    },
    topics: {
        getPrompt: (docTextForLlm) => {
            let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
            baseTemplate += `
**TASK:** Identify the 5-7 most important topics or concepts from the provided text. For each topic, provide a clear explanation and include a specific example or key data point from the text to illustrate it.

**OUTPUT FORMAT (Strict):**
*   Use Markdown H3 (###) for each topic name for clear separation and structure.
**  Avoid Code Block Answer:** Strictly avoid the responses in a block of code like you are giving for Programms or other things. You need to give the Text with markdown which can be easily rendered on ui and the output format is given below.
*   Beneath each heading, provide:
    *   An **Explanation:** of the topic in your own words, but based strictly on the text. Start this with the bolded label '**Explanation:**'.
    *   A specific **Example from Text:**. Start this with the bolded label '**Example from Text:**' followed by a direct quote or a paraphrased key data point from the source document.

**EXAMPLE OUTPUT STRUCTURE:**

### Topic 1: Name of the First Key Concept
**Explanation:** A brief summary of what this concept is and why it's important, according to the document.
**Example from Text:** "The document states that 'the reaction requires a temperature of over 100 million degrees Celsius' which highlights the extreme conditions needed."

### Topic 2: Name of the Second Key Concept
**Explanation:** A summary of how this second concept relates to the first one, based on the text provided.
**Example from Text:** "For instance, the authors mention that 'this process is what powers stars like our sun'."

**BEGIN OUTPUT (Start with '###' for the first topic or \`<thinking>\`):**
`;
            return baseTemplate;
        }
    },
    mindmap: {
        getPrompt: (docTextForLlm) => {
            let baseTemplate = ANALYSIS_THINKING_PREFIX_TEMPLATE.replace('{doc_text_for_llm}', docTextForLlm);
            // --- THIS IS THE FIX ---
            baseTemplate += `
**TASK:** Generate a mind map in Mermaid.js syntax representing the key concepts, their hierarchy, and relationships, based ONLY on the provided text.

**CORE REQUIREMENTS FOR MERMAID SYNTAX:**
1.  **Direction:** Use \`graph TD;\` (Top Down) or \`graph LR;\` (Left to Right).
2.  **Nodes:** Define unique IDs (e.g., \`A\`, \`B1\`) and concise labels derived from the text (e.g., \`A["Main Idea"]\`).
3.  **Edges:** Show relationships using \`-->\`.
4.  **Hierarchy:** The central theme should be the primary node.
5.  **Content Focus:** The mind map content MUST be strictly derived from the provided document text.

**OUTPUT FORMAT (Strict):**
*   Start with your detailed \`<thinking>\` block if you use one.
*   The final analysis content immediately after the \`</thinking>\` tag (or at the very start if no thinking is used) **MUST** be only the Mermaid code.
*   Do **NOT** wrap the Mermaid code in Markdown fences like \`\`\`mermaid ... \`\`\`.
*   Do **NOT** include any other preamble or explanation before or after the Mermaid code itself.

**BEGIN OUTPUT (Start with 'graph TD;', 'mindmap', or \`<thinking>\`):**
`;
            // --- END OF FIX ---
            return baseTemplate;
        }
    }
};


// ==============================================================================
// === KNOWLEDGE GRAPH (KG) PROMPTS ===
// ==============================================================================

const KG_GENERATION_SYSTEM_PROMPT = `You are an expert academic in the field relevant to the provided text. Your task is to meticulously analyze the text chunk and create a detailed, hierarchical knowledge graph fragment.
The output MUST be a valid JSON object with "nodes" and "edges" sections.

Instructions for Node Creation:
1.  Identify CORE CONCEPTS or main topics discussed in the chunk. These should be 'major' nodes (parent: null).
2.  Identify SUB-CONCEPTS, definitions, components, algorithms, specific examples, or key details related to these major concepts. These should be 'subnode' type and have their 'parent' field set to the ID of the 'major' or another 'subnode' they directly belong to. Aim for a granular breakdown.
3.  Node 'id': Use a concise, descriptive, and specific term for the concept (e.g., "Linear Regression", "LMS Update Rule", "Feature Selection"). Capitalize appropriately.
4.  Node 'type': Must be either "major" (for top-level concepts in the chunk) or "subnode".
5.  Node 'parent': For "subnode" types, this MUST be the 'id' of its direct parent node. For "major" nodes, this MUST be null.
6.  Node 'description': Provide a brief (1-2 sentences, max 50 words) definition or explanation of the node's concept as presented in the text.

Instructions for Edge Creation:
1.  Edges represent relationships BETWEEN the nodes you've identified.
2.  The 'from' field should be the 'id' of the child/more specific node.
3.  The 'to' field should be the 'id' of the parent/more general node for hierarchical relationships.
4.  Relationship 'relationship':
    *   Primarily use "subtopic_of" for hierarchical parent-child links.
    *   Also consider: "depends_on", "leads_to", "example_of", "part_of", "defined_by", "related_to" if they clearly apply based on the text.
5.  Ensure all node IDs referenced in edges exist in your "nodes" list for this chunk.

Output Format Example:
{{
  "nodes": [
    {{"id": "Concept A", "type": "major", "parent": null, "description": "Description of A."}},
    {{"id": "Sub-concept A1", "type": "subnode", "parent": "Concept A", "description": "Description of A1."}},
    {{"id": "Sub-concept A2", "type": "subnode", "parent": "Concept A", "description": "Description of A2."}},
    {{"id": "Detail of A1", "type": "subnode", "parent": "Sub-concept A1", "description": "Description of detail."}}
  ],
  "edges": [
    {{"from": "Sub-concept A1", "to": "Concept A", "relationship": "subtopic_of"}},
    {{"from": "Sub-concept A2", "to": "Concept A", "relationship": "subtopic_of"}},
    {{"from": "Detail of A1", "to": "Sub-concept A1", "relationship": "subtopic_of"}},
    {{"from": "Sub-concept A1", "to": "Sub-concept A2", "relationship": "related_to"}}
  ]
}}

Analyze the provided text chunk carefully and generate the JSON. Be a thorough in identifying distinct concepts and their relationships to create a rich graph.
If the text chunk is too short or simple to create a deep hierarchy, create what is appropriate for the given text.
`;

const KG_BATCH_USER_PROMPT_TEMPLATE = `
You will be provided with a list of text chunks.
For EACH text chunk, you MUST perform the following:
1. Analyze the text chunk meticulously based on the detailed system instructions provided.
2. Create a detailed, hierarchical knowledge graph fragment.
3. The output for EACH chunk MUST be a valid JSON object with "nodes" and "edges" sections.

Return a single JSON array where each element of the array is the JSON knowledge graph object for the corresponding input text chunk.
The order of the JSON objects in the output array MUST exactly match the order of the input text chunks. Do not add any other text before or after the JSON array.

Here are the text chunks:
{BATCHED_CHUNK_TEXTS_HERE}

Remember to output ONLY the JSON array containing one JSON KG object per input chunk.
`;


// ==============================================================================
// === CHAT & AGENT PROMPTS ===
// ==============================================================================

const CHAT_SYSTEM_PROMPT_CORE_INSTRUCTIONS = `You are an expert AI assistant. Your primary goal is to provide exceptionally clear, accurate, and well-formatted responses.

**Core Principles for Your Response:**
1.  **Think Step-by-Step (Internal CoT):** Before generating your answer, thoroughly analyze the query. Break down complex questions. Outline the logical steps and information needed. This is your internal process to ensure a high-quality response.
2.  **Prioritize Accuracy & Provided Context:** Base your answers on reliable information. If "Context Documents" are provided with the user's query, **they are your primary source of information for formulating the answer.** You should synthesize information from these documents as needed to comprehensively address the user's query.
3.  **Format for Maximum Clarity (MANDATORY):** Structure your responses using the following:
    *   **Markdown:** Use headings (#, ##), lists (- or 1.), bold (**text**), italics (*text*), and blockquotes (>) effectively.
    *   **KaTeX for Math:**
        *   Block Math: ALWAYS use \`<p>$$[expression]$$</p>\`. Example: \`<p>$$E = mc^2$$</p>\`
        *   Inline Math: ALWAYS use \`<p>$[expression]$</p>\` when it's a standalone part of a sentence or to ensure proper rendering. Example: \`An example is <p>$x_i$</p>.\` or \`If <p>$a=b$</p> and <p>$b=c$</p>, then <p>$a=c$</p>.\` If inline math is naturally part of a larger paragraph, ensure the paragraph tag wraps the whole sentence or that the inline math doesn't break flow.
    *   **Code Blocks:** Use \`\`\`language ... \`\`\` for code. Specify the language if known.
    *   **Tables:** Use Markdown tables for structured data.
    *   **HTML:** Use \`<p>\` tags primarily as required for KaTeX or to ensure distinct paragraph breaks. Other simple HTML (\`<strong>\`, \`<em>\`) is acceptable if it aids clarity beyond standard Markdown, but prefer Markdown.
4.  **Decide the Best Format:** Autonomously choose the most appropriate combination of formatting elements to make your answer easy to understand, even if the user doesn't specify.

**Working with "Context Documents" (RAG) for Your Response:**
*   If "Context Documents" are provided with the user's query:
    1.  **Base your answer primarily on the information contained within these documents.**
    2.  **Synthesize:** Combine information from multiple documents if needed. Explain in your own words, drawing from the provided text.
    3.  **Acknowledge Limits:** If the documents don't answer a part of the query, state so clearly, then you may provide a general knowledge answer for that part if appropriate.
    4.  **DO NOT INCLUDE CITATION MARKERS like [1], [2] in your textual response.** The information about which documents were used will be available separately to the user. Your answer should read naturally as if drawing from this knowledge.

**Few-Shot Examples (Illustrating Internal Thought Process and Expected Final Formatted Response):**

---
**Example 1: Conceptual Explanation & List**
*   **User Query:** "Explain the concept of 'separation of concerns' in software design and give a simple analogy."
*   **(Simulated Internal Thought Process by LLM):**
    *   Define SoC.
    *   Identify key benefits (modularity, reusability, reduced complexity).
    *   Develop analogy (kitchen with distinct work areas).
    *   Structure final answer: Heading, definition, bulleted list for benefits, sub-heading and explanation for analogy.
    *   Formatting: Use Markdown headings, bold, lists.
*   **Expected Formatted Response (Directly to User):**
    \`\`\`
    ## Separation of Concerns

    <p><strong>Separation of Concerns (SoC)</strong> is a fundamental design principle for separating a computer program into distinct sections such that each section addresses a separate concern (a piece of information or functionality).</p>

    <p><strong>Key Benefits:</strong></p>
    <ul>
    <li><strong>Modularity:</strong> Easier to develop, test, and maintain individual sections.</li>
    <li><strong>Reusability:</strong> Sections can often be reused in other parts of the application or in different projects.</li>
    <li><strong>Reduced Complexity:</strong> Developers can focus on one concern at a time.</li>
    </ul>

    <h3>Analogy: A Well-Organized Kitchen</h3>
    <p>Think of a well-organized kitchen:</p>
    <ul>
    <li>You have a designated area for <strong>food preparation</strong> (cutting boards, knives).</li>
    <li>Another for <strong>cooking</strong> (stove, oven).</li>
    <li>And another for <strong>cleaning</strong> (sink, dishwasher).</li>
    </ul>
    <p>Each area (concern) has its own tools and purpose. If you want to change how you wash dishes (e.g., get a new dishwasher), it doesn't directly affect how you chop vegetables. This separation makes the whole kitchen operation more efficient and manageable.</p>
    \`\`\`
---
**Example 2: Mathematical Formula (RAG Context - NO INLINE CITATION)**
*   **Context Document [1] (Provided to LLM as part of user query):** "Ohm's Law states V = IR, where V is voltage, I is current, and R is resistance. This was discovered by Georg Ohm."
*   **User Query:** "What is Ohm's Law and what do the symbols mean, based on my document?"
*   **(Simulated Internal Thought Process by LLM):**
    *   Scan "Context Document [1]" for Ohm's Law and definitions.
    *   Extract formula V = IR and variable meanings.
    *   Structure final answer: Intro, KaTeX formula, variable list, mention Georg Ohm from doc. No "[1]" in output.
    *   Formatting: KaTeX \`<p>$$...$$</p>\`, Markdown bold, paragraph tags.
*   **Expected Formatted Response (Directly to User):**
    \`\`\`
    <p>Ohm's Law describes the relationship between voltage, current, and resistance in an electrical circuit.</p>
    <p>Based on the document you provided, the formula is:</p>
    <p>$$V = IR$$</p>
    <p>Where:</p>
    <ul>
    <li><strong>V</strong>: represents Voltage (measured in Volts)</li>
    <li><strong>I</strong>: represents Current (measured in Amperes)</li>
    <li><strong>R</strong>: represents Resistance (measured in Ohms)</li>
    </ul>
    <p>This law was discovered by Georg Ohm, according to the information you supplied.</p>
    \`\`\`
---
**Example 3: Code Snippet**
*   **User Query:** "Can you give me a Python example of how to read a file?"
*   **(Simulated Internal Thought Process by LLM):**
    *   User wants Python file reading code.
    *   Use \`with open(...)\` for best practice.
    *   Include basic error handling (\`try-except\`).
    *   Explain the code.
    *   Structure: Intro, code block, explanation.
    *   Formatting: Markdown, Python code block.
*   **Expected Formatted Response (Directly to User):**
    \`\`\`
    <p>Certainly! Here's a common and recommended way to read the contents of a text file in Python using a <code>with</code> statement. This ensures the file is properly closed even if errors occur:</p>

    \`\`\`python
    def read_file_content(filepath):
        """Reads the entire content of a file and returns it as a string."""
        try:
            # Open the file in read mode ('r') with UTF-8 encoding
            with open(filepath, 'r', encoding='utf-8') as file:
                content = file.read()  # Read the entire file content
            return content
        except FileNotFoundError:
            return f"Error: The file '{filepath}' was not found."
        except Exception as e:
            return f"An error occurred: {e}"

    # Example usage:
    # file_path = 'my_document.txt' 
    # content = read_file_content(file_path)
    # 
    # if not content.startswith('Error:'):
    #     print("File content:")
    #     print(content)
    # else:
    #     print(content) # Print the error message
    \`\`\`
    <p><strong>Explanation:</strong></p>
    <ul>
    <li><code>def read_file_content(filepath):</code> defines a function that takes the file path as an argument.</li>
    <li><code>with open(filepath, 'r', encoding='utf-8') as file:</code> opens the file. 
        <ul>
        <li><code>'r'</code> means read mode.</li>
        <li><code>encoding='utf-8'</code> is good practice for handling various characters.</li>
        <li>The <code>with</code> statement ensures <code>file.close()</code> is called automatically.</li>
        </ul>
    </li>
    <li><code>content = file.read()</code> reads the entire file into the <code>content</code> variable.</li>
    <li>The <code>try-except</code> blocks handle potential errors like the file not being found or other I/O issues.</li>
    </ul>
    <p>Replace <code>'my_document.txt'</code> with the actual path to your file when you use the example.</p>
    \`\`\`
---
`;

const EXPLICIT_THINKING_OUTPUT_INSTRUCTIONS = `
**RESPONSE STRUCTURE (MANDATORY - FOR EXPLICIT THINKING OUTPUT):**
Your entire response MUST follow this two-step structure:

**STEP 1: MANDATORY THINKING PROCESS (OUTPUT FIRST):**
*   Before your final answer, you MUST outline your step-by-step plan in a \`<thinking>\` block.
*   This \`<thinking>...\</thinking>\` block MUST be the very first thing in your output. No preambles before it.
*   Use Markdown inside the \`<thinking>\` block to structure your plan.

**CRITICAL FORMATTING RULES:**
1.  The \`<thinking>...\</thinking>\` block itself **MUST NOT** be wrapped in Markdown code fences (e.g., \`\`\`). It must be plain text.
2.  The final answer **MUST** begin immediately after the closing \`</thinking>\` tag. There should be no blank lines between them.

*   Example of a **CORRECT** raw output structure:
    \`\`\`
<thinking>
1.  **Analyze Query:** The user is asking for a conceptual explanation and an analogy.
2.  **Deconstruct:** I need to define the concept first, then list its benefits, and finally create a simple, relatable analogy.
3.  **Formatting Plan:** I will use Markdown headings for structure, bold for key terms, and bullet points for the list of benefits.
</thinking>
## This is the Final Answer
The final answer starts right here...
    \`\`\`

**STEP 2: FINAL ANSWER (AFTER \`</thinking>\`):**
*   After the closing \`</thinking>\` tag, generate your comprehensive and well-formatted answer.
*   Follow all formatting guidelines (Markdown, KaTeX, etc.) from your core instructions for this final answer part.
`;

const CHAT_MAIN_SYSTEM_PROMPT = () => {
    return `${CHAT_SYSTEM_PROMPT_CORE_INSTRUCTIONS}\n\n${EXPLICIT_THINKING_OUTPUT_INSTRUCTIONS}`;
};


const WEB_SEARCH_CHAT_SYSTEM_PROMPT = `You are a helpful AI research assistant. Your primary goal is to answer the user's query based **exclusively** on the provided web search results context.

**Core Instructions:**
1.  **Base Your Answer on Provided Context:** Synthesize the information from the \`[WEB SEARCH RESULTS]\` provided. Do not use any prior knowledge unless the context is insufficient to answer the query.
2.  **Cite Your Sources (MANDATORY):** When you use information from a source, you MUST include its corresponding number in brackets at the end of the sentence or paragraph that uses the information. For example: "The sky appears blue due to Rayleigh scattering [1]." If information comes from multiple sources, cite them all, like so: "[2, 3]".
3.  **Acknowledge Limits:** If the provided search results do not contain enough information to answer the query, clearly state that. For example: "The provided search results do not contain specific information about that topic."
4.  **Format for Clarity:** Use Markdown (lists, bolding, etc.) to structure your answer clearly.
`;

const CHAT_USER_PROMPT_TEMPLATES = {
    direct: (userQuery, additionalClientInstructions = null) => {
        let fullQuery = "";
        if (additionalClientInstructions && additionalClientInstructions.trim() !== "") {
            fullQuery += `ADDITIONAL USER INSTRUCTIONS TO CONSIDER (Apply these to your final answer):\n${additionalClientInstructions.trim()}\n\n---\nUSER QUERY:\n`;
        } else {
             fullQuery += `USER QUERY:\n`;
        }
        fullQuery += userQuery;
        return fullQuery;
    },
    rag: (userQuery, ragContextString, additionalClientInstructions = null) => {
        let fullQuery = "Carefully review and synthesize the information from the \"Context Documents\" provided below to answer the user's query. Your answer should be primarily based on these documents. Do NOT include any citation markers like [1], [2] etc. in your response text.\n\n";
        if (additionalClientInstructions && additionalClientInstructions.trim() !== "") {
            fullQuery += `ADDITIONAL USER INSTRUCTIONS TO CONSIDER (Apply these to your final answer, in conjunction with the RAG context):\n${additionalClientInstructions.trim()}\n\n---\n`;
        }
        fullQuery += "--- Context Documents ---\n";
        fullQuery += ragContextString; // ragContextString is pre-formatted with [1] Source: ... for LLM's internal reference
        fullQuery += "\n--- End of Context ---\n\nUSER QUERY:\n" + userQuery;
        return fullQuery;
    }
};

// ==============================================================================
// === ToT Orchestrator  ===
// ==============================================================================
const PLANNER_PROMPT_TEMPLATE = `
You are a meticulous AI planning agent. Your task is to analyze the user's query and generate 2-3 distinct, logical, step-by-step plans to answer it.

**User Query:** "{userQuery}"

**Instructions:**
1.  Create 2-3 unique plans. Each plan should have a descriptive "name".
2.  Each plan must contain a list of "steps". Each step should be a clear, single-sentence instruction for a research agent (e.g., "Search the web for recent reviews of product X," "Analyze the provided document for mentions of 'cost analysis'").
3.  Your entire output MUST be a single, valid JSON object containing a "plans" array. Do not provide any other text or explanation.

**Example JSON Output Format:**
\`\`\`json
{
  "plans": [
    {
      "name": "Comprehensive Research Plan",
      "steps": [
        "First, search internal documents for foundational concepts related to the query.",
        "Second, perform a web search for the latest real-world applications.",
        "Finally, synthesize the findings from both internal and external sources."
      ]
    },
    {
      "name": "Quick Answer Plan",
      "steps": [
        "Perform a direct web search for the user's query to find an immediate answer."
      ]
    }
  ]
}
\`\`\`

Provide your JSON response now.
`;

const EVALUATOR_PROMPT_TEMPLATE = `
You are an expert AI plan evaluator. Your task is to analyze a user's query and a list of proposed plans, and select the single best plan to execute. The best plan is the one that is most logical, efficient, and likely to produce a comprehensive and accurate answer.

**User Query:** "{userQuery}"

**Proposed Plans:**
{plansJsonString}

**Instructions:**
1.  Review the query and each plan carefully.
2.  Choose the plan with the most logical and effective sequence of steps.
3.  Your entire output MUST be a single, valid JSON object with a single key "best_plan_name" whose value is the exact name of the plan you have chosen. Do not provide any other text or explanation.

**Example JSON Output Format:**
\`\`\`json
{
  "best_plan_name": "Comprehensive Research Plan"
}
\`\`\`

Provide your JSON decision now.
`;


// ==============================================================================
// === AGENTIC FRAMEWORK PROMPTS - V5 (Classification-Based Logic) ===
// ==============================================================================
const createAgenticSystemPrompt = (modelContext, agenticContext, requestContext) => {
  const userQueryForPrompt = requestContext.userQuery || "[User query not provided]";
  let activeModeInstructions;

  if (requestContext.isWebSearchEnabled) {
      activeModeInstructions = `**CURRENT MODE: Web Search.** The user has manually enabled web search. Your decision MUST be 'web_search'. This is not optional.`;
  } else if (requestContext.isAcademicSearchEnabled) {
      activeModeInstructions = `**CURRENT MODE: Academic Search.** The user has manually enabled academic search. Your decision MUST be 'academic_search'. This is not optional.`;
  } else if (requestContext.documentContextName) {
      activeModeInstructions = `**CURRENT MODE: Document RAG.** The user has selected a document named "${requestContext.documentContextName}". Your decision MUST be 'rag_search'. This is not optional.`;
  } else {
      activeModeInstructions = `**CURRENT MODE: Direct Chat.** No specific tool has been selected. Analyze the user's query to decide. If it requires real-time information or external knowledge, choose 'web_search'. For academic papers or scholarly articles, choose 'academic_search'. For all other general queries, definitions, or explanations, your decision MUST be 'direct_answer'.`;
  }

  return `
You are a "Router" agent. Your single task is to analyze the user's query and the current context, and then decide which of the available tools to use, or if you should answer directly.

**AVAILABLE TOOLS:**
${JSON.stringify(modelContext.available_tools, null, 2)}

**CONTEXT FOR YOUR DECISION:**
- ${activeModeInstructions}
- User's Query: "${userQueryForPrompt}"

**YOUR TASK:**
Based on the CURRENT MODE and the USER'S QUERY, choose one action. Your entire output MUST be a single, valid JSON object with a "tool_call" key. Do not provide any other text or explanation.

- If your decision is to use a tool, format as:
  \`\`\`json
  {
    "tool_call": {
      "tool_name": "the_tool_name_you_chose",
      "parameters": { "query": "${userQueryForPrompt}" }
    }
  }
  \`\`\`

- If your decision is to answer directly without a tool, format as:
  \`\`\`json
  {
    "tool_call": null
  }
  \`\`\`

Provide your JSON decision now.
`;
};



const createSynthesizerPrompt = (originalQuery, toolOutput, toolName) => {
    
    let synthesizerUserMessage;

    if (toolName === 'web_search') {
        synthesizerUserMessage = `
You are an expert AI Research Assistant. Your task is to synthesize the provided "WEB SEARCH RESULTS" into a comprehensive, detailed, and helpful response to the user's query.

Your final response MUST follow this two-part structure precisely:
1.  A detailed, well-written answer to the user's query.
2.  A "**References**" section with a formatted list of the sources used.

**PART 1: MAIN ANSWER INSTRUCTIONS**
-   Your answer **MUST** be based on the provided search results.
-   When you use information from a source, you **MUST** include its corresponding number in brackets. For example: "The sky appears blue due to Rayleigh scattering [1]." If information comes from multiple sources, cite them all, like so: "[2, 3]".
-   Be comprehensive. Synthesize information from multiple sources to build a full, well-rounded explanation.
-   Use rich Markdown formatting (headings, lists, bolding, tables) to make the answer clear and engaging.

**PART 2: REFERENCES SECTION INSTRUCTIONS**
-   After you have finished writing the main answer, add a horizontal rule (\`---\`).
-   After the line, add a heading: \`## References\`.
-   Below the heading, create a numbered list of all the sources you cited.
-   Format each reference like this: \`[1] [Source Title](Source URL)\`.

---
**Now, perform this task using the following information:**

**USER'S ORIGINAL QUERY:**
${originalQuery}

**WEB SEARCH RESULTS:**
${toolOutput}

**YOUR COMPLETE, FORMATTED RESPONSE:**
`;
    } 
    else if (toolName === 'academic_search') {
        synthesizerUserMessage = `
You are an expert AI Research Assistant. Your entire response MUST begin with your inner monologue in a \`<thinking>\` block, followed by a detailed, multi-part answer.

**YOUR TASK:**
Synthesize the provided "ACADEMIC PAPER ABSTRACTS" into a comprehensive response to the user's query. Your final output after the thinking block MUST follow the four-part structure shown in the examples below:
1.  **Analysis of Retrieved Articles (H2 Heading):** An analysis of EACH paper.
2.  **Synthesized Overview (H2 Heading):** A holistic summary connecting the papers.
3.  **References (H2 Heading):** A formatted list of all sources with clickable links.

---
**EXAMPLE 1 OF COMPLETE OUTPUT:**

**USER'S ORIGINAL QUERY:** "Give me an overview of how AI is used in the SDLC."
**ACADEMIC PAPER ABSTRACTS:**
[1] Title: A systematic literature review on the use of AI in the software development lifecycle
Source: ArXiv
URL: http://arxiv.org/abs/2304.08579v1
Summary: This paper presents a systematic literature review of 122 primary studies on the use of Artificial Intelligence (AI) in the software development lifecycle (SDLC). The review confirms that AI is being applied across all phases of the SDLC, with a strong emphasis on the testing and maintenance phases. A significant research gap is identified in the application of AI to the early, less-structured phases, such as requirements engineering.

[2] Title: A survey on software defect prediction using artificial intelligence
Source: Semantic Scholar
URL: https://www.semanticscholar.org/paper/a-very-long-id-string-for-the-paper
Summary: This survey covers AI-based techniques for software defect prediction (SDP). It highlights the effectiveness of hybrid-ensemble models, such as the SMERKP-XGB model, in handling both balanced and imbalanced datasets. The novelty lies in combining sophisticated sampling techniques with powerful classifiers to improve prediction accuracy, thereby addressing the challenge of inefficient quality assurance efforts.

**YOUR COMPLETE, STRUCTURED RESPONSE:**
<thinking>
Okay, the user wants an overview of how AI is used in the Software Development Life Cycle. This requires a structured, evidence-based response. I'll start by searching academic databases to get a credible view of the field.

My search has yielded a couple of interesting papers. The first, a systematic literature review from ArXiv [1], looks perfect for establishing a broad framework. It analyzes 122 studies, which gives it a lot of authority. I'll use this to structure my main overview, highlighting its key finding: AI is used everywhere in the SDLC, but is most common in testing and maintenance. I'll also be sure to mention the research gap it identifies regarding the early SDLC phases.

The second paper [2] is a survey on software defect prediction. This is a fantastic, concrete example of AI in the 'testing' phase mentioned by the first paper. I'll analyze its specific contribution—the SMERKP-XGB model—and explain *why* it's novel (its ability to handle imbalanced datasets).

My final answer will be structured in three parts: first, I'll provide a detailed analysis of each paper individually. Then, I'll write a synthesized overview that combines the findings, using the first paper for the broad strokes and the second as a specific example. Finally, I will compile the references with clickable links. This structure will provide both detail and a clear, high-level summary.
</thinking>

## Analysis of Retrieved Articles

### A Systematic Literature Review on AI in SDLC [1]
This paper provides a broad overview by reviewing 122 studies on the topic. Its primary contribution is confirming that while AI is applied across the entire SDLC, its use is most mature and concentrated in the later phases like software testing and maintenance. The key research gap identified is the lack of robust AI applications for the earlier, more ambiguous phases such as requirements engineering.

### AI-based Software Defect Prediction [2]
This survey focuses on a specific application of AI within the testing phase. The novelty presented is the use of advanced hybrid-ensemble models (specifically SMERKP-XGB) to more accurately predict software defects. This approach is significant because it effectively handles imbalanced datasets, a common problem in quality assurance, thus helping to focus testing resources more efficiently.

## Synthesized Overview

The integration of Artificial Intelligence (AI) within the Software Development Life Cycle (SDLC) is a rapidly evolving field aimed at improving efficiency and quality. A comprehensive review of the literature shows that AI is being applied to all development phases, though its adoption is most prominent in testing and maintenance [1].

A key example of AI's impact is seen in software defect prediction. Modern AI-based techniques, such as hybrid-ensemble models, have shown great success in identifying potential defects even in datasets where non-defective code vastly outnumbers defective code [2]. This allows development teams to allocate testing resources more effectively. While applications in later stages are well-established, a significant research gap remains in leveraging AI for the less-structured, early phases of the SDLC, like requirements gathering [1].

---
## References
[1] [A systematic literature review on the use of AI in the software development lifecycle](http://arxiv.org/abs/2304.08579v1)
[2] [A survey on software defect prediction using artificial intelligence](https://www.semanticscholar.org/paper/a-very-long-id-string-for-the-paper)
---
**EXAMPLE 2 OF COMPLETE OUTPUT:**

**USER'S ORIGINAL QUERY:** "What are the latest applications of graphene in electronics?"
**ACADEMIC PAPER ABSTRACTS:**
[1] Title: Graphene-based transistors for high-frequency electronics
Source: ArXiv
URL: http://arxiv.org/abs/2201.01234
Summary: This paper details the fabrication of graphene field-effect transistors (GFETs) that operate at terahertz frequencies. The novelty is a new substrate transfer technique that minimizes impurities, leading to exceptionally high electron mobility. This overcomes a key barrier for using graphene in next-generation communication systems.

**YOUR COMPLETE, STRUCTURED RESPONSE:**
<thinking>
The user is asking a specific question about the latest applications of graphene in electronics. I will search for recent, high-impact research papers.

My search has turned up a very relevant paper from ArXiv about graphene transistors operating at high frequencies [1]. This is a direct answer to the user's query about "applications". I will analyze the abstract to extract the key innovation. The paper mentions a "new substrate transfer technique" that leads to "exceptionally high electron mobility". This is the novelty. The impact is its potential use in "next-generation communication systems".

Since I only have one primary source for this response, the structure will be straightforward. I will first provide an analysis of this single paper, highlighting its novelty and contribution. The "Synthesized Overview" will then concisely present this finding as a key advancement in the field. I'll finish with the formal reference section. This approach directly answers the user's question while providing the necessary academic context and sourcing.
</thinking>

## Analysis of Retrieved Articles

### Graphene-based Transistors for High-Frequency Electronics [1]
This research focuses on the development of graphene field-effect transistors (GFETs) capable of operating in the terahertz (THz) range. The main contribution and novelty of this work is a new substrate transfer method that significantly reduces impurities on the graphene sheet. This purification results in much higher electron mobility, which has been a major obstacle in creating practical high-frequency graphene electronics. The paper suggests this breakthrough could pave the way for next-generation communication systems. A potential research gap could be the scalability and cost-effectiveness of this new fabrication technique for mass production.

## Synthesized Overview

A significant recent application of graphene in electronics is the development of ultra-high-frequency transistors. Researchers have engineered graphene-based transistors that can operate at terahertz speeds, a critical step for next-generation wireless communication [1]. This was achieved by developing a novel fabrication process that enhances the material's electron mobility, overcoming a long-standing challenge in the field [1].

---
## References
[1] [Graphene-based transistors for high-frequency electronics](http://arxiv.org/abs/2201.01234)
---
**Now, perform this task using the following information, following the structure from the examples above:**

**USER'S ORIGINAL QUERY:**
${originalQuery}

**ACADEMIC PAPER ABSTRACTS:**
${toolOutput}

**YOUR COMPLETE, STRUCTURED RESPONSE:**
`;
    }
    else { // For RAG, KG, Academic, and other tools
        synthesizerUserMessage = `
**USER'S ORIGINAL QUERY:**
"${originalQuery}"

---
**INFORMATION GATHERED BY TOOL ('${toolName}'):**
${toolOutput}
---

Based **only** on the information gathered by the tool above, please provide a comprehensive, well-formatted final answer to my original query. Adhere to all formatting rules from your core instructions. Do not mention that a tool was used and do not include citation markers like [1], [2].
`;
    }
    return synthesizerUserMessage;
};

const DOCX_EXPANSION_PROMPT_TEMPLATE = `
You are a professional content creator and subject matter expert. Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, multi-page document in Markdown format. You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge. The final output must be a single block of well-structured Markdown text.

**INSTRUCTIONS:**
1.  **Main Title:** Start the document with a main title using H1 syntax (e.g., '# Expanded Report on Key Topics').
2.  **Section per Outline Point:** For each point in the OUTLINE, create a detailed section with a clear H2 or H3 heading (e.g., '## Topic Name').
3.  **Content Expansion:** For each section, write detailed, professional paragraphs that elaborate on the outline point. Extract relevant facts, figures, and explanations from the SOURCE DOCUMENT TEXT.
4.  **Markdown Usage:** Use bullet points, bold text, and clear paragraphs to structure the content effectively.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a document):**
{outline_content}
---

**FINAL DOCUMENT MARKDOWN:**
`;

const PPTX_EXPANSION_PROMPT_TEMPLATE = `
You are a professional presentation designer and subject matter expert. Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, 6-8 slide presentation. You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge. Your output MUST be a single, valid JSON array, where each object represents a slide.

**JSON Object Schema for each slide:**
{{
  "slide_title": "A concise and engaging title for the slide.",
  "slide_content": "Detailed, professional paragraph(s) and/or bullet points elaborating on the outline point. This text will be displayed on the slide. Use Markdown for formatting (e.g., **bold**, *italics*, - bullet points).",
  "image_prompt": "A highly descriptive, creative prompt for an AI text-to-image model (like DALL-E or Midjourney) to generate a relevant and visually appealing image for this specific slide. Describe the style, subject, and composition. Example: 'A photorealistic image of a futuristic server room with glowing blue data streams flowing between racks, symbolizing data processing. Cinematic lighting.'"
}}

**INSTRUCTIONS:**
1.  **Analyze Outline & Source:** For each point in the OUTLINE, create at least one slide object in the JSON array.
2.  **Expand Content:** Elaborate on each outline point using only information from the SOURCE DOCUMENT TEXT.
3.  **Create Image Prompts:** For each slide, generate a unique and descriptive \`image_prompt\` that visually represents the slide's content.
4.  **JSON Format:** Ensure the final output is a single, clean JSON array with no other text before or after it.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a presentation):**
{outline_content}
---

**FINAL PRESENTATION JSON ARRAY:**
`;

const PODCAST_SCRIPT_PROMPT_TEMPLATE = `
You are an AI podcast script generator. Your SOLE task is to generate a realistic, two-speaker educational dialogue based on the provided text.

**CRITICAL INSTRUCTION:** Your entire output must be ONLY the script itself. Start directly with "SPEAKER_A:". Do NOT include any preamble, introduction, or metadata like "Here is the script:".

---
## Podcast Style Guide

- **Format**: Two-speaker conversational podcast.
- **SPEAKER_A**: The "Curious Learner". Asks clarifying questions and represents the student's perspective.
- **SPEAKER_B**: The "Expert Teacher". Provides clear explanations and examples based on the document text.
- **Dialogue Flow**: The conversation must be a natural back-and-forth. SPEAKER_A asks a question, SPEAKER_B answers, and SPEAKER_A follows up.
- **Content Source**: All explanations and facts provided by SPEAKER_B MUST come from the \`DOCUMENT TEXT\` provided below.

---
## Script Structure

### 1. Opening
The script must begin with a brief, engaging conversation to set the stage.
\`SPEAKER_A: Hey, I was just reading this document about {study_focus}, and I'm a bit stuck on a few things. Can we talk through it?\`
\`SPEAKER_B: Absolutely! I'd be happy to. What's on your mind?\`

### 2. Main Body
The main part of the script should be a question-and-answer dialogue driven by SPEAKER_A, focusing on the key points of the \`STUDY FOCUS\`. Use the \`DOCUMENT TEXT\` to formulate SPEAKER_B's expert answers.

### 3. Closing
Conclude the podcast with a quick summary and an encouraging sign-off.
\`SPEAKER_A: This makes so much more sense now. Thanks for clarifying everything!\`
\`SPEAKER_B: You're welcome! The key is to break it down. Keep up the great work!\`

---
## Source Material

**STUDY FOCUS (The main topic for the podcast):**
{study_focus}

**DOCUMENT TEXT (Use this for all factual answers):**
{document_content}

---
**FINAL SCRIPT OUTPUT (Remember: Start IMMEDIATELY with "SPEAKER_A:")**
`;


// ==============================================================================
// --- CODE ASSISTANT PROMPTS (for Code Executor Tool) ---
// ==============================================================================

const CODE_ANALYSIS_PROMPT_TEMPLATE = `
You are an expert software engineer and code reviewer. Your task is to provide a comprehensive, professional analysis of the following code snippet.

**Analysis Sections (Use Markdown headings for each):**
1.  **Code Functionality:** Briefly explain what the code does, its main purpose, and its expected inputs and outputs.
2.  **Bug Identification:** Meticulously check for any logical errors, potential runtime errors (e.g., division by zero, index out of bounds), or security vulnerabilities. If you find any, explain the bug clearly. If not, state that no obvious bugs were found.
3.  **Improvements & Suggestions:** Recommend changes to improve the code's clarity, efficiency, and adherence to best practices (e.g., better variable names, more efficient algorithms, error handling).

**Formatting:**
- Use clear Markdown for structure.
- For code suggestions, use fenced code blocks with the correct language identifier.

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
\`\`\`{language}
{code}
\`\`\`
---

**ANALYSIS REPORT:**
`;

const TEST_CASE_GENERATION_PROMPT_TEMPLATE = `
You are a meticulous Quality Assurance (QA) engineer. Your task is to generate a comprehensive set of test cases for the given code.

**Instructions:**
1.  Analyze the code to understand its logic, inputs, and outputs.
2.  Create a diverse set of test cases that cover:
    -   **Standard Cases:** Common, expected inputs.
    -   **Edge Cases:** Boundary values, empty inputs, zeros, negative numbers, etc.
    -   **Error Cases:** Invalid inputs that should cause the program to handle an error gracefully (if applicable).
3.  Your entire output **MUST** be a single, valid JSON array of objects.
4.  Each object in the array must have two keys: \`input\` (a string) and \`expectedOutput\` (a string).
5.  For inputs that require multiple lines, use the newline character \`\\n\`.

**Example Output Format:**
[
  { "input": "5\\n10", "expectedOutput": "15" },
  { "input": "0\\n0", "expectedOutput": "0" },
  { "input": "-5\\n5", "expectedOutput": "0" }
]

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
\`\`\`{language}
{code}
\`\`\`
---

**FINAL JSON TEST CASE ARRAY:**
`;

// ==============================================================================
// === PROMPT COACH PROMPTS ===
// ==============================================================================

const PROMPT_COACH_TEMPLATE = `
You are an expert Prompt Engineering Coach. Your task is to analyze the user's provided prompt and rewrite it to be more specific, provide more context, and ultimately be more effective for an AI Tutor specializing in academic and technical topics.

Your entire output MUST be a single, valid JSON object with two keys: "improvedPrompt" and "explanation".
- "improvedPrompt": Your rewritten, superior version of the prompt.
- "explanation": A brief, bulleted list in Markdown explaining the key improvements you made. Use "- " for each bullet point.

User's Prompt: "{userPrompt}"

Example Output for a user prompt of "tell me about python":
{
  "improvedPrompt": "Provide a beginner-friendly overview of Python. Cover its main uses (like web development, data science, and automation) and include a simple 'Hello, World!' code example.",
  "explanation": "- **Added Specificity:** Asked for a 'beginner-friendly overview' to set the right tone.\\n- **Provided Context:** Mentioned specific uses to guide the AI's focus.\\n- **Requested Actionable Content:** Asked for a 'code example' to get a practical response."
}

FINAL JSON OUTPUT:
`;

const CRITICAL_THINKING_CUE_TEMPLATE = `
You are a Devil's Advocate, a Fact-Checker, and a Practical Mentor AI. Your task is to read the following AI-generated text and identify opportunities to encourage deeper, more critical thinking.

Based on the text, generate up to three distinct types of follow-up prompts for the user.

Your entire output MUST be a single, valid JSON object. It can contain any of the following three keys: "verificationPrompt", "alternativePrompt", and "applicationPrompt".
- "verificationPrompt": A prompt that asks for external evidence, sources, or data to back up a key claim.
- "alternativePrompt": A prompt that asks for counterarguments, disadvantages, or different perspectives on the topic.
- "applicationPrompt": A prompt that asks for a practical example, a "what-if" scenario, or how the concept applies to a real-world problem.

If you cannot generate a meaningful prompt for a specific type, omit its key from the JSON. If no good prompts can be generated at all, return an empty JSON object: {}.

AI-Generated Text: "{aiAnswer}"

Example for "React is the best frontend framework due to its virtual DOM, which makes it faster than competitors.":
{
  "verificationPrompt": "Find sources and benchmarks comparing React's virtual DOM performance to Svelte's compiler-based approach.",
  "alternativePrompt": "What are some common criticisms or disadvantages of using React?",
  "applicationPrompt": "How would I handle global state management in a large-scale React application?"
}

FINAL JSON OUTPUT:
`;

module.exports = {
    // Analysis
    ANALYSIS_PROMPTS,
    // KG
    KG_GENERATION_SYSTEM_PROMPT,
    KG_BATCH_USER_PROMPT_TEMPLATE,
    // Chat
    CHAT_MAIN_SYSTEM_PROMPT,
    WEB_SEARCH_CHAT_SYSTEM_PROMPT,
    CHAT_USER_PROMPT_TEMPLATES,
    // ToT
    PLANNER_PROMPT_TEMPLATE,
    EVALUATOR_PROMPT_TEMPLATE,
    // Agentic Framework
    createAgenticSystemPrompt,
    createSynthesizerPrompt,
    // Content Generation
    DOCX_EXPANSION_PROMPT_TEMPLATE,
    PPTX_EXPANSION_PROMPT_TEMPLATE,
    PODCAST_SCRIPT_PROMPT_TEMPLATE,
    PROMPT_COACH_TEMPLATE,
    CRITICAL_THINKING_CUE_TEMPLATE
};  
```

`server/config/redisClient.js`

```javascript
// server/config/redisClient.js
const { createClient } = require('redis');
const
 
dotenv = require('dotenv');
dotenv.config();

const redisUrl = process.env.REDIS_URL;
if (!redisUrl) {
    console.warn("! REDIS_URL not found in .env, Redis caching will be disabled.");
}

const redisClient = redisUrl ? createClient({ url: redisUrl }) : null;

if (redisClient) {
    redisClient.on('error', (err) => console.error('Redis Client Error', err));
    redisClient.on('connect', () => console.log('✓ Redis client connected successfully.'));
    redisClient.on('reconnecting', () => console.log('Redis client is reconnecting...'));
}

// Function to connect the client
const connectRedis = async () => {
    if (redisClient && !redisClient.isOpen) {
        try {
            console.log('[Redis Cache] Attempting to connect to Redis...');
            await redisClient.connect();
        } catch (err) {
            console.error('Failed to connect to Redis:', err);
        }
    }
};

module.exports = { redisClient, connectRedis };
```

`server/middleware/authMiddleware.js`

```javascript
// server/middleware/authMiddleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');
require('dotenv').config();

const authMiddleware = async (req, res, next) => {
    const authHeader = req.header('Authorization');

    if (!authHeader) {
        console.warn("Auth Middleware: No Authorization header found.");
        return res.status(401).json({ message: 'Not authorized, no token' });
    }

    const parts = authHeader.split(' ');

    if (parts.length !== 2 || parts[0] !== 'Bearer') {
        console.warn("Auth Middleware: Token format is 'Bearer <token>', received:", authHeader);
        return res.status(401).json({ message: 'Token format is invalid' });
    }

    const token = parts[1];

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await User.findById(decoded.userId).select('-password');

        if (!user) {
            console.warn(`Auth Middleware: User not found for ID: ${decoded.userId} from token.`);
            return res.status(401).json({ message: 'User not found, token invalid' });
        }

        req.user = user;
        next();
    } catch (error) {
        console.warn("Auth Middleware: Token verification failed:", error.message);
        if (error.name === 'TokenExpiredError') {
            return res.status(401).json({ message: 'Token expired' });
        }
        if (error.name === 'JsonWebTokenError') {
            return res.status(401).json({ message: 'Token is not valid' });
        }
        res.status(401).json({ message: 'Not authorized, token verification failed' });
    }
};

module.exports = { authMiddleware }; // ONLY export this
```

`server/middleware/cacheMiddleware.js`

```javascript
// server/middleware/cacheMiddleware.js
const { redisClient } = require('../config/redisClient');

const cacheMiddleware = (durationInSeconds) => async (req, res, next) => {
    if (!redisClient || !redisClient.isOpen || req.method !== 'GET') {
        return next();
    }

    const key = `__express__${req.originalUrl || req.url}`;
    try {
        const cachedResponse = await redisClient.get(key);
        if (cachedResponse) {
            res.setHeader('X-Cache', 'HIT');
            res.send(JSON.parse(cachedResponse));
            return;
        }

        res.setHeader('X-Cache', 'MISS');
        const originalSend = res.send;

        res.send = (body) => {
            // Only cache successful 2xx responses
            if (res.statusCode >= 200 && res.statusCode < 300) {
                redisClient.setEx(key, durationInSeconds, JSON.stringify(body)).catch(err => {
                    console.error(`Redis SETEX error for key ${key}:`, err);
                });
            }
            return originalSend.call(res, body);
        };
        next();
    } catch (err) {
        console.error('Redis cache middleware error:', err);
        next();
    }
};

module.exports = { cacheMiddleware };
```

`server/middleware/fixedAdminAuthMiddleware.js`

```javascript
// server/middleware/fixedAdminAuthMiddleware.js
require('dotenv').config({ path: require('path').resolve(__dirname, '..', '.env') }); // Ensure .env from server directory is loaded

const ADMIN_USERNAME = process.env.FIXED_ADMIN_USERNAME || 'admin';
const ADMIN_PASSWORD = process.env.FIXED_ADMIN_PASSWORD || 'admin123';

const fixedAdminAuthMiddleware = (req, res, next) => {
    const authHeader = req.headers.authorization;

    if (!ADMIN_USERNAME || !ADMIN_PASSWORD) {
        console.error("FATAL: FIXED_ADMIN_USERNAME or FIXED_ADMIN_PASSWORD not set in environment for admin auth.");
        // Do not send WWW-Authenticate here as it's a server config issue
        return res.status(500).json({ message: "Admin authentication system not configured properly." });
    }

    if (!authHeader || !authHeader.toLowerCase().startsWith('basic ')) {
        // Prompt for Basic Authentication
        res.setHeader('WWW-Authenticate', 'Basic realm="Admin Document Area"');
        return res.status(401).json({ message: 'Admin authentication required (Basic Auth).' });
    }

    const encodedCreds = authHeader.substring(6); // Length of "Basic "
    let decodedCreds;
    try {
        decodedCreds = Buffer.from(encodedCreds, 'base64').toString('utf8');
    } catch (e) {
        console.warn("Admin Auth: Invalid Base64 encoding in Basic Auth header.");
        res.setHeader('WWW-Authenticate', 'Basic realm="Admin Document Area"'); // Re-prompt
        return res.status(400).json({ message: 'Invalid Basic Auth encoding format.' });
    }

    const [username, password] = decodedCreds.split(':', 2); // Split into max 2 parts

    if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
        // Attach a simple admin context to the request object
        // This isn't a full user object from DB, just an indicator
        req.adminUser = { 
            username: ADMIN_USERNAME, 
            id: "fixed_admin_id_marker" // A placeholder ID
        }; 
        return next(); // Authentication successful, proceed to the route handler
    }

    // Authentication failed
    console.warn(`Admin Auth Failed: Incorrect credentials received. Username: ${username}`);
    res.setHeader('WWW-Authenticate', 'Basic realm="Admin Document Area"'); // Re-prompt
    return res.status(401).json({ message: 'Invalid admin credentials.' });
};

module.exports = { fixedAdminAuthMiddleware };
```

`server/models/AdminDocument.js`

```javascript
// server/models/AdminDocument.js
const mongoose = require('mongoose');

const AdminDocumentSchema = new mongoose.Schema({
  filename: { // Server-generated unique filename (e.g., timestamp-originalname.ext)
    type: String,
    required: true,
    unique: true,
  },
  originalName: { // The original name of the file uploaded by the admin
    type: String,
    required: true,
  },
  text: { // Extracted text content from the document, ready for analysis input
    type: String,
    default: "",
  },
  analysis: {
    faq: { // Stores the full string output (including <thinking>) for FAQ generation
      type: String,
      default: "",
    },
    topics: { // Stores the full string output for Key Topics generation
      type: String,
      default: "",
    },
    mindmap: { // Stores the full string output for Mind Map generation
      type: String,
      default: "",
    },
  },
  uploadedAt: { // Timestamp of when the document record was created/file uploaded
    type: Date,
    default: Date.now,
  },
  // Optional: Add a timestamp for when analysis was last updated
  analysisUpdatedAt: {
    type: Date,
  }
});

// Index for frequently queried fields if necessary, e.g., originalName
AdminDocumentSchema.index({ originalName: 1 });

const AdminDocument = mongoose.model('AdminDocument', AdminDocumentSchema);

module.exports = AdminDocument;
```

`server/models/ChatHistory.js`

```javascript
// server/models/ChatHistory.js
const mongoose = require('mongoose');
const { v4: uuidv4 } = require('uuid');

const MessageSchema = new mongoose.Schema({
    role: { type: String, enum: ['user', 'model'], required: true },
    parts: [{ text: { type: String, required: true } }],
    timestamp: { type: Date, default: Date.now },
    thinking: { type: String, default: '' },
    references: { type: Array, default: [] },
    source_pipeline: { type: String, default: '' }
}, { _id: false });

const ChatHistorySchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true,
    },
    sessionId: {
        type: String,
        required: true,
        unique: true,
        index: true,
    },
    messages: [MessageSchema],
    summary: {
        type: String,
        default: ''
    },
    createdAt: {
        type: Date,
        default: Date.now,
    },
    updatedAt: {
        type: Date,
        default: Date.now,
    }
});

ChatHistorySchema.pre('save', function (next) {
    if (this.isModified()) {
      this.updatedAt = Date.now();
    }
    next();
});

ChatHistorySchema.pre('findOneAndUpdate', function(next) {
  this.set({ updatedAt: new Date() });
  next();
});

const ChatHistory = mongoose.model('ChatHistory', ChatHistorySchema);
module.exports = ChatHistory;
```

`server/models/KnowledgeSource.js`

```javascript
// server/models/KnowledgeSource.js
const mongoose = require('mongoose');

const AnalysisSchema = new mongoose.Schema({
    faq: { type: String, default: "" },
    topics: { type: String, default: "" },
    mindmap: { type: String, default: "" },
}, { _id: false });

const KnowledgeSourceSchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true,
    },
    sourceType: {
        type: String,
        enum: ['document', 'youtube', 'webpage', 'audio', 'video', 'image'],
        required: true,
    },
    title: {
        type: String,
        required: true,
        trim: true,
    },
    // Only for URL-based sources
    sourceUrl: {
        type: String,
        trim: true,
    },
    // Only for file-based sources
    serverFilename: {
        type: String,
    },
    status: {
        type: String,
        enum: ['processing_extraction', 'processing_analysis', 'completed', 'failed'],
        default: 'processing_extraction',
    },
    failureReason: {
        type: String,
    },
    textContent: {
        type: String,
    },
    analysis: {
        type: AnalysisSchema,
        default: () => ({}),
    },
    kgStatus: {
        type: String,
        default: "pending", // pending, processing, completed, failed_extraction, skipped_no_chunks, failed_critical
    },
}, { timestamps: true }); // Adds createdAt and updatedAt automatically

KnowledgeSourceSchema.index({ userId: 1, title: 1 }, { unique: true });

const KnowledgeSource = mongoose.model('KnowledgeSource', KnowledgeSourceSchema);

module.exports = KnowledgeSource;
```

`server/models/LearningPath.js`

```javascript
// server/models/LearningPath.js
const mongoose = require('mongoose');
const { v4: uuidv4 } = require('uuid');

const ModuleSchema = new mongoose.Schema({
    moduleId: { 
        type: String, 
        required: true, 
        default: () => `mod_${uuidv4()}` 
    },
    title: { 
        type: String, 
        required: true 
    },
    status: { 
        type: String, 
        enum: ['completed', 'in_progress', 'not_started', 'locked'], 
        default: 'not_started' 
    },
    objective: {
        type: String
    },
    activity: {
        type: { 
            type: String, 
            required: true,
            enum: ['direct_answer', 'web_search', 'academic_search', 'document_review', 'code_executor']
        },
        resourceName: { // e.g., 'RL_Foundations.pdf' or null
            type: String 
        },
        suggestedPrompt: {
            type: String
        }
    }
}, { _id: false });

const LearningPathSchema = new mongoose.Schema({
    userId: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: 'User', 
        required: true, 
        index: true 
    },
    title: { 
        type: String, 
        required: true 
    }, // The user's goal, e.g., "Master Reinforcement Learning"
    isActive: { 
        type: Boolean, 
        default: true 
    },
    modules: [ModuleSchema],
    createdAt: { 
        type: Date, 
        default: Date.now 
    }
});

const LearningPath = mongoose.model('LearningPath', LearningPathSchema);
module.exports = LearningPath;
```

`server/models/User.js`

```javascript
// server/models/User.js
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const { encrypt } = require("../utils/crypto");

// server/models/User.js

const ProfileSchema = new mongoose.Schema(
  {
    name: { type: String, default: "", trim: true },
    college: { type: String, default: "", trim: true },
    universityNumber: { type: String, default: "", trim: true },
    degreeType: { type: String, default: "", trim: true },
    branch: { type: String, default: "", trim: true },
    year: { type: String, default: "", trim: true },
    learningStyle: {
      type: String,
      enum: ['Not Specified', 'Visual', 'Auditory', 'Reading/Writing', 'Kinesthetic'],
      default: 'Not Specified'
    },
    currentGoals: {
      type: String,
      default: '',
      trim: true,
      maxlength: 500 // Prevent excessively long inputs
    },
    performanceMetrics: {
      type: Map,
      of: Number, // Stores topic proficiency, e.g., { "Calculus": 0.8 }
      default: () => new Map()
    }
    // --- NEW FIELDS END HERE ---
  },
  { _id: false }
);

const UserSchema = new mongoose.Schema({
  email: {
    type: String,
    required: [true, "Please provide an email"],
    unique: true,
    trim: true,
    lowercase: true,
    match: [
      /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
      "Please provide a valid email address",
    ],
  },
  username: {
    type: String,
    required: [true, "A unique username is required"],
    unique: true,
    trim: true,
  },
  password: {
    type: String,
    required: [true, "Please provide a password"],
    minlength: 6,
    select: false,
  },
  profile: {
    type: ProfileSchema,
    default: () => ({}),
  },
  apiKeyRequestStatus: {
    type: String,
    enum: ["none", "pending", "approved", "rejected"],
    default: "none",
  },
  encryptedApiKey: {
    type: String,
    select: false,
  },
  preferredLlmProvider: {
    type: String,
    enum: ["gemini", "ollama"],
    default: "gemini",
  },
  ollamaUrl: {
    type: String,
    trim: true,
    default: "",
  },
  ollamaModel: {
    type: String,
    default: process.env.OLLAMA_DEFAULT_MODEL || "llama3",
  },
  // uploadedDocuments: [
  //   {
  //     filename: { type: String },
  //     text: { type: String, default: "" },
  //     analysis: {
  //       faq: { type: String, default: "" },
  //       topics: { type: String, default: "" },
  //       mindmap: { type: String, default: "" },
  //     },
  //     ragStatus: { type: String, default: "pending" },
  //     analysisStatus: { type: String, default: "pending" },
  //     analysisTimestamp: { type: Date },
  //     kgStatus: { type: String, default: "pending" },
  //     kgNodesCount: { type: Number, default: 0 },
  //     kgEdgesCount: { type: Number, default: 0 },
  //     kgTimestamp: { type: Date },
  //     uploadedAt: { type: Date, default: Date.now },
  //   },
  // ],
  learningPaths: [{ 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'LearningPath' 
  }],
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

UserSchema.pre("save", async function (next) {
  if (this.isModified("password")) {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
  }
  if (this.isModified("encryptedApiKey") && this.encryptedApiKey) {
    try {
      this.encryptedApiKey = encrypt(this.encryptedApiKey);
    } catch (encError) {
      console.error("Error encrypting API key during user save:", encError);
      return next(new Error("Failed to encrypt API key."));
    }
  } else if (this.isModified("encryptedApiKey") && !this.encryptedApiKey) {
    this.encryptedApiKey = null;
  }
  next();
});

UserSchema.methods.comparePassword = async function (candidatePassword) {
  if (!this.password) return false;
  return await bcrypt.compare(candidatePassword, this.password);
};

UserSchema.statics.findByCredentials = async function (email, password) {
  const user = await this.findOne({ email }).select("+password");
  if (!user) {
    return null;
  }
  const isMatch = await user.comparePassword(password);
  if (!isMatch) {
    return null;
  }
  return user;
};

const User = mongoose.model("User", UserSchema);
module.exports = User;

```

`server/protocols/contextProtocols.js`

```javascript
// server/protocols/contextProtocols.js

const createModelContext = ({ availableTools, currentMode = 'chat' }) => ({
  current_mode: currentMode,
  available_tools: Object.entries(availableTools).map(([name, details]) => ({
    name,
    description: details.description,
    parameters: details.requiredParams,
  })),
});

const createAgenticContext = ({ systemPrompt }) => ({
  agent_role: "AI Engineering Tutor",
  agent_objectives: ["Provide accurate, clear, and helpful answers.", "Intelligently use available tools to fulfill user requests."],
  long_term_goals: ["Help the user learn and solve complex engineering problems."],
  constraints: ["Base answers on provided context when available.", "Do not hallucinate facts.", "Adhere to safety guidelines."],
  base_instructions: systemPrompt,
});

const createThreadContext = ({ sessionId, userId, history }) => ({
  thread_id: sessionId,
  user_id: userId,
  prior_interactions_summary: null,
});

module.exports = {
    createModelContext,
    createAgenticContext,
    createThreadContext,
};
```

`server/rag_service/academic_search.py`

```python
# server/rag_service/academic_search.py
import requests
import xml.etree.ElementTree as ET
import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

def search_arxiv(query: str, max_results: int = 3) -> List[Dict[str, Any]]:
    """Searches the ArXiv API for papers."""
    base_url = 'http://export.arxiv.org/api/query?'
    search_query = f'search_query=all:{query}&start=0&max_results={max_results}&sortBy=relevance'
    
    logger.info(f"Querying ArXiv with: {query}")
    response = requests.get(base_url + search_query, timeout=10)
    response.raise_for_status()
    
    root = ET.fromstring(response.content)
    papers = []
    for entry in root.findall('{http://www.w3.org/2005/Atom}entry'):
        paper = {
            'source': 'ArXiv',
            'title': entry.find('{http://www.w3.org/2005/Atom}title').text.strip(),
            'url': entry.find('{http://www.w3.org/2005/Atom}id').text.strip(),
            'summary': entry.find('{http://www.w3.org/2005/Atom}summary').text.strip(),
            'authors': [author.find('{http://www.w3.org/2005/Atom}name').text for author in entry.findall('{http://www.w3.org/2005/Atom}author')]
        }
        papers.append(paper)
    return papers

def search_semantic_scholar(query: str, max_results: int = 3) -> List[Dict[str, Any]]:
    """Searches the Semantic Scholar API."""
    base_url = 'https://api.semanticscholar.org/graph/v1/paper/search'
    params = {'query': query, 'limit': max_results, 'fields': 'title,url,abstract,authors'}
    
    logger.info(f"Querying Semantic Scholar with: {query}")
    response = requests.get(base_url, params=params, timeout=10)
    response.raise_for_status()
    
    data = response.json()
    papers = []
    if 'data' in data:
        for item in data['data']:
            paper = {
                'source': 'Semantic Scholar',
                'title': item.get('title'),
                'url': item.get('url'),
                'summary': item.get('abstract'),
                'authors': [author['name'] for author in item.get('authors', []) if 'name' in author]
            }
            papers.append(paper)
    return papers

def search_all_apis(query: str, max_results_per_api: int = 3) -> List[Dict[str, Any]]:
    """Searches all configured academic APIs and aggregates results."""
    all_results = []
    
    api_functions = {
        'ArXiv': search_arxiv,
        'Semantic Scholar': search_semantic_scholar
    }
    
    for api_name, search_func in api_functions.items():
        try:
            results = search_func(query, max_results=max_results_per_api)
            all_results.extend(results)
            logger.info(f"Found {len(results)} results from {api_name}.")
        except Exception as e:
            logger.warning(f"Could not retrieve results from {api_name}: {e}")
            
    # Simple de-duplication based on title to avoid showing the same paper from two sources
    unique_results = {paper['title'].lower(): paper for paper in all_results if paper.get('title')}.values()
    
    return list(unique_results)
```

`server/rag_service/ai_core.py`

```python
# ./ai_core.py

# Standard Library Imports
import logging
import os
import io
import re
import copy
import uuid
from typing import Any, Callable, Dict, List, Optional, Union
from datetime import datetime # For improved date parsing in metadata

# --- Global Initializations ---
logger = logging.getLogger(__name__)

# --- Configuration Import ---
try:
    import config # This should import server/config.py
except ImportError as e:
    logger.critical(f"CRITICAL: Failed to import 'config' (expected server/config.py): {e}. ")
    # Depending on how critical config is, you might want to sys.exit(1)
    # For now, we'll let it proceed and other parts will fail if config isn't loaded.


# Local aliases for config flags, models, constants, and classes from config.py
# Ensure all these are actually defined in your config.py
PYPDF_AVAILABLE = getattr(config, 'PYPDF_AVAILABLE', False)
PDFPLUMBER_AVAILABLE = getattr(config, 'PDFPLUMBER_AVAILABLE', False)
PANDAS_AVAILABLE = getattr(config, 'PANDAS_AVAILABLE', False)
DOCX_AVAILABLE = getattr(config, 'DOCX_AVAILABLE', False)
PPTX_AVAILABLE = getattr(config, 'PPTX_AVAILABLE', False)
PIL_AVAILABLE = getattr(config, 'PIL_AVAILABLE', False)
FITZ_AVAILABLE = getattr(config, 'FITZ_AVAILABLE', False)
PYTESSERACT_AVAILABLE = getattr(config, 'PYTESSERACT_AVAILABLE', False)
SPACY_MODEL_LOADED = getattr(config, 'SPACY_MODEL_LOADED', False)
PYPDF2_AVAILABLE = getattr(config, 'PYPDF2_AVAILABLE', False)
EMBEDDING_MODEL_LOADED = getattr(config, 'EMBEDDING_MODEL_LOADED', False)
MAX_TEXT_LENGTH_FOR_NER  = getattr(config, 'MAX_TEXT_LENGTH_FOR_NER', 500000)
LANGCHAIN_SPLITTER_AVAILABLE = getattr(config, 'LANGCHAIN_SPLITTER_AVAILABLE', False)

PYPDF_PDFREADERROR = getattr(config, 'PYPDF_PDFREADERROR', Exception)
TESSERACT_ERROR = getattr(config, 'TESSERACT_ERROR', Exception)

# Libraries and Models (ensure these are None if not available to prevent AttributeError)
pypdf = getattr(config, 'pypdf', None)
PyPDF2 = getattr(config, 'PyPDF2', None)
pdfplumber = getattr(config, 'pdfplumber', None)
pd = getattr(config, 'pd', None)
DocxDocument = getattr(config, 'DocxDocument', None)
Presentation = getattr(config, 'Presentation', None)
Image = getattr(config, 'Image', None)
fitz = getattr(config, 'fitz', None)
pytesseract = getattr(config, 'pytesseract', None)
nlp_spacy_core = getattr(config, 'nlp_spacy_core', None)
document_embedding_model = getattr(config, 'document_embedding_model', None)
RecursiveCharacterTextSplitter = getattr(config, 'RecursiveCharacterTextSplitter', None)

# Constants
AI_CORE_CHUNK_SIZE = getattr(config, 'AI_CORE_CHUNK_SIZE', 1024) # Default if not in config
AI_CORE_CHUNK_OVERLAP = getattr(config, 'AI_CORE_CHUNK_OVERLAP', 200) # Default if not in config
DOCUMENT_EMBEDDING_MODEL_NAME = getattr(config, 'DOCUMENT_EMBEDDING_MODEL_NAME', "unknown_model")


# ==============================================================================
# Phase 2: Unified Rich Element Extraction Layer
# ==============================================================================

# Standard Output Structure for Element Extractors
# {
#     'text_content': Optional[str],
#     'tables': List[Union[pd.DataFrame, List[List[str]]]],
#     'images': List[Image.Image],
#     'parser_metadata': Dict[str, Any],
#     'is_scanned_heuristic': bool
# }

def _make_empty_extraction_result() -> Dict[str, Any]:
    """Helper to create a default empty result structure."""
    return {
        'text_content': None,
        'tables': [],
        'images': [],
        'parser_metadata': {},
        'is_scanned_heuristic': False
    }

def _extract_pdf_elements(file_path: str) -> Dict[str, Any]:
    if not os.path.exists(file_path):
        logger.error(f"PDF file not found: {file_path}")
        return _make_empty_extraction_result()

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    extracted_text_parts = []

    # 1. Text and Table Extraction with pdfplumber (if available)
    if PDFPLUMBER_AVAILABLE and pdfplumber:
        try:
            with pdfplumber.open(file_path) as pdf:
                num_pages_plumber = len(pdf.pages)
                for i, page in enumerate(pdf.pages):
                    page_text = page.extract_text(x_tolerance=1, y_tolerance=1.5, layout=False) # layout=False for more raw text
                    if page_text and page_text.strip():
                        extracted_text_parts.append(page_text.strip())

                    # Extract tables
                    page_tables_data = page.extract_tables()
                    if page_tables_data:
                        for table_data_list in page_tables_data:
                            if not table_data_list: continue
                            if PANDAS_AVAILABLE and pd:
                                try:
                                    # Attempt to use first row as header if meaningful
                                    if len(table_data_list) > 1 and all(c is not None and isinstance(c, str) for c in table_data_list[0]):
                                        df = pd.DataFrame(table_data_list[1:], columns=table_data_list[0])
                                    else:
                                        df = pd.DataFrame(table_data_list)
                                    result['tables'].append(df)
                                except Exception as df_err:
                                    logger.warning(f"pdfplumber: DataFrame conversion error for table on page {i+1} of {file_base_name}: {df_err}. Storing as list.")
                                    result['tables'].append(table_data_list)
                            else:
                                result['tables'].append(table_data_list)
                
                result['text_content'] = "\n\n".join(extracted_text_parts).strip() or None
                if result['tables']: logger.info(f"pdfplumber: Extracted {len(result['tables'])} tables from {file_base_name}.")

                # Scanned PDF Heuristic (based on pdfplumber text)
                if num_pages_plumber > 0:
                    total_chars = sum(len(pt.replace(" ", "")) for pt in extracted_text_parts)
                    avg_chars_per_page = total_chars / num_pages_plumber
                    # Heuristic: low average characters per page suggests scanned
                    if avg_chars_per_page < 20 and total_chars < (num_pages_plumber * 50): # Tunable thresholds
                        result['is_scanned_heuristic'] = True
                        logger.info(f"PDF {file_base_name} potentially scanned (low avg text [{avg_chars_per_page:.1f} chars/page] from pdfplumber).")

        except Exception as e_plumber:
            logger.warning(f"pdfplumber: Error processing PDF {file_base_name}: {e_plumber}", exc_info=True)
            # If pdfplumber fails, pypdf (now pypdf) can be a fallback for basic text
            if PYPDF_AVAILABLE and pypdf and not result['text_content']:
                logger.info(f"Attempting pypdf fallback for text extraction from {file_base_name}")
                try:
                    reader = pypdf.PdfReader(file_path)
                    pypdf_text_parts = []
                    for page in reader.pages:
                        page_text = page.extract_text()
                        if page_text and page_text.strip():
                            pypdf_text_parts.append(page_text.strip())
                    result['text_content'] = "\n\n".join(pypdf_text_parts).strip() or None
                except Exception as e_pypdf:
                    logger.warning(f"pypdf fallback also failed for {file_base_name}: {e_pypdf}")


    # 2. Image Extraction with Fitz (PyMuPDF)
    if FITZ_AVAILABLE and fitz and PIL_AVAILABLE and Image:
        try:
            doc_fitz = fitz.open(file_path)
            if not result['is_scanned_heuristic'] and not result['text_content'] and len(doc_fitz) > 0:
                # If no text from plumber/pypdf, but fitz finds pages, highly likely scanned.
                result['is_scanned_heuristic'] = True
                logger.info(f"PDF {file_base_name} likely scanned (no text extracted, but pages found by fitz).")

            for page_idx in range(len(doc_fitz)):
                for img_info_tuple in doc_fitz.get_page_images(page_idx):
                    xref = img_info_tuple[0]
                    try:
                        img_bytes_dict = doc_fitz.extract_image(xref)
                        if img_bytes_dict and "image" in img_bytes_dict:
                             result['images'].append(Image.open(io.BytesIO(img_bytes_dict["image"])))
                    except Exception as img_err:
                        logger.warning(f"fitz: Could not extract/open image xref {xref} from page {page_idx} of {file_base_name}: {img_err}")
            if result['images']: logger.info(f"fitz: Extracted {len(result['images'])} images from {file_base_name}.")
            doc_fitz.close()
        except Exception as e_fitz:
            logger.warning(f"fitz: Error processing PDF {file_base_name} for images: {e_fitz}", exc_info=True)

    # 3. Metadata with PyPDF2 (or pypdf if PyPDF2 not available/fails)
    metadata_extractor = None
    if PYPDF2_AVAILABLE and PyPDF2:
        metadata_extractor = PyPDF2.PdfReader
        extractor_name = "PyPDF2"
    elif PYPDF_AVAILABLE and pypdf: # Fallback to pypdf for metadata
        metadata_extractor = pypdf.PdfReader
        extractor_name = "pypdf"

    if metadata_extractor:
        try:
            with open(file_path, 'rb') as f:
                reader = metadata_extractor(f)
                info = reader.metadata
                if info:
                    if hasattr(info, 'title') and info.title: result['parser_metadata']['title'] = str(info.title).strip()
                    if hasattr(info, 'author') and info.author: result['parser_metadata']['author'] = str(info.author).strip()
                    
                    pdf_date_formats = [
                        "D:%Y%m%d%H%M%S%z",    
                        "D:%Y%m%d%H%M%S",
                        "D:%Y%m%d%H%M%SZ",
                        "%Y%m%d%H%M%S%z",
                        "%Y%m%d%H%M%S",
                        "%Y%m%d%H%M%SZ",
                    ]
                    def parse_pdf_date(date_val_str_or_dt):
                        if isinstance(date_val_str_or_dt, datetime): return date_val_str_or_dt
                        if not isinstance(date_val_str_or_dt, str): return None
                        clean_date_str = date_val_str_or_dt.strip().rstrip("'")
                        for fmt in pdf_date_formats:
                            try: return datetime.strptime(clean_date_str, fmt)
                            except ValueError: continue
                        return None
                    

                    raw_creation_date = info.get("/CreationDate") if isinstance(info, dict) else getattr(info, 'creation_date', None)
                    creation_date_obj = parse_pdf_date(raw_creation_date)

                    if creation_date_obj: result['parser_metadata']['creation_date'] = creation_date_obj.isoformat()
                    
                    raw_mod_date = info.get("/ModDate") if isinstance(info, dict) else getattr(info, 'modification_date', None)
                    modification_date_obj = parse_pdf_date(raw_mod_date)
                    
                    if modification_date_obj: result['parser_metadata']['modification_date'] = modification_date_obj.isoformat()

                result['parser_metadata']['page_count'] = len(reader.pages)
        except Exception as e_meta:
            logger.warning(f"Metadata: Error using {extractor_name} for {file_base_name}: {e_meta}", exc_info=True)
            if 'page_count' not in result['parser_metadata'] and FITZ_AVAILABLE and fitz: # Fallback page count
                try:
                    doc_fitz_pc = fitz.open(file_path)
                    result['parser_metadata']['page_count'] = len(doc_fitz_pc)
                    doc_fitz_pc.close()
                except: pass


    return result

def _extract_docx_elements(file_path: str) -> Dict[str, Any]:
    if not (DOCX_AVAILABLE and DocxDocument and PIL_AVAILABLE and Image):
        logger.error("python-docx or Pillow not available. DOCX parsing will be limited.")
        return _make_empty_extraction_result()
    
    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    text_content_parts = []

    try:
        doc = DocxDocument(file_path)
        # Text
        for para in doc.paragraphs:
            if para.text.strip():
                text_content_parts.append(para.text.strip())
        result['text_content'] = "\n".join(text_content_parts).strip() or None

        # Tables
        for i, table in enumerate(doc.tables):
            table_list = [[cell.text.strip() for cell in row.cells] for row in table.rows]
            if not table_list: continue
            if PANDAS_AVAILABLE and pd:
                try:
                    if len(table_list) > 1 and all(c for c in table_list[0]): # Use first row as header
                        result['tables'].append(pd.DataFrame(table_list[1:], columns=table_list[0]))
                    else:
                        result['tables'].append(pd.DataFrame(table_list))
                except Exception as df_err:
                    logger.warning(f"docx: DataFrame conversion error for table {i} in {file_base_name}: {df_err}. Storing as list.")
                    result['tables'].append(table_list)
            else:
                result['tables'].append(table_list)
        if result['tables']: logger.info(f"docx: Extracted {len(result['tables'])} tables from {file_base_name}.")

        # Images (Inline shapes)
        for rel_id, image_part in doc.part.image_parts:
             try:
                 img = Image.open(io.BytesIO(image_part.blob))
                 result['images'].append(img)
             except Exception as e_img:
                 logger.warning(f"docx: Error processing an image from {file_base_name}: {e_img}")
        # A more thorough way for inline_shapes if doc.part.image_parts is not sufficient:
        # for shape in doc.inline_shapes:
        #    if shape.type == MSO_SHAPE_TYPE.PICTURE: # Requires from docx.enum.shape import MSO_SHAPE_TYPE
        #        try:
        #            image_part = doc.part.related_parts[shape._inline.graphic.graphicData.pic.blipFill.blip.embed]
        #            img = Image.open(io.BytesIO(image_part.blob))
        #            result['images'].append(img)
        #        except Exception: pass # ignore if not an image or error
        if result['images']: logger.info(f"docx: Extracted {len(result['images'])} images from {file_base_name}.")


        # Metadata
        props = doc.core_properties
        if props.title: result['parser_metadata']['title'] = props.title
        if props.author: result['parser_metadata']['author'] = props.author
        if props.created: result['parser_metadata']['creation_date'] = props.created.isoformat()
        if props.modified: result['parser_metadata']['modification_date'] = props.modified.isoformat()
        result['parser_metadata']['page_count'] = len(doc.paragraphs) // 20 or 1 # Rough estimate

        # Scanned Heuristic
        if not result['text_content'] and result['images']:
            result['is_scanned_heuristic'] = True
            logger.info(f"DOCX {file_base_name} potentially image-based (no text, images present).")

    except FileNotFoundError:
        logger.error(f"docx: File not found: {file_path}")
    except Exception as e:
        logger.error(f"docx: Error parsing DOCX {file_base_name}: {e}", exc_info=True)
    
    return result

def _extract_pptx_elements(file_path: str) -> Dict[str, Any]:
    if not (PPTX_AVAILABLE and Presentation and PIL_AVAILABLE and Image):
        logger.error("python-pptx or Pillow not available. PPTX parsing will be limited.")
        return _make_empty_extraction_result()

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    text_content_parts = []

    try:
        prs = Presentation(file_path)
        for slide_idx, slide in enumerate(prs.slides):
            slide_texts = []
            for shape in slide.shapes:
                if hasattr(shape, "text_frame") and shape.text_frame and shape.text_frame.text.strip():
                    slide_texts.append(shape.text_frame.text.strip())
                elif hasattr(shape, "text") and shape.text.strip(): # For shapes with direct text
                    slide_texts.append(shape.text.strip())
                
                # Image extraction
                if hasattr(shape, "image"): # If shape is an image
                    try:
                        image_bytes = shape.image.blob
                        img = Image.open(io.BytesIO(image_bytes))
                        result['images'].append(img)
                    except Exception as e_img_shape:
                        logger.warning(f"pptx: Error extracting image from shape on slide {slide_idx} of {file_base_name}: {e_img_shape}")
            
            if slide_texts:
                text_content_parts.append("\n".join(slide_texts))
        
        result['text_content'] = "\n\n".join(text_content_parts).strip() or None
        if result['images']: logger.info(f"pptx: Extracted {len(result['images'])} images from {file_base_name}.")

        # Metadata
        props = prs.core_properties
        if props.title: result['parser_metadata']['title'] = props.title
        if props.author: result['parser_metadata']['author'] = props.author
        if props.created: result['parser_metadata']['creation_date'] = props.created.isoformat()
        if props.last_modified_by : result['parser_metadata']['last_modified_by'] = props.last_modified_by
        if props.modified : result['parser_metadata']['modification_date'] = props.modified.isoformat()

        result['parser_metadata']['page_count'] = len(prs.slides)

        # Scanned Heuristic
        if not result['text_content'] and result['images']:
            result['is_scanned_heuristic'] = True
            logger.info(f"PPTX {file_base_name} potentially image-based (no text, images present).")

    except FileNotFoundError:
        logger.error(f"pptx: File not found: {file_path}")
    except Exception as e:
        logger.error(f"pptx: Error parsing PPTX {file_base_name}: {e}", exc_info=True)

    return result

def _extract_csv_elements(file_path: str) -> Dict[str, Any]:
    if not (PANDAS_AVAILABLE and pd):
        logger.error("pandas not available. CSV parsing will be limited.")
        return _extract_generic_text_elements(file_path, ".csv") # Fallback to text

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    try:
        df = pd.read_csv(file_path)
        result['tables'].append(df)
        # Create a text representation of the CSV for text_content
        # Could be markdown, simple string, or first N rows.
        # Using to_string() for now. Consider to_markdown() for better structure if text will be LLM input.
        result['text_content'] = df.to_string(index=False, na_rep='NULL').strip() or None
        logger.info(f"csv: Extracted 1 table (shape: {df.shape}) from {file_base_name}.")
    except FileNotFoundError:
        logger.error(f"csv: File not found: {file_path}")
    except Exception as e:
        logger.error(f"csv: Error parsing CSV {file_base_name}: {e}", exc_info=True)
        # Fallback to generic text if pandas fails
        return _extract_generic_text_elements(file_path, ".csv")
    return result


def _extract_generic_text_elements(file_path: str, file_type_ext: str) -> Dict[str, Any]:
    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            text = f.read()
        result['text_content'] = text.strip() or None
        
        # For HTML/XML, optionally strip tags (basic)
        if file_type_ext in ['.html', '.xml'] and result['text_content']:
            stripped_text = re.sub(r'<[^>]+>', ' ', result['text_content'])
            result['text_content'] = re.sub(r'\s+', ' ', stripped_text).strip() or None

    except FileNotFoundError:
        logger.error(f"txt-like: File not found: {file_path}")
    except Exception as e:
        logger.error(f"txt-like: Error parsing {file_base_name}: {e}", exc_info=True)
    return result

def _extract_image_file_elements(file_path: str) -> Dict[str, Any]:
    if not (PIL_AVAILABLE and Image):
        logger.error("Pillow (PIL) not available. Image file parsing will fail.")
        return _make_empty_extraction_result()

    result = _make_empty_extraction_result()
    file_base_name = os.path.basename(file_path)
    try:
        img = Image.open(file_path)
        result['images'].append(img)
        result['is_scanned_heuristic'] = True # By definition, an image file is "scanned" for OCR
        logger.info(f"Image file {file_base_name} opened.")
    except FileNotFoundError:
        logger.error(f"image-file: File not found: {file_path}")
    except Exception as e:
        logger.error(f"image-file: Error opening {file_base_name}: {e}", exc_info=True)
    return result


def _get_rich_extraction_results(file_path: str) -> Dict[str, Any]:
    """Dispatcher for rich element extraction based on file type."""
    ext = os.path.splitext(file_path)[1].lower()
    logger.info(f"Rich extraction: Dispatching for file type '{ext}' ({os.path.basename(file_path)})")

    if ext == '.pdf':
        return _extract_pdf_elements(file_path)
    elif ext == '.docx':
        return _extract_docx_elements(file_path)
    elif ext == '.pptx':
        return _extract_pptx_elements(file_path)
    elif ext == '.csv':
        return _extract_csv_elements(file_path)
    elif ext in ['.txt', '.py', '.js', '.md', '.log', '.html', '.xml', '.json']:
        return _extract_generic_text_elements(file_path, ext)
    elif ext in ['.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.gif']:
        return _extract_image_file_elements(file_path)
    else:
        logger.warning(f"Unsupported file extension for rich extraction: {ext} ({os.path.basename(file_path)}). Attempting generic text.")
        return _extract_generic_text_elements(file_path, ext) # Fallback for unknown types


# ==============================================================================
# Phase 3: Streamlined Main Processing Pipeline
# ==============================================================================

def _get_initial_parsed_document(file_path: str) -> Dict[str, Any]:
    """Calls the appropriate rich element extractor for the file."""
    return _get_rich_extraction_results(file_path)


# --- Stages 2-7 (OCR, Cleaning, Layout, Metadata, Chunking, Embedding) ---
# These functions are largely the same as your corrected versions, but will now consume
# the structured output from _get_initial_parsed_document.

def perform_ocr_on_images(image_objects: List[Any], file_base_name_for_log: str ="") -> str: # Added filename for logging
    if not image_objects: return ""
    if not (PYTESSERACT_AVAILABLE and pytesseract):
        logger.error(f"Pytesseract not available. OCR for {file_base_name_for_log} cannot be performed.")
        return ""

    logger.info(f"Performing OCR on {len(image_objects)} image(s) for {file_base_name_for_log}.")
    ocr_text_parts = []
    images_ocrd = 0
    for i, img_obj in enumerate(image_objects):
        try:
            if not (PIL_AVAILABLE and Image and isinstance(img_obj, Image.Image)):
                logger.warning(f"Skipping non-PIL Image object at index {i} for OCR of {file_base_name_for_log}.")
                continue
            # Improve image for OCR: convert to grayscale, potentially apply thresholding if needed
            processed_img_for_ocr = img_obj.convert('L') # Grayscale
            text = pytesseract.image_to_string(processed_img_for_ocr)
            if text and text.strip():
                ocr_text_parts.append(text.strip())
                images_ocrd += 1
        except Exception as e:
            if TESSERACT_ERROR and isinstance(e, TESSERACT_ERROR): # Check specific Tesseract error
                logger.critical(f"Tesseract executable not found or error for {file_base_name_for_log}. OCR will fail. Error: {e}")
                # Re-raise if it's a critical setup issue that will affect all subsequent OCR
                # For now, we'll let it try other images, but this indicates a setup problem.
            logger.error(f"Error during OCR for image {i+1}/{len(image_objects)} of {file_base_name_for_log}: {e}", exc_info=True)
    
    full_ocr_text = "\n\n--- OCR Text from Image ---\n\n".join(ocr_text_parts).strip()
    logger.info(f"OCR for {file_base_name_for_log}: Extracted {len(full_ocr_text)} chars from {images_ocrd} image(s).")
    return full_ocr_text


def clean_and_normalize_text_content(text: str, file_base_name_for_log: str ="") -> str:
    if not text or not text.strip(): return ""
    logger.info(f"Text cleaning for {file_base_name_for_log}: Initial length {len(text)}")
    
    # Basic regex cleaning (order matters)
    text = re.sub(r'<script[^>]*>.*?</script>|<style[^>]*>.*?</style>', ' ', text, flags=re.I | re.S) # Remove script/style
    text = re.sub(r'<[^>]+>', ' ', text) # Remove all other HTML tags
    text = re.sub(r'http\S+|www\S+|https\S+', '', text, flags=re.MULTILINE) # Remove URLs
    text = re.sub(r'\S*@\S*\s?', '', text, flags=re.MULTILINE) # Remove emails
    text = re.sub(r'\s*&\w+;\s*', ' ', text) # Remove HTML entities like  
    text = re.sub(r'[\n\r\t]+', ' ', text) # Normalize whitespace (newlines, tabs to single space)
    text = re.sub(r'\s+', ' ', text).strip() # Consolidate multiple spaces to one and strip ends
    
    # Character filtering (allow more common punctuation useful for context)
    # text = re.sub(r'[^\w\s.,!?"\'():;-]', '', text) # Keeps more standard punctuation
    # For more aggressive cleaning for embedding, you might use:
    text = re.sub(r'[^a-zA-Z0-9\s.,!?-]', '', text) # More restrictive, closer to your original

    text_lower = text.lower() # Convert to lowercase AFTER regex to preserve case for URLs/emails if needed

    if not (SPACY_MODEL_LOADED and nlp_spacy_core):
        logger.warning(f"SpaCy model not loaded for {file_base_name_for_log}. Skipping lemmatization. Returning regex-cleaned text.")
        return text_lower
    
    try:
        # Process in chunks if text is very long to avoid SpaCy memory issues, though less likely after cleaning
        max_spacy_len = 1000000 # SpaCy's default internal limit for nlp()
        if len(text_lower) > max_spacy_len:
            logger.warning(f"Text for SpaCy in {file_base_name_for_log} exceeds {max_spacy_len} chars. Processing in parts or truncating.")
            # Simple truncation for now, chunking for spacy is more complex
            text_lower = text_lower[:max_spacy_len]

        doc = nlp_spacy_core(text_lower, disable=['parser', 'ner']) # Disable unused pipes
        lemmatized_tokens = [
            token.lemma_ for token in doc 
            if not token.is_stop and \
               not token.is_punct and \
               not token.is_space and \
               len(token.lemma_) > 1 and \
               token.lemma_ != '-PRON-' # Exclude pronouns after lemmatization
        ]
        final_cleaned_text = " ".join(lemmatized_tokens)
        logger.info(f"SpaCy cleaning for {file_base_name_for_log}: Final length {len(final_cleaned_text)}")
        return final_cleaned_text
    except Exception as e:
        logger.error(f"SpaCy processing failed for {file_base_name_for_log}: {e}. Returning pre-SpaCy cleaned text.", exc_info=True)
        return text_lower


def reconstruct_document_layout(text_content: str, tables_data: List[Any], file_type: str, file_base_name_for_log: str ="") -> str:
    if not text_content and not tables_data: return ""
    logger.info(f"Layout reconstruction for {file_base_name_for_log} ({file_type}): Text len {len(text_content)}, Tables {len(tables_data)}")
    
    # Hyphenated word de-joining (if text_content is not None)
    processed_text = text_content if text_content else ""
    processed_text = re.sub(r'(\w+)-\s*\n\s*(\w+)', r'\1\2', processed_text) # Across newlines
    # processed_text = re.sub(r'(\w+)-(\w+)', r'\1\2', processed_text) # Within same line (less common needed after initial parse)

    if tables_data:
        table_md_parts = []
        for i, table_obj in enumerate(tables_data):
            table_header = f"\n\n[START OF TABLE {i+1} extracted from {file_base_name_for_log}]\n"
            table_footer = f"\n[END OF TABLE {i+1}]\n"
            md_table_content = ""
            try:
                if PANDAS_AVAILABLE and pd and isinstance(table_obj, pd.DataFrame):
                    md_table_content = table_obj.to_markdown(index=False)
                elif isinstance(table_obj, list) and table_obj and all(isinstance(row, list) for row in table_obj):
                    # Basic list of lists to Markdown
                    if table_obj[0]: # Assume first row is header
                        md_table_content = "| " + " | ".join(map(str, table_obj[0])) + " |\n"
                        md_table_content += "| " + " | ".join(["---"] * len(table_obj[0])) + " |\n"
                        for row_data in table_obj[1:]:
                            if len(row_data) == len(table_obj[0]):
                                md_table_content += "| " + " | ".join(map(str, row_data)) + " |\n"
                            else: logger.warning(f"Table {i+1} (list) row length mismatch in {file_base_name_for_log}.")
                    else: md_table_content = "[Empty Table Data]"
                else: md_table_content = str(table_obj) # Fallback
            except Exception as e_table_md:
                logger.warning(f"Table {i+1} to Markdown conversion error for {file_base_name_for_log}: {e_table_md}. Using raw string.")
                md_table_content = str(table_obj)
            
            if md_table_content.strip():
                table_md_parts.append(table_header + md_table_content.strip() + table_footer)
        
        if table_md_parts:
            processed_text += "\n\n" + "\n\n".join(table_md_parts)
    
    # Final whitespace cleanup
    final_layout_text = re.sub(r'\s{2,}', ' ', processed_text).strip() # Consolidate multiple spaces
    logger.info(f"Layout reconstruction for {file_base_name_for_log}: Final length {len(final_layout_text)}")
    return final_layout_text


def extract_document_metadata_info(
    file_path: str, 
    processed_text: str, 
    parsed_doc_elements: Dict[str, Any], # Output from _get_initial_parsed_document
    original_file_name: str, 
    user_id: str
) -> Dict[str, Any]:
    logger.info(f"Metadata extraction for: {original_file_name} (User: {user_id})")
    
    parser_meta = parsed_doc_elements.get('parser_metadata', {})
    file_type_from_parser = os.path.splitext(original_file_name)[1].lower() # Fallback if not in parser_meta

    doc_meta = {
        'file_name': original_file_name,
        'file_path_on_server': file_path,
        'original_file_type': parser_meta.get('file_type', file_type_from_parser),
        'processing_user': user_id,
        'title': parser_meta.get('title', original_file_name), # Prioritize parser title
        'author': parser_meta.get('author', "Unknown"),       # Prioritize parser author
        'creation_date': parser_meta.get('creation_date'),   # Expect ISO format from parser
        'modification_date': parser_meta.get('modification_date'), # Expect ISO format
        'page_count': parser_meta.get('page_count', 0),
        'char_count_processed_text': len(processed_text),
        'named_entities': {},
        'structural_elements': "Paragraphs" + (", Tables" if parsed_doc_elements.get('tables') else ""),
        'is_scanned_document': parsed_doc_elements.get('is_scanned_heuristic', False), # Initial guess
        'ocr_applied': False # Will be set to True if OCR text was actually used
    }

    # OS-level metadata (can augment or be overridden by parser_meta)
    try:
        doc_meta['file_size_bytes'] = os.path.getsize(file_path)
        if PANDAS_AVAILABLE and pd: # Using pandas for robust timestamp conversion
            # Only set OS dates if not already provided by a more specific parser
            if not doc_meta['creation_date']:
                 doc_meta['creation_date_os'] = pd.Timestamp(os.path.getctime(file_path), unit='s').isoformat()
            if not doc_meta['modification_date']:
                 doc_meta['modification_date_os'] = pd.Timestamp(os.path.getmtime(file_path), unit='s').isoformat()
    except Exception as e_os_meta:
        logger.warning(f"Metadata: OS metadata error for {original_file_name}: {e_os_meta}")

    # If page_count is still 0 after parser, estimate from text
    if doc_meta['page_count'] == 0 and processed_text:
        doc_meta['page_count'] = max(1, processed_text.count('\n\n') + 1) # Rough estimate

    # NER (Named Entity Recognition) - using SpaCy
    if processed_text and SPACY_MODEL_LOADED and nlp_spacy_core:
        logger.info(f"Extracting named entities for {original_file_name}...")
        try:
            text_for_ner = processed_text[:MAX_TEXT_LENGTH_FOR_NER] # Use config alias
            spacy_doc = nlp_spacy_core(text_for_ner) # NER pipe should be enabled by default
            
            entities_by_type = {}
            for ent in spacy_doc.ents:
                entities_by_type.setdefault(ent.label_, set()).add(ent.text)
            
            doc_meta['named_entities'] = {label: sorted(list(texts)) for label, texts in entities_by_type.items()}
            num_entities_found = sum(len(v) for v in doc_meta['named_entities'].values())
            logger.info(f"Extracted {num_entities_found} unique named entities for {original_file_name}.")
        except Exception as e_ner:
            logger.error(f"Metadata: NER error for {original_file_name}: {e_ner}", exc_info=True)
    else:
        logger.info(f"Skipping NER for {original_file_name} (no text or SpaCy model not loaded/configured for NER).")
    
    logger.info(f"Metadata extraction complete for {original_file_name}.")
    return doc_meta

# Chunking and Embedding functions remain largely the same as your corrected versions,
# just ensure they consume the correct data.
def chunk_document_into_segments(
    text_to_chunk: str,
    document_level_metadata: Dict[str, Any] # This is the output from extract_document_metadata_info
) -> List[Dict[str, Any]]:
    if not text_to_chunk or not text_to_chunk.strip():
        logger.warning(f"Chunking: No text for {document_level_metadata.get('file_name', 'unknown')}.")
        return []

    if not (LANGCHAIN_SPLITTER_AVAILABLE and RecursiveCharacterTextSplitter):
        logger.error("RecursiveCharacterTextSplitter not available. Cannot chunk text.")
        return []
        
    chunk_s = AI_CORE_CHUNK_SIZE
    chunk_o = AI_CORE_CHUNK_OVERLAP
    original_doc_name_for_log = document_level_metadata.get('file_name', 'unknown_doc')
    logger.info(f"Chunking {original_doc_name_for_log}: Size={chunk_s}, Overlap={chunk_o}")
    
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=chunk_s,
        chunk_overlap=chunk_o,
        length_function=len,
        separators=["\n\n", "\n", ". ", " ", ""], 
        keep_separator=True # Consider if True or False is better for your LLM
    )

    try:
        raw_text_segments: List[str] = text_splitter.split_text(text_to_chunk)
    except Exception as e_split: 
        logger.error(f"Chunking: Error splitting text for {original_doc_name_for_log}: {e_split}", exc_info=True)
        return []
        
    output_chunks: List[Dict[str, Any]] = []
    # Use a more robust base name if original name contains problematic characters for reference
    base_file_name_for_ref = re.sub(r'[^a-zA-Z0-9_-]', '_', os.path.splitext(original_doc_name_for_log)[0])


    for i, segment_content in enumerate(raw_text_segments):
        if not segment_content.strip(): 
            logger.debug(f"Skipping empty chunk at index {i} for {original_doc_name_for_log}.")
            continue

        # Create a deep copy of document-level metadata for each chunk
        chunk_specific_metadata = copy.deepcopy(document_level_metadata)
        
        qdrant_point_id = str(uuid.uuid4()) # Unique ID for this chunk in Qdrant

        # Add chunk-specific details to its metadata
        chunk_specific_metadata['chunk_id'] = qdrant_point_id 
        chunk_specific_metadata['chunk_reference_name'] = f"{base_file_name_for_ref}_chunk_{i:04d}"
        chunk_specific_metadata['chunk_index'] = i
        chunk_specific_metadata['chunk_char_count'] = len(segment_content)
        # Remove potentially very large or redundant fields from chunk metadata if necessary
        # e.g., chunk_specific_metadata.pop('named_entities', None) if too verbose per chunk
        
        output_chunks.append({
            'id': qdrant_point_id, # This ID is for Qdrant
            'text_content': segment_content,
            'metadata': chunk_specific_metadata # This payload goes into Qdrant
        })
    
    logger.info(f"Chunking: Split '{original_doc_name_for_log}' into {len(output_chunks)} non-empty chunks.")
    return output_chunks

def generate_segment_embeddings(document_chunks: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    if not document_chunks: return []
    if not (EMBEDDING_MODEL_LOADED and document_embedding_model):
        logger.error("Embedding model not loaded. Cannot generate embeddings.")
        for chunk_dict in document_chunks: chunk_dict['embedding'] = None
        return document_chunks

    model_name_for_logging = DOCUMENT_EMBEDDING_MODEL_NAME
    logger.info(f"Embedding {len(document_chunks)} chunks using {model_name_for_logging}.")
    
    texts_to_embed: List[str] = []
    valid_chunk_indices: List[int] = [] # To map embeddings back to original chunk objects

    for i, chunk_dict in enumerate(document_chunks):
        text_content = chunk_dict.get('text_content')
        if text_content and text_content.strip():
            texts_to_embed.append(text_content)
            valid_chunk_indices.append(i)
        else:
            chunk_dict['embedding'] = None # Ensure 'embedding' key exists
            logger.debug(f"Embedding: Chunk {chunk_dict.get('id', i)} has no text, skipping.")

    if not texts_to_embed:
        logger.warning("Embedding: No text content found in chunks to generate embeddings.")
        return document_chunks

    try:
        embeddings_np_array = document_embedding_model.encode(texts_to_embed, show_progress_bar=True) # Set to True for long lists
        
        for i, original_chunk_idx in enumerate(valid_chunk_indices):
            if i < len(embeddings_np_array):
                document_chunks[original_chunk_idx]['embedding'] = embeddings_np_array[i].tolist()
            else: # Should not happen if encode works correctly
                logger.error(f"Embedding: Mismatch in embedding count for chunk at original index {original_chunk_idx}.")
                document_chunks[original_chunk_idx]['embedding'] = None
        
        logger.info(f"Embedding: Generated and assigned embeddings to {len(valid_chunk_indices)} chunks.")
    except Exception as e_embed:
        logger.error(f"Embedding: Error during generation with {model_name_for_logging}: {e_embed}", exc_info=True)
        for original_chunk_idx in valid_chunk_indices: # Ensure all attempted chunks get None on error
            document_chunks[original_chunk_idx]['embedding'] = None
            
    return document_chunks


# --- Main Orchestration Function ---
def process_document_for_qdrant(
    file_path: str, # Could be empty if text_content_override is used
    original_name: str,
    user_id: str,
    text_content_override: Optional[str] = None # NEW parameter
) -> tuple[List[Dict[str, Any]], Optional[str], List[Dict[str, Any]]]:
    """
    Main orchestrator for processing a document or raw text.
    Returns:
        - final_chunks_for_qdrant: List of chunks with embeddings for Qdrant.
        - text_for_node_analysis: Consolidated text for Node.js general analysis (FAQ, Topics).
        - chunks_for_kg_worker: List of chunks with metadata (no embeddings) for KG worker.
    """
    logger.info(f"ai_core: Orchestrating document processing for '{original_name}', user '{user_id}'")
    
    # Check if source is valid (either text_content_override or existing file_path)
    if not text_content_override and not (file_path and os.path.exists(file_path)):
        logger.error(f"File not found at ai_core entry or no text_content_override: {file_path}")
        return [], None, []

    # Default return values for failure cases
    empty_qdrant_chunks = []
    no_analysis_text = None
    empty_kg_chunks = []

    try:
        initial_text_from_parser = None
        images_from_parser = []
        tables_from_parser = []
        is_scanned_heuristic = False
        file_type_from_parser = os.path.splitext(original_name)[1].lower() # Default type from original name

        if text_content_override:
            # If override is provided, use it directly, bypass file parsing.
            logger.info(f"ai_core: Using text_content_override for '{original_name}'.")
            initial_text_from_parser = text_content_override
            file_type_from_parser = "text_override" # Custom type for metadata for debugging/tracking
        else:
            # Original file parsing logic
            parsed_doc_elements = _get_initial_parsed_document(file_path)
            initial_text_from_parser = parsed_doc_elements.get('text_content')
            images_from_parser = parsed_doc_elements.get('images', [])
            tables_from_parser = parsed_doc_elements.get('tables', [])
            is_scanned_heuristic = parsed_doc_elements.get('is_scanned_heuristic', False)
            file_type_from_parser = os.path.splitext(original_name)[1].lower() # Or get from parsed_doc_elements if available

        # 2. OCR if needed (only if content was from a file/images and not explicitly overridden)
        ocr_text_output = ""
        ocr_applied_flag = False
        
        # Decide if OCR is necessary:
        # Only try OCR if there's no initial text (from parser or override) AND images were found
        # OR if it's explicitly an image file type and no override.
        should_ocr = (not text_content_override) and \
                     (is_scanned_heuristic or \
                      (file_type_from_parser in ['.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.gif']) or \
                      (not initial_text_from_parser and images_from_parser) or \
                      (initial_text_from_parser and len(initial_text_from_parser) < 200 * len(images_from_parser) and images_from_parser))

        if should_ocr and images_from_parser:
            if PYTESSERACT_AVAILABLE and pytesseract:
                logger.info(f"OCR triggered for {original_name} based on heuristics/file type.")
                ocr_text_output = perform_ocr_on_images(images_from_parser, original_name)
                if ocr_text_output: ocr_applied_flag = True
            else:
                logger.warning(f"OCR needed for {original_name} but Pytesseract not available. Content may be incomplete.")
        
        # 3. Combine Text (Parser/Override + OCR)
        combined_raw_text_parts = []
        if initial_text_from_parser: combined_raw_text_parts.append(initial_text_from_parser)
        if ocr_text_output: combined_raw_text_parts.append(ocr_text_output)
        combined_raw_text = "\n\n".join(combined_raw_text_parts).strip()

        if not combined_raw_text and not tables_from_parser:
            logger.warning(f"No text content or tables for {original_name} after initial parsing/OCR. Processing cannot continue.")
            return empty_qdrant_chunks, no_analysis_text, empty_kg_chunks

        # 4. Clean Text
        cleaned_text = clean_and_normalize_text_content(combined_raw_text, original_name)
        if not cleaned_text and not tables_from_parser: # If cleaning results in empty text
            logger.warning(f"No meaningful text for {original_name} after cleaning, and no tables. Processing cannot continue.")
            return empty_qdrant_chunks, no_analysis_text, empty_kg_chunks

        # 5. Reconstruct Layout (Integrate Tables as Markdown)
        text_for_further_processing = reconstruct_document_layout(
            cleaned_text, # Use the cleaned text
            tables_from_parser,
            file_type_from_parser,
            original_name
        )
        raw_text_for_node_analysis = text_for_further_processing 

        # 6. Extract Comprehensive Metadata
        doc_metadata = extract_document_metadata_info(
            file_path if not text_content_override else f"virtual://{original_name}", # Provide a sensible path for metadata if override
            text_for_further_processing, # Pass the final text that will be chunked
            parsed_doc_elements if not text_content_override else {}, # Pass initial parse results or empty if override
            original_name,
            user_id
        )
        doc_metadata['ocr_applied'] = ocr_applied_flag # Update with actual OCR status
        doc_metadata['source_type_actual'] = file_type_from_parser # Capture true source type from URL processing

        # 7. Chunk Document
        chunks_with_metadata_for_qdrant_and_kg = chunk_document_into_segments(
            text_for_further_processing,
            doc_metadata # Pass rich metadata to chunks
        )
        if not chunks_with_metadata_for_qdrant_and_kg:
            logger.warning(f"No chunks produced for {original_name}. Cannot proceed with Qdrant/KG.")
            return empty_qdrant_chunks, raw_text_for_node_analysis, empty_kg_chunks

        # Prepare chunks for KG worker (these don't need embeddings yet)
        chunks_for_kg_worker = copy.deepcopy(chunks_with_metadata_for_qdrant_and_kg) 
        for chunk in chunks_for_kg_worker:
            chunk.pop('embedding', None) 

        # 8. Generate Embeddings for Qdrant chunks
        final_chunks_for_qdrant = generate_segment_embeddings(chunks_with_metadata_for_qdrant_and_kg)
        
        logger.info(f"ai_core: Successfully processed '{original_name}'. Generated {len(final_chunks_for_qdrant)} chunks for Qdrant.")
        return final_chunks_for_qdrant, raw_text_for_node_analysis, chunks_for_kg_worker

    except Exception as e:
        if TESSERACT_ERROR and isinstance(e, TESSERACT_ERROR):
            logger.critical(f"ai_core: Tesseract (OCR) not found processing {original_name}. OCR failed. Error: {e}", exc_info=False)
            raise
        
        logger.error(f"ai_core: Critical error processing {original_name}: {e}", exc_info=True)
        raise
```

`server/rag_service/app.py`

```python
# server/rag_service/app.py
import os
import sys
import traceback
from flask import Flask, request, jsonify, current_app, send_from_directory, after_this_request
import logging
import atexit
import uuid
import subprocess
import tempfile
import shutil
import json
import re
import knowledge_engine
import media_processor

from duckduckgo_search import DDGS
from qdrant_client import models as qdrant_models

import subprocess
import tempfile
import shutil
import json

# --- Add server directory to sys.path ---
SERVER_DIR = os.path.dirname(os.path.abspath(__file__))
if SERVER_DIR not in sys.path:
    sys.path.insert(0, SERVER_DIR)

import config
config.setup_logging()

# --- Import configurations and services ---
try:
    from vector_db_service import VectorDBService
    import ai_core
    import neo4j_handler 
    from neo4j import exceptions as neo4j_exceptions
    import document_generator
    import podcast_generator
    import google.generativeai as genai
    from prompts import CODE_ANALYSIS_PROMPT_TEMPLATE, TEST_CASE_GENERATION_PROMPT_TEMPLATE, EXPLAIN_ERROR_PROMPT_TEMPLATE, QUIZ_GENERATION_PROMPT_TEMPLATE
    import quiz_utils
    from academic_search import search_all_apis as academic_search

    if config.GEMINI_API_KEY:
        genai.configure(api_key=config.GEMINI_API_KEY)
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        LLM_MODEL = genai.GenerativeModel(config.GEMINI_MODEL_NAME, safety_settings=safety_settings)
    else:
        LLM_MODEL = None
        logging.getLogger(__name__).error("GEMINI_API_KEY not found, AI features will fail.")

    def llm_wrapper(prompt, api_key=None):
        """
        A flexible wrapper for the Gemini API that can use a provided per-request API key
        or fall back to the server's global key.
        """
        key_to_use = api_key or config.GEMINI_API_KEY
        if not key_to_use:
            raise ConnectionError("Gemini API Key is not configured for this request.")

        genai.configure(api_key=key_to_use)
        
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        model_instance = genai.GenerativeModel(config.GEMINI_MODEL_NAME, safety_settings=safety_settings)

        for attempt in range(3):
            try:
                response = model_instance.generate_content(prompt)
                if response.parts:
                    return "".join(part.text for part in response.parts if hasattr(part, 'text'))
                elif response.prompt_feedback and response.prompt_feedback.block_reason:
                     raise ValueError(f"Prompt blocked by API. Reason: {response.prompt_feedback.block_reason_message}")
                else:
                    logger.warning("LLM returned empty response without explicit block reason.")
                    return ""
            except Exception as e:
                logger.warning(f"LLM generation attempt {attempt + 1} failed: {e}")
                if attempt == 2: raise
        return ""

except ImportError as e:
    print(f"CRITICAL IMPORT ERROR: {e}.")
    sys.exit(1)

logger = logging.getLogger(__name__)
app = Flask(__name__)

GENERATED_DOCS_DIR = os.path.join(SERVER_DIR, 'generated_docs')
os.makedirs(GENERATED_DOCS_DIR, exist_ok=True)
app.config['GENERATED_DOCS_DIR'] = GENERATED_DOCS_DIR

# Initialize services
vector_service = None
try:
    vector_service = VectorDBService()
    vector_service.setup_collection()
    app.vector_service = vector_service
except Exception as e:
    logger.critical(f"Failed to initialize VectorDBService: {e}", exc_info=True)

try:
    neo4j_handler.init_driver()
except Exception as e:
    logger.critical(f"Neo4j driver failed to initialize: {e}.")
atexit.register(neo4j_handler.close_driver)

def create_error_response(message, status_code=500, details=None):
    log_message = f"API Error ({status_code}): {message}"
    if details: log_message += f" | Details: {details}"
    current_app.logger.error(log_message)
    response_payload = {"error": message}
    if details and status_code != 500: response_payload["details"] = details
    return jsonify(response_payload), status_code

# === API Endpoints ===

# This config is now cleaner. The platform-specific logic is handled in the route.
LANGUAGE_CONFIG = {
    "python": {
        "filename": "main.py",
        "compile_cmd": None,
        "run_cmd": [sys.executable, "main.py"]
    },
    "java": {
        "filename": "Main.java",
        "compile_cmd": ["javac", "-Xlint:all", "Main.java"],
        "run_cmd": ["java", "Main"]
    },
    "c": {
        "filename": "main.c",
        "compile_cmd": ["gcc", "main.c", "-o", "main", "-Wall", "-Wextra", "-pedantic"],
        "run_cmd": ["main"] # Just the base name
    },
    "cpp": {
        "filename": "main.cpp",
        "compile_cmd": ["g++", "main.cpp", "-o", "main", "-Wall", "-Wextra", "-pedantic"],
        "run_cmd": ["main"] # Just the base name
    }
}


# --- (START) Code Executor End Points ---

@app.route('/execute_code', methods=['POST'])
def execute_code():
    data = request.get_json()
    if not data:
        return create_error_response("Request must be JSON", 400)

    code = data.get('code')
    language = data.get('language', '').lower()
    test_cases = data.get('testCases', [])

    if not code or not language:
        return create_error_response("Missing 'code' or 'language'", 400)

    lang_config = LANGUAGE_CONFIG.get(language)
    if not lang_config:
        unsupported_message = f"Language '{language}' is not currently supported for execution."
        return jsonify({"compilationError": unsupported_message}), 200

    results = []
    temp_dir = tempfile.mkdtemp()
    
    try:
        source_path = os.path.join(temp_dir, lang_config["filename"])
        with open(source_path, 'w', encoding='utf-8') as f:
            f.write(code)

        if lang_config["compile_cmd"]:
            # --- THIS IS THE FIX for FileNotFoundError ---
            try:
                compile_process = subprocess.run(
                    lang_config["compile_cmd"], cwd=temp_dir, capture_output=True,
                    text=True, timeout=10, encoding='utf-8', check=False
                )
            except FileNotFoundError:
                compiler_name = lang_config["compile_cmd"][0]
                error_msg = f"Compiler Error: The '{compiler_name}' command was not found. Please ensure the required compiler for '{language}' is installed and that its 'bin' directory is in your system's PATH environment variable."
                logger.error(error_msg)
                return jsonify({"compilationError": error_msg}), 200
            # --- END OF FIX ---
                
            if compile_process.returncode != 0:
                error_output = (compile_process.stdout + "\n" + compile_process.stderr).strip()
                logger.warning(f"Compilation failed for {language}. Error: {error_output}")
                return jsonify({"compilationError": error_output}), 200

        for i, case in enumerate(test_cases):
            case_input = case.get('input', '')
            expected_output = str(case.get('expectedOutput', '')).strip()
            
            case_result = { "input": case_input, "expected": expected_output, "output": "", "error": None, "status": "fail" }

            try:
                # --- THIS IS THE FIX ---
                # Dynamically build the command with an absolute path for compiled languages
                run_command = lang_config["run_cmd"][:] # Make a copy

                if language in ["c", "cpp"]:
                    executable_name = run_command[0]
                    if os.name == 'nt':
                        executable_name += '.exe'
                    # Create the full, unambiguous path to the executable
                    absolute_executable_path = os.path.join(temp_dir, executable_name)
                    run_command[0] = absolute_executable_path
                # --- END OF FIX ---

                run_process = subprocess.run(
                    run_command, # Use the potentially modified command
                    cwd=temp_dir,
                    input=case_input,
                    capture_output=True, text=True, timeout=5, encoding='utf-8'
                )
                stdout = run_process.stdout.strip().replace('\r\n', '\n')
                stderr = run_process.stderr.strip()
                case_result["output"] = stdout

                if run_process.returncode != 0:
                    case_result["status"] = "error"
                    case_result["error"] = stderr or "Script failed with a non-zero exit code."
                elif stderr:
                     case_result["error"] = f"Warning (stderr):\n{stderr}"
                
                if case_result["status"] != "error":
                    if stdout == expected_output:
                        case_result["status"] = "pass"
                    else:
                        case_result["status"] = "fail"
                
            except subprocess.TimeoutExpired:
                case_result["status"] = "error"
                case_result["error"] = "Execution timed out after 5 seconds."
            except Exception as exec_err:
                case_result["status"] = "error"
                case_result["error"] = f"An unexpected error occurred during execution: {str(exec_err)}"
            results.append(case_result)
    finally:
        shutil.rmtree(temp_dir)

    return jsonify({"results": results}), 200

# ... (the rest of the file remains unchanged) ...

@app.route('/analyze_code', methods=['POST'])
def analyze_code_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    code, language, api_key = data.get('code'), data.get('language'), data.get('apiKey')
    
    if not all([code, language]):
        return create_error_response("Missing 'code' or 'language'", 400)
        
    try:
        prompt = CODE_ANALYSIS_PROMPT_TEMPLATE.format(language=language, code=code)
        analysis = llm_wrapper(prompt, api_key)
        return jsonify({"analysis": analysis}), 200
    except Exception as e:
        return create_error_response(f"Failed to analyze code: {str(e)}", 500)

@app.route('/generate_test_cases', methods=['POST'])
def generate_test_cases_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    code, language, api_key = data.get('code'), data.get('language'), data.get('apiKey')
    
    if not all([code, language]):
        return create_error_response("Missing 'code' or 'language'", 400)

    try:
        prompt = TEST_CASE_GENERATION_PROMPT_TEMPLATE.format(language=language, code=code)
        response_text = llm_wrapper(prompt, api_key)
        
        json_match = re.search(r'\[.*\]', response_text, re.DOTALL)
        if not json_match:
            raise ValueError("LLM response did not contain a valid JSON array for test cases.")
        
        test_cases = json.loads(json_match.group(0))
        return jsonify({"testCases": test_cases}), 200
    except Exception as e:
        return create_error_response(f"Failed to generate test cases: {str(e)}", 500)

@app.route('/explain_error', methods=['POST'])
def explain_error_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    code, language, error_message, api_key = data.get('code'), data.get('language'), data.get('errorMessage'), data.get('apiKey')
    
    if not all([code, language, error_message]):
        return create_error_response("Missing 'code', 'language', or 'errorMessage'", 400)
        
    try:
        prompt = EXPLAIN_ERROR_PROMPT_TEMPLATE.format(language=language, code=code, error_message=error_message)
        explanation = llm_wrapper(prompt, api_key)
        return jsonify({"explanation": explanation}), 200
    except Exception as e:
        return create_error_response(f"Failed to explain error: {str(e)}", 500)

# --- (END) Code Executor End Points ---

# --- (START) Quiz Generator End Points ---
@app.route('/generate_quiz', methods=['POST'])
def generate_quiz_route():
    if 'file' not in request.files:
        return create_error_response("No file part in the request", 400)
    
    file = request.files['file']
    quiz_option = request.form.get('quizOption', 'standard')
    api_key = request.form.get('api_key')
    
    quiz_option_map = {
        'quick': 5,
        'standard': 10,
        'deep_dive': 15,
        'comprehensive': 20
    }
    num_questions = quiz_option_map.get(quiz_option, 10) # Default to 10

    if file.filename == '':
        return create_error_response("No selected file", 400)
    if not api_key:
        return create_error_response("API Key is required for quiz generation", 400)

    temp_dir = tempfile.mkdtemp()
    try:
        filename = werkzeug_utils.secure_filename(file.filename)
        file_path = os.path.join(temp_dir, filename)
        file.save(file_path)

        logger.info(f"Quiz Gen: Processing uploaded file '{filename}' for text extraction.")
        document_text = quiz_utils.extract_text_for_quiz(file_path)

        if not document_text or not document_text.strip():
            return create_error_response("Could not extract any text from the provided document.", 422)

        prompt = QUIZ_GENERATION_PROMPT_TEMPLATE.format(
            num_questions=num_questions,
            document_text=document_text
        )
        
        logger.info(f"Quiz Gen: Sending prompt to LLM for {num_questions} questions.")
        response_text = llm_wrapper(prompt, api_key)
        
        json_match = re.search(r'\[.*\]', response_text, re.DOTALL)
        if not json_match:
            raise ValueError("LLM response did not contain a valid JSON array for the quiz.")
        
        quiz_data = json.loads(json_match.group(0))
        logger.info(f"Quiz Gen: Successfully generated and parsed {len(quiz_data)} questions.")
        
        return jsonify({"quiz": quiz_data}), 200

    except Exception as e:
        logger.error(f"Error during quiz generation: {e}", exc_info=True)
        return create_error_response(f"Quiz Generation failed: {str(e)}", 500)
    finally:
        shutil.rmtree(temp_dir)

# --- (END) Quiz Generator End Points ---

@app.route('/query', methods=['POST'])
def search_qdrant_documents():
    current_app.logger.info("--- /query Request (RAG + KG Search) ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    query_text = data.get('query')
    user_id = data.get('user_id')
    document_context_name = data.get('documentContextName')
    use_kg = data.get('use_kg_critical_thinking', False) 
    
    if not query_text or not user_id:
        return create_error_response("Missing 'query' or 'user_id'", 400)

    try:
        k = data.get('k', 5)
        
        facts_from_kg = ""
        if use_kg and document_context_name:
            current_app.logger.info(f"KG search is ENABLED for doc '{document_context_name}'.")
            try:
                facts_from_kg = neo4j_handler.search_knowledge_graph(user_id, document_context_name, query_text)
            except Exception as e_kg:
                logger.error(f"Error during KG search part of RAG query: {e_kg}", exc_info=True)
                facts_from_kg = "Note: An error occurred while searching the knowledge graph."
        else:
            current_app.logger.info("KG search is DISABLED for this query.")

        must_conditions = []
        if document_context_name:
            current_app.logger.info(f"Applying document context filter for vector search: '{document_context_name}'")
            must_conditions.append(qdrant_models.FieldCondition(
                key="file_name",
                match=qdrant_models.MatchValue(value=document_context_name)
            ))
        
        qdrant_filters = qdrant_models.Filter(must=must_conditions) if must_conditions else None
        
        retrieved_docs, snippet_from_vector, docs_map = vector_service.search_documents(
            query=query_text, k=k, filter_conditions=qdrant_filters
        )
        
        final_snippet = ""
        if facts_from_kg and "No specific facts were found" not in facts_from_kg:
            final_snippet += facts_from_kg + "\n\n---\n\n"
        
        final_snippet += snippet_from_vector

        response_payload = {
            "retrieved_documents_list": [d.to_dict() for d in retrieved_docs],
            "formatted_context_snippet": final_snippet.strip(), 
            "retrieved_documents_map": docs_map,
        }
        
        current_app.logger.info(f"RAG+KG search successful. Returning {len(retrieved_docs)} documents.")
        return jsonify(response_payload), 200
        
    except Exception as e:
        logger.error(f"Error in /query (RAG+KG search): {e}", exc_info=True)
        return create_error_response(f"Query failed: {str(e)}", 500)

@app.route('/health', methods=['GET'])
def health_check():
    status_details = { "status": "error", "qdrant_service": "not_initialized", "neo4j_service": "not_initialized_via_handler", "neo4j_connection": "unknown"}
    http_status_code = 503
    if not vector_service:
        status_details["qdrant_service"] = "failed_to_initialize"
    else:
        status_details["qdrant_service"] = "initialized"
        try:
            vector_service.client.get_collection(collection_name=vector_service.collection_name)
            status_details["qdrant_collection_status"] = "exists_and_accessible"
        except Exception as e:
            status_details["qdrant_collection_status"] = f"error: {str(e)}"
    
    neo4j_ok, neo4j_conn_status = neo4j_handler.check_neo4j_connectivity()
    if neo4j_ok:
        status_details["neo4j_service"], status_details["neo4j_connection"] = "initialized_via_handler", "connected"
    else:
        status_details["neo4j_service"], status_details["neo4j_connection"] = "initialization_failed_or_handler_error", neo4j_conn_status
    
    if status_details["qdrant_service"] == "initialized" and status_details.get("qdrant_collection_status") == "exists_and_accessible" and neo4j_ok:
        status_details["status"], http_status_code = "ok", 200
    
    return jsonify(status_details), http_status_code

@app.route('/add_document', methods=['POST'])
def add_document_qdrant():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    user_id = data.get('user_id')
    file_path = data.get('file_path') # This might be temporary or empty for URL content
    original_name = data.get('original_name')
    text_content_override = data.get('text_content_override') # NEW parameter

    if not all([user_id, original_name]):
        return create_error_response("Missing 'user_id' or 'original_name'", 400)

    # Conditional check for source of text
    if text_content_override:
        logger.info(f"Adding document '{original_name}' (from text_content_override), user '{user_id}'.")
        # ai_core.process_document_for_qdrant needs to handle text_content_override
        # Pass a dummy file_path as it's required by the signature, actual file is not read.
        processed_chunks, raw_text, kg_chunks = ai_core.process_document_for_qdrant(
            file_path="",  # Dummy, as content is overridden
            original_name=original_name,
            user_id=user_id,
            text_content_override=text_content_override # Pass the override
        )
    elif file_path and os.path.exists(file_path):
        logger.info(f"Adding document '{original_name}' (from file_path), user '{user_id}'.")
        processed_chunks, raw_text, kg_chunks = ai_core.process_document_for_qdrant(
            file_path=file_path,
            original_name=original_name,
            user_id=user_id
        )
    else:
        return create_error_response("Neither 'file_path' (and file exists) nor 'text_content_override' provided.", 400)

    num_added, status = 0, "processed_no_content"
    if processed_chunks:
        num_added = app.vector_service.add_processed_chunks(processed_chunks)
        if num_added > 0: status = "added_to_qdrant"
    
    return jsonify({
        "message": "Document processed.",
        "status": status,
        "filename": original_name,
        "num_chunks_added_to_qdrant": num_added,
        "raw_text_for_analysis": raw_text or "",
        "chunks_with_metadata": kg_chunks
    }), 201


@app.route('/academic_search', methods=['POST'])
def academic_search_route():
    data = request.get_json()
    if not data or 'query' not in data: return create_error_response("Missing 'query'", 400)
    try:
        results = academic_search(data['query'], max_results_per_api=data.get('max_results', 3))
        return jsonify({"success": True, "results": results}), 200
    except Exception as e:
        return create_error_response(f"Academic search failed: {str(e)}", 500)

@app.route('/web_search', methods=['POST'])
def web_search_route():
    data = request.get_json()
    if not data or 'query' not in data: return create_error_response("Missing 'query'", 400)
    try:
        with DDGS() as ddgs:
            results = list(ddgs.text(data['query'], max_results=5))
        return jsonify([{"title": r.get("title"), "url": r.get("href"), "content": r.get("body")} for r in results]), 200
    except Exception as e: return create_error_response(f"Web search failed: {str(e)}", 500)

@app.route('/export_podcast', methods=['POST'])
def export_podcast_route():
    current_app.logger.info("--- /export_podcast Request (gTTS + Speed-Up) ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    source_document_text = data.get('sourceDocumentText')
    analysis_content = data.get('analysisContent')
    podcast_options = data.get('podcastOptions', {})
    api_key = data.get('api_key')
    
    if not all([source_document_text, analysis_content, api_key]):
        return create_error_response("Missing 'sourceDocumentText', 'analysisContent', or 'api_key'", 400)

    try:
        script = podcast_generator.generate_podcast_script(
            source_document_text, 
            analysis_content,
            podcast_options,
            lambda p: llm_wrapper(p, api_key)
        )
        
        temp_gtts_filename = f"podcast_gtts_{uuid.uuid4()}.mp3"
        temp_gtts_path = os.path.join(app.config['GENERATED_DOCS_DIR'], temp_gtts_filename)
        podcast_generator.synthesize_audio_with_gtts(script, temp_gtts_path)

        sound = AudioSegment.from_mp3(temp_gtts_path)
        sped_up_sound = sound.speedup(playback_speed=1.20)
        
        final_mp3_filename = f"podcast_final_{uuid.uuid4()}.mp3"
        final_mp3_path = os.path.join(app.config['GENERATED_DOCS_DIR'], final_mp3_filename)
        
        sped_up_sound.export(final_mp3_path, format="mp3")
        os.remove(temp_gtts_path)

        @after_this_request
        def cleanup(response):
            try: os.remove(final_mp3_path)
            except OSError as e: logger.error(f"Error deleting temp podcast MP3 file {final_mp3_path}: {e}")
            return response
            
        return send_from_directory(app.config['GENERATED_DOCS_DIR'], final_mp3_filename, as_attachment=True)
    except Exception as e:
        logger.error(f"Failed to generate podcast: {e}", exc_info=True)
        return create_error_response(f"Failed to generate podcast: {str(e)}", 500)

@app.route('/generate_document', methods=['POST'])
def generate_document_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    outline, doc_type, source_text, api_key = data.get('markdownContent'), data.get('docType'), data.get('sourceDocumentText'), data.get('api_key')
    if not all([outline, doc_type, source_text, api_key]): return create_error_response("Missing required fields", 400)
    try:
        expanded_content = document_generator.expand_content_with_llm(outline, source_text, doc_type, lambda p: llm_wrapper(p, api_key))
        slides = document_generator.parse_pptx_json(expanded_content) if doc_type == 'pptx' else document_generator.refined_parse_docx_markdown(expanded_content)
        filename, path = f"gen_{uuid.uuid4()}.{doc_type}", os.path.join(app.config['GENERATED_DOCS_DIR'], f"gen_{uuid.uuid4()}.{doc_type}")
        if doc_type == 'pptx': document_generator.create_ppt(slides, path)
        else: document_generator.create_doc(slides, path, "text_content")
        return jsonify({"success": True, "filename": filename}), 201
    except Exception as e: return create_error_response(f"Failed to generate document: {str(e)}", 500)

@app.route('/download_document/<filename>', methods=['GET'])
def download_document_route(filename):
    if '..' in filename: return create_error_response("Invalid filename.", 400)
    try:
        file_path = os.path.join(app.config['GENERATED_DOCS_DIR'], filename)
        if not os.path.exists(file_path): return create_error_response("File not found.", 404)
        @after_this_request
        def cleanup(response):
            try: os.remove(file_path)
            except OSError as e: logger.error(f"Error deleting temp file {file_path}: {e}")
            return response
        return send_from_directory(app.config['GENERATED_DOCS_DIR'], filename, as_attachment=True)
    except Exception as e:
        return create_error_response("Could not process download request.", 500)

# KG & DB Management Routes
@app.route('/delete_qdrant_document_data', methods=['DELETE'])
def delete_qdrant_data_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, document_name = data.get('user_id'), data.get('document_name') 
    if not user_id or not document_name: return create_error_response("Missing fields", 400)
    try:
        result = vector_service.delete_document_vectors(user_id, document_name)
        return jsonify(result), 200
    except Exception as e: return create_error_response(f"Deletion failed: {str(e)}", 500)

@app.route('/kg', methods=['POST'])
def add_or_update_kg_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, original_name, nodes, edges = data.get('userId'), data.get('originalName'), data.get('nodes'), data.get('edges')
    if not all([user_id, original_name, isinstance(nodes, list), isinstance(edges, list)]): return create_error_response("Missing fields", 400)
    try:
        result = neo4j_handler.ingest_knowledge_graph(user_id, original_name, nodes, edges)
        return jsonify({"message": "KG ingested", "status": "completed", **result}), 201
    except Exception as e: return create_error_response(f"KG ingestion failed: {str(e)}", 500)

@app.route('/kg/<user_id>/<path:document_name>', methods=['GET'])
def get_kg_route(user_id, document_name):
    try:
        kg_data = neo4j_handler.get_knowledge_graph(user_id, document_name)
        
        if kg_data is None:
            logger.info(f"No KG found for user '{user_id}', doc '{document_name}'. Returning empty graph.")
            return jsonify({"nodes": [], "edges": []}), 200
        
        return jsonify(kg_data), 200

    except Exception as e: 
        return create_error_response(f"KG retrieval failed: {str(e)}", 500)


@app.route('/kg/<user_id>/<path:document_name>', methods=['DELETE'])
def delete_kg_route(user_id, document_name):
    try:
        deleted = neo4j_handler.delete_knowledge_graph(user_id, document_name)
        return jsonify({"message": "KG deleted"}) if deleted else create_error_response("KG not found", 404)
    except Exception as e: return create_error_response(f"KG deletion failed: {str(e)}", 500)

@app.route('/query_kg', methods=['POST'])
def query_kg_route():
    current_app.logger.info("--- /query_kg Request (Knowledge Graph Search) ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    query_text = data.get('query')
    document_name = data.get('document_name')
    user_id = data.get('user_id')

    if not all([query_text, document_name, user_id]):
        return create_error_response("Missing 'query', 'document_name', or 'user_id'", 400)

    try:
        # Call the Neo4j handler to search the KG
        facts_from_kg = neo4j_handler.search_knowledge_graph(user_id, document_name, query_text)
        
        return jsonify({"success": True, "facts": facts_from_kg}), 200
    except neo4j_exceptions.ClientError as e:
        logger.error(f"Neo4j client error during KG query: {e}", exc_info=True)
        return create_error_response(f"Database error during KG query: {str(e)}", 500)
    except Exception as e:
        logger.error(f"Error during KG query: {e}", exc_info=True)
        return create_error_response(f"KG query failed: {str(e)}", 500)


if __name__ == '__main__':
    @app.route('/process_media_file', methods=['POST'])
    def process_media_file_route():
        """Handles direct file uploads of audio, video, or images for transcription/OCR."""
        current_app.logger.info("--- /process_media_file Request ---")
        data = request.get_json()
        if not data:
            return create_error_response("Request must be JSON", 400)

        file_path = data.get('file_path')
        media_type = data.get('media_type')  # Expected: 'audio', 'video', or 'image'

        if not file_path or not media_type:
            return create_error_response("Missing 'file_path' or 'media_type'", 400)
        if not os.path.exists(file_path):
            return create_error_response(f"File not found at path: {file_path}", 404)

        try:
            text_content = None
            if media_type == 'audio':
                text_content = media_processor.process_uploaded_audio(file_path)
            elif media_type == 'video':
                text_content = media_processor.process_uploaded_video(file_path)
            elif media_type == 'image':
                text_content = media_processor.process_uploaded_image(file_path)
            else:
                return create_error_response(f"Unsupported media_type: {media_type}", 400)
            
            if not text_content or not text_content.strip():
                return create_error_response(f"Failed to extract meaningful text from the {media_type} file.", 422)

            return jsonify({
                "success": True,
                "message": f"Successfully extracted text from {media_type} file.",
                "text_content": text_content,
            }), 200
        except Exception as e:
            logger.error(f"Error in /process_media_file for type '{media_type}': {e}", exc_info=True)
            return create_error_response(f"Failed to process {media_type} file: {str(e)}", 500)

    @app.route('/process_url', methods=['POST'])
    def process_url_source_route():
        """Handles YouTube and generic web URLs."""
        current_app.logger.info("--- /process_url Request ---")
        data = request.get_json()
        if not data: return create_error_response("Request must be JSON", 400)
        
        url = data.get('url')
        user_id = data.get('user_id')

        if not url or not user_id: return create_error_response("Missing 'url' or 'user_id'", 400)
        
        try:
            # Delegate to the knowledge engine
            extracted_text, final_title, source_type = knowledge_engine.process_url_source(url, user_id)
            if not extracted_text:
                return create_error_response(f"Failed to extract meaningful text from the {source_type}.", 422)

            return jsonify({
                "success": True,
                "message": f"Successfully extracted text from {source_type}.",
                "text_content": extracted_text,
                "title": final_title,
                "source_type": source_type,
            }), 200
        except Exception as e:
            logger.error(f"Error in /process_url for URL '{url}': {e}", exc_info=True)
            return create_error_response(f"Failed to process URL: {str(e)}", 500)

    logger.info(f"--- Starting RAG & Knowledge API Service on port {config.API_PORT} ---")
    # Using threaded=False for stability with external processes like ffmpeg/tesseract
    app.run(host='0.0.0.0', port=config.API_PORT, debug=False, threaded=False)

```

`server/rag_service/appBackup.py`

```python
# server/rag_service/app.py
import os
import sys
import traceback
from flask import Flask, request, jsonify, current_app, send_from_directory, after_this_request
import logging
import atexit
import uuid
import subprocess
import tempfile
import shutil
import json
import re
from werkzeug import utils as werkzeug_utils 

from duckduckgo_search import DDGS
from qdrant_client import models as qdrant_models

import subprocess
import tempfile
import shutil
import json

# --- Add server directory to sys.path ---
SERVER_DIR = os.path.dirname(os.path.abspath(__file__))
if SERVER_DIR not in sys.path:
    sys.path.insert(0, SERVER_DIR)

import config
config.setup_logging()

# --- Import configurations and services ---
try:
    from vector_db_service import VectorDBService
    import ai_core
    import neo4j_handler 
    from neo4j import exceptions as neo4j_exceptions
    import document_generator
    import podcast_generator
    import google.generativeai as genai
    from prompts import CODE_ANALYSIS_PROMPT_TEMPLATE, TEST_CASE_GENERATION_PROMPT_TEMPLATE, EXPLAIN_ERROR_PROMPT_TEMPLATE, QUIZ_GENERATION_PROMPT_TEMPLATE
    import quiz_utils

    if config.GEMINI_API_KEY:
        genai.configure(api_key=config.GEMINI_API_KEY)
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        LLM_MODEL = genai.GenerativeModel(config.GEMINI_MODEL_NAME, safety_settings=safety_settings)
    else:
        LLM_MODEL = None
        logging.getLogger(__name__).error("GEMINI_API_KEY not found, AI features will fail.")

    def llm_wrapper(prompt, api_key=None):
        """
        A flexible wrapper for the Gemini API that can use a provided per-request API key
        or fall back to the server's global key.
        """
        key_to_use = api_key or config.GEMINI_API_KEY
        if not key_to_use:
            raise ConnectionError("Gemini API Key is not configured for this request.")

        genai.configure(api_key=key_to_use)
        
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        model_instance = genai.GenerativeModel(config.GEMINI_MODEL_NAME, safety_settings=safety_settings)

        for attempt in range(3):
            try:
                response = model_instance.generate_content(prompt)
                if response.parts:
                    return "".join(part.text for part in response.parts if hasattr(part, 'text'))
                elif response.prompt_feedback and response.prompt_feedback.block_reason:
                     raise ValueError(f"Prompt blocked by API. Reason: {response.prompt_feedback.block_reason_message}")
                else:
                    logger.warning("LLM returned empty response without explicit block reason.")
                    return ""
            except Exception as e:
                logger.warning(f"LLM generation attempt {attempt + 1} failed: {e}")
                if attempt == 2: raise
        return ""

except ImportError as e:
    print(f"CRITICAL IMPORT ERROR: {e}.")
    sys.exit(1)

logger = logging.getLogger(__name__)
app = Flask(__name__)

GENERATED_DOCS_DIR = os.path.join(SERVER_DIR, 'generated_docs')
os.makedirs(GENERATED_DOCS_DIR, exist_ok=True)
app.config['GENERATED_DOCS_DIR'] = GENERATED_DOCS_DIR

# Initialize services
vector_service = None
try:
    vector_service = VectorDBService()
    vector_service.setup_collection()
    app.vector_service = vector_service
except Exception as e:
    logger.critical(f"Failed to initialize VectorDBService: {e}", exc_info=True)

try:
    neo4j_handler.init_driver()
except Exception as e:
    logger.critical(f"Neo4j driver failed to initialize: {e}.")
atexit.register(neo4j_handler.close_driver)

def create_error_response(message, status_code=500, details=None):
    log_message = f"API Error ({status_code}): {message}"
    if details: log_message += f" | Details: {details}"
    current_app.logger.error(log_message)
    response_payload = {"error": message}
    if details and status_code != 500: response_payload["details"] = details
    return jsonify(response_payload), status_code

# === API Endpoints ===

LANGUAGE_CONFIG = {
    "python": {
        "filename": "main.py",
        "compile_cmd": None,
        "run_cmd": [sys.executable, "main.py"]
    },
    "java": {
        "filename": "Main.java",
        "compile_cmd": ["javac", "-Xlint:all", "Main.java"],
        "run_cmd": ["java", "Main"]
    },
    "c": {
        "filename": "main.c",
        "compile_cmd": ["gcc", "main.c", "-o", "main", "-Wall", "-Wextra", "-pedantic"],
        "run_cmd": ["./main"] if os.name != 'nt' else [".\\main.exe"]
    },
    "cpp": {
        "filename": "main.cpp",
        "compile_cmd": ["g++", "main.cpp", "-o", "main", "-Wall", "-Wextra", "-pedantic"],
        "run_cmd": ["./main"] if os.name != 'nt' else [".\\main.exe"]
    }
}

# --- (START) Code Executor End Points ---

@app.route('/execute_code', methods=['POST'])
def execute_code():
    data = request.get_json()
    if not data:
        return create_error_response("Request must be JSON", 400)

    code = data.get('code')
    language = data.get('language', '').lower()
    test_cases = data.get('testCases', [])

    if not code or not language:
        return create_error_response("Missing 'code' or 'language'", 400)

    lang_config = LANGUAGE_CONFIG.get(language)
    if not lang_config:
        unsupported_message = f"Language '{language}' is not currently supported for execution."
        return jsonify({"compilationError": unsupported_message}), 200

    results = []
    temp_dir = tempfile.mkdtemp()
    
    try:
        source_path = os.path.join(temp_dir, lang_config["filename"])
        with open(source_path, 'w', encoding='utf-8') as f:
            f.write(code)

        if lang_config["compile_cmd"]:
            compile_process = subprocess.run(
                lang_config["compile_cmd"], cwd=temp_dir, capture_output=True,
                text=True, timeout=10, encoding='utf-8'
            )
            if compile_process.returncode != 0:
                error_output = (compile_process.stdout + "\n" + compile_process.stderr).strip()
                logger.warning(f"Compilation failed for {language}. Error: {error_output}")
                return jsonify({"compilationError": error_output}), 200

        for i, case in enumerate(test_cases):
            case_input = case.get('input', '')
            expected_output = str(case.get('expectedOutput', '')).strip()
            
            case_result = { "input": case_input, "expected": expected_output, "output": "", "error": None, "status": "fail" }

            try:
                run_process = subprocess.run(
                    lang_config["run_cmd"], cwd=temp_dir, input=case_input,
                    capture_output=True, text=True, timeout=5, encoding='utf-8'
                )
                stdout = run_process.stdout.strip().replace('\r\n', '\n')
                stderr = run_process.stderr.strip()
                case_result["output"] = stdout

                if run_process.returncode != 0:
                    case_result["status"] = "error"
                    case_result["error"] = stderr or "Script failed with a non-zero exit code."
                elif stderr:
                     case_result["error"] = f"Warning (stderr):\n{stderr}"
                
                if case_result["status"] != "error":
                    if stdout == expected_output:
                        case_result["status"] = "pass"
                    else:
                        case_result["status"] = "fail"
                
            except subprocess.TimeoutExpired:
                case_result["status"] = "error"
                case_result["error"] = "Execution timed out after 5 seconds."
            except Exception as exec_err:
                case_result["status"] = "error"
                case_result["error"] = f"An unexpected error occurred during execution: {str(exec_err)}"
            results.append(case_result)
    finally:
        shutil.rmtree(temp_dir)

    return jsonify({"results": results}), 200

@app.route('/analyze_code', methods=['POST'])
def analyze_code_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    code, language, api_key = data.get('code'), data.get('language'), data.get('apiKey')
    
    if not all([code, language]):
        return create_error_response("Missing 'code' or 'language'", 400)
        
    try:
        prompt = CODE_ANALYSIS_PROMPT_TEMPLATE.format(language=language, code=code)
        analysis = llm_wrapper(prompt, api_key)
        return jsonify({"analysis": analysis}), 200
    except Exception as e:
        return create_error_response(f"Failed to analyze code: {str(e)}", 500)

@app.route('/generate_test_cases', methods=['POST'])
def generate_test_cases_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    code, language, api_key = data.get('code'), data.get('language'), data.get('apiKey')
    
    if not all([code, language]):
        return create_error_response("Missing 'code' or 'language'", 400)

    try:
        prompt = TEST_CASE_GENERATION_PROMPT_TEMPLATE.format(language=language, code=code)
        response_text = llm_wrapper(prompt, api_key)
        
        json_match = re.search(r'\[.*\]', response_text, re.DOTALL)
        if not json_match:
            raise ValueError("LLM response did not contain a valid JSON array for test cases.")
        
        test_cases = json.loads(json_match.group(0))
        return jsonify({"testCases": test_cases}), 200
    except Exception as e:
        return create_error_response(f"Failed to generate test cases: {str(e)}", 500)

@app.route('/explain_error', methods=['POST'])
def explain_error_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    code, language, error_message, api_key = data.get('code'), data.get('language'), data.get('errorMessage'), data.get('apiKey')
    
    if not all([code, language, error_message]):
        return create_error_response("Missing 'code', 'language', or 'errorMessage'", 400)
        
    try:
        prompt = EXPLAIN_ERROR_PROMPT_TEMPLATE.format(language=language, code=code, error_message=error_message)
        explanation = llm_wrapper(prompt, api_key)
        return jsonify({"explanation": explanation}), 200
    except Exception as e:
        return create_error_response(f"Failed to explain error: {str(e)}", 500)

# --- (END) Code Executor End Points ---

# --- (START) Quiz Generator End Points ---
@app.route('/generate_quiz', methods=['POST'])
def generate_quiz_route():
    if 'file' not in request.files:
        return create_error_response("No file part in the request", 400)
    
    file = request.files['file']
    # --- THIS IS THE FIX ---
    # Map the descriptive string from the frontend to a number of questions
    quiz_option = request.form.get('quizOption', 'standard')
    api_key = request.form.get('api_key')
    
    quiz_option_map = {
        'quick': 5,
        'standard': 10,
        'deep_dive': 15,
        'comprehensive': 20
    }
    num_questions = quiz_option_map.get(quiz_option, 10) # Default to 10
    # --- END OF FIX ---

    if file.filename == '':
        return create_error_response("No selected file", 400)
    if not api_key:
        return create_error_response("API Key is required for quiz generation", 400)

    temp_dir = tempfile.mkdtemp()
    try:
        filename = werkzeug_utils.secure_filename(file.filename)
        file_path = os.path.join(temp_dir, filename)
        file.save(file_path)

        logger.info(f"Quiz Gen: Processing uploaded file '{filename}' for text extraction.")
        document_text = quiz_utils.extract_text_for_quiz(file_path)

        if not document_text or not document_text.strip():
            return create_error_response("Could not extract any text from the provided document.", 422)

        prompt = QUIZ_GENERATION_PROMPT_TEMPLATE.format(
            num_questions=num_questions,
            document_text=document_text
        )
        
        logger.info(f"Quiz Gen: Sending prompt to LLM for {num_questions} questions.")
        response_text = llm_wrapper(prompt, api_key)
        
        json_match = re.search(r'\[.*\]', response_text, re.DOTALL)
        if not json_match:
            raise ValueError("LLM response did not contain a valid JSON array for the quiz.")
        
        quiz_data = json.loads(json_match.group(0))
        logger.info(f"Quiz Gen: Successfully generated and parsed {len(quiz_data)} questions.")
        
        return jsonify({"quiz": quiz_data}), 200

    except Exception as e:
        logger.error(f"Error during quiz generation: {e}", exc_info=True)
        return create_error_response(f"Quiz Generation failed: {str(e)}", 500)
    finally:
        shutil.rmtree(temp_dir)

# --- (END) Quiz Generator End Points ---



@app.route('/query', methods=['POST'])
def search_qdrant_documents():
    current_app.logger.info("--- /query Request (RAG Search Only) ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    query_text = data.get('query')
    user_id = data.get('user_id') # user_id is mainly for logging here
    
    if not query_text or not user_id:
        return create_error_response("Missing 'query' or 'user_id'", 400)

    try:
        k = data.get('k', 5)
        document_context_name = data.get('documentContextName')
        
        must_conditions = []
        if document_context_name:
            current_app.logger.info(f"Applying document context filter: '{document_context_name}'")
            must_conditions.append(qdrant_models.FieldCondition(
                key="file_name",
                match=qdrant_models.MatchValue(value=document_context_name)
            ))
        
        qdrant_filters = qdrant_models.Filter(must=must_conditions) if must_conditions else None
        
        retrieved_docs, snippet, docs_map = vector_service.search_documents(
            query=query_text, k=k, filter_conditions=qdrant_filters
        )
        
        response_payload = {
            "retrieved_documents_list": [d.to_dict() for d in retrieved_docs],
            "formatted_context_snippet": snippet,
            "retrieved_documents_map": docs_map,
        }
        
        current_app.logger.info(f"RAG search successful. Returning {len(retrieved_docs)} documents.")
        return jsonify(response_payload), 200
        
    except Exception as e:
        logger.error(f"Error in /query (RAG search): {e}", exc_info=True)
        return create_error_response(f"Query failed: {str(e)}", 500)

# All other endpoints remain unchanged and are included for completeness

@app.route('/health', methods=['GET'])
def health_check():
    status_details = { "status": "error", "qdrant_service": "not_initialized", "neo4j_service": "not_initialized_via_handler", "neo4j_connection": "unknown"}
    http_status_code = 503
    if not vector_service:
        status_details["qdrant_service"] = "failed_to_initialize"
    else:
        status_details["qdrant_service"] = "initialized"
        try:
            vector_service.client.get_collection(collection_name=vector_service.collection_name)
            status_details["qdrant_collection_status"] = "exists_and_accessible"
        except Exception as e:
            status_details["qdrant_collection_status"] = f"error: {str(e)}"
    
    neo4j_ok, neo4j_conn_status = neo4j_handler.check_neo4j_connectivity()
    if neo4j_ok:
        status_details["neo4j_service"], status_details["neo4j_connection"] = "initialized_via_handler", "connected"
    else:
        status_details["neo4j_service"], status_details["neo4j_connection"] = "initialization_failed_or_handler_error", neo4j_conn_status
    
    if status_details["qdrant_service"] == "initialized" and status_details.get("qdrant_collection_status") == "exists_and_accessible" and neo4j_ok:
        status_details["status"], http_status_code = "ok", 200
    
    return jsonify(status_details), http_status_code

@app.route('/add_document', methods=['POST'])
def add_document_qdrant():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, file_path, original_name = data.get('user_id'), data.get('file_path'), data.get('original_name')
    if not all([user_id, file_path, original_name]): return create_error_response("Missing required fields", 400)
    if not os.path.exists(file_path): return create_error_response(f"File not found: {file_path}", 404)
    try:
        processed_chunks, raw_text, kg_chunks = ai_core.process_document_for_qdrant(file_path, original_name, user_id)
        num_added, status = 0, "processed_no_content"
        if processed_chunks:
            num_added = app.vector_service.add_processed_chunks(processed_chunks)
            if num_added > 0: status = "added_to_qdrant"
        return jsonify({ "message": "Document processed.", "status": status, "filename": original_name, "num_chunks_added_to_qdrant": num_added, "raw_text_for_analysis": raw_text or "", "chunks_with_metadata": kg_chunks }), 201
    except Exception as e: return create_error_response(f"Failed to process document: {str(e)}", 500)


@app.route('/academic_search', methods=['POST'])
def academic_search_route():
    data = request.get_json()
    if not data or 'query' not in data: return create_error_response("Missing 'query'", 400)
    try:
        results = academic_search.search_all_apis(data['query'], max_results_per_api=data.get('max_results', 3))
        return jsonify({"success": True, "results": results}), 200
    except Exception as e:
        return create_error_response(f"Academic search failed: {str(e)}", 500)

@app.route('/web_search', methods=['POST'])
def web_search_route():
    data = request.get_json()
    if not data or 'query' not in data: return create_error_response("Missing 'query'", 400)
    try:
        with DDGS() as ddgs:
            results = list(ddgs.text(data['query'], max_results=5))
        return jsonify([{"title": r.get("title"), "url": r.get("href"), "content": r.get("body")} for r in results]), 200
    except Exception as e: return create_error_response(f"Web search failed: {str(e)}", 500)

@app.route('/export_podcast', methods=['POST'])
def export_podcast_route():
    current_app.logger.info("--- /export_podcast Request (gTTS + Speed-Up) ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    source_document_text = data.get('sourceDocumentText')
    analysis_content = data.get('analysisContent')
    podcast_options = data.get('podcastOptions', {})
    api_key = data.get('api_key')
    
    if not all([source_document_text, analysis_content, api_key]):
        return create_error_response("Missing 'sourceDocumentText', 'analysisContent', or 'api_key'", 400)

    try:
        script = podcast_generator.generate_podcast_script(
            source_document_text, 
            analysis_content,
            podcast_options,
            lambda p: llm_wrapper(p, api_key)
        )
        
        temp_gtts_filename = f"podcast_gtts_{uuid.uuid4()}.mp3"
        temp_gtts_path = os.path.join(app.config['GENERATED_DOCS_DIR'], temp_gtts_filename)
        podcast_generator.synthesize_audio_with_gtts(script, temp_gtts_path)

        sound = AudioSegment.from_mp3(temp_gtts_path)
        sped_up_sound = sound.speedup(playback_speed=1.20)
        
        final_mp3_filename = f"podcast_final_{uuid.uuid4()}.mp3"
        final_mp3_path = os.path.join(app.config['GENERATED_DOCS_DIR'], final_mp3_filename)
        
        sped_up_sound.export(final_mp3_path, format="mp3")
        os.remove(temp_gtts_path)

        @after_this_request
        def cleanup(response):
            try: os.remove(final_mp3_path)
            except OSError as e: logger.error(f"Error deleting temp podcast MP3 file {final_mp3_path}: {e}")
            return response
            
        return send_from_directory(app.config['GENERATED_DOCS_DIR'], final_mp3_filename, as_attachment=True)
    except Exception as e:
        logger.error(f"Failed to generate podcast: {e}", exc_info=True)
        return create_error_response(f"Failed to generate podcast: {str(e)}", 500)

@app.route('/generate_kg_from_text', methods=['POST'])
def generate_kg_from_text_route():
    current_app.logger.info("--- /generate_kg_from_text Request ---")
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    
    document_text = data.get('document_text')
    api_key = data.get('api_key')
    
    if not document_text or not api_key:
        return create_error_response("Missing 'document_text' or 'api_key' in request body", 400)
    
    try:
        graph_data = knowledge_graph_generator.generate_graph_from_text(
            document_text, 
            lambda p: llm_wrapper(p, api_key)
        )
        return jsonify({"success": True, "graph_data": graph_data}), 200
    except Exception as e:
        logger.error(f"Error during on-the-fly KG generation: {e}", exc_info=True)
        return create_error_response(f"KG Generation failed: {str(e)}", 500)

@app.route('/generate_document', methods=['POST'])
def generate_document_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    outline, doc_type, source_text, api_key = data.get('markdownContent'), data.get('docType'), data.get('sourceDocumentText'), data.get('api_key')
    if not all([outline, doc_type, source_text, api_key]): return create_error_response("Missing required fields", 400)
    try:
        expanded_content = document_generator.expand_content_with_llm(outline, source_text, doc_type, lambda p: llm_wrapper(p, api_key))
        slides = document_generator.parse_pptx_json(expanded_content) if doc_type == 'pptx' else document_generator.refined_parse_docx_markdown(expanded_content)
        filename, path = f"gen_{uuid.uuid4()}.{doc_type}", os.path.join(app.config['GENERATED_DOCS_DIR'], f"gen_{uuid.uuid4()}.{doc_type}")
        if doc_type == 'pptx': document_generator.create_ppt(slides, path)
        else: document_generator.create_doc(slides, path, "text_content")
        return jsonify({"success": True, "filename": filename}), 201
    except Exception as e: return create_error_response(f"Failed to generate document: {str(e)}", 500)

@app.route('/download_document/<filename>', methods=['GET'])
def download_document_route(filename):
    if '..' in filename: return create_error_response("Invalid filename.", 400)
    try:
        file_path = os.path.join(app.config['GENERATED_DOCS_DIR'], filename)
        if not os.path.exists(file_path): return create_error_response("File not found.", 404)
        @after_this_request
        def cleanup(response):
            try: os.remove(file_path)
            except OSError as e: logger.error(f"Error deleting temp file {file_path}: {e}")
            return response
        return send_from_directory(app.config['GENERATED_DOCS_DIR'], filename, as_attachment=True)
    except Exception as e:
        return create_error_response("Could not process download request.", 500)

# KG & DB Management Routes
@app.route('/delete_qdrant_document_data', methods=['DELETE'])
def delete_qdrant_data_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, document_name = data.get('user_id'), data.get('document_name') 
    if not user_id or not document_name: return create_error_response("Missing fields", 400)
    try:
        result = vector_service.delete_document_vectors(user_id, document_name)
        return jsonify(result), 200
    except Exception as e: return create_error_response(f"Deletion failed: {str(e)}", 500)

@app.route('/kg', methods=['POST'])
def add_or_update_kg_route():
    data = request.get_json()
    if not data: return create_error_response("Request must be JSON", 400)
    user_id, original_name, nodes, edges = data.get('userId'), data.get('originalName'), data.get('nodes'), data.get('edges')
    if not all([user_id, original_name, isinstance(nodes, list), isinstance(edges, list)]): return create_error_response("Missing fields", 400)
    try:
        result = neo4j_handler.ingest_knowledge_graph(user_id, original_name, nodes, edges)
        return jsonify({"message": "KG ingested", "status": "completed", **result}), 201
    except Exception as e: return create_error_response(f"KG ingestion failed: {str(e)}", 500)

@app.route('/kg/<user_id>/<path:document_name>', methods=['GET'])
def get_kg_route(user_id, document_name):
    try:
        kg_data = neo4j_handler.get_knowledge_graph(user_id, document_name)
        return jsonify(kg_data) if kg_data else create_error_response("KG not found", 404)
    except Exception as e: return create_error_response(f"KG retrieval failed: {str(e)}", 500)

@app.route('/kg/<user_id>/<path:document_name>', methods=['DELETE'])
def delete_kg_route(user_id, document_name):
    try:
        deleted = neo4j_handler.delete_knowledge_graph(user_id, document_name)
        return jsonify({"message": "KG deleted"}) if deleted else create_error_response("KG not found", 404)
    except Exception as e: return create_error_response(f"KG deletion failed: {str(e)}", 500)

if __name__ == '__main__':
    logger.info(f"--- Starting RAG API Service on port {config.API_PORT} ---")
    app.run(host='0.0.0.0', port=config.API_PORT, debug=False, threaded=True)

```

`server/rag_service/config.py`

```python
# server/rag_service/config.py
import os
import logging
from dotenv import load_dotenv

# --- Load .env from the parent 'server' directory ---
# This ensures that both Node.js and Python use the same .env file
# The path is calculated relative to this config.py file
dotenv_path = os.path.join(os.path.dirname(__file__), '..', '.env')
load_dotenv(dotenv_path=dotenv_path)


# ─── Logging Configuration ───────────────────────────
logger = logging.getLogger(__name__)
LOGGING_LEVEL_NAME = os.getenv('LOGGING_LEVEL', 'INFO').upper()
LOGGING_LEVEL      = getattr(logging, LOGGING_LEVEL_NAME, logging.INFO)
LOGGING_FORMAT     = '%(asctime)s - %(levelname)s - [%(name)s:%(lineno)d] - %(message)s'

def setup_logging():
    """Configure logging across the app."""
    root_logger = logging.getLogger()
    if not root_logger.handlers:  # prevent duplicate handlers
        handler = logging.StreamHandler()
        formatter = logging.Formatter(LOGGING_FORMAT)
        handler.setFormatter(formatter)
        root_logger.addHandler(handler)
        root_logger.setLevel(LOGGING_LEVEL)

    logging.getLogger("urllib3").setLevel(logging.WARNING)
    logging.getLogger("httpx").setLevel(logging.WARNING)
    logging.getLogger("faiss.loader").setLevel(logging.WARNING)
    logging.getLogger(__name__).info(f"Logging initialized at {LOGGING_LEVEL_NAME}")

# --- API Keys and Service URLs ---
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
GEMINI_MODEL_NAME = "gemini-1.5-flash-latest" # Or your preferred Gemini model

NEO4J_URI = os.getenv("NEO4J_URI", "bolt://localhost:8768")
NEO4J_USERNAME = os.getenv("NEO4J_USERNAME", "neo4j")
NEO4J_PASSWORD = os.getenv("NEO4J_PASSWORD", "password")
NEO4J_DATABASE = os.getenv("NEO4J_DATABASE", "neo4j")

QDRANT_HOST = os.getenv("QDRANT_HOST", "localhost")
QDRANT_PORT = int(os.getenv("QDRANT_PORT", 6333))
QDRANT_COLLECTION_NAME = os.getenv("QDRANT_COLLECTION_NAME", "my_qdrant_rag_collection")
QDRANT_API_KEY = os.getenv("QDRANT_API_KEY", None)
QDRANT_URL = os.getenv("QDRANT_URL", None)

# --- Embedding Model Configuration ---
DEFAULT_DOC_EMBED_MODEL = 'mixedbread-ai/mxbai-embed-large-v1'
DOCUMENT_EMBEDDING_MODEL_NAME = os.getenv('DOCUMENT_EMBEDDING_MODEL_NAME', DEFAULT_DOC_EMBED_MODEL)

_MODEL_TO_DIM_MAPPING = {
    'mixedbread-ai/mxbai-embed-large-v1': 1024,
    'BAAI/bge-large-en-v1.5': 1024,
    'all-MiniLM-L6-v2': 384,
    'sentence-transformers/all-mpnet-base-v2': 768,
}
_FALLBACK_DIM = 768
DOCUMENT_VECTOR_DIMENSION = int(os.getenv("DOCUMENT_VECTOR_DIMENSION", _MODEL_TO_DIM_MAPPING.get(DOCUMENT_EMBEDDING_MODEL_NAME, _FALLBACK_DIM)))
QDRANT_COLLECTION_VECTOR_DIM = DOCUMENT_VECTOR_DIMENSION

QUERY_EMBEDDING_MODEL_NAME = os.getenv("QUERY_EMBEDDING_MODEL_NAME", DOCUMENT_EMBEDDING_MODEL_NAME)
QUERY_VECTOR_DIMENSION = int(os.getenv("QUERY_VECTOR_DIMENSION", _MODEL_TO_DIM_MAPPING.get(QUERY_EMBEDDING_MODEL_NAME, _FALLBACK_DIM)))

if QUERY_VECTOR_DIMENSION != QDRANT_COLLECTION_VECTOR_DIM:
    logger.warning(f"[Config Warning] Query vector dim ({QUERY_VECTOR_DIMENSION}) != Qdrant dim ({QDRANT_COLLECTION_VECTOR_DIM})")

# --- AI Core & Search Configuration ---
AI_CORE_CHUNK_SIZE = int(os.getenv("AI_CORE_CHUNK_SIZE", 512))
AI_CORE_CHUNK_OVERLAP = int(os.getenv("AI_CORE_CHUNK_OVERLAP", 100))
MAX_TEXT_LENGTH_FOR_NER = int(os.getenv("MAX_TEXT_LENGTH_FOR_NER", 500000))
QDRANT_DEFAULT_SEARCH_K = int(os.getenv("QDRANT_DEFAULT_SEARCH_K", 5))
QDRANT_SEARCH_MIN_RELEVANCE_SCORE = float(os.getenv("QDRANT_SEARCH_MIN_RELEVANCE_SCORE", 0.1))

# --- SpaCy Configuration ---
SPACY_MODEL_NAME = os.getenv('SPACY_MODEL_NAME', 'en_core_web_sm')

# --- API Port Configuration ---
API_PORT = int(os.getenv('API_PORT', 5000))

# --- Tesseract OCR Path ---
TESSERACT_CMD = os.getenv('TESSERACT_CMD', r'C:\Program Files\Tesseract-OCR\tesseract.exe')


# ─── Library Availability Flags & Dynamic Imports ──────────────────────
try:
    import pypdf
    PYPDF_AVAILABLE = True
    PYPDF_PDFREADERROR = pypdf.errors.PdfReadError
except ImportError: PYPDF_AVAILABLE, PYPDF_PDFREADERROR = False, Exception

try:
    from docx import Document as DocxDocument
    DOCX_AVAILABLE = True
except ImportError: DOCX_AVAILABLE, DocxDocument = False, None

try:
    from pptx import Presentation
    PPTX_AVAILABLE = True
except ImportError: PPTX_AVAILABLE, Presentation = False, None

try:
    import pdfplumber
    PDFPLUMBER_AVAILABLE = True
except ImportError: PDFPLUMBER_AVAILABLE, pdfplumber = False, None

try:
    import pandas as pd
    PANDAS_AVAILABLE = True
except ImportError: PANDAS_AVAILABLE, pd = False, None

try:
    from PIL import Image
    PIL_AVAILABLE = True
except ImportError: PIL_AVAILABLE, Image = False, None

try:
    import fitz
    FITZ_AVAILABLE = True
except ImportError: FITZ_AVAILABLE, fitz = False, None

try:
    import pytesseract
    PYTESSERACT_AVAILABLE = True
    TESSERACT_ERROR = pytesseract.TesseractNotFoundError
    if TESSERACT_CMD: pytesseract.pytesseract.tesseract_cmd = TESSERACT_CMD
except ImportError: PYTESSERACT_AVAILABLE, pytesseract, TESSERACT_ERROR = False, None, Exception

try:
    import PyPDF2
    PYPDF2_AVAILABLE = True
except ImportError: PYPDF2_AVAILABLE, PyPDF2 = False, None

try:
    from langchain.text_splitter import RecursiveCharacterTextSplitter
    LANGCHAIN_SPLITTER_AVAILABLE = True
except ImportError: LANGCHAIN_SPLITTER_AVAILABLE, RecursiveCharacterTextSplitter = False, None



try:
    import yt_dlp
    YTDLP_AVAILABLE = True
except ImportError:
    YTDLP_AVAILABLE, yt_dlp = False, None
    
try:
    import whisper
    WHISPER_AVAILABLE = True
except ImportError:
    WHISPER_AVAILABLE, whisper = False, None
    
try:
    from playwright.sync_api import sync_playwright
    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE, sync_playwright = False, None
    
try:
    from bs4 import BeautifulSoup
    BS4_AVAILABLE = True
except ImportError:
    BS4_AVAILABLE, BeautifulSoup = False, None
    
try:
    import ffmpeg
    FFMPEG_PYTHON_AVAILABLE = True
except ImportError:
    FFMPEG_PYTHON_AVAILABLE, ffmpeg = False, None


    
# ─── Optional: Preload SpaCy & Embedding Model ───────
nlp_spacy_core, SPACY_MODEL_LOADED = None, False
try:
    import spacy
    nlp_spacy_core = spacy.load(SPACY_MODEL_NAME)
    SPACY_MODEL_LOADED = True
except Exception as e:
    logger.warning(f"Failed to load SpaCy model '{SPACY_MODEL_NAME}': {e}")

document_embedding_model, EMBEDDING_MODEL_LOADED = None, False
try:
    from sentence_transformers import SentenceTransformer
    document_embedding_model = SentenceTransformer(DOCUMENT_EMBEDDING_MODEL_NAME)
    EMBEDDING_MODEL_LOADED = True
except Exception as e:
    logger.warning(f"Failed to load Sentence Transformer model '{DOCUMENT_EMBEDDING_MODEL_NAME}': {e}")

whisper_model, WHISPER_MODEL_LOADED = None, False
try:
    import whisper
    # Using 'base' model is a good balance. Could be configured via .env in the future.
    whisper_model = whisper.load_model("base")
    WHISPER_MODEL_LOADED = True
    logger.info("Successfully pre-loaded Whisper 'base' model.")
except Exception as e:
    logger.warning(f"Failed to pre-load Whisper model: {e}. Transcription will fail.")
```

`server/rag_service/document_generator.py`

```python
# server/rag_service/document_generator.py
import re
import json
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from pptx.enum.text import PP_ALIGN
from docx import Document
from docx.shared import Inches as DocxInches
import logging

logger = logging.getLogger(__name__)

# --- PROMPT FOR INTELLIGENT PPTX GENERATION (JSON-based) ---
PPTX_EXPANSION_PROMPT_TEMPLATE = """
You are a professional presentation designer and subject matter expert.
Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, 6-8 slide presentation.
You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge.
Your output MUST be a single, valid JSON array, where each object represents a slide.

**JSON Object Schema for each slide:**
{{
  "slide_title": "A concise and engaging title for the slide.",
  "slide_content": "Detailed, professional paragraph(s) and/or bullet points elaborating on the outline point. This text will be displayed on the slide. Use Markdown for formatting (e.g., **bold**, *italics*, - bullet points).",
  "image_prompt": "A highly descriptive, creative prompt for an AI text-to-image model (like DALL-E or Midjourney) to generate a relevant and visually appealing image for this specific slide. Describe the style, subject, and composition. Example: 'A photorealistic image of a futuristic server room with glowing blue data streams flowing between racks, symbolizing data processing. Cinematic lighting.'"
}}

**INSTRUCTIONS:**
1.  **Analyze Outline & Source:** For each point in the OUTLINE, create at least one slide object in the JSON array.
2.  **Expand Content:** Elaborate on each outline point using only information from the SOURCE DOCUMENT TEXT.
3.  **Create Image Prompts:** For each slide, generate a unique and descriptive `image_prompt` that visually represents the slide's content.
4.  **JSON Format:** Ensure the final output is a single, clean JSON array with no other text before or after it.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a presentation):**
{outline_content}
---

**FINAL PRESENTATION JSON ARRAY:**
"""

# --- PROMPT FOR INTELLIGENT DOCX GENERATION (Markdown-based) ---
DOCX_EXPANSION_PROMPT_TEMPLATE = """
You are a professional content creator and subject matter expert.
Your task is to expand a given OUTLINE (which could be a list of key topics or FAQs) into a full, detailed, multi-page document in Markdown format.
You must use the provided SOURCE DOCUMENT TEXT as your only source of truth. Do not use outside knowledge.
The final output must be a single block of well-structured Markdown text.

**INSTRUCTIONS:**
1.  **Main Title:** Start the document with a main title using H1 syntax (e.g., `# Expanded Report on Key Topics`).
2.  **Section per Outline Point:** For each point in the OUTLINE, create a detailed section with a clear H2 or H3 heading (e.g., `## Topic Name`).
3.  **Content Expansion:** For each section, write detailed, professional paragraphs that elaborate on the outline point. Extract relevant facts, figures, and explanations from the SOURCE DOCUMENT TEXT.
4.  **Markdown Usage:** Use bullet points, bold text, and clear paragraphs to structure the content effectively.

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**OUTLINE (Topics/FAQs to expand into a document):**
{outline_content}
---

**FINAL DOCUMENT MARKDOWN:**
"""

def expand_content_with_llm(outline_content, source_document_text, doc_type, llm_function):
    """Uses an LLM to expand an outline into full content for the specified doc type."""
    logger.info(f"Expanding outline for '{doc_type}' using LLM...")
    
    if doc_type == 'pptx':
        prompt = PPTX_EXPANSION_PROMPT_TEMPLATE.format(
            source_document_text=source_document_text,
            outline_content=outline_content
        )
    else: # for 'docx'
        prompt = DOCX_EXPANSION_PROMPT_TEMPLATE.format(
            source_document_text=source_document_text,
            outline_content=outline_content
        )

    expanded_content = llm_function(prompt)
    
    if not expanded_content or not expanded_content.strip():
        raise ValueError("LLM failed to generate expanded content.")
    
    logger.info(f"LLM generated expanded content for {doc_type}. Length: {len(expanded_content)}")
    return expanded_content

def parse_pptx_json(json_string):
    """Parses the LLM's JSON output for PPTX generation."""
    try:
        cleaned_str = re.sub(r'^```json\s*|\s*```$', '', json_string.strip())
        slides_data = json.loads(cleaned_str)
        if not isinstance(slides_data, list):
            raise ValueError("Parsed JSON is not a list of slides.")
        return slides_data
    except (json.JSONDecodeError, ValueError) as e:
        logger.error(f"Failed to parse JSON from LLM response: {e}")
        raise ValueError("LLM returned invalid JSON format for the presentation.") from e

def refined_parse_docx_markdown(markdown_content):
    """Parses the expanded markdown for DOCX generation into a single 'slide' object for consistency."""
    if not markdown_content or not markdown_content.strip():
        return []
    
    title_match = re.search(r"^\s*#\s+(.*)", markdown_content, re.MULTILINE)
    if title_match:
        title = title_match.group(1).strip()
        content = markdown_content[title_match.end():].strip()
    else:
        title = "Generated Document"
        content = markdown_content

    return [{"title": title, "text_content": content}]

def add_text_to_shape_with_markdown(text_frame, markdown_text, is_title=False, is_notes=False):
    text_frame.clear()
    text_frame.word_wrap = True
    title_font_size = Pt(36)
    content_font_size = Pt(16)
    notes_font_size = Pt(11)

    for line in markdown_text.split('\n'):
        p = text_frame.add_paragraph()
        p.alignment = PP_ALIGN.LEFT
        bullet_match = re.match(r'^(\s*)[\*\-]\s*(.*)', line)
        
        if bullet_match and not is_title:
            leading_spaces, content_line = bullet_match.groups()
            p.level = min(len(leading_spaces) // 2, 5)
        else:
            content_line = line.lstrip()

        segments = re.split(r'(\*\*.*?\*\*|__.*?__)', content_line)
        for segment in segments:
            if not segment: continue
            run = p.add_run()
            if (segment.startswith("**") and segment.endswith("**")) or (segment.startswith("__") and segment.endswith("__")):
                run.text = segment[2:-2]
                run.font.bold = True
            else:
                run.text = segment
            
            if is_title:
                run.font.color.rgb = RGBColor(255, 255, 255)
                run.font.size = title_font_size
            elif is_notes:
                run.font.color.rgb = RGBColor(210, 210, 230)
                run.font.size = notes_font_size
                run.font.italic = True
            else:
                run.font.color.rgb = RGBColor(255, 255, 255)
                run.font.size = content_font_size

def create_ppt(slides_data, output_path):
    prs = Presentation()
    prs.slide_width = Inches(16)
    prs.slide_height = Inches(9)

    for slide_data in slides_data:
        slide_layout = prs.slide_layouts[6] # Blank layout
        slide = prs.slides.add_slide(slide_layout)
        background = slide.background
        fill = background.fill
        fill.solid()
        fill.fore_color.rgb = RGBColor(15, 23, 42)

        title_shape = slide.shapes.add_textbox(Inches(0.5), Inches(0.2), prs.slide_width - Inches(1.0), Inches(1.0))
        add_text_to_shape_with_markdown(title_shape.text_frame, slide_data.get("slide_title", "Untitled Slide"), is_title=True)

        content_shape = slide.shapes.add_textbox(Inches(0.5), Inches(1.3), Inches(8.5), Inches(7.0))
        add_text_to_shape_with_markdown(content_shape.text_frame, slide_data.get("slide_content", "[No content provided]"))

        notes_shape = slide.shapes.add_textbox(Inches(9.5), Inches(1.3), Inches(6.0), Inches(7.0))
        image_prompt_header = "🎨 Image Generation Prompt:"
        image_prompt_body = slide_data.get("image_prompt", "N/A")
        add_text_to_shape_with_markdown(notes_shape.text_frame, f"**{image_prompt_header}**\n{image_prompt_body}", is_notes=True)

    prs.save(output_path)
    return True

def add_markdown_line_to_docx(doc, markdown_line):
    heading_match = re.match(r'^(#+)\s+(.*)', markdown_line)
    if heading_match:
        level = len(heading_match.group(1))
        doc.add_heading(heading_match.group(2).strip(), level=min(level, 4))
        return

    bullet_match = re.match(r'^(\s*)[\*\-]\s+(.*)', markdown_line)
    if bullet_match:
        leading_spaces, content_line = bullet_match.groups()
        p = doc.add_paragraph(style='List Bullet')
        p.paragraph_format.left_indent = DocxInches(0.25 * (len(leading_spaces) // 2))
    else:
        content_line = markdown_line
        p = doc.add_paragraph()
    
    segments = re.split(r'(\*\*.*?\*\*|__.*?__)', content_line)
    for segment in segments:
        if not segment: continue
        run = p.add_run()
        if (segment.startswith("**") and segment.endswith("**")) or (segment.startswith("__") and segment.endswith("__")):
            run.text = segment[2:-2]
            run.font.bold = True
        else:
            run.text = segment

def create_doc(slides_data, output_path, content_key="text_content"):
    doc = Document()
    if slides_data:
        doc_title = slides_data[0].get("title", "Generated Document")
        doc.add_heading(doc_title, level=0)
        
        content_to_add = slides_data[0].get(content_key, "")
        if content_to_add.strip():
            for line in content_to_add.split('\n'):
                add_markdown_line_to_docx(doc, line)
    else:
        doc.add_paragraph("[No content to generate]")
    doc.save(output_path)
    return True
```

`server/rag_service/file_parser.py`

```python
# server/rag_service/file_parser.py
import os
try:
    import pypdf
except ImportError:
    print("pypdf not found, PDF parsing will fail. Install with: pip install pypdf")
    pypdf = None # Set to None if not installed

try:
    from docx import Document as DocxDocument
except ImportError:
    print("python-docx not found, DOCX parsing will fail. Install with: pip install python-docx")
    DocxDocument = None

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_core.documents import Document as LangchainDocument
from rag_service import config # Import from package
import logging

# Configure logger for this module
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO) # Or DEBUG for more details
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
if not logger.hasHandlers():
    logger.addHandler(handler)


def parse_pdf(file_path):
    """Extracts text content from a PDF file using pypdf."""
    if not pypdf: return None # Check if library loaded
    text = ""
    try:
        reader = pypdf.PdfReader(file_path)
        num_pages = len(reader.pages)
        # logger.debug(f"Reading {num_pages} pages from PDF: {os.path.basename(file_path)}")
        for i, page in enumerate(reader.pages):
            try:
                page_text = page.extract_text()
                if page_text:
                    text += page_text + "\n" # Add newline between pages
            except Exception as page_err:
                 logger.warning(f"Error extracting text from page {i+1} of {os.path.basename(file_path)}: {page_err}")
        # logger.debug(f"Extracted {len(text)} characters from PDF.")
        return text.strip() if text.strip() else None # Return None if empty after stripping
    except FileNotFoundError:
        logger.error(f"PDF file not found: {file_path}")
        return None
    except pypdf.errors.PdfReadError as pdf_err:
        logger.error(f"Error reading PDF {os.path.basename(file_path)} (possibly corrupted or encrypted): {pdf_err}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error parsing PDF {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

def parse_docx(file_path):
    """Extracts text content from a DOCX file."""
    if not DocxDocument: return None # Check if library loaded
    try:
        doc = DocxDocument(file_path)
        text = "\n".join([para.text for para in doc.paragraphs if para.text.strip()])
        # logger.debug(f"Extracted {len(text)} characters from DOCX.")
        return text.strip() if text.strip() else None
    except Exception as e:
        logger.error(f"Error parsing DOCX {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

def parse_txt(file_path):
    """Reads text content from a TXT file (or similar plain text like .py, .js)."""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            text = f.read()
        # logger.debug(f"Read {len(text)} characters from TXT file.")
        return text.strip() if text.strip() else None
    except Exception as e:
        logger.error(f"Error parsing TXT {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

# Add PPTX parsing (requires python-pptx)
try:
    from pptx import Presentation
    PPTX_SUPPORTED = True
    def parse_pptx(file_path):
        """Extracts text content from a PPTX file."""
        text = ""
        try:
            prs = Presentation(file_path)
            for slide in prs.slides:
                for shape in slide.shapes:
                    if hasattr(shape, "text"):
                        shape_text = shape.text.strip()
                        if shape_text:
                            text += shape_text + "\n" # Add newline between shape texts
            # logger.debug(f"Extracted {len(text)} characters from PPTX.")
            return text.strip() if text.strip() else None
        except Exception as e:
            logger.error(f"Error parsing PPTX {os.path.basename(file_path)}: {e}", exc_info=True)
            return None
except ImportError:
    PPTX_SUPPORTED = False
    logger.warning("python-pptx not installed. PPTX parsing will be skipped.")
    def parse_pptx(file_path):
        logger.warning(f"Skipping PPTX file {os.path.basename(file_path)} as python-pptx is not installed.")
        return None


def parse_file(file_path):
    """Parses a file based on its extension, returning text content or None."""
    _, ext = os.path.splitext(file_path)
    ext = ext.lower()
    logger.debug(f"Attempting to parse file: {os.path.basename(file_path)} (Extension: {ext})")

    if ext == '.pdf':
        return parse_pdf(file_path)
    elif ext == '.docx':
        return parse_docx(file_path)
    elif ext == '.pptx':
        return parse_pptx(file_path) # Use the conditional function
    elif ext in ['.txt', '.py', '.js', '.md', '.log', '.csv', '.html', '.xml', '.json']: # Expand text-like types
        return parse_txt(file_path)
    # Add other parsers here if needed (e.g., for .doc, .xls)
    elif ext == '.doc':
        # Requires antiword or similar external tool, more complex
        logger.warning(f"Parsing for legacy .doc files is not implemented: {os.path.basename(file_path)}")
        return None
    else:
        logger.warning(f"Unsupported file extension for parsing: {ext} ({os.path.basename(file_path)})")
        return None

def chunk_text(text, file_name, user_id):
    """Chunks text and creates Langchain Documents with metadata."""
    if not text or not isinstance(text, str):
        logger.warning(f"Invalid text input for chunking (file: {file_name}). Skipping.")
        return []

    # Use splitter configured in config.py
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=config.CHUNK_SIZE,
        chunk_overlap=config.CHUNK_OVERLAP,
        length_function=len,
        is_separator_regex=False, # Use default separators
        # separators=["\n\n", "\n", " ", ""] # Default separators
    )

    try:
        chunks = text_splitter.split_text(text)
        if not chunks:
             logger.warning(f"Text splitting resulted in zero chunks for file: {file_name}")
             return []

        documents = []
        for i, chunk in enumerate(chunks):
             # Ensure chunk is not just whitespace before creating Document
             if chunk and chunk.strip():
                 documents.append(
                     LangchainDocument(
                         page_content=chunk,
                         metadata={
                             'userId': user_id, # Store user ID
                             'documentName': file_name, # Store original filename
                             'chunkIndex': i # Store chunk index for reference
                         }
                     )
                 )
        if documents:
            logger.info(f"Split '{file_name}' into {len(documents)} non-empty chunks.")
        else:
            logger.warning(f"No non-empty chunks created for file: {file_name} after splitting.")
        return documents
    except Exception as e:
        logger.error(f"Error during text splitting for file {file_name}: {e}", exc_info=True)
        return [] # Return empty list on error

```

`server/rag_service/knowledge_engine.py`

```python
# server/rag_service/knowledge_engine.py
import os
import re
import tempfile
import shutil
import logging
import time
from typing import Tuple, Optional

# --- Tool Imports ---
# REMOVE the local try/except blocks for imports. We now rely on config.
from playwright.sync_api import TimeoutError as PlaywrightTimeoutError

# --- THIS IS THE FIX: Import the central config ---
import config
# --- END OF FIX ---

logger = logging.getLogger(__name__)


# --- YouTube Processing ---
def _extract_youtube_text(url: str) -> Tuple[Optional[str], Optional[str]]:
    # --- FIX: Reference config for availability and library objects ---
    if not config.YTDLP_AVAILABLE or not config.WHISPER_MODEL_LOADED:
        raise ImportError("YouTube processing requires 'yt-dlp' and the Whisper model to be loaded.")
    # --- END FIX ---
    
    logger.info(f"Processing YouTube URL: {url}")
    temp_dir = tempfile.mkdtemp()
    try:
        audio_filename_template = os.path.join(temp_dir, 'audio.%(ext)s')
        ydl_opts = {
            'format': 'm4a/bestaudio/best',
            'outtmpl': audio_filename_template,
            'noplaylist': True,
            'quiet': True,
            'postprocessors': [{'key': 'FFmpegExtractAudio', 'preferredcodec': 'wav'}],
        }

        # --- FIX: Reference config for library object ---
        with config.yt_dlp.YoutubeDL(ydl_opts) as ydl:
        # --- END FIX ---
            info_dict = ydl.extract_info(url, download=True)
            video_title = info_dict.get('title', 'YouTube Video')
            audio_file_path = os.path.join(temp_dir, 'audio.wav')

        logger.info(f"Transcribing audio for '{video_title}' with Whisper...")
        result = config.whisper_model.transcribe(audio_file_path, fp16=False)
        transcribed_text = result['text']
        
        logger.info(f"Transcription complete for '{video_title}'. Text length: {len(transcribed_text)}")
        return transcribed_text, video_title
    except Exception as e:
        logger.error(f"yt-dlp/whisper error processing URL {url}: {e}")
        raise ConnectionError(f"Failed to process YouTube video: {e}")
    finally:
        shutil.rmtree(temp_dir)

# --- Webpage Content Processing ---
def _extract_webpage_text(url: str, retries: int = 2) -> Tuple[Optional[str], Optional[str]]:
    # --- FIX: Reference config for availability and library objects ---
    if not config.PLAYWRIGHT_AVAILABLE or not config.BS4_AVAILABLE:
        raise ImportError("Webpage processing requires 'playwright' and 'beautifulsoup4'.")
    # --- END FIX ---

    logger.info(f"Processing webpage URL: {url}")
    
    for attempt in range(retries):
        logger.info(f"Scraping attempt {attempt + 1}/{retries} for URL: {url}")
        try:
            # --- FIX: Reference config for library object ---
            with config.sync_playwright() as p:
            # --- END FIX ---
                browser = p.chromium.launch(headless=True)
                context = browser.new_context(
                    user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                )
                page = context.new_page()
                page.goto(url, wait_until='load', timeout=45000)
                
                page_title = page.title() or url
                html_content = page.content()
                browser.close()

                logger.info(f"Successfully fetched content for '{page_title}'")
                
                # --- FIX: Reference config for library object ---
                soup = config.BeautifulSoup(html_content, "html.parser")
                # --- END FIX ---
                for element in soup(["script", "style", "nav", "footer", "aside", "header", "form", "button", "iframe"]):
                    element.decompose()
                
                body = soup.find('body')
                if body:
                    text = body.get_text(separator='\n', strip=True)
                    cleaned_text = re.sub(r'\n{3,}', '\n\n', text)
                else:
                    cleaned_text = ""
                
                logger.info(f"Extracted and cleaned text from '{page_title}'. Length: {len(cleaned_text)}")
                return cleaned_text, page_title

        except PlaywrightTimeoutError as e:
            logger.warning(f"Attempt {attempt + 1} timed out for URL {url}. Error: {e}")
            if attempt + 1 == retries:
                logger.error(f"All {retries} scraping attempts failed for URL {url}.")
                raise ConnectionError(f"Failed to scrape webpage after {retries} attempts: Timeout")
            time.sleep(2)
        except Exception as e:
            logger.error(f"Playwright/BS4 error on attempt {attempt + 1} for URL {url}: {e}")
            if attempt + 1 == retries:
                 raise ConnectionError(f"Failed to scrape webpage after {retries} attempts: {e}")
            time.sleep(2)

# --- Main Orchestrator for URLs ---
def process_url_source(url: str, user_id: str) -> Tuple[Optional[str], str, str]:
    # ... (rest of the function is the same, no changes needed here)
    logger.info(f"Knowledge Engine: Orchestrating URL processing for '{url}'")
    
    raw_text, final_title, source_type = None, url, 'webpage'
    youtube_regex = (
        r'(https?://)?(www\.)?'
        '(youtube|youtu|youtube-nocookie)\.(com|be)/'
        '(watch\?v=|embed/|v/|.+\?v=)?([^&=%\?]{11})')
    is_youtube = re.match(youtube_regex, url)

    if is_youtube:
        source_type = 'youtube'
        raw_text, final_title = _extract_youtube_text(url)
    else:
        source_type = 'webpage'
        raw_text, final_title = _extract_webpage_text(url)

    if not raw_text:
        return None, final_title, source_type

    cleaned_text = re.sub(r'\s+', ' ', raw_text).strip()
    
    logger.info(f"Successfully processed URL '{url}'. Title: '{final_title}'. Type: '{source_type}'.")
    return cleaned_text, final_title, source_type
```

`server/rag_service/knowledge_graph_generator.py`

```python
# server/rag_service/knowledge_graph_generator.py
import logging
import json
import re
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

KG_GENERATION_PROMPT = """
You are an expert data architect. Your task is to analyze the provided text and extract a detailed knowledge graph. The graph should represent the core entities, concepts, and their relationships.

**INSTRUCTIONS:**
1.  **Identify Entities/Nodes**: Identify the key entities (people, places, concepts, processes, technologies). These will be your nodes. For each node, provide a unique ID (a short, descriptive string) and a 'type' (e.g., 'Concept', 'Technology', 'Process').
2.  **Identify Relationships/Edges**: Determine how these nodes are connected. The relationship should be a descriptive verb phrase (e.g., 'IS_A', 'USES', 'RESULTS_IN', 'PART_OF').
3.  **Format as JSON**: Your entire output MUST be a single, valid JSON object containing two keys: "nodes" and "edges".
    -   **Nodes**: An array of objects, where each object is `{"id": "NodeID", "label": "Full Node Name", "type": "NodeType"}`. The `label` is the full name, the `id` is a concise version for linking.
    -   **Edges**: An array of objects, where each object is `{"from": "SourceNodeID", "to": "TargetNodeID", "relationship": "RELATIONSHIP_TYPE"}`.
4.  **Be Thorough**: Extract as many meaningful nodes and edges as possible to create a rich, interconnected graph.

---
**DOCUMENT TEXT TO ANALYZE:**
__DOCUMENT_TEXT_PLACEHOLDER__
---

**FINAL KNOWLEDGE GRAPH JSON (start immediately with `{`):**
"""

def generate_graph_from_text(document_text: str, llm_function) -> Dict[str, Any]:
    """Uses an LLM to generate a knowledge graph from a block of text."""
    logger.info(f"Generating knowledge graph from text of length {len(document_text)}...")
    
    prompt = KG_GENERATION_PROMPT.replace(
        "__DOCUMENT_TEXT_PLACEHOLDER__", 
        document_text[:60000]
    )
    
    response_text = llm_function(prompt)
    
    if not response_text or not response_text.strip():
        raise ValueError("LLM failed to generate knowledge graph content.")
        
    json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
    if not json_match:
        raise ValueError("LLM response did not contain a valid JSON object for the knowledge graph.")
    
    json_string = json_match.group(0)
    
    try:
        graph_data = json.loads(json_string)
        if "nodes" not in graph_data or "edges" not in graph_data:
            raise ValueError("Parsed JSON is missing 'nodes' or 'edges' keys.")
        
        logger.info(f"Successfully generated knowledge graph with {len(graph_data['nodes'])} nodes and {len(graph_data['edges'])} edges.")
        return graph_data
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON from LLM response for KG: {e}")
        raise ValueError("LLM returned invalid JSON format for the knowledge graph.") from e
```

`server/rag_service/media_processor.py`

```python
# server/rag_service/media_processor.py
import os
import tempfile
import shutil
import logging
from typing import Optional

# --- Tool Imports are now centralized ---
import config

logger = logging.getLogger(__name__)

if config.PYTESSERACT_AVAILABLE and config.TESSERACT_CMD:
    config.pytesseract.pytesseract.tesseract_cmd = config.TESSERACT_CMD

def process_uploaded_audio(file_path: str) -> Optional[str]:
    """Transcribes audio content from a given file path."""
    if not config.WHISPER_MODEL_LOADED:
        raise ImportError("Audio processing requires the Whisper model to be loaded.")
    
    logger.info(f"Transcribing audio file: {os.path.basename(file_path)}")
    try:
        result = config.whisper_model.transcribe(file_path, fp16=False)
        transcribed_text = result['text']
        logger.info(f"Transcription complete for audio file. Text length: {len(transcribed_text)}")
        return transcribed_text
    except Exception as e:
        logger.error(f"Whisper error processing audio file {file_path}: {e}")
        raise IOError(f"Failed to transcribe audio file: {e}")

def process_uploaded_video(file_path: str) -> Optional[str]:
    """Extracts audio from a video file and transcribes it using ffmpeg-python."""
    if not config.FFMPEG_PYTHON_AVAILABLE:
        raise ImportError("Video processing requires 'ffmpeg-python' and a system installation of ffmpeg.")

    logger.info(f"Processing video file for audio extraction: {os.path.basename(file_path)}")
    temp_dir = tempfile.mkdtemp()
    temp_audio_path = os.path.join(temp_dir, "extracted_audio.wav")
    try:
        (
            config.ffmpeg
            .input(file_path)
            .output(
                temp_audio_path,
                acodec='pcm_s16le',
                ar=16000,
                ac=1
            )
            .run(cmd=['ffmpeg', '-nostdin'], capture_stdout=True, capture_stderr=True, quiet=True)
        )
        
        logger.info(f"Audio extracted to temporary file. Now transcribing.")
        return process_uploaded_audio(temp_audio_path)
    except config.ffmpeg.Error as e:
        logger.error(f"FFmpeg error processing video file {file_path}:\n{e.stderr.decode()}")
        raise IOError(f"Failed to extract audio from video using FFmpeg.")
    except Exception as e:
        logger.error(f"General error processing video file {file_path}: {e}")
        raise IOError(f"An unexpected error occurred during video processing: {e}")
    finally:
        shutil.rmtree(temp_dir)

def process_uploaded_image(file_path: str) -> Optional[str]:
    """Performs OCR on an image file to extract text."""
    if not config.PYTESSERACT_AVAILABLE:
        raise ImportError("Image processing requires 'pytesseract' and 'Pillow'.")
    
    logger.info(f"Performing OCR on image file: {os.path.basename(file_path)}")
    try:
        img = config.Image.open(file_path)
        processed_img = img.convert('L')
        text = config.pytesseract.image_to_string(processed_img)
        logger.info(f"OCR complete for image file. Text length: {len(text)}")
        return text
    except config.TESSERACT_ERROR:
        logger.critical("Tesseract executable not found or not configured correctly in config.py.")
        raise
    except Exception as e:
        logger.error(f"Pytesseract error processing image file {file_path}: {e}")
        raise IOError(f"Failed to perform OCR on image: {e}")
```

`server/rag_service/neo4j_handler.py`

```python
# server/rag_service/neo4j_handler.py

import logging
from neo4j import GraphDatabase, exceptions as neo4j_exceptions
import config

logger = logging.getLogger(__name__)

# --- Neo4j Driver Management (No changes here) ---
_neo4j_driver = None
def init_driver():
    global _neo4j_driver
    if _neo4j_driver is not None:
        try:
            _neo4j_driver.verify_connectivity()
            try:
                with _neo4j_driver.session(database=config.NEO4J_DATABASE) as session:
                    session.execute_write(_create_fulltext_index_if_not_exists)
            except Exception as e:
                logger.warning(f"Neo4j: Could not execute index creation during init_driver (non-fatal if already exists): {e}")
            return # Driver already initialized and healthy, index check done
        except Exception:
            if _neo4j_driver: _neo4j_driver.close()
            _neo4j_driver = None # Reset if not healthy
    try:
        _neo4j_driver = GraphDatabase.driver(config.NEO4J_URI, auth=(config.NEO4J_USERNAME, config.NEO4J_PASSWORD))
        _neo4j_driver.verify_connectivity()
        logger.info(f"Neo4j driver initialized. Connected to: {config.NEO4J_URI}")
        
        with _neo4j_driver.session(database=config.NEO4J_DATABASE) as session:
            session.execute_write(_create_fulltext_index_if_not_exists)

    except Exception as e:
        logger.critical(f"Failed to initialize Neo4j driver: {e}", exc_info=True)
        _neo4j_driver = None
def get_driver_instance():
    if _neo4j_driver is None: init_driver()
    if _neo4j_driver is None: raise ConnectionError("Neo4j driver is not available.")
    return _neo4j_driver
def close_driver():
    global _neo4j_driver
    if _neo4j_driver: _neo4j_driver.close(); _neo4j_driver = None
def check_neo4j_connectivity():
    try: get_driver_instance().verify_connectivity(); return True, "connected"
    except Exception as e: return False, f"disconnected: {e}"
def _execute_read_tx(tx_function, *args, **kwargs):
    with get_driver_instance().session(database=config.NEO4J_DATABASE) as session:
        return session.execute_read(tx_function, *args, **kwargs)
def _execute_write_tx(tx_function, *args, **kwargs):
    with get_driver_instance().session(database=config.NEO4J_DATABASE) as session:
        return session.execute_write(tx_function, *args, **kwargs)
def _create_fulltext_index_if_not_exists(tx):
    index_name = "node_search_index"
    
    result = tx.run(f"SHOW FULLTEXT INDEXES WHERE name = '{index_name}'")
    if result.single():
        logger.info(f"Neo4j: Full-text index '{index_name}' already exists.")
        return

    create_query = (
        f"CREATE FULLTEXT INDEX {index_name} "
        f"FOR (n:KnowledgeNode) ON EACH [n.nodeId, n.description] "
        f"OPTIONS {{indexConfig: {{`fulltext.analyzer`: 'standard', `fulltext.eventually_consistent`: true}}}}"
    )
    try:
        tx.run(create_query)
        logger.info(f"Neo4j: Successfully created full-text index '{index_name}'.")
    except Exception as e:
        # Handle cases where index might have been created by another process concurrently
        if "already exists" in str(e):
            logger.info(f"Neo4j: Full-text index '{index_name}' concurrently created or already exists (race condition). Proceeding.")
        else:
            logger.error(f"Neo4j: Failed to create full-text index '{index_name}': {e}", exc_info=True)
            raise #
            
def _delete_kg_transactional(tx, user_id, document_name):
    query = "MATCH (n:KnowledgeNode {userId: $userId, documentName: $documentName}) DETACH DELETE n"
    tx.run(query, userId=user_id, documentName=document_name)
    return True
def _add_nodes_transactional(tx, nodes_param, user_id, document_name):
    processed_nodes = [
        {"id": n["id"].strip(), "type": n.get("type", "concept"), "description": n.get("description", ""), "llm_parent_id": n.get("parent")}
        for n in nodes_param if isinstance(n.get("id"), str) and n.get("id").strip()
    ]
    if not processed_nodes: return 0
    query = """
    UNWIND $nodes_data as props MERGE (n:KnowledgeNode {nodeId: props.id, userId: $userId, documentName: $documentName})
    SET n += props, n.userId = $userId, n.documentName = $documentName RETURN count(n)
    """
    result = tx.run(query, nodes_data=processed_nodes, userId=user_id, documentName=document_name)
    return result.single()[0] if result.peek() else 0
def _add_edges_transactional(tx, edges_param, user_id, document_name):
    valid_edges = [
        {"from": e["from"].strip(), "to": e["to"].strip(), "relationship": e["relationship"].strip().upper().replace(" ", "_")}
        for e in edges_param if isinstance(e.get("from"), str) and e["from"].strip() and isinstance(e.get("to"), str) and e["to"].strip() and isinstance(e.get("relationship"), str) and e["relationship"].strip()
    ]
    if not valid_edges: return 0
    query = """
    UNWIND $edges_data as edge
    MATCH (startNode:KnowledgeNode {nodeId: edge.from, userId: $userId, documentName: $documentName})
    MATCH (endNode:KnowledgeNode {nodeId: edge.to, userId: $userId, documentName: $documentName})
    MERGE (startNode)-[r:RELATED_TO {type: edge.relationship}]->(endNode) RETURN count(r)
    """
    result = tx.run(query, edges_data=valid_edges, userId=user_id, documentName=document_name)
    return result.single()[0] if result.peek() else 0


def _search_kg_transactional(tx, user_id, document_name, query_text):
    logger.info(f"Neo4j TX: Searching KG for user '{user_id}', doc '{document_name}' with query: '{query_text[:50]}...'")
    
    query = """
    CALL db.index.fulltext.queryNodes("node_search_index", $query_text) YIELD node, score
    WHERE node.userId = $userId AND toLower(node.documentName) = toLower($documentName)
    WITH node, score ORDER BY score DESC LIMIT 5
    MATCH (node)-[r:RELATED_TO]-(neighbor)
    WHERE neighbor.userId = $userId AND toLower(neighbor.documentName) = toLower($documentName)
    RETURN node.nodeId AS nodeId, node.description AS description, 
           COLLECT(DISTINCT { relationship: r.type, neighborId: neighbor.nodeId }) AS relations
    """
    
    results = tx.run(query, userId=user_id, documentName=document_name, query_text=query_text)
    
    facts = []
    for record in results:
        fact = f"- Concept '{record['nodeId']}': {record['description']}"
        relations = [f"is '{rel['relationship']}' '{rel['neighborId']}'" for rel in record['relations'] if rel.get('relationship') and rel.get('neighborId')]
        if relations:
            fact += f" | It {', '.join(relations)}."
        facts.append(fact)
    # --- END OF FIX ---
        
    if not facts:
        return "No specific facts were found in the knowledge graph for this query."
        
    return "Facts from Knowledge Graph:\n" + "\n".join(facts)


def _get_kg_transactional(tx, user_id, document_name):
    logger.info(f"Neo4j TX: Retrieving FULL KG for visualization. User '{user_id}', Doc '{document_name}'")
    
    nodes_query = """
    MATCH (n:KnowledgeNode {userId: $userId}) WHERE toLower(n.documentName) = toLower($documentName)
    RETURN n.nodeId AS id, n.type AS type, n.description AS description, n.llm_parent_id AS parent
    """
    nodes_result = tx.run(nodes_query, userId=user_id, documentName=document_name)
    nodes_data = [dict(record) for record in nodes_result]

    edges_query = """
    MATCH (startNode:KnowledgeNode {userId: $userId})-[r:RELATED_TO]->(endNode:KnowledgeNode {userId: $userId})
    WHERE toLower(startNode.documentName) = toLower($documentName) AND toLower(endNode.documentName) = toLower($documentName)
    RETURN startNode.nodeId AS from, endNode.nodeId AS to, r.type AS relationship
    """
    edges_result = tx.run(edges_query, userId=user_id, documentName=document_name)
    edges_data = [dict(record) for record in edges_result]

    logger.info(f"Neo4j TX: Retrieved {len(nodes_data)} nodes and {len(edges_data)} edges for '{document_name}'.")
    return {"nodes": nodes_data, "edges": edges_data}


# --- Public Service Functions ---
def ingest_knowledge_graph(user_id: str, document_name: str, nodes: list, edges: list) -> dict:
    try:
        nodes_affected = _execute_write_tx(_add_nodes_transactional, nodes, user_id, document_name) if nodes else 0
        edges_affected = _execute_write_tx(_add_edges_transactional, edges, user_id, document_name) if edges else 0
        return {"success": True, "message": "KG ingested.", "nodes_affected": nodes_affected, "edges_affected": edges_affected}
    except Exception as e:
        logger.error(f"Error during KG ingestion for doc '{document_name}': {e}", exc_info=True)
        raise

def get_knowledge_graph(user_id: str, document_name: str) -> dict:
    try:
        kg_data = _execute_read_tx(_get_kg_transactional, user_id, document_name)
        if not kg_data or (not kg_data.get("nodes") and not kg_data.get("edges")):
            logger.info(f"No KG data found for user '{user_id}', document '{document_name}'.")
            return None
        return kg_data
    except Exception as e:
        logger.error(f"Error retrieving KG for doc '{document_name}': {e}", exc_info=True)
        raise

def delete_knowledge_graph(user_id: str, document_name: str) -> bool:
    try:
        return _execute_write_tx(_delete_kg_transactional, user_id, document_name)
    except Exception as e:
        logger.error(f"Error deleting KG for doc '{document_name}': {e}", exc_info=True)
        raise

def search_knowledge_graph(user_id: str, document_name: str, query_text: str) -> str:
    try:
        return _execute_read_tx(_search_kg_transactional, user_id, document_name, query_text)
    except Exception as e:
        logger.error(f"Error searching KG for doc '{document_name}', user '{user_id}': {e}", exc_info=True)
        return f"An error occurred while searching the knowledge graph: {e}"
```

`server/rag_service/podcast_generator.py`

```python

# server/rag_service/podcast_generator.py
import logging
import re
from gtts import gTTS

logger = logging.getLogger(__name__)

PODCAST_SCRIPT_PROMPT_TEMPLATE = """
You are an AI podcast script generator. Your SOLE task is to generate a realistic, two-speaker educational dialogue based on the provided text. The script should be substantial, aiming for a length of at least 600-800 words to ensure a meaningful discussion.

**CRITICAL INSTRUCTION:** Your entire output must be ONLY the script itself. Start directly with "SPEAKER_A:". Do NOT include any preamble, introduction, or metadata like "Here is the script:".

---
## Podcast Style Guide
- **Format**: Two-speaker conversational podcast.
- **SPEAKER_A**: The "Curious Learner". Asks clarifying questions and drives the conversation.
- **SPEAKER_B**: The "Expert Teacher". Provides clear, detailed explanations based on the document.
- **Dialogue Flow**: Natural back-and-forth. Create at least 5-7 exchanges.

---
## Task-Specific Instructions
- **Podcast Purpose**: {purpose_instruction}
- **Podcast Length**: {length_instruction}

---
## Source Material
**STUDY FOCUS (The main topic for the podcast):**
{study_focus}
**DOCUMENT TEXT (Use this for all factual answers):**
{document_content}
---
**FINAL SCRIPT OUTPUT (Remember: Start IMMEDIATELY with "SPEAKER_A:"):**
"""

def generate_podcast_script(source_document_text, outline_content, podcast_options, llm_function):
    """Generates a two-speaker podcast script using the LLM with dynamic options."""
    logger.info(f"Generating podcast script with options: {podcast_options}")

    purpose_map = {
        'introduction': "Focus on high-level concepts and definitions. Assume the listener is new to the topic. Keep explanations simple and clear.",
        'exam_prep': "Focus on key facts, data, and potential test questions. The dialogue should be structured like a Q&A review session, covering the most important material for an exam.",
        'deep_dive': "Explore the topic in great detail. Discuss nuances, complexities, and specific examples from the text. Assume the listener has some prior knowledge.",
        'review': "Provide a balanced overview of the main topics. Cover the most important points without getting lost in minor details. This is for general understanding."
    }
    
    length_map = {
        'quick': "The script should be concise, resulting in approximately 5-7 minutes of spoken audio. Aim for around 800-1000 words.",
        'standard': "The script should be of a standard length, resulting in approximately 10-15 minutes of spoken audio. Aim for around 1500-2000 words.",
        'comprehensive': "The script should be very detailed and long, resulting in approximately 15-25 minutes of spoken audio. Aim for over 2500 words."
    }

    purpose_instruction = purpose_map.get(podcast_options.get('studyPurpose'), purpose_map['review'])
    length_instruction = length_map.get(podcast_options.get('sessionLength'), length_map['standard'])

    prompt = PODCAST_SCRIPT_PROMPT_TEMPLATE.format(
        purpose_instruction=purpose_instruction,
        length_instruction=length_instruction,
        document_content=source_document_text[:60000],
        study_focus=outline_content,
    )
    
    script = llm_function(prompt)
    if not script or not script.strip():
        raise ValueError("LLM failed to generate a podcast script.")
    logger.info(f"LLM generated podcast script. Length: {len(script)}")
    return script

def synthesize_audio_with_gtts(text: str, output_path: str):
    """
    Synthesizes audio from text using the gTTS library and saves it as an MP3.
    """
    logger.info(f"Synthesizing audio with gTTS for text of length {len(text)}...")
    
    clean_text = re.sub(r'SPEAKER_[AB]:', '', text).replace('*', '').replace('#', '').strip()
    
    try:
        tts = gTTS(text=clean_text, lang='en', slow=False)
        tts.save(output_path)
        logger.info(f"gTTS audio saved successfully to {output_path}")
    except Exception as e:
        logger.error(f"gTTS failed during synthesis: {e}", exc_info=True)
        raise IOError("Text-to-Speech synthesis with gTTS failed.") from e

```

`server/rag_service/prompts.py`

```python
# server/rag_service/prompts.py

CODE_ANALYSIS_PROMPT_TEMPLATE = """
You are an expert software engineer and code reviewer. Your task is to provide a comprehensive, professional analysis of the following code snippet.

**Analysis Sections (Use Markdown headings for each):**
1.  **Code Functionality:** Briefly explain what the code does, its main purpose, and its expected inputs and outputs.
2.  **Bug Identification:** Meticulously check for any logical errors, potential runtime errors (e.g., division by zero, index out of bounds), or security vulnerabilities. If you find any, explain the bug clearly. If not, state that no obvious bugs were found.
3.  **Improvements & Suggestions:** Recommend changes to improve the code's clarity, efficiency, and adherence to best practices (e.g., better variable names, more efficient algorithms, error handling).

**Formatting:**
- Use clear Markdown for structure.
- For code suggestions, use fenced code blocks with the correct language identifier.

---
**LANGUAGE:**
{language}
---
**CODE TO ANALYZE:**
{code}
**ANALYSIS REPORT:**
"""

TEST_CASE_GENERATION_PROMPT_TEMPLATE = """
You are a meticulous Quality Assurance (QA) engineer. Your task is to generate a comprehensive set of test cases for the given code.
Instructions:
Analyze the code to understand its logic, inputs, and outputs.
Create a diverse set of test cases that cover:
Standard Cases: Common, expected inputs.
Edge Cases: Boundary values, empty inputs, zeros, negative numbers, etc.
Error Cases: Invalid inputs that should cause the program to handle an error gracefully (if applicable).
Your entire output MUST be a single, valid JSON array of objects.
Each object in the array must have two keys: input (a string) and expectedOutput (a string).
For inputs that require multiple lines, use the newline character \\n.
Example Output Format:
[
{{ "input": "5\\n10", "expectedOutput": "15" }},
{{ "input": "0\\n0", "expectedOutput": "0" }},
{{ "input": "-5\\n5", "expectedOutput": "0" }}
]
LANGUAGE:
{language}
CODE TO ANALYZE:
{code}
FINAL JSON TEST CASE ARRAY:
"""


EXPLAIN_ERROR_PROMPT_TEMPLATE = """
You are an expert programming tutor, specializing in explaining complex errors to beginners. Your task is to explain the following runtime error in a clear, step-by-step manner.
Instructions:
Identify the Root Cause: Analyze the error message in the context of the provided code to determine the exact reason for the error.
Explain the Error: Describe what the error message means in simple terms. Avoid jargon where possible, or explain it if necessary.
Pinpoint the Location: State which line(s) of code are causing the problem.
Provide a Solution: Give a corrected version of the problematic code in a fenced code block and explain why the fix works.
Offer General Advice: Provide a concluding tip to help the user avoid similar errors in the future.
Formatting:
Use clear Markdown headings for each section (e.g., ## What Went Wrong, ## How to Fix It).
Use fenced code blocks for all code snippets.
LANGUAGE:
{language}

CODE WITH THE ERROR:
{code}
ERROR MESSAGE:
{error_message}
ERROR EXPLANATION:
"""


QUIZ_GENERATION_PROMPT_TEMPLATE = """
You are an expert educator and assessment creator. Your task is to generate a multiple-choice quiz based SOLELY on the provided document text.

**CRITICAL INSTRUCTIONS (MUST FOLLOW):**
1.  **Strictly Adhere to Context:** Every question, option, and correct answer MUST be directly derived from the information present in the "DOCUMENT TEXT TO ANALYZE" section. Do NOT use any outside knowledge or make assumptions beyond the text.
2.  **Generate Questions:** Create exactly {num_questions} high-quality multiple-choice questions that test understanding of the main concepts, definitions, and key facts in the text.
3.  **Plausible Distractors:** For each question, provide 4 distinct options. One must be the correct answer from the text. The other three must be plausible but incorrect distractors that are relevant to the topic but not supported by the provided text.
4.  **No Trivial Questions:** Do not ask questions about document metadata, section titles, or insignificant details. Focus on the core material.
5.  **Strict JSON Output:** Your entire output **MUST** be a single, valid JSON array of objects. Do NOT include any introductory text, explanations, or markdown fences like ```json ... ```. Your response must begin with `[` and end with `]`.

**JSON SCHEMA PER QUESTION (STRICT):**
{{
    "question": "The full text of the question.",
    "options": ["Option A text", "Option B text", "Option C text", "Option D text"],
    "correctAnswer": "The exact text of the correct answer, which MUST match one of the four options."
}}

**EXAMPLE OF A GOOD QUESTION (Based on a hypothetical text about photosynthesis):**
{{
    "question": "According to the document, what are the two primary products of photosynthesis?",
    "options": ["Water and Carbon Dioxide", "Glucose and Oxygen", "Sunlight and Chlorophyll", "Nitrogen and Water"],
    "correctAnswer": "Glucose and Oxygen"
}}

---
**DOCUMENT TEXT TO ANALYZE:**
{document_text}
---

**FINAL QUIZ JSON ARRAY (start immediately with `[`):**
"""


```

`server/rag_service/quiz_utils.py`

```python
# server/rag_service/quiz_utils.py
import os
import logging
import config  # Use relative import

logger = logging.getLogger(__name__)

# --- THIS IS THE FIX ---
# Set a reasonable character limit to prevent extremely long LLM calls.
# 50,000 characters is roughly 10,000-12,000 words, which is more than enough
# context for a high-quality quiz without excessive processing time.
MAX_TEXT_LEN_FOR_QUIZ = 50000

def extract_text_for_quiz(file_path: str) -> str:
    """
    A lightweight, fast text extractor for quiz generation.
    It supports PDF, DOCX, and TXT files.
    Bypasses heavy processing like OCR, embedding, etc. for speed.
    """
    _, ext = os.path.splitext(file_path)
    ext = ext.lower()
    text_content = ""
    
    logger.info(f"Quiz Utils: Extracting text from '{os.path.basename(file_path)}' (type: {ext})")

    try:
        if ext == '.pdf':
            if config.PYPDF_AVAILABLE and config.pypdf:
                reader = config.pypdf.PdfReader(file_path)
                for page in reader.pages:
                    page_text = page.extract_text()
                    if page_text:
                        text_content += page_text + "\n"
            else:
                logger.warning("pypdf library not available for PDF parsing in quiz utility.")
        
        elif ext == '.docx':
            if config.DOCX_AVAILABLE and config.DocxDocument:
                doc = config.DocxDocument(file_path)
                text_content = "\n".join([para.text for para in doc.paragraphs if para.text.strip()])
            else:
                logger.warning("python-docx library not available for DOCX parsing in quiz utility.")

        elif ext in ['.txt', '.md']:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                text_content = f.read()
        
        else:
            logger.warning(f"Unsupported file type for quick quiz extraction: {ext}. Returning empty text.")
            return ""

        # --- THIS IS THE FIX ---
        if len(text_content) > MAX_TEXT_LEN_FOR_QUIZ:
            logger.warning(f"Quiz Utils: Document text length ({len(text_content)}) exceeds limit ({MAX_TEXT_LEN_FOR_QUIZ}). Truncating text for performance.")
            text_content = text_content[:MAX_TEXT_LEN_FOR_QUIZ]
        # --- END OF FIX ---
        
        logger.info(f"Quiz Utils: Successfully extracted {len(text_content)} characters.")
        return text_content.strip()

    except Exception as e:
        logger.error(f"Quiz Utils: Failed to extract text from '{os.path.basename(file_path)}': {e}", exc_info=True)
        return "" # Return empty string on failure
```

`server/rag_service/requirements.txt`

```
flask
requests
langchain
langchain-huggingface
pypdf
PyPDF2
python-docx
python-dotenv
ollama # Keep if using Ollama embeddings
python-pptx
uuid
langchain-community
pdfplumber
fitz # PyMuPDF for PDF parsing
pytesseract
nltk
spacy-layout
pandas
numpy
typing
pytesseract # OCR
pillow
qdrant-client
neo4j
sentence_transformers
spacy
opencv-python
ddgs
python-pptx
python-docx
reportlab
google-generativeai
gTTS
yt-dlp
openai-whisper
beautifulsoup4
playwright
moviepy
Werkzeug
```

`server/rag_service/speech_enhancer.py`

```python
# server/rag_service/speech_enhancer.py
import speech_recognition as sr
import logging
import io

logger = logging.getLogger(__name__)

recognizer = sr.Recognizer()

def transcribe_audio_from_wav_bytes(audio_bytes: bytes) -> str:
    """
    Transcribes audio from an in-memory WAV byte buffer using Google's free API.
    Note: The input MUST be WAV format bytes.
    """
    logger.info("Transcribing audio using SpeechRecognition (Google Web Speech API free tier)...")
    try:
        # The library's AudioFile class can read from a file-like object (the byte buffer)
        with sr.AudioFile(io.BytesIO(audio_bytes)) as source:
            audio_data = recognizer.record(source)
            text = recognizer.recognize_google(audio_data)
            logger.info(f"Transcription successful. Length: {len(text)}")
            return text
    except sr.UnknownValueError:
        logger.warning("Google Speech Recognition could not understand audio.")
        raise ValueError("Could not understand the audio. It may be silent or unclear.")
    except sr.RequestError as e:
        logger.error(f"Could not request results from Google Speech Recognition service; {e}")
        raise ConnectionError(f"Speech recognition service request failed: {e}")
    except Exception as e:
        logger.error(f"An unexpected error occurred during transcription: {e}", exc_info=True)
        raise

ENHANCEMENT_PROMPT_TEMPLATE = """
You are an expert academic editor and content strategist.
You have been given a raw, unedited transcription of a spoken audio clip. You also have the full source document the speaker was referencing.

Your task is to **enhance the raw transcription** into a polished, professional, and insightful script. You MUST adhere to these rules:
1.  **Correct Errors:** Fix any grammatical errors, stutters, or awkward phrasing from the raw transcription.
2.  **Add Academic Depth:** Seamlessly integrate key facts, data, or concepts from the provided **SOURCE DOCUMENT TEXT** to add depth and accuracy to the speaker's points.
3.  **Maintain Speaker's Voice:** The output should still sound like a natural, spoken script, not a dense academic paper. Keep the original intent and tone.
4.  **Output Only the Polished Script:** Your entire response must be ONLY the final, enhanced script text. Do not include any preambles like "Here is the enhanced script:".

---
**SOURCE DOCUMENT TEXT (Your knowledge base):**
{source_document_text}
---
**RAW AUDIO TRANSCRIPTION (To be enhanced):**
{raw_transcription}
---

**FINAL, ENHANCED SCRIPT (Start immediately with the first sentence):**
"""

def enhance_script_with_llm(raw_transcription: str, source_document_text: str, llm_function) -> str:
    """Uses an LLM to enhance a raw transcription with context from a source document."""
    logger.info("Enhancing transcribed script using LLM...")
    
    prompt = ENHANCEMENT_PROMPT_TEMPLATE.format(
        source_document_text=source_document_text[:40000], # Limit context to avoid excessive token usage
        raw_transcription=raw_transcription
    )
    
    enhanced_script = llm_function(prompt)
    if not enhanced_script or not enhanced_script.strip():
        raise ValueError("LLM failed to generate the enhanced script.")
        
    logger.info(f"LLM generated enhanced script. Length: {len(enhanced_script)}")
    return enhanced_script
```

`server/rag_service/vector_db_service.py`

```python
import uuid
import logging
from typing import List, Dict, Tuple, Optional, Any

from qdrant_client import QdrantClient, models
from sentence_transformers import SentenceTransformer

# Assuming vector_db_service.py and config.py are in the same package directory (e.g., rag_service/)
# and you run your application as a module (e.g., python -m rag_service.main_app)
# or have otherwise correctly set up the Python path.
import config # Changed to relative import

# Configure basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class Document: # For search result formatting
    def __init__(self, page_content: str, metadata: dict):
        self.page_content = page_content
        self.metadata = metadata

    def to_dict(self):
        return {"page_content": self.page_content, "metadata": self.metadata}

class VectorDBService:
    def __init__(self):
        logger.info("Initializing VectorDBService...")
        logger.info(f"  Qdrant Host: {config.QDRANT_HOST}, Port: {config.QDRANT_PORT}, URL: {config.QDRANT_URL}")
        logger.info(f"  Collection: {config.QDRANT_COLLECTION_NAME}")
        logger.info(f"  Query Embedding Model: {config.QUERY_EMBEDDING_MODEL_NAME}")
        
        # The vector dimension for the Qdrant collection is defined by the DOCUMENT embedding model
        # This is set in config.QDRANT_COLLECTION_VECTOR_DIM
        self.vector_dim = config.QDRANT_COLLECTION_VECTOR_DIM
        logger.info(f"  Service expects Vector Dim for Qdrant collection: {self.vector_dim} (from document model config)")

        if config.QDRANT_URL:
            self.client = QdrantClient(
                url=config.QDRANT_URL,
                api_key=config.QDRANT_API_KEY,
                timeout=30
            )
        else:
            self.client = QdrantClient(
                host=config.QDRANT_HOST,
                port=config.QDRANT_PORT,
                api_key=config.QDRANT_API_KEY,
                timeout=30
            )

        try:
            # This model is for encoding search queries.
            # Its output dimension MUST match self.vector_dim (QDRANT_COLLECTION_VECTOR_DIM).
            logger.info(f"  Loading query embedding model: '{config.QUERY_EMBEDDING_MODEL_NAME}'")
            self.model = SentenceTransformer(config.QUERY_EMBEDDING_MODEL_NAME)
            model_embedding_dim = self.model.get_sentence_embedding_dimension()
            logger.info(f"  Query model loaded. Output dimension: {model_embedding_dim}")

            if model_embedding_dim != self.vector_dim:
                error_msg = (
                    f"CRITICAL DIMENSION MISMATCH: Query model '{config.QUERY_EMBEDDING_MODEL_NAME}' "
                    f"outputs embeddings of dimension {model_embedding_dim}, but the Qdrant collection "
                    f"is configured for dimension {self.vector_dim} (derived from document model: "
                    f"'{config.DOCUMENT_EMBEDDING_MODEL_NAME}'). Search functionality will fail. "
                    "Ensure query and document models produce compatible embedding dimensions, "
                    "or environment variables for dimensions are correctly set."
                )
                logger.error(error_msg)
                raise ValueError(error_msg) # Critical error, stop initialization
            else:
                logger.info(f"  Query model output dimension ({model_embedding_dim}) matches "
                            f"Qdrant collection dimension ({self.vector_dim}).")

        except Exception as e:
            logger.error(f"Error initializing SentenceTransformer model '{config.QUERY_EMBEDDING_MODEL_NAME}' for query encoding: {e}", exc_info=True)
            raise # Re-raise to prevent service startup with a non-functional query encoder

        self.collection_name = config.QDRANT_COLLECTION_NAME
        # No ThreadPoolExecutor needed here if document encoding is external

    def _recreate_qdrant_collection(self):
        logger.info(f"Attempting to (re)create collection '{self.collection_name}' with vector size {self.vector_dim}.")
        try:
            self.client.recreate_collection(
                collection_name=self.collection_name,
                vectors_config=models.VectorParams(
                    size=self.vector_dim,
                    distance=models.Distance.COSINE,
                ),
            )
            logger.info(f"Collection '{self.collection_name}' (re)created successfully.")
        except Exception as e_recreate:
            logger.error(f"Failed to (re)create collection '{self.collection_name}': {e_recreate}", exc_info=True)
            raise

    def setup_collection(self):
        try:
            collection_info = self.client.get_collection(collection_name=self.collection_name)
            logger.info(f"Collection '{self.collection_name}' already exists.")
            
            # Handle different Qdrant client versions for accessing vector config
            current_vectors_config = None
            if hasattr(collection_info.config.params, 'vectors'): # For simple vector config
                if isinstance(collection_info.config.params.vectors, models.VectorParams):
                     current_vectors_config = collection_info.config.params.vectors
                elif isinstance(collection_info.config.params.vectors, dict): # For named vectors
                    # Assuming default unnamed vector or first one if named
                    default_vector_name = '' # Common for single vector setup
                    if default_vector_name in collection_info.config.params.vectors:
                        current_vectors_config = collection_info.config.params.vectors[default_vector_name]
                    elif collection_info.config.params.vectors: # Get first one if default not found
                        current_vectors_config = next(iter(collection_info.config.params.vectors.values()))

            if not current_vectors_config:
                 logger.error(f"Could not determine vector configuration for existing collection '{self.collection_name}'. Recreating.")
                 self._recreate_qdrant_collection()
            elif current_vectors_config.size != self.vector_dim:
                logger.warning(f"Collection '{self.collection_name}' vector size {current_vectors_config.size} "
                               f"differs from service's expected {self.vector_dim}. Recreating.")
                self._recreate_qdrant_collection()
            elif current_vectors_config.distance != models.Distance.COSINE: # Ensure distance is also checked
                logger.warning(f"Collection '{self.collection_name}' distance {current_vectors_config.distance} "
                               f"differs from expected {models.Distance.COSINE}. Recreating.")
                self._recreate_qdrant_collection()
            else:
                logger.info(f"Collection '{self.collection_name}' configuration is compatible (Size: {current_vectors_config.size}, Distance: {current_vectors_config.distance}).")

        except Exception as e: # Broad exception for Qdrant client errors
            # More specific check for "Not found" type errors
            if "not found" in str(e).lower() or \
               (hasattr(e, 'status_code') and e.status_code == 404) or \
               " ভাগ্যবান" in str(e).lower(): # "Lucky" in Bengali, seems to be part of an error message you encountered
                 logger.info(f"Collection '{self.collection_name}' not found. Attempting to create...")
            else:
                 logger.warning(f"Error checking collection '{self.collection_name}': {type(e).__name__} - {e}. Attempting to (re)create anyway...")
            self._recreate_qdrant_collection()

    def add_processed_chunks(self, processed_chunks: List[Dict[str, Any]]) -> int:
        if not processed_chunks:
            logger.warning("add_processed_chunks received an empty list. No points to upsert.")
            return 0

        points_to_upsert = []
        doc_name_for_logging = "Unknown Document"

        for chunk_data in processed_chunks:
            point_id = chunk_data.get('id', str(uuid.uuid4()))
            vector = chunk_data.get('embedding')
            
            payload = chunk_data.get('metadata', {}).copy()
            payload['chunk_text_content'] = chunk_data.get('text_content', '')

            if not doc_name_for_logging or doc_name_for_logging == "Unknown Document":
                doc_name_for_logging = payload.get('original_name', payload.get('document_name', "Unknown Document"))

            if not vector:
                logger.warning(f"Chunk with ID '{point_id}' from '{doc_name_for_logging}' is missing 'embedding'. Skipping.")
                continue
            if not isinstance(vector, list) or not all(isinstance(x, (float, int)) for x in vector): # Allow int too, SentenceTransformer can return float32 which might be int-like in lists
                logger.warning(f"Chunk with ID '{point_id}' from '{doc_name_for_logging}' has an invalid 'embedding' format. Skipping.")
                continue
            if len(vector) != self.vector_dim:
                logger.error(f"Chunk with ID '{point_id}' from '{doc_name_for_logging}' has embedding dimension {len(vector)}, "
                             f"but collection expects {self.vector_dim}. Skipping. "
                             f"Ensure ai_core's document embedding model ('{config.DOCUMENT_EMBEDDING_MODEL_NAME}') "
                             f"output dimension matches configuration.")
                continue

            points_to_upsert.append(models.PointStruct(
                id=point_id,
                vector=[float(v) for v in vector], # Ensure all are floats for Qdrant
                payload=payload
            ))

        if not points_to_upsert:
            logger.warning(f"No valid points constructed from processed_chunks for document: {doc_name_for_logging}.")
            return 0

        try:
            self.client.upsert(collection_name=self.collection_name, points=points_to_upsert, wait=True) # wait=True can be useful for debugging
            logger.info(f"Successfully upserted {len(points_to_upsert)} chunks for document: {doc_name_for_logging} into Qdrant.")
            return len(points_to_upsert)
        except Exception as e:
            logger.error(f"Error upserting processed chunks to Qdrant for document: {doc_name_for_logging}: {e}", exc_info=True)
            raise

    def search_documents(self, query: str, k: int = -1, filter_conditions: Optional[models.Filter] = None) -> Tuple[List[Document], str, Dict]:
        # Use default k from config if not provided or invalid
        if k <= 0:
            k_to_use = config.QDRANT_DEFAULT_SEARCH_K
        else:
            k_to_use = k

        context_docs = []
        formatted_context_text = "No relevant context was found in the available documents."
        context_docs_map = {}

        logger.info(f"Searching with query (first 50 chars): '{query[:50]}...', k: {k_to_use}")
        if filter_conditions:
            try: filter_dict = filter_conditions.dict()
            except AttributeError: # For older Pydantic versions
                try: filter_dict = filter_conditions.model_dump()
                except AttributeError: filter_dict = str(filter_conditions) # Fallback
            logger.info(f"Applying filter: {filter_dict}")
        else:
            logger.info("No filter applied for search.")

        try:
            query_embedding = self.model.encode(query).tolist()
            logger.debug(f"Generated query_embedding (length: {len(query_embedding)}, first 5 dims: {query_embedding[:5]})")

            search_results = self.client.search(
                collection_name=self.collection_name,
                query_vector=query_embedding,
                query_filter=filter_conditions,
                limit=k_to_use,
                with_payload=True,
                score_threshold=config.QDRANT_SEARCH_MIN_RELEVANCE_SCORE # Apply score threshold directly in search
            )
            logger.info(f"Qdrant client.search returned {len(search_results)} results (after score threshold).")

            if not search_results:
                return context_docs, formatted_context_text, context_docs_map

            for idx, point in enumerate(search_results):
                # Score threshold is already applied by Qdrant if score_threshold parameter is used.
                # If not using score_threshold in client.search, uncomment this:
                # if point.score < config.QDRANT_SEARCH_MIN_RELEVANCE_SCORE:
                #     logger.debug(f"Skipping point ID {point.id} with score {point.score:.4f} (below threshold {config.QDRANT_SEARCH_MIN_RELEVANCE_SCORE})")
                #     continue

                payload = point.payload
                content = payload.get("chunk_text_content", payload.get("text_content", payload.get("chunk_text", "")))

                retrieved_metadata = payload.copy()
                retrieved_metadata["qdrant_id"] = point.id
                retrieved_metadata["score"] = point.score

                doc = Document(page_content=content, metadata=retrieved_metadata)
                context_docs.append(doc)

            # Format context and citations
            formatted_context_parts = []
            for i, doc_obj in enumerate(context_docs):
                citation_index = i + 1
                doc_meta = doc_obj.metadata
                # Use more robust fetching of metadata keys
                display_subject = doc_meta.get("title", doc_meta.get("subject", "Unknown Subject")) # Prefer title for subject
                doc_name = doc_meta.get("original_name", doc_meta.get("file_name", "N/A"))
                page_num_info = f" (Page: {doc_meta.get('page_number', 'N/A')})" if doc_meta.get('page_number') else "" # Add page number if available
                
                content_preview = doc_obj.page_content[:200] + "..." if len(doc_obj.page_content) > 200 else doc_obj.page_content

                formatted = (f"[{citation_index}] Score: {doc_meta.get('score', 0.0):.4f} | "
                             f"Source: {doc_name}{page_num_info} | Subject: {display_subject}\n"
                             f"Content: {content_preview}") # Show content preview
                formatted_context_parts.append(formatted)

                context_docs_map[str(citation_index)] = {
                    "subject": display_subject,
                    "document_name": doc_name,
                    "page_number": doc_meta.get("page_number"),
                    "content_preview": content_preview, # Store preview
                    "full_content": doc_obj.page_content, # Store full content for potential later use
                    "score": doc_meta.get("score", 0.0),
                    "qdrant_id": doc_meta.get("qdrant_id"),
                    "original_metadata": doc_meta # Store all original metadata from payload
                }
            if formatted_context_parts:
                formatted_context_text = "\n\n---\n\n".join(formatted_context_parts)
            else:
                formatted_context_text = "No sufficiently relevant context was found after filtering."

        except Exception as e:
            logger.error(f"Qdrant search/RAG error: {e}", exc_info=True)
            formatted_context_text = "Error retrieving context due to an internal server error."

        return context_docs, formatted_context_text, context_docs_map
    
    # Add this method to the VectorDBService class in vector_db_service.py

    def delete_document_vectors(self, user_id: str, document_name: str) -> Dict[str, Any]:
        logger.info(f"Attempting to delete vectors for document: '{document_name}', user: '{user_id}' from Qdrant collection '{self.collection_name}'.")
        
        # These metadata keys must match what's stored during ingestion from ai_core.py
        # 'processing_user' was the user_id passed to ai_core
        # 'file_name' was the original_name passed to ai_core
        qdrant_filter = models.Filter(
            must=[
                models.FieldCondition(
                    key="processing_user", # The metadata field storing the user ID
                    match=models.MatchValue(value=user_id)
                ),
                models.FieldCondition(
                    key="file_name", # The metadata field storing the original document name
                    match=models.MatchValue(value=document_name)
                )
            ]
        )
        
        try:
            # Optional: Count points before deleting for logging/confirmation
            # count_response = self.client.count(collection_name=self.collection_name, count_filter=qdrant_filter)
            # num_to_delete = count_response.count
            # logger.info(f"Qdrant: Found {num_to_delete} points matching criteria for document '{document_name}', user '{user_id}'.")

            # if num_to_delete == 0:
            #     logger.info(f"Qdrant: No points found to delete for document '{document_name}', user '{user_id}'.")
            #     return {"success": True, "message": "No matching vectors found in Qdrant to delete.", "deleted_count": 0}

            delete_result = self.client.delete(
                collection_name=self.collection_name,
                points_selector=models.FilterSelector(filter=qdrant_filter),
                wait=True # Make it synchronous
            )
            
            # Check the status of the delete operation
            # delete_result should be an UpdateResult object
            if delete_result.status == models.UpdateStatus.COMPLETED or delete_result.status == models.UpdateStatus.ACKNOWLEDGED:
                # The actual number of deleted points isn't directly returned by filter-based delete.
                # We can infer it was successful if no error.
                # For a precise count, you'd need to list IDs by filter, then delete by IDs.
                logger.info(f"Qdrant delete operation for document '{document_name}', user '{user_id}' acknowledged/completed. Status: {delete_result.status}")
                return {"success": True, "message": f"Qdrant vector deletion for document '{document_name}' completed. Status: {delete_result.status}."}
            else:
                logger.warning(f"Qdrant delete operation for document '{document_name}', user '{user_id}' returned status: {delete_result.status}")
                return {"success": False, "message": f"Qdrant delete operation status: {delete_result.status}"}

        except Exception as e:
            logger.error(f"Error deleting document vectors from Qdrant for document '{document_name}', user '{user_id}': {e}", exc_info=True)
            # Check for specific Qdrant client errors if possible, e.g., if the collection doesn't exist.
            return {"success": False, "message": f"Failed to delete Qdrant vectors: {str(e)}"}

    def close(self):
        logger.info("VectorDBService close called.")
        # No specific resources like ThreadPoolExecutor to release in this version.
        # QdrantClient does not have an explicit close() method in recent versions.
```

`server/rag_service/__init__.py`

```python

```

`server/routes/admin.js`

```javascript
// server/routes/admin.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const fsPromises = fs.promises;
const AdminDocument = require('../models/AdminDocument');
const axios = require('axios');
const User = require('../models/User');
const ChatHistory = require('../models/ChatHistory');
const { cacheMiddleware } = require('../middleware/cacheMiddleware');
const { redisClient } = require('../config/redisClient');
const { encrypt } = require('../utils/crypto');

const router = express.Router();
const CACHE_DURATION_SECONDS = 30; 
// --- NEW Dashboard Stats Route ---
// @route   GET /api/admin/dashboard-stats
// @desc    Get key statistics for the admin dashboard
router.get('/dashboard-stats',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const [totalUsers, totalAdminDocs, totalSessions, pendingApiKeys] = await Promise.all([
            User.countDocuments(),
            AdminDocument.countDocuments(),
            ChatHistory.countDocuments(),
            User.countDocuments({ apiKeyRequestStatus: 'pending' })
        ]);

        res.json({
            totalUsers,
            totalAdminDocs,
            totalSessions,
            pendingApiKeys
        });
    } catch (error) {
        console.error('Error fetching dashboard stats:', error);
        res.status(500).json({ message: 'Server error while fetching dashboard stats.' });
    }
});


// --- API Key Management Routes ---

// @route   GET /api/admin/key-requests
// @desc    Get all users with a pending API key request
router.get('/key-requests',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const requests = await User.find({ apiKeyRequestStatus: 'pending' })
            .select('email profile createdAt')
            .sort({ createdAt: -1 });
        res.json(requests);
    } catch (error) {
        console.error('Error fetching API key requests:', error);
        res.status(500).json({ message: 'Server error while fetching requests.' });
    }
});

// @route   POST /api/admin/key-requests/approve
router.post("/key-requests/approve", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "User ID is required." });
  }

  try {
    const serverApiKey = process.env.GEMINI_API_KEY;
    if (!serverApiKey) {
      return res
        .status(500)
        .json({ message: "Server-side GEMINI_API_KEY is not configured." });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    user.encryptedApiKey = serverApiKey; // pre-save hook handles encryption
    user.apiKeyRequestStatus = "approved";
    user.preferredLlmProvider = "gemini";

    await user.save();

    // --- NEW: Invalidate Redis Cache for pending requests and dashboard stats ---
    if (redisClient && redisClient.isOpen) {
        await redisClient.del('__express__/api/admin/key-requests').catch(err => console.error("Redis DEL error:", err));
        await redisClient.del('__express__/api/admin/dashboard-stats').catch(err => console.error("Redis DEL error:", err));
        console.log(`Redis cache for '/api/admin/key-requests' and '/api/admin/dashboard-stats' invalidated.`);
    }
    // --- END NEW ---

    res.json({
      message: `API key request for ${user.email} has been approved.`,
    });
  } catch (error) {
    console.error(`Error approving API key for user ${userId}:`, error);
    res.status(500).json({ message: "Server error while approving request." });
  }
})
// @route   POST /api/admin/key-requests/reject
// @desc    Reject a user's API key request
router.post("/key-requests/reject", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "User ID is required." });
  }

  try {
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    user.apiKeyRequestStatus = "rejected";
    await user.save();

    // --- NEW: Invalidate Redis Cache for pending requests and dashboard stats ---
    if (redisClient && redisClient.isOpen) {
        await redisClient.del('__express__/api/admin/key-requests').catch(err => console.error("Redis DEL error:", err));
        await redisClient.del('__express__/api/admin/dashboard-stats').catch(err => console.error("Redis DEL error:", err));
        console.log(`Redis cache for '/api/admin/key-requests' and '/api/admin/dashboard-stats' invalidated.`);
    }
    // --- END NEW ---

    res.json({
      message: `API key request for ${user.email} has been rejected.`,
    });
  } catch (error) {
    console.error(`Error rejecting API key for user ${userId}:`, error);
    res.status(500).json({ message: "Server error while rejecting request." });
  }
});
// --- Document Management Routes ---

const ADMIN_UPLOAD_DIR_BASE = path.join(
  __dirname,
  "..",
  "assets",
  "_admin_uploads_"
);
const MAX_FILE_SIZE = 20 * 1024 * 1024;
const allowedAdminMimeTypes = {
  "application/pdf": "docs",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
    "docs",
  "text/plain": "docs",
  "text/markdown": "docs",
};
const allowedAdminExtensions = [".pdf", ".docx", ".txt", ".md"];

const adminStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const fileMimeType = file.mimetype.toLowerCase();
    const fileTypeSubfolder = allowedAdminMimeTypes[fileMimeType] || "others";
    const destinationPath = path.join(ADMIN_UPLOAD_DIR_BASE, fileTypeSubfolder);
    fs.mkdir(destinationPath, { recursive: true }, (err) => {
      if (err) return cb(err);
      cb(null, destinationPath);
    });
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const fileExt = path.extname(file.originalname).toLowerCase();
    const sanitizedBaseName = path
      .basename(file.originalname, fileExt)
      .replace(/[^a-zA-Z0-9._-]/g, "_")
      .substring(0, 100);
    cb(null, `${timestamp}-${sanitizedBaseName}${fileExt}`);
  },
});
const adminFileFilter = (req, file, cb) => {
  const fileExt = path.extname(file.originalname).toLowerCase();
  const mimeType = file.mimetype.toLowerCase();
  if (
    allowedAdminMimeTypes[mimeType] &&
    allowedAdminExtensions.includes(fileExt)
  ) {
    cb(null, true);
  } else {
    const error = new multer.MulterError("LIMIT_UNEXPECTED_FILE_TYPE_ADMIN");
    error.message = `Invalid file type. Allowed: ${allowedAdminExtensions.join(
      ", "
    )}`;
    cb(error, false);
  }
};
const adminUpload = multer({ storage: adminStorage, fileFilter: adminFileFilter, limits: { fileSize: MAX_FILE_SIZE }});
async function triggerPythonRagProcessingForAdmin(filePath, originalName) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        return { success: false, message: "Python service URL not configured.", text: null, chunksForKg: [] };
    }
    const addDocumentUrl = `${pythonServiceUrl}/add_document`;
    try {
        const response = await axios.post(addDocumentUrl, {
            user_id: "admin",
            file_path: filePath, original_name: originalName
        }, { timeout: 300000 });
        
        const text = response.data?.raw_text_for_analysis || null;
        const chunksForKg = response.data?.chunks_with_metadata || [];
        const isSuccess = !!(text && text.trim());
        return { 
            success: isSuccess, 
            message: response.data?.message || "Python RAG service call completed.", 
            text: text,
            chunksForKg: chunksForKg
        };
    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Unknown error calling Python RAG.";
        return { success: false, message: `Python RAG call failed: ${errorMsg}`, text: null, chunksForKg: [] };
    }
}
async function callPythonDeletionEndpoint(
  method,
  endpointPath,
  userId,
  originalName
) {
  const pythonServiceUrl =
    process.env.PYTHON_RAG_SERVICE_URL || "http://localhost:5000";
  const deleteUrl = `${pythonServiceUrl.replace(/\/$/, "")}${endpointPath}`;
  try {
    await axios.delete(deleteUrl, {
      data: { user_id: userId, document_name: originalName },
      timeout: 30000,
    });
    return {
      success: true,
      message: `Successfully requested deletion from ${endpointPath}`,
    };
  } catch (error) {
    return {
      success: false,
      message: `Python service call failed for ${endpointPath}: ${error.message}`,
    };
  }
}

// @route   POST /api/admin/documents/upload
router.post(
  "/documents/upload",
  adminUpload.single("file"),
  async (req, res) => {
    if (!req.file) {
      return res
        .status(400)
        .json({ message: "No file uploaded or file type rejected." });
    }
    const {
      filename: serverFilename,
      originalname: originalName,
      path: tempServerPath,
    } = req.file;
    let adminDocRecord;
    try {
      if (await AdminDocument.exists({ originalName: originalName })) {
        await fsPromises.unlink(tempServerPath);
        return res
          .status(409)
          .json({ message: `Document '${originalName}' already exists.` });
      }

      const ragResult = await triggerPythonRagProcessingForAdmin(
        tempServerPath,
        originalName
      );
      if (!ragResult.success) {
        await fsPromises.unlink(tempServerPath);
        return res.status(422).json({ message: ragResult.message });
      }

      adminDocRecord = new AdminDocument({
        filename: serverFilename,
        originalName: originalName,
        text: ragResult.text,
      });
      await adminDocRecord.save();
      await fsPromises.unlink(tempServerPath);

      res.status(202).json({
        message: `Admin document '${originalName}' uploaded. Background processing initiated.`,
      });

      const { Worker } = require("worker_threads");
      const analysisWorker = new Worker(
        path.resolve(__dirname, "..", "workers", "adminAnalysisWorker.js"),
        {
          workerData: {
            adminDocumentId: adminDocRecord._id.toString(),
            originalName: originalName,
            textForAnalysis: ragResult.text,
          },
        }
      );
      analysisWorker.on("error", (err) =>
        console.error(
          `Admin Analysis Worker Error [Doc: ${originalName}]:`,
          err
        )
      );

      if (ragResult.chunksForKg && ragResult.chunksForKg.length > 0) {
        const kgWorker = new Worker(
          path.resolve(__dirname, "..", "workers", "kgWorker.js"),
          {
            workerData: {
              adminDocumentId: adminDocRecord._id.toString(),
              userId: "admin",
              originalName: originalName,
              chunksForKg: ragResult.chunksForKg,
              llmProvider: "gemini",
            },
          }
        );
        kgWorker.on("error", (err) =>
          console.error(`Admin KG Worker Error [Doc: ${originalName}]:`, err)
        );
      } else {
        console.warn(
          `[Admin Upload] No chunks for KG processing for '${originalName}'.`
        );
        await AdminDocument.updateOne(
          { _id: adminDocRecord._id },
          { $set: { kgStatus: "skipped_no_chunks" } }
        );
      }
    } catch (error) {
      console.error(
        `Admin Upload: Overall error for '${
          originalName || req.file?.originalname
        }':`,
        error
      );
      if (tempServerPath && fs.existsSync(tempServerPath))
        await fsPromises.unlink(tempServerPath).catch(() => {});
      if (!res.headersSent) {
        res
          .status(500)
          .json({ message: "Server error during admin document upload." });
      }
    }
  }
);

// @route   GET /api/admin/documents
router.get('/documents',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const adminDocs = await AdminDocument.find().sort({ uploadedAt: -1 })
            .select('originalName filename uploadedAt analysisUpdatedAt analysis.faq analysis.topics analysis.mindmap');
        const documentsList = adminDocs.map(doc => ({
            originalName: doc.originalName, serverFilename: doc.filename, uploadedAt: doc.uploadedAt,
            analysisUpdatedAt: doc.analysisUpdatedAt,
            hasFaq: !!(doc.analysis?.faq?.trim()),
            hasTopics: !!(doc.analysis?.topics?.trim()),
            hasMindmap: !!(doc.analysis?.mindmap?.trim()),
        }));
        res.json({ documents: documentsList });
    } catch (error) {
        res.status(500).json({ message: 'Server error fetching admin documents.' });
    }
});

// @route   DELETE /api/admin/documents/:serverFilename
router.delete("/documents/:serverFilename", async (req, res) => {
  const { serverFilename } = req.params;
  if (!serverFilename) {
    return res.status(400).json({ message: "Server filename is required." });
  }
  try {
    const docToDelete = await AdminDocument.findOne({
      filename: serverFilename,
    });
    if (!docToDelete) {
      return res
        .status(404)
        .json({ message: `Admin document '${serverFilename}' not found.` });
    }

    const originalName = docToDelete.originalName;
    const userId = "admin";

    await callPythonDeletionEndpoint(
      "DELETE",
      `/delete_qdrant_document_data`,
      userId,
      originalName
    );
    await callPythonDeletionEndpoint(
      "DELETE",
      `/kg/${userId}/${encodeURIComponent(originalName)}`,
      userId,
      originalName
    );
    await AdminDocument.deleteOne({ _id: docToDelete._id });

    res
      .status(200)
      .json({
        message: `Admin document '${originalName}' and all associated data deleted.`,
      });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Server error during admin document deletion." });
  }
});

// @route   GET /api/admin/documents/:serverFilename/analysis
router.get("/documents/:serverFilename/analysis", async (req, res) => {
  const { serverFilename } = req.params;
  if (!serverFilename)
    return res
      .status(400)
      .json({ message: "Server filename parameter is required." });
  try {
    const adminDoc = await AdminDocument.findOne({
      filename: serverFilename,
    }).select("originalName analysis analysisUpdatedAt");
    if (!adminDoc)
      return res
        .status(404)
        .json({ message: `Admin document '${serverFilename}' not found.` });
    res.status(200).json({
      originalName: adminDoc.originalName,
      analysis: adminDoc.analysis || { faq: "", topics: "", mindmap: "" },
      analysisUpdatedAt: adminDoc.analysisUpdatedAt,
    });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Server error retrieving admin document analysis." });
  }
});

// @route   GET /api/admin/documents/by-original-name/:originalName/analysis
router.get(
  "/documents/by-original-name/:originalName/analysis",
  async (req, res) => {
    const { originalName } = req.params;
    if (!originalName)
      return res
        .status(400)
        .json({ message: "Original name parameter is required." });
    try {
      const decodedOriginalName = decodeURIComponent(originalName);
      const adminDoc = await AdminDocument.findOne({
        originalName: decodedOriginalName,
      }).select("originalName filename analysis analysisUpdatedAt");
      if (!adminDoc) {
        return res
          .status(404)
          .json({
            message: `Admin document '${decodedOriginalName}' not found.`,
          });
      }
      res.status(200).json({
        originalName: adminDoc.originalName,
        serverFilename: adminDoc.filename,
        analysis: adminDoc.analysis || { faq: "", topics: "", mindmap: "" },
        analysisUpdatedAt: adminDoc.analysisUpdatedAt,
      });
    } catch (error) {
      res
        .status(500)
        .json({
          message: "Server error while retrieving analysis by original name.",
        });
    }
  }
);

// --- User & Chat Management Routes ---

// @route   GET /api/admin/users-with-chats
// @desc    Get all users and their chat session summaries
router.get('/users-with-chats',cacheMiddleware(CACHE_DURATION_SECONDS), async (req, res) => {
    try {
        const allHistories = await ChatHistory.find({})
            .populate('userId', 'email profile.name')
            .sort({ updatedAt: -1 })
            .lean();

        const usersMap = new Map();

        for (const session of allHistories) {
            if (!session.userId) continue;

            const userId = session.userId._id.toString();

            if (!usersMap.has(userId)) {
                usersMap.set(userId, {
                    user: {
                        _id: userId,
                        email: session.userId.email,
                        name: session.userId.profile?.name || 'N/A'
                    },
                    sessions: []
                });
            }

            const userEntry = usersMap.get(userId);
            userEntry.sessions.push({
                sessionId: session.sessionId,
                updatedAt: session.updatedAt,
                summary: session.summary || 'No summary available.',
                messageCount: session.messages?.length || 0
            });
        }

        res.json(Array.from(usersMap.values()));

    } catch (error) {
        console.error('Error fetching users with chat summaries:', error);
        res.status(500).json({ message: 'Server error while fetching user chat data.' });
    }
});


module.exports = router;
```

`server/routes/analysis.js`

```javascript
// server/routes/analysis.js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');
const KnowledgeSource = require('../models/KnowledgeSource');
const AdminDocument = require('../models/AdminDocument');

// @route   GET /api/analysis/:documentFilename
// @desc    Get analysis data for a user's knowledge source or an admin subject
// @access  Private
router.get('/:documentFilename', authMiddleware, async (req, res) => {
    const userId = req.user._id;
    const { documentFilename } = req.params;

    if (!documentFilename) {
        return res.status(400).json({ message: 'Document filename parameter is required.' });
    }

    try {
        let sourceDocument = null;

        // 1. Check user-specific KnowledgeSource by its title
        sourceDocument = await KnowledgeSource.findOne({ userId, title: documentFilename }).select('analysis').lean();
        
        // 2. If not found, fallback to AdminDocument (Subjects) by its originalName
        if (!sourceDocument) {
            sourceDocument = await AdminDocument.findOne({ originalName: documentFilename }).select('analysis').lean();
        }

        if (!sourceDocument) {
            return res.status(404).json({ message: `Document or Subject '${documentFilename}' not found.` });
        }
        
        // Send the analysis sub-document, ensuring it's an object even if empty
        res.status(200).json(sourceDocument.analysis || { faq: "", topics: "", mindmap: "" });

    } catch (error) {
        console.error(`Error fetching analysis for '${documentFilename}':`, error);
        res.status(500).json({ message: 'Server error while retrieving document analysis.' });
    }
});

module.exports = router;
```

`server/routes/auth.js`

```javascript
// server/routes/auth.js
const express = require('express');
const jwt = require('jsonwebtoken');
const { v4: uuidv4 } = require('uuid');
const User = require('../models/User');
const { authMiddleware } = require('../middleware/authMiddleware');
require('dotenv').config();

const router = express.Router();
const JWT_EXPIRATION = process.env.JWT_EXPIRATION || '7d';

// --- @route   POST /api/auth/signup ---
// server/routes/auth.js

router.post('/signup', async (req, res) => {
  // 1. Destructure the full payload from the multi-step form
  const {
    email, password, apiKey, ollamaUrl, preferredLlmProvider, requestAdminKey,
    name, college, universityNumber, degreeType, branch, year,
    learningStyle, currentGoals
  } = req.body;

  // 2. Comprehensive Validation for the entire payload
  if (!email || !password || !name || !college || !universityNumber || !degreeType || !branch || !year || !learningStyle) {
    return res.status(400).json({ message: 'All required profile fields must be completed to sign up.' });
  }
  if (!/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/.test(email)) {
    return res.status(400).json({ message: 'Please provide a valid email address.' });
  }
  if (password.length < 6) {
    return res.status(400).json({ message: 'Password must be at least 6 characters long.' });
  }
  if (preferredLlmProvider === 'gemini' && !requestAdminKey && (!apiKey || apiKey.trim() === '')) {
    return res.status(400).json({ message: 'A Gemini API Key is required unless you request one from the admin.' });
  }
  if (preferredLlmProvider === 'ollama' && (!ollamaUrl || ollamaUrl.trim() === '')) {
    return res.status(400).json({ message: 'An Ollama URL is required when Ollama is selected.' });
  }

  try {
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'An account with this email already exists.' });
    }

    // 3. Create the new User with the complete profile object
    const newUser = new User({
      email,
      username: email.split('@')[0],
      password,
      preferredLlmProvider: preferredLlmProvider || 'gemini',
      apiKeyRequestStatus: requestAdminKey ? 'pending' : 'none',
      encryptedApiKey: requestAdminKey ? null : (preferredLlmProvider === 'gemini' ? apiKey : null),
      ollamaUrl: (preferredLlmProvider === 'ollama') ? ollamaUrl.trim() : '',
      profile: {
        name, college, universityNumber, degreeType, branch, year,
        learningStyle, currentGoals: currentGoals || '' // Ensure currentGoals is not null
      }
    });

    await newUser.save();

    const payload = {
      userId: newUser._id,
      email: newUser.email,
      username: newUser.username,
    };
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: JWT_EXPIRATION });

    res.status(201).json({
      token,
      _id: newUser._id,
      email: newUser.email,
      username: newUser.username,
      sessionId: uuidv4(),
      message: "User registered successfully",
    });

  } catch (error) {
    console.error('Signup Error:', error);
    if (error.code === 11000 || error.message.includes('duplicate key error collection')) {
        return res.status(400).json({ message: 'An account with this email or username already exists.' });
    }
    if (error.name === 'ValidationError') {
        const messages = Object.values(error.errors).map(val => val.message);
        return res.status(400).json({ message: messages.join(', ') });
    }
    res.status(500).json({ message: 'Server error during signup.' });
  }
});

// --- @route   POST /api/auth/signin ---
router.post('/signin', async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ message: 'Please provide email and password.' });
  }

  try {
    const ADMIN_EMAIL = process.env.FIXED_ADMIN_USERNAME || 'admin@admin.com';
    const ADMIN_PASSWORD = process.env.FIXED_ADMIN_PASSWORD || 'admin123';

    if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
        console.log("Admin login successful via special auth check.");
        return res.status(200).json({
            isAdminLogin: true,
            message: 'Admin login successful',
        });
    }

    const user = await User.findByCredentials(email, password);
    if (!user) {
      return res.status(401).json({ message: 'Invalid email address or password.' });
    }

    const payload = { userId: user._id, email: user.email };
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: JWT_EXPIRATION });

    res.status(200).json({
      token,
      _id: user._id,
      email: user.email,
      username: user.username,
      sessionId: uuidv4(),
      message: "Login successful",
    });
  } catch (error) {
    console.error('Signin Error:', error);
    res.status(500).json({ message: 'Server error during signin.' });
  }
});

// --- @route   GET /api/auth/me ---
router.get('/me', authMiddleware, async (req, res) => {
  if (!req.user) {
    return res.status(401).json({ message: 'Not authorized.' });
  }
  res.status(200).json({
    _id: req.user._id,
    email: req.user.email,
    username: req.user.username,
  });
});

module.exports = router;
```

`server/routes/chat.js`

```javascript
// server/routes/chat.js
const express = require('express');
const mongoose = require('mongoose');
const { v4: uuidv4 } = require('uuid');
const ChatHistory = require('../models/ChatHistory');
const User = require('../models/User');
const { processQueryWithToT_Streaming } = require('../services/totOrchestrator');
const { analyzeAndRecommend } = require('../services/sessionAnalysisService');
const { processAgenticRequest } = require('../services/agentService');
const { generateCues } = require('../services/criticalThinkingService');
const { decrypt } = require('../utils/crypto');
const { redisClient } = require('../config/redisClient');
const { analyzePrompt } = require('../services/promptCoachService');
<<<<<<< HEAD
const { extractAndStoreKgFromText } = require('../services/kgExtractionService');
=======
>>>>>>> 458645dd4bb632680f0b033a4ca7dc99642d1798
const router = express.Router();


function streamEvent(res, eventData) {
    if (res.writableEnded) {
        console.warn('[Chat Route Stream] Attempted to write to an already closed stream.');
        return;
    }
    res.write(`data: ${JSON.stringify(eventData)}\n\n`);
}



function doesQuerySuggestRecall(query) {
    const lowerCaseQuery = query.toLowerCase();
    const recallKeywords = [
        'my name', 'my profession', 'i am', 'i told you',
        'remember', 'recall', 'remind me', 'go back to',
        'previously', 'before', 'we discussed', 'we were talking about',
        'earlier', 'yesterday', 'last session',
        'what did i say', 'what was', 'what were', 'who am i',
        'do you know', 'can you tell me again',
        'continue with', 'let\'s continue', 'pick up where we left off',
    ];
    return recallKeywords.some(keyword => lowerCaseQuery.includes(keyword));
}


router.post('/message', async (req, res) => {
    const {
        query, sessionId, useWebSearch, useAcademicSearch,
        systemPrompt: clientProvidedSystemInstruction, criticalThinkingEnabled,
        documentContextName, filter
    } = req.body;
    
    const userId = req.user._id;

    if (!query || typeof query !== 'string' || query.trim() === '') {
        return res.status(400).json({ message: 'Query message text required.' });
    }
    if (!sessionId || typeof sessionId !== 'string') {
        return res.status(400).json({ message: 'Session ID required.' });
    }

    const userMessageForDb = { role: 'user', parts: [{ text: query }], timestamp: new Date() };
    console.log(`>>> POST /api/chat/message: User=${userId}, Session=${sessionId}, CriticalThinking=${criticalThinkingEnabled}, Query: "${query.substring(0, 50)}..."`);

    try {
        const [chatSession, user] = await Promise.all([
            ChatHistory.findOne({ sessionId: sessionId, userId: userId }),
            User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaModel ollamaUrl').lean()
        ]);

        const llmProvider = user?.preferredLlmProvider || 'gemini';
        const ollamaModel = user?.ollamaModel || process.env.OLLAMA_DEFAULT_MODEL;

        const llmConfig = {
            llmProvider,
            ollamaModel,
            apiKey: user?.encryptedApiKey ? decrypt(user.encryptedApiKey) : null,
            ollamaUrl: user?.ollamaUrl
        };

        const historyFromDb = chatSession ? chatSession.messages : [];
        const summaryFromDb = chatSession ? chatSession.summary || "" : "";
        const historyForLlm = [];

        if (summaryFromDb && doesQuerySuggestRecall(query.trim())) {
            historyForLlm.push({ 
                role: 'user', 
                parts: [{ text: `CONTEXT (Summary of Past Conversations): """${summaryFromDb}"""` }] 
            });
            historyForLlm.push({ 
                role: 'model', 
                parts: [{ text: "Understood. I will use this context if the user's query is about our past conversations." }] 
            });
        }
        
        const formattedDbMessages = historyFromDb.map(msg => ({
            role: msg.role, parts: msg.parts.map(part => ({ text: part.text || '' }))
        }));
        historyForLlm.push(...formattedDbMessages);
        
        const requestContext = {
            documentContextName, criticalThinkingEnabled, filter,
            userId: userId.toString(), 
            systemPrompt: clientProvidedSystemInstruction,
            isWebSearchEnabled: !!useWebSearch, 
            isAcademicSearchEnabled: !!useAcademicSearch,
            ...llmConfig
        };

        if (criticalThinkingEnabled) {
            console.log(`[Chat Route] Diverting to ToT Orchestrator.`);
            
            res.setHeader('Content-Type', 'text/event-stream');
            res.setHeader('Cache-Control', 'no-cache');
            res.setHeader('Connection', 'keep-alive');
            res.flushHeaders();

            const accumulatedThoughts = [];

            const interceptingStreamCallback = (eventData) => {
                if (eventData.type === 'thought' || eventData.type === 'error') {
                    if (eventData.type === 'thought') {
                        accumulatedThoughts.push(eventData.content);
                    }
                    streamEvent(res, eventData);
                }
            };

            const totResult = await processQueryWithToT_Streaming(
                query.trim(), historyForLlm, requestContext, interceptingStreamCallback
            );

            const criticalThinkingCues = await generateCues(totResult.finalAnswer, llmConfig);

            const aiMessageForClient = {
                sender: 'bot', role: 'model',
                parts: [{ text: totResult.finalAnswer }],
                text: totResult.finalAnswer,
                timestamp: new Date(),
                thinking: accumulatedThoughts.join(''),
                references: totResult.references || [],
                source_pipeline: totResult.sourcePipeline,
                criticalThinkingCues: criticalThinkingCues // Add cues for client
            };

            streamEvent(res, { type: 'final_answer', content: aiMessageForClient });
            
            const aiMessageForDb = { ...aiMessageForClient };
            delete aiMessageForDb.criticalThinkingCues; // Remove cues for DB

            await ChatHistory.findOneAndUpdate(
                { sessionId: sessionId, userId: userId },
                { $push: { messages: { $each: [userMessageForDb, aiMessageForDb] } } },
                { upsert: true, new: true }
            );
            if (finalBotMessageObject) {
                extractAndStoreKgFromText(finalBotMessageObject.text, sessionId, userId, llmConfig);
            }
            console.log(`<<< POST /api/chat/message (ToT) successful for Session ${sessionId}.`);
            res.end();
        } else {
            console.log(`[Chat Route] Diverting to standard Agentic Service.`);

            const agentResponse = await processAgenticRequest(
                query.trim(), historyForLlm, clientProvidedSystemInstruction, requestContext
            );

            const criticalThinkingCues = await generateCues(agentResponse.finalAnswer, llmConfig);
            
            const aiMessageForClient = {
                sender: 'bot', role: 'model',
                parts: [{ text: agentResponse.finalAnswer }],
                text: agentResponse.finalAnswer,
                timestamp: new Date(),
                thinking: agentResponse.thinking || null,
                references: agentResponse.references || [],
                source_pipeline: agentResponse.sourcePipeline,
                criticalThinkingCues: criticalThinkingCues // Add cues for client
            };
            
            const aiMessageForDb = { ...aiMessageForClient };
            delete aiMessageForDb.criticalThinkingCues; // Remove cues for DB

            await ChatHistory.findOneAndUpdate(
                { sessionId: sessionId, userId: userId },
                { $push: { messages: { $each: [userMessageForDb, aiMessageForDb] } } },
                { upsert: true, new: true }
            );

            console.log(`<<< POST /api/chat/message (Agentic) successful for Session ${sessionId}.`);
            res.status(200).json({ reply: aiMessageForClient });
<<<<<<< HEAD
            extractAndStoreKgFromText(agentResponse.finalAnswer, sessionId, userId, llmConfig);
=======
>>>>>>> 458645dd4bb632680f0b033a4ca7dc99642d1798
        }

    } catch (error) {
        console.error(`!!! Error processing chat message for Session ${sessionId}:`, error);
        const clientMessage = error.message || "Failed to get response from AI service.";
        
        if (res.headersSent && !res.writableEnded) {
            streamEvent(res, { type: 'error', content: clientMessage });
            res.end();
        } else if (!res.headersSent) {
            res.status(error.status || 500).json({ message: clientMessage });
        }
    }
});

router.post('/history', async (req, res) => {
    const { previousSessionId } = req.body;
    const userId = req.user._id;
    const newSessionId = uuidv4();
    
    // This will hold our final response payload
    const responsePayload = {
        message: 'New session started.',
        newSessionId: newSessionId,
        studyPlanSuggestion: null // Default to null
    };

    try {
        if (previousSessionId) {
            const previousSession = await ChatHistory.findOne({ sessionId: previousSessionId, userId: userId });
            
            if (previousSession && previousSession.messages?.length > 1) {
                console.log(`[Chat Route] Finalizing previous session '${previousSessionId}'...`);
                
                const user = await User.findById(userId).select('profile preferredLlmProvider ollamaModel ollamaUrl +encryptedApiKey');
                const llmConfig = {
                    llmProvider: user?.preferredLlmProvider || 'gemini',
                    ollamaModel: user?.ollamaModel || process.env.OLLAMA_DEFAULT_MODEL,
                    apiKey: user?.encryptedApiKey ? decrypt(user.encryptedApiKey) : null,
                    ollamaUrl: user?.ollamaUrl || null
                };

                const { summary, knowledgeGaps, recommendations, keyTopics } = await analyzeAndRecommend(
                    previousSession.messages, previousSession.summary,
                    llmConfig.llmProvider, llmConfig.ollamaModel, llmConfig.apiKey, llmConfig.ollamaUrl
                );

                await ChatHistory.updateOne(
                    { sessionId: previousSessionId, userId: userId },
                    { $set: { summary: summary } }
                );

                if (knowledgeGaps && knowledgeGaps.size > 0) {
                    user.profile.performanceMetrics.clear();     
                    knowledgeGaps.forEach((score, topic) => {
                        user.profile.performanceMetrics.set(topic.replace(/\./g, '-'), score);
                    });
                    await user.save(); 
                    console.log(`[Chat Route] Updated user performance metrics with ${knowledgeGaps.size} new gaps.`);

                    let mostSignificantGap = null;
                    let lowestScore = 1.1;

                    knowledgeGaps.forEach((score, topic) => {
                        if (score < lowestScore) {
                            lowestScore = score;
                            mostSignificantGap = topic;
                        }
                    });

                    if (mostSignificantGap && lowestScore < 0.6) {
                        console.log(`[Chat Route] SIGNIFICANT KNOWLEDGE GAP DETECTED: "${mostSignificantGap}" (Score: ${lowestScore}). Generating study plan suggestion.`);
                        responsePayload.studyPlanSuggestion = {
                            topic: mostSignificantGap,
                            reason: `Analysis of your last session shows this is a key area for improvement.`
                        };
                    }
                }
                
                if (keyTopics && keyTopics.length > 0 && !responsePayload.studyPlanSuggestion) {
                    const primaryTopic = keyTopics[0];
                    console.log(`[Chat Route] Focused topic detected: "${primaryTopic}". Generating study plan suggestion.`);
                    responsePayload.studyPlanSuggestion = {
                        topic: primaryTopic,
                        reason: `Your last session focused on ${primaryTopic}. Would you like to create a structured study plan to master it?`
                    };
                }

                if (redisClient && redisClient.isOpen && recommendations && recommendations.length > 0) {
                    const cacheKey = `recommendations:${newSessionId}`;
                    await redisClient.set(cacheKey, JSON.stringify(recommendations), { EX: 3600 });
                    console.log(`[Chat Route] Caching ${recommendations.length} quick recommendations for new session ${newSessionId}.`);
                }
            }
        }

        await ChatHistory.create({ userId, sessionId: newSessionId, messages: [] });
        console.log(`[Chat Route] New session ${newSessionId} created. Sending response to user ${userId}.`);
        res.status(200).json(responsePayload);

    } catch (error) {
        console.error(`Error during finalize-and-create-new process:`, error);
        if (!res.headersSent) {
            try {
                await ChatHistory.create({ userId, sessionId: newSessionId, messages: [] });
                responsePayload.message = 'New session started, but analysis of previous session failed.';
                res.status(200).json(responsePayload);
            } catch (fallbackError) {
                 res.status(500).json({ message: 'A critical error occurred while creating a new session.' });
            }
        }
    }
});

router.get('/sessions', async (req, res) => {
    try {
        const sessions = await ChatHistory.find({ userId: req.user._id }).sort({ updatedAt: -1 }).select('sessionId createdAt updatedAt messages').lean();
        const sessionSummaries = sessions.map(session => {
            const firstUserMessage = session.messages?.find(m => m.role === 'user');
            let preview = firstUserMessage?.parts?.[0]?.text?.substring(0, 75) || 'Chat Session';
            if (preview.length === 75) preview += '...';
            return { sessionId: session.sessionId, createdAt: session.createdAt, updatedAt: session.updatedAt, messageCount: session.messages?.length || 0, preview: preview };
        });
        res.status(200).json(sessionSummaries);
    } catch (error) {
        res.status(500).json({ message: 'Failed to retrieve chat sessions.' });
    }
});

router.get('/session/:sessionId', async (req, res) => {
    try {
        const session = await ChatHistory.findOne({ sessionId: req.params.sessionId, userId: req.user._id }).lean();
        if (!session) return res.status(404).json({ message: 'Chat session not found or access denied.' });
        const messagesForFrontend = (session.messages || []).map(msg => ({ id: msg._id || uuidv4(), sender: msg.role === 'model' ? 'bot' : 'user', text: msg.parts?.[0]?.text || '', thinking: msg.thinking, references: msg.references, timestamp: msg.timestamp, source_pipeline: msg.source_pipeline }));
        res.status(200).json({ ...session, messages: messagesForFrontend });
    } catch (error) {
        console.error(`!!! Error fetching chat session ${req.params.sessionId} for user ${req.user._id}:`, error);
        res.status(500).json({ message: 'Failed to retrieve chat session details.' });
    }
});

router.delete('/session/:sessionId', async (req, res) => {
    const { sessionId } = req.params;
    const userId = req.user._id;
    try {
        const result = await ChatHistory.deleteOne({ sessionId: sessionId, userId: userId });
        if (redisClient && redisClient.isOpen) {
            const cacheKey = `session:${sessionId}`;
            await redisClient.del(cacheKey);
        }
        if (result.deletedCount === 0) {
            return res.status(404).json({ message: 'Chat session not found.' });
        }
        res.status(200).json({ message: 'Chat session deleted successfully.' });
    } catch (error) {
        res.status(500).json({ message: 'Server error while deleting chat session.' });
    }
});


// @route   POST /api/chat/analyze-prompt
// @desc    Analyze a user's prompt and suggest improvements.
// @access  Private
router.post('/analyze-prompt', async (req, res) => {
    const { prompt } = req.body;
    const userId = req.user._id;

    // --- REVISED VALIDATION ---
    if (!prompt || typeof prompt !== 'string') {
        console.warn(`[API /analyze-prompt] Bad Request from user ${userId}: 'prompt' field is missing or not a string. Received body:`, req.body);
        return res.status(400).json({ message: "'prompt' field is missing or invalid." });
    }

    const trimmedPrompt = prompt.trim();
    if (trimmedPrompt.length < 3) { // <-- The changed value
        console.warn(`[API /analyze-prompt] Bad Request from user ${userId}: Prompt is too short. Received: "${trimmedPrompt}"`);
        return res.status(400).json({ message: `Prompt must be at least 3 characters long.` }); // <-- The changed message
    }
    // --- END REVISED VALIDATION ---

    try {
        const analysis = await analyzePrompt(userId, trimmedPrompt);
        res.status(200).json(analysis);
    } catch (error) {
        console.error(`[API /analyze-prompt] Error for user ${userId} with prompt "${trimmedPrompt.substring(0, 50)}...":`, error);
        res.status(500).json({ message: error.message || 'Server error during prompt analysis.' });
    }
});

module.exports = router;
```

`server/routes/export.js`

```javascript
// server/routes/export.js
const express = require('express');
const axios = require('axios');
const router = express.Router();
const User = require('../models/User');
const AdminDocument = require('../models/AdminDocument');
const { decrypt } = require('../utils/crypto');

router.post('/podcast', async (req, res) => {
    const { analysisContent, sourceDocumentName, podcastOptions } = req.body;
    const userId = req.user._id;

    if (!analysisContent || !sourceDocumentName || !podcastOptions) {
        return res.status(400).json({ message: 'analysisContent, sourceDocumentName, and podcastOptions are required.' });
    }

    try {
        let sourceDocumentText = null;
        let apiKeyForRequest = null;
        
        // Fetch the user to get their documents and encrypted API key
        const user = await User.findById(userId).select('uploadedDocuments.filename uploadedDocuments.text +encryptedApiKey');

        // Check user's documents first
        const userDoc = user?.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
        if (userDoc?.text) {
            sourceDocumentText = userDoc.text;
            if (user.encryptedApiKey) {
                apiKeyForRequest = decrypt(user.encryptedApiKey);
            }
        } else {
            // Fallback to checking admin documents
            const adminDoc = await AdminDocument.findOne({ originalName: sourceDocumentName }).select('text');
            if (adminDoc?.text) {
                sourceDocumentText = adminDoc.text;
                apiKeyForRequest = process.env.GEMINI_API_KEY; // Admin docs use server's key
            }
        }
        
        if (!sourceDocumentText) {
            return res.status(404).json({ message: `Source document '${sourceDocumentName}' not found.` });
        }
        if (!apiKeyForRequest) {
            return res.status(400).json({ message: "API Key for podcast generation is missing." });
        }

        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) {
            return res.status(500).json({ message: "Audio generation service is not configured." });
        }

        const generationUrl = `${pythonServiceUrl}/export_podcast`;
        
        console.log(`[Node Export] Forwarding HQ podcast request to Python with API Key.`);

        const pythonPayload = {
            sourceDocumentText: sourceDocumentText,
            analysisContent: analysisContent,
            podcastOptions: podcastOptions,
            api_key: apiKeyForRequest // <<< Pass the correct key
        };
        
        const fileResponse = await axios.post(generationUrl, pythonPayload, {
            responseType: 'stream',
            timeout: 600000 // 10 minute timeout
        });

        const safeFilename = sourceDocumentName.split('.')[0].replace(/[^a-zA-Z0-9]/g, '_');
        const finalFilename = `HQ_Podcast_${safeFilename}.mp3`;
        
        res.setHeader('Content-Disposition', `attachment; filename="${finalFilename}"`);
        res.setHeader('Content-Type', 'audio/mpeg');
        fileResponse.data.pipe(res);

    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Failed to generate podcast.";
        console.error(`[Node Export] Error proxying podcast generation: ${errorMsg}`);
        if (!res.headersSent) {
            res.status(error.response?.status || 500).json({ message: errorMsg });
        }
    }
});

module.exports = router;
```

`server/routes/files.js`

```javascript
// // server/routes/files.js
// const express = require('express');
// const fs = require('fs').promises;
// const path = require('path');
// const { authMiddleware } = require('../middleware/authMiddleware');
// const User = require('../models/User');
// const axios = require('axios');
// const router = express.Router();

// const ASSETS_DIR = path.join(__dirname, '..', 'assets');
// const BACKUP_DIR = path.join(__dirname, '..', 'backup_assets');

// // --- Helper functions (sanitizeUsernameForDir, parseServerFilename, ensureDirExists are existing) ---
// const sanitizeUsernameForDir = (username) => {
//     if (!username) return '';
//     return username.replace(/[^a-zA-Z0-9_-]/g, '_');
// };

// const parseServerFilename = (filename) => {
//     // Matches "timestamp-originalName.ext"
//     // Allows originalName to contain dots now.
//     const match = filename.match(/^(\d+)-(.+?)(\.\w+)$/);
//     if (match && match.length === 4) {
//         return { timestamp: match[1], originalName: `${match[2]}${match[3]}`, extension: match[3] };
//     }
//     // Fallback for names that might not perfectly fit the new pattern, or originalName without extension before timestamp
//     const ext = path.extname(filename);
//     const baseWithoutExt = filename.substring(0, filename.length - ext.length);
//     const tsMatch = baseWithoutExt.match(/^(\d+)-(.*)$/);
//     if (tsMatch) {
//         return { timestamp: tsMatch[1], originalName: `${tsMatch[2]}${ext}`, extension: ext };
//     }
//     // Final fallback if no timestamp prefix is reliably parsed
//     return { timestamp: null, originalName: filename, extension: path.extname(filename) };
// };

// const ensureDirExists = async (dirPath) => {
//     try { await fs.mkdir(dirPath, { recursive: true }); }
//     catch (error) { if (error.code !== 'EEXIST') { console.error(`Error creating dir ${dirPath}:`, error); throw error; } }
// };

// async function callPythonDeletionEndpoint(method, endpointPath, userId, originalName, logContext) {
//     const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL || process.env.DEFAULT_PYTHON_RAG_URL || 'http://localhost:5000'; // Fallback if not set
//     if (!pythonServiceUrl) {
//         console.error(`Python Service Deletion Error for ${logContext}: PYTHON_RAG_SERVICE_URL not set.`);
//         return { success: false, message: "Python service URL not configured." };
//     }

//     const deleteUrl = `${pythonServiceUrl.replace(/\/$/, '')}${endpointPath}`;

//     try {
//         console.log(`Calling Python Service (${method.toUpperCase()}) for deletion: ${deleteUrl} (Doc: ${originalName}, User: ${userId})`);
//         let response;
//         if (method.toUpperCase() === 'DELETE') {
//             // For DELETE, data is often in query params or path, but axios allows a 'data' field for body
//             response = await axios.delete(deleteUrl, {
//                 data: { // For Python endpoints that expect a body (like a new Qdrant delete one)
//                     user_id: userId,
//                     document_name: originalName
//                 },
//                 timeout: 30000 // 30s timeout
//             });
//         } else {
//             throw new Error(`Unsupported method for Python deletion: ${method}`);
//         }

//         if (response.status === 200 || response.status === 204) { // 204 No Content is also success
//             return { success: true, message: response.data?.message || `Successfully deleted from ${endpointPath}` };
//         } else {
//             return { success: false, message: response.data?.message || `Python service returned ${response.status} for ${endpointPath}` };
//         }
//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.response?.data?.message || error.message || `Unknown error deleting from ${endpointPath}`;
//         console.error(`Error calling Python Service for deletion (${deleteUrl}) for ${originalName} (User: ${userId}): ${errorMsg}`, error.response ? { status: error.response.status, data: error.response.data } : error);
//         return { success: false, message: `Python service call failed for ${endpointPath}: ${errorMsg}` };
//     }
// }
// // --- End Helper Functions ---


// // --- @route   GET /api/files ---
// // Use authMiddleware middleware 
// // TO GET FILE NAMES
// router.get('/', authMiddleware, async (req, res) => {
    
//     const userFiles = []
//     try {
//         const userId = req.user._id.toString();

//         // Find user by ID, select only uploadedDocuments to optimize
//         const user = await User.findById(userId).select('uploadedDocuments');

//         if (!user) return res.status(404).json({ msg: 'User not found' });

//         // Extract filenames
//         const filenames = user.uploadedDocuments
//         .map(doc => doc.filename)
//         .filter(Boolean)  // filter out undefined or null filenames just in case
//         .reverse();       // reverse the order

//         return res.json({ filenames });

//     } catch (error) {
//         console.log(error.message);
//         return res.status(500).json({ msg: 'Server error' });
//     }
// });


// // --- @route   DELETE /api/files/:serverFilename ---
// // Use authMiddleware middleware
// router.delete('/:serverFilename', authMiddleware, async (req, res) => {
  
//     const { serverFilename } = req.params;
//     const userId = req.user._id.toString(); // Get userId from authenticated user
//     const usernameForLog = req.user.username;

//     if (!serverFilename) {
//         return res.status(400).json({ message: 'Server filename parameter is required.' });
//     }

//     const parsedFileDetails = parseServerFilename(serverFilename);
//     const originalName = parsedFileDetails.originalName;
//     if (!originalName) {
//         console.error(`DELETE /api/files: Could not parse originalName from serverFilename: ${serverFilename}`);
//         return res.status(400).json({ message: 'Invalid server filename format for deletion.' });
//     }
//     const logContext = `File: '${originalName}' (server: ${serverFilename}), User: ${usernameForLog} (${userId})`;
//     console.log(`Attempting to delete all data for ${logContext}`);

//     const results = {
//         mongodb: { success: false, message: "Not attempted" },
//         qdrant: { success: false, message: "Not attempted" },
//         neo4j: { success: false, message: "Not attempted" },
//         filesystem: { success: false, message: "Not attempted" },
//     };
//     let overallSuccess = true; // Assume success, set to false if any critical step fails
//     let httpStatus = 200;
//     let fileFoundInMongo = false;
//     let physicalFileFound = false;

//     try {
//         // 1. Delete from MongoDB
//         try {
//             const user = await User.findById(userId);
//             if (!user) {
//                 results.mongodb.message = "User not found.";
//                 // If user not found, we can't confirm if the file was theirs.
//                 // Treat as if the file wasn't found for this user.
//             } else {
//                 const docIndex = user.uploadedDocuments.findIndex(doc => doc.filename === originalName);
//                 if (docIndex > -1) {
//                     fileFoundInMongo = true;
//                     user.uploadedDocuments.splice(docIndex, 1);
//                     await user.save();
//                     results.mongodb.success = true;
//                     results.mongodb.message = "Successfully removed from user's document list.";
//                     console.log(`MongoDB: Document entry '${originalName}' removed for user ${userId}.`);
//                 } else {
//                     results.mongodb.message = "Document not found in user's list.";
//                     console.log(`MongoDB: Document entry '${originalName}' not found for user ${userId}.`);
//                 }
//             }
//         } catch (mongoError) {
//             console.error(`MongoDB Deletion Error for ${logContext}:`, mongoError);
//             results.mongodb.message = `MongoDB deletion failed: ${mongoError.message}`;
//             overallSuccess = false; // DB error is critical
//         }

//         // 2. Delete from Qdrant (via Python service)
//         // This endpoint will need to be created in Python: e.g., /delete_qdrant_document_data
//         // It should expect { user_id: userId, document_name: originalName } in the body
//         const qdrantDeleteResult = await callPythonDeletionEndpoint(
//             'DELETE',
//             `/delete_qdrant_document_data`,
//             userId,
//             originalName,
//             logContext
//         );
//         results.qdrant = qdrantDeleteResult;
//         if (!qdrantDeleteResult.success) {
//             console.warn(`Qdrant deletion failed or reported no data for ${logContext}. Message: ${qdrantDeleteResult.message}`);
//             // overallSuccess = false; // Non-critical for now, but log
//         }

//         // 3. Delete from Neo4j (via Python service)
//         // This uses the existing Python endpoint: /kg/<user_id>/<document_name>
//         const neo4jEndpointPath = `/kg/${userId}/${encodeURIComponent(originalName)}`;
//         const neo4jDeleteResult = await callPythonDeletionEndpoint(
//             'DELETE',
//             neo4jEndpointPath, // userId and originalName are in the path
//             userId, // still pass for logging consistency in helper
//             originalName, // still pass for logging consistency in helper
//             logContext
//         );
//         results.neo4j = neo4jDeleteResult;
//         if (!neo4jDeleteResult.success) {
//             console.warn(`Neo4j deletion failed or reported no data for ${logContext}. Message: ${neo4jDeleteResult.message}`);
//             // overallSuccess = false; // Non-critical for now, but log
//         }

//         // 4. Move physical file to backup (filesystem operation)
//         let currentPath = null;
//         let fileType = '';
//         const fileTypesToSearch = ['docs', 'images', 'code', 'others'];
//         const sanitizedUsernameForPath = sanitizeUsernameForDir(usernameForLog);

//         for (const type of fileTypesToSearch) {
//             const potentialPath = path.join(ASSETS_DIR, sanitizedUsernameForPath, type, serverFilename);
//             try {
//                 await fs.access(potentialPath); // Check if file exists
//                 currentPath = potentialPath;
//                 fileType = type;
//                 physicalFileFound = true;
//                 break;
//             } catch (e) {
//                 if (e.code !== 'ENOENT') {
//                     console.warn(`Filesystem: Error accessing ${potentialPath} during delete scan: ${e.message}`);
//                 }
//             }
//         }

//         if (currentPath) { // If physical file was found
//             const backupUserDir = path.join(BACKUP_DIR, sanitizedUsernameForPath, fileType);
//             await ensureDirExists(backupUserDir);
//             const backupPath = path.join(backupUserDir, serverFilename);
//             try {
//                 await fs.rename(currentPath, backupPath);
//                 results.filesystem = { success: true, message: "File moved to backup successfully." };
//                 console.log(`Filesystem: Moved '${currentPath}' to '${backupPath}'.`);
//             } catch (fsError) {
//                 console.error(`Filesystem: Error moving file ${currentPath} to backup for ${logContext}:`, fsError);
//                 results.filesystem.message = `Filesystem move to backup failed: ${fsError.message}`;
//                 // overallSuccess = false; // Decide if this is critical enough to mark overall failure
//             }
//         } else {
//             results.filesystem.message = "Physical file not found in assets, or already moved.";
//             console.log(`Filesystem: Physical file '${serverFilename}' not found for user ${usernameForLog}.`);
//         }

//         // Determine final status and message
//         const successfulDeletes = [results.mongodb.success, results.qdrant.success, results.neo4j.success, results.filesystem.success].filter(Boolean).length;

//         if (!fileFoundInMongo && !physicalFileFound) {
//             httpStatus = 404;
//             finalMessage = `File '${originalName}' not found for user.`;
//         } else if (results.mongodb.success) { // Primary record deleted
//             if (successfulDeletes === 4) {
//                 finalMessage = `Successfully deleted all data associated with '${originalName}'.`;
//                 httpStatus = 200;
//             } else {
//                 finalMessage = `File '${originalName}' removed from your list. Some backend data cleanup attempts had issues. Check server logs for details.`;
//                 httpStatus = 207; // Multi-Status
//             }
//         } else { // MongoDB deletion failed, but file might have existed
//             finalMessage = `Failed to remove '${originalName}' from your list. Some backend data cleanup may have also failed. Check server logs.`;
//             httpStatus = 500;
//         }

//         console.log(`Deletion outcome for ${logContext}: HTTP Status=${httpStatus}, Overall Success Flag (was pre-status logic)=${overallSuccess}`);
//         return res.status(httpStatus).json({
//             message: finalMessage,
//             details: results
//         });

//     } catch (error) {
//         console.error(`!!! UNEXPECTED Error in DELETE /api/files/${serverFilename} for user ${usernameForLog}:`, error);
//         return res.status(500).json({
//             message: 'An unexpected server error occurred during file deletion.',
//             details: results // Send partial results if any
//         });
//     }
// });


// module.exports = router;

```

`server/routes/generation.js`

```javascript
// // server/routes/generation.js
// const express = require('express');
// const axios = require('axios');
// const router = express.Router();

// // This route is protected by authMiddleware applied in server.js

// // @route   POST /api/generate/document
// // @desc    Generate a document (PPTX or DOCX) by proxying to the Python service.
// // @access  Private
// router.post('/document', async (req, res) => {
//     const { markdownContent, docType } = req.body;

//     if (!markdownContent || !docType) {
//         return res.status(400).json({ message: 'markdownContent and docType are required.' });
//     }

//     const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
//     if (!pythonServiceUrl) {
//         console.error("[Generation Route] PYTHON_RAG_SERVICE_URL is not set.");
//         return res.status(500).json({ message: "Document generation service is not configured." });
//     }

//     const generationUrl = `${pythonServiceUrl}/generate_document`;
//     console.log(`[Generation Route] Forwarding request to Python service: ${generationUrl}`);

//     try {
//         const pythonResponse = await axios.post(generationUrl, {
//             markdownContent,
//             docType
//         }, { timeout: 60000 }); // 1 minute timeout for generation

//         if (pythonResponse.data && pythonResponse.data.success) {
//             const filename = pythonResponse.data.filename;
//             // Construct the full download URL for the client
//             const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;
            
//             res.status(200).json({
//                 success: true,
//                 downloadUrl: downloadUrl,
//                 filename: filename
//             });
//         } else {
//             throw new Error(pythonResponse.data.error || "Unknown error from generation service.");
//         }
//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
//         console.error(`[Generation Route] Error calling Python service: ${errorMsg}`);
//         res.status(500).json({ message: errorMsg });
//     }
// });

// module.exports = router;














// // server/routes/generation.js
// const express = require('express');
// const axios = require('axios');
// const router = express.Router();
// const User = require('../models/User'); // <-- Import User model

// // This route is protected by authMiddleware applied in server.js

// // @route   POST /api/generate/document
// // @desc    Generate a document (PPTX or DOCX) by proxying to the Python service.
// // @access  Private
// router.post('/document', async (req, res) => {
//     // --- MODIFIED: Destructure new fields ---
//     const { markdownContent, docType, sourceDocumentName } = req.body;
//     const userId = req.user._id;

//     if (!markdownContent || !docType || !sourceDocumentName) {
//         return res.status(400).json({ message: 'markdownContent, docType, and sourceDocumentName are required.' });
//     }

//     try {
//         // --- NEW: Fetch the full text of the source document ---
//         const user = await User.findById(userId).select('uploadedDocuments');
//         if (!user) {
//             return res.status(404).json({ message: 'User not found.' });
//         }
//         const sourceDocument = user.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
//         if (!sourceDocument || !sourceDocument.text) {
//             return res.status(404).json({ message: `Source document '${sourceDocumentName}' or its text content not found.` });
//         }
//         const sourceDocumentText = sourceDocument.text;
//         // --- END NEW ---

//         const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
//         if (!pythonServiceUrl) {
//             console.error("[Generation Route] PYTHON_RAG_SERVICE_URL is not set.");
//             return res.status(500).json({ message: "Document generation service is not configured." });
//         }

//         const generationUrl = `${pythonServiceUrl}/generate_document`;
//         console.log(`[Generation Route] Forwarding request to Python service: ${generationUrl}`);

//         const pythonResponse = await axios.post(generationUrl, {
//             markdownContent, // This is the outline (e.g., FAQ, Key Topics)
//             docType,
//             sourceDocumentText // Pass the full text for context
//         }, { timeout: 300000 }); // Increased timeout to 5 minutes for LLM generation

//         if (pythonResponse.data && pythonResponse.data.success) {
//             const filename = pythonResponse.data.filename;
//             const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;
            
//             res.status(200).json({
//                 success: true,
//                 downloadUrl: downloadUrl,
//                 filename: filename
//             });
//         } else {
//             throw new Error(pythonResponse.data.error || "Unknown error from generation service.");
//         }
//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
//         console.error(`[Generation Route] Error: ${errorMsg}`);
//         res.status(500).json({ message: errorMsg });
//     }
// });

// module.exports = router;










// // server/routes/generation.js
// const express = require('express');
// const axios = require('axios');
// const router = express.Router();
// const User = require('../models/User');
// const AdminDocument = require('../models/AdminDocument'); // <-- Import AdminDocument model

// // This route is protected by authMiddleware applied in server.js

// // @route   POST /api/generate/document
// // @desc    Generate a document (PPTX or DOCX) by proxying to the Python service.
// // @access  Private
// router.post('/document', async (req, res) => {
//     const { markdownContent, docType, sourceDocumentName } = req.body;
//     const userId = req.user._id;

//     if (!markdownContent || !docType || !sourceDocumentName) {
//         return res.status(400).json({ message: 'markdownContent, docType, and sourceDocumentName are required.' });
//     }

//     try {
//         let sourceDocumentText = null;

//         // --- NEW UNIFIED DOCUMENT RETRIEVAL LOGIC ---
//         // 1. First, try to find the document in the user's personal documents.
//         const user = await User.findById(userId).select('uploadedDocuments');
//         if (user) {
//             const userDocument = user.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
//             if (userDocument && userDocument.text) {
//                 sourceDocumentText = userDocument.text;
//                 console.log(`[Generation Route] Found source text in user's documents for: ${sourceDocumentName}`);
//             }
//         }

//         // 2. If not found in user's docs, try to find it in the Admin documents.
//         if (!sourceDocumentText) {
//             console.log(`[Generation Route] Not found in user docs. Checking admin 'Subjects' for: ${sourceDocumentName}`);
//             const adminDocument = await AdminDocument.findOne({ originalName: sourceDocumentName }).select('text');
//             if (adminDocument && adminDocument.text) {
//                 sourceDocumentText = adminDocument.text;
//                 console.log(`[Generation Route] Found source text in admin documents for: ${sourceDocumentName}`);
//             }
//         }
//         // --- END UNIFIED LOGIC ---
        
//         // 3. If still not found after checking both, return an error.
//         if (!sourceDocumentText) {
//             return res.status(404).json({ message: `Source document '${sourceDocumentName}' not found.` });
//         }

//         const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
//         if (!pythonServiceUrl) {
//             console.error("[Generation Route] PYTHON_RAG_SERVICE_URL is not set.");
//             return res.status(500).json({ message: "Document generation service is not configured." });
//         }

//         const generationUrl = `${pythonServiceUrl}/generate_document`;
//         console.log(`[Generation Route] Forwarding request to Python service: ${generationUrl}`);

//         const pythonResponse = await axios.post(generationUrl, {
//             markdownContent,
//             docType,
//             sourceDocumentText // Pass the full text from whichever source it was found
//         }, { timeout: 300000 });

//         if (pythonResponse.data && pythonResponse.data.success) {
//             const filename = pythonResponse.data.filename;
//             const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;
            
//             res.status(200).json({
//                 success: true,
//                 downloadUrl: downloadUrl,
//                 filename: filename
//             });
//         } else {
//             throw new Error(pythonResponse.data.error || "Unknown error from generation service.");
//         }
//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
//         console.error(`[Generation Route] Error: ${errorMsg}`);
//         res.status(500).json({ message: errorMsg });
//     }
// });

// module.exports = router;









// // server/routes/generation.js
// const express = require('express');
// const axios = require('axios');
// const router = express.Router();
// const User = require('../models/User');
// const AdminDocument = require('../models/AdminDocument');

// router.post('/document', async (req, res) => {
//     const { markdownContent, docType, sourceDocumentName } = req.body;
//     const userId = req.user._id;

//     if (!markdownContent || !docType || !sourceDocumentName) {
//         return res.status(400).json({ message: 'markdownContent, docType, and sourceDocumentName are required.' });
//     }

//     try {
//         let sourceDocumentText = null;

//         const user = await User.findById(userId).select('uploadedDocuments');
//         if (user) {
//             const userDocument = user.uploadedDocuments.find(doc => doc.filename === sourceDocumentName);
//             if (userDocument && userDocument.text) {
//                 sourceDocumentText = userDocument.text;
//             }
//         }

//         if (!sourceDocumentText) {
//             const adminDocument = await AdminDocument.findOne({ originalName: sourceDocumentName }).select('text');
//             if (adminDocument && adminDocument.text) {
//                 sourceDocumentText = adminDocument.text;
//             }
//         }
        
//         if (!sourceDocumentText) {
//             return res.status(404).json({ message: `Source document '${sourceDocumentName}' not found.` });
//         }

//         const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
//         if (!pythonServiceUrl) {
//             return res.status(500).json({ message: "Document generation service is not configured." });
//         }

//         const generationUrl = `${pythonServiceUrl}/generate_document`;
        
//         // 1. Ask Python to generate the document and get the filename
//         const genResponse = await axios.post(generationUrl, {
//             markdownContent, docType, sourceDocumentText
//         }, { timeout: 300000 });

//         if (!genResponse.data || !genResponse.data.success) {
//             throw new Error(genResponse.data.error || "Python service failed to generate the document.");
//         }

//         const filename = genResponse.data.filename;
//         const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;

//         // 2. Fetch the generated document from Python as a stream (blob)
//         console.log(`[Generation Route] Fetching generated file from Python: ${downloadUrl}`);
//         const fileResponse = await axios.get(downloadUrl, {
//             responseType: 'stream'
//         });

//         // 3. Stream the file directly back to the client
//         res.setHeader('Content-Disposition', `attachment; filename=${filename}`);
//         res.setHeader('Content-Type', fileResponse.headers['content-type']);
//         fileResponse.data.pipe(res);

//     } catch (error) {
//         const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
//         console.error(`[Generation Route] Error: ${errorMsg}`);
//         res.status(500).json({ message: errorMsg });
//     }
// });

// module.exports = router;

// server/routes/generation.js
const express = require('express');
const axios = require('axios');
const router = express.Router();
const User = require('../models/User'); // Still needed for API key
const AdminDocument = require('../models/AdminDocument');
const KnowledgeSource = require('../models/KnowledgeSource'); // <-- Import KnowledgeSource
const { decrypt } = require('../utils/crypto'); // For user API key

router.post('/document', async (req, res) => {
    const { markdownContent, docType, sourceDocumentName } = req.body;
    const userId = req.user._id;

    if (!markdownContent || !docType || !sourceDocumentName) {
        return res.status(400).json({ message: 'markdownContent, docType, and sourceDocumentName are required.' });
    }

    try {
        let sourceDocumentText = null;
        let apiKeyForRequest = null;

        // 1. Check user-specific KnowledgeSource and get API key
        const user = await User.findById(userId).select('+encryptedApiKey');
        const userSource = await KnowledgeSource.findOne({ userId, title: sourceDocumentName }).select('textContent').lean();
        
        if (userSource?.textContent) {
            sourceDocumentText = userSource.textContent;
            if (user?.encryptedApiKey) {
                apiKeyForRequest = decrypt(user.encryptedApiKey);
            }
        } else {
            // 2. Fallback to AdminDocument and use server key
            const adminDoc = await AdminDocument.findOne({ originalName: sourceDocumentName }).select('text').lean();
            if (adminDoc?.text) {
                sourceDocumentText = adminDoc.text;
                apiKeyForRequest = process.env.GEMINI_API_KEY;
            }
        }
        
        if (!sourceDocumentText) {
            return res.status(404).json({ message: `Source document '${sourceDocumentName}' not found.` });
        }
        if (!apiKeyForRequest) {
            return res.status(400).json({ message: "API Key for document generation is missing." });
        }

        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) {
            return res.status(500).json({ message: "Document generation service is not configured." });
        }
        
        const generationUrl = `${pythonServiceUrl}/generate_document`;
        
        // Ask Python to generate the document
        const genResponse = await axios.post(generationUrl, {
            markdownContent, docType, sourceDocumentText, api_key: apiKeyForRequest
        }, { timeout: 300000 });

        if (!genResponse.data || !genResponse.data.success) {
            throw new Error(genResponse.data.error || "Python service failed to generate the document.");
        }

        const filename = genResponse.data.filename;
        const downloadUrl = `${pythonServiceUrl}/download_document/${filename}`;

        // Fetch the generated document as a stream and pipe it to the client
        const fileResponse = await axios.get(downloadUrl, { responseType: 'stream' });

        res.setHeader('Content-Disposition', `attachment; filename=${filename}`);
        res.setHeader('Content-Type', fileResponse.headers['content-type']);
        fileResponse.data.pipe(res);

    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Failed to generate document.";
        console.error(`[Generation Route] Error: ${errorMsg}`);
        res.status(error.response?.status || 500).json({ message: errorMsg });
    }
});

module.exports = router;
```

`server/routes/kg.js`

```javascript

// server/routes/kg.js
const express = require('express');
const router = express.Router();
const axios = require('axios');
const User = require('../models/User');
const AdminDocument = require('../models/AdminDocument');
const { decrypt } = require('../utils/crypto');

router.get('/visualize/:documentName', async (req, res) => {
    const { documentName } = req.params;
    const currentUserId = req.user._id;

    if (!documentName) {
        return res.status(400).json({ message: 'Document name is required.' });
    }

    try {
        let sourceDocumentText = null;
        let apiKeyForRequest = null;
        
        // We need to fetch the user to get their encrypted API key
        const user = await User.findById(currentUserId).select('uploadedDocuments.filename uploadedDocuments.text +encryptedApiKey');

        // Check if the requested document belongs to the user
        const userDoc = user?.uploadedDocuments.find(doc => doc.filename === documentName);
        
        if (userDoc?.text) {
            sourceDocumentText = userDoc.text;
            // Decrypt the key if the document is a user document
            if (user.encryptedApiKey) {
                apiKeyForRequest = decrypt(user.encryptedApiKey);
            }
        } else {
            // If not a user document, check if it's an admin document (Subject)
            const adminDoc = await AdminDocument.findOne({ originalName: documentName }).select('text');
            if (adminDoc?.text) {
                sourceDocumentText = adminDoc.text;
                // For admin docs, use the server's global API key
                apiKeyForRequest = process.env.GEMINI_API_KEY;
            }
        }
        
        if (!sourceDocumentText) {
            return res.status(404).json({ message: `Source document '${documentName}' not found.` });
        }

        if (!apiKeyForRequest) {
             return res.status(400).json({ message: "API Key for document processing is missing." });
        }

        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) {
            return res.status(500).json({ message: "Knowledge Graph service is not configured." });
        }
        
        const getKgUrl = `${pythonServiceUrl}/generate_kg_from_text`;
        
        console.log(`[KG Visualize] Proxying request to Python with API Key for KG generation.`);
        
        const pythonResponse = await axios.post(getKgUrl, {
            document_text: sourceDocumentText,
            api_key: apiKeyForRequest // <<< Pass the correct key
        }, { timeout: 300000 });

        if (pythonResponse.data && pythonResponse.data.success) {
            res.status(200).json(pythonResponse.data.graph_data);
        } else {
            throw new Error(pythonResponse.data.error || "Python service failed to generate the knowledge graph.");
        }
    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Failed to retrieve knowledge graph.";
        console.error(`[KG Visualize] Error for '${documentName}': ${errorMsg}`);
        res.status(error.response?.status || 500).json({ error: errorMsg });
    }
});


// --- NEW ROUTE ---
// @route   GET /api/kg/session/:sessionId
// @desc    Get the knowledge graph for a specific chat session
// @access  Private
router.get('/session/:sessionId', async (req, res) => {
    const { sessionId } = req.params;
    const userId = req.user._id.toString();

    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        return res.status(500).json({ error: "Knowledge Graph service is not configured." });
    }
    
    // The sessionId is used as the document_name for the KG
    const getKgUrl = `${pythonServiceUrl}/kg/${userId}/${encodeURIComponent(sessionId)}`;

    try {
        console.log(`[KG Route] Proxying request to Python service to get KG for session: ${sessionId}`);
        const pythonResponse = await axios.get(getKgUrl, { timeout: 30000 });
        
        if (pythonResponse.data) {
            res.status(200).json(pythonResponse.data);
        } else {
            // It's not an error if a KG doesn't exist yet, just return empty data
            res.status(200).json({ nodes: [], edges: [] });
        }
    } catch (error) {
        if (error.response && error.response.status === 404) {
            // Handle case where Python service returns 404 if KG doesn't exist
            return res.status(200).json({ nodes: [], edges: [] });
        }
        const errorMsg = error.response?.data?.error || error.message || "Failed to retrieve knowledge graph.";
        console.error(`[KG Route] Error for session '${sessionId}': ${errorMsg}`);
        res.status(error.response?.status || 500).json({ error: errorMsg });
    }
});

module.exports = router;
```

`server/routes/knowledgeSource.js`

```javascript
// server/routes/knowledgeSource.js
const express = require('express');
const router = express.Router();
const { Worker } = require('worker_threads');
const path = require('path');
const axios = require('axios');
const User = require('../models/User');
const AdminDocument = require('../models/AdminDocument');
const KnowledgeSource = require('../models/KnowledgeSource');
const { decrypt } = require('../utils/crypto');
const fs = require('fs').promises;

// --- HELPER FOR PYTHON SERVICE DELETION ---
async function callPythonDeletionEndpoint(endpointPath, userId, documentName) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        console.warn(`Python Service Deletion request for ${documentName} skipped: URL not configured.`);
        return { success: false, message: "Python service URL not configured." };
    }
    const deleteUrl = `${pythonServiceUrl.replace(/\/$/, '')}${endpointPath}`;
    try {
        await axios.delete(deleteUrl, {
            data: { user_id: userId, document_name: documentName },
            timeout: 30000
        });
        return { success: true, message: `Successfully requested deletion from ${endpointPath}` };
    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message;
        console.error(`Error calling Python for deletion (${deleteUrl}): ${errorMsg}`);
        return { success: false, message: errorMsg };
    }
}


// @route   POST /api/knowledge-sources
// @desc    Add a new URL-based knowledge source
// @access  Private
router.post('/', async (req, res) => {
    const { type, content } = req.body;
    const userId = req.user._id;

    if (type !== 'url' || !content) {
        return res.status(400).json({ message: "Request must be for type 'url' and include 'content'." });
    }

    let newSource;
    try {
        // Create initial record in DB to track progress
        newSource = new KnowledgeSource({
            userId,
            sourceType: 'webpage', // Initial type, will be corrected by Python
            title: content, 
            sourceUrl: content,
            status: 'processing_extraction',
        });
        await newSource.save();

        // Immediately respond to the user so the UI doesn't hang
        res.status(202).json({ 
            message: "URL received. Processing has started in the background.",
            source: newSource 
        });
        
        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) throw new Error("Python service URL not configured.");

        // 1. Call Python to extract text from URL
        const extractionResponse = await axios.post(`${pythonServiceUrl}/process_url`, {
            url: content,
            user_id: userId.toString(),
        }, { timeout: 300000 }); // 5 min timeout for scraping/transcription

        const { text_content, title, source_type } = extractionResponse.data;
        if (!text_content) throw new Error("Failed to extract text from the URL source.");
        
        // 2. Call Python to add the extracted content to Qdrant and get KG chunks
        // This is the CRITICAL NEW STEP for URL embedding
        const addDocumentResponse = await axios.post(`${pythonServiceUrl}/add_document`, {
            user_id: userId.toString(),
            file_path: '', // Dummy path, as content is provided directly
            original_name: title, // Use the extracted title as the original_name
            text_content_override: text_content // Pass the actual content here
        }, { timeout: 300000 }); // Large timeout for processing

        const { num_chunks_added_to_qdrant, raw_text_for_analysis, chunks_with_metadata: chunksForKg } = addDocumentResponse.data;

        if (num_chunks_added_to_qdrant === 0) {
            throw new Error("No embeddings generated for the URL content. It might be too short or failed processing.");
        }

        // 3. Update the KnowledgeSource record in MongoDB with final details
        const sourceDoc = await KnowledgeSource.findById(newSource._id);
        if (!sourceDoc) throw new Error(`KnowledgeSource with ID ${newSource._id} disappeared during processing.`);

        sourceDoc.textContent = text_content; // Store the extracted content
        sourceDoc.title = title; // Update with proper title from Python
        sourceDoc.sourceType = source_type; // Update with actual type from Python
        sourceDoc.status = 'processing_analysis'; // Next step: analysis
        await sourceDoc.save();

        // 4. Trigger Analysis Worker
        const user = await User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaModel ollamaUrl').lean();
        const llmProvider = user?.preferredLlmProvider || 'gemini';
        const userApiKey = user.encryptedApiKey ? decrypt(user.encryptedApiKey) : null;
        
        const workerBaseData = {
            sourceId: sourceDoc._id.toString(), userId: userId.toString(), originalName: title, llmProvider,
            ollamaModel: user.ollamaModel, apiKey: userApiKey, ollamaUrl: user.ollamaUrl
        };
        
        const analysisWorker = new Worker(path.resolve(__dirname, '../workers/analysisWorker.js'), { 
            workerData: { ...workerBaseData, textForAnalysis: raw_text_for_analysis }
        });
        analysisWorker.on('error', (err) => console.error(`Analysis Worker Error (URL: ${title}):`, err));
        
        // 5. Trigger KG Worker if chunks are available
        if (chunksForKg && chunksForKg.length > 0) {
            const kgWorker = new Worker(path.resolve(__dirname, '../workers/kgWorker.js'), { 
                workerData: { ...workerBaseData, chunksForKg }
            });
            kgWorker.on('error', (err) => console.error(`KG Worker Error (URL: ${title}):`, err));
        } else {
            console.warn(`[KnowledgeSource Route] No chunks for KG processing for URL '${title}'.`);
            await KnowledgeSource.updateOne(
                { _id: sourceDoc._id },
                { $set: { kgStatus: "skipped_no_chunks" } }
            );
        }

    } catch (error) {
        console.error(`Error processing URL source '${content}':`, error);
        if (newSource) {
            await KnowledgeSource.updateOne({ _id: newSource._id }, {
                $set: { status: 'failed', failureReason: error.message }
            });
        }
    }
});

// @route   GET /api/knowledge-sources
// @desc    Get all knowledge sources for the user (files, urls) and admin (subjects)
// @access  Private
router.get('/', async (req, res) => {
    try {
        const userId = req.user._id;

        const userSourcesPromise = KnowledgeSource.find({ userId }).sort({ createdAt: -1 }).lean();
        const adminSubjectsPromise = AdminDocument.find().sort({ originalName: 1 }).select('originalName createdAt').lean();

        const [userSources, adminSubjects] = await Promise.all([userSourcesPromise, adminSubjectsPromise]);

        const formattedAdminSubjects = adminSubjects.map(doc => ({
            _id: `admin_${doc._id}`, // Create a unique ID for the frontend key
            sourceType: 'subject',
            title: doc.originalName,
            status: 'completed',
            createdAt: doc.createdAt // Pass the creation date
        }));

        res.json([...formattedAdminSubjects, ...userSources]);
    } catch (error) {
        console.error("Error fetching all knowledge sources:", error);
        res.status(500).json({ message: "Server error while fetching knowledge sources." });
    }
});


// --- NEW ---
// @route   DELETE /api/knowledge-sources/:sourceId
// @desc    Delete a knowledge source and all its associated data
// @access  Private
router.delete('/:sourceId', async (req, res) => {
    const { sourceId } = req.params;
    const userId = req.user._id.toString();
    const username = req.user.username;

    try {
        const source = await KnowledgeSource.findOne({ _id: sourceId, userId });
        if (!source) {
            return res.status(404).json({ message: "Knowledge source not found or you do not have permission to delete it." });
        }

        console.log(`[Delete Source] Deleting source: '${source.title}' for user: ${username}`);

        // 1. Delete from Vector DB (Qdrant) and Graph DB (Neo4j) via Python service
        await callPythonDeletionEndpoint(`/delete_qdrant_document_data`, userId, source.title);
        await callPythonDeletionEndpoint(`/kg/${userId}/${encodeURIComponent(source.title)}`, userId, source.title);

        // 2. If it's a file, move the physical file to a backup location
        if (source.sourceType === 'document' && source.serverFilename) {
            const sanitizedUsername = username.replace(/[^a-zA-Z0-9_-]/g, '_');
            const sourcePath = path.join(__dirname, '..', 'assets', sanitizedUsername, 'document', source.serverFilename);
            const backupDir = path.join(__dirname, '..', 'backup_assets', sanitizedUsername, 'document');
            
            await fs.mkdir(backupDir, { recursive: true });
            const backupPath = path.join(backupDir, source.serverFilename);
            
            try {
                await fs.rename(sourcePath, backupPath);
                console.log(`[Delete Source] Backed up file to ${backupPath}`);
            } catch (fileError) {
                if (fileError.code !== 'ENOENT') { // ENOENT = file not found, which is ok if it was already cleaned up
                    console.warn(`[Delete Source] Could not back up physical file '${sourcePath}': ${fileError.message}`);
                }
            }
        }

        // 3. Delete from MongoDB
        await KnowledgeSource.deleteOne({ _id: sourceId });
        console.log(`[Delete Source] Removed MongoDB record for '${source.title}'`);

        res.status(200).json({ message: `Successfully deleted '${source.title}'.` });
    } catch (error) {
        console.error(`[Delete Source] Error deleting source ID '${sourceId}':`, error);
        res.status(500).json({ message: "An error occurred while deleting the knowledge source." });
    }
});


module.exports = router;
```

`server/routes/learning.js`

```javascript
// server/routes/learning.js
const express = require('express');
const router = express.Router();
const { redisClient } = require('../config/redisClient');
const axios = require('axios');

// @route   GET /api/learning/recommendations/:sessionId
// @desc    Get cached recommendations for a new session.
// @access  Private
router.get('/recommendations/:sessionId', async (req, res) => {
    const { sessionId } = req.params;
    const cacheKey = `recommendations:${sessionId}`;

    try {
        if (redisClient && redisClient.isOpen) {
            const cachedData = await redisClient.get(cacheKey);

            console.log(`[Learning Route] GET recommendations for session ${sessionId}:`);
            console.log(`  - Cache Key: ${cacheKey}`);
            console.log(`  - Data from Redis: ${cachedData ? cachedData.substring(0, 100) + '...' : 'null'}`);

            
            if (cachedData) {
                console.log(`[Learning Route] Cache HIT for recommendations on session ${sessionId}.`);
                // Once read, we can remove it from the cache
                await redisClient.del(cacheKey); 
                return res.status(200).json({ recommendations: JSON.parse(cachedData) });
            }
        }
        console.log(`[Learning Route] Cache MISS for recommendations on session ${sessionId}.`);
        res.status(200).json({ recommendations: [] }); // Return empty array if not found
    } catch (error) {
        console.error(`Error fetching recommendations from cache for session ${sessionId}:`, error);
        res.status(500).json({ message: 'Server error retrieving recommendations.' });
    }
});

// @route   POST /api/learning/find-document
// @desc    Perform a JIT RAG search for a recommended topic.
// @access  Private
router.post('/find-document', async (req, res) => {
    const { topic } = req.body;
    const userId = req.user._id.toString();

    if (!topic) {
        return res.status(400).json({ message: 'Topic is required.' });
    }

    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        return res.status(500).json({ message: 'RAG service is not configured.' });
    }
    const searchUrl = `${pythonServiceUrl}/query`;

    try {
        console.log(`[Learning Route] Performing JIT RAG search for topic: "${topic}" for user ${userId}`);
        const response = await axios.post(searchUrl, {
            query: topic,
            user_id: userId, // Pass user ID to search their docs and admin docs
            k: 1 // We only want the single best document for this topic
        });

        const docs = response.data?.retrieved_documents_list;
        if (docs && docs.length > 0) {
            const bestDoc = docs[0].metadata?.file_name || docs[0].metadata?.original_name;
            if (bestDoc) {
                return res.status(200).json({ documentName: bestDoc });
            }
        }

        res.status(404).json({ message: 'No relevant document could be found for that topic.' });

    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message;
        console.error(`[Learning Route] RAG search failed for topic "${topic}":`, errorMsg);
        res.status(500).json({ message: 'Failed to find a relevant document.' });
    }
});

module.exports = router;
```

`server/routes/learningPath.js`

```javascript
// server/routes/learningPath.js
const express = require('express');
const router = express.Router();
const LearningPath = require('../models/LearningPath');
const { createLearningPath } = require('../services/learning/curriculumOrchestrator');

// @route   POST /api/learning/paths/generate
// @desc    Create a new learning path for the authenticated user based on a goal.
// @access  Private
router.post('/generate', async (req, res) => {
    const { goal, context } = req.body;
    const userId = req.user._id;

    if (!goal) {
        return res.status(400).json({ message: 'A learning goal is required.' });
    }

    try {
        const newPath = await createLearningPath(userId, goal, context);
        res.status(201).json(newPath);
    } catch (error) {
        console.error(`[API Error] Failed to create learning path for user ${userId}:`, error);
        res.status(500).json({ message: `Server error: ${error.message}` });
    }
});

// @route   GET /api/learning/paths
// @desc    Get all learning paths for the authenticated user.
// @access  Private
router.get('/', async (req, res) => {
    const userId = req.user._id;

    try {
        const paths = await LearningPath.find({ userId: userId }).sort({ createdAt: -1 });
        res.status(200).json(paths);
    } catch (error) {
        console.error(`[API Error] Failed to retrieve learning paths for user ${userId}:`, error);
        res.status(500).json({ message: 'Server error while fetching learning paths.' });
    }
});


router.put('/:pathId/modules/:moduleId', async (req, res) => {
    const { pathId, moduleId } = req.params;
    const { status } = req.body;
    const userId = req.user._id;

    if (!status || !['completed', 'in_progress', 'not_started'].includes(status)) {
        return res.status(400).json({ message: 'A valid status is required (completed, in_progress, not_started).' });
    }

    try {
        // Find the learning path ensuring it belongs to the current user
        const learningPath = await LearningPath.findOne({ _id: pathId, userId: userId });

        if (!learningPath) {
            return res.status(404).json({ message: 'Learning path not found or you do not have permission to modify it.' });
        }

        const moduleIndex = learningPath.modules.findIndex(m => m.moduleId === moduleId);
        if (moduleIndex === -1) {
            return res.status(404).json({ message: 'Module not found in this learning path.' });
        }

        // Update the status of the specific module
        learningPath.modules[moduleIndex].status = status;

        // Business Logic: If a module is completed, unlock the next one
        if (status === 'completed' && moduleIndex + 1 < learningPath.modules.length) {
            // Check if the next module is currently locked
            if (learningPath.modules[moduleIndex + 1].status === 'locked') {
                learningPath.modules[moduleIndex + 1].status = 'not_started';
            }
        }

        // Mark the document as modified before saving
        learningPath.markModified('modules');
        await learningPath.save();
        
        // Return the entire updated path so the frontend can refresh its state
        res.status(200).json(learningPath);

    } catch (error) {
        console.error(`[API Error] Failed to update module status for user ${userId}:`, error);
        res.status(500).json({ message: 'Server error while updating module status.' });
    }
});


module.exports = router;
```

`server/routes/llmConfig.js`

```javascript
// server/routes/llmConfig.js
const express = require("express");
const router = express.Router();
const User = require("../models/User");
const { encrypt } = require("../utils/crypto");

// @route   PUT /api/llm/config
// @desc    Update user's LLM preferences (provider, key, or URL)
// @access  Private
router.put("/config", async (req, res) => {
  // 1. Destructure all possible fields.
  const { llmProvider, apiKey, ollamaUrl, ollamaModel } = req.body;
  const userId = req.user._id;

  try {
    // 2. Start with a blank object. We will only update what is sent.
    const updates = {};

    if (llmProvider) {
      if (!["gemini", "ollama"].includes(llmProvider)) {
        return res
          .status(400)
          .json({ message: "Invalid LLM provider specified." });
      }
      updates.preferredLlmProvider = llmProvider;
    }

    // If a new API key is provided, encrypt and add it to updates.
    if (apiKey) {
      updates.encryptedApiKey = encrypt(apiKey);
    }

    // If a new Ollama URL is provided, add it to updates.
    if (typeof ollamaUrl === "string") {
      updates.ollamaUrl = ollamaUrl.trim();
    }

    // If a new Ollama model is provided, add it to updates.
    if (ollamaModel) {
      updates.ollamaModel = ollamaModel;
    }

    // 3. If the updates object is empty, nothing was sent to change.
    if (Object.keys(updates).length === 0) {
      return res
        .status(400)
        .json({ message: "No valid update information provided." });
    }

    // 4. Use $set to only modify the fields present in the 'updates' object.
    // This will NEVER delete a field that isn't included in the request.
    await User.updateOne({ _id: userId }, { $set: updates });

    res.status(200).json({ message: "LLM preferences updated successfully." });
  } catch (error) {
    console.error(`Error updating LLM config for user ${userId}:`, error);
    res.status(500).json({
      message: `Server error while updating LLM preferences: ${error.message}`,
    });
  }
});

// This GET route is correct and doesn't need changes, but it should also return ollamaUrl
router.get("/config", async (req, res) => {
  const userId = req.user._id;
  try {
    const user = await User.findById(userId).select(
      "preferredLlmProvider ollamaModel ollamaUrl"
    );
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }
    res.status(200).json({
      preferredLlmProvider: user.preferredLlmProvider,
      ollamaModel: user.ollamaModel,
      ollamaUrl: user.ollamaUrl, // Also return the URL
    });
  } catch (error) {
    console.error(`Error fetching LLM config for user ${userId}:`, error);
    res.status(500).json({ message: "Server error fetching LLM preferences." });
  }
});

module.exports = router;

```

`server/routes/mindmap.js`

```javascript
// server/routes/mindmap.js
const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');
const User = require('../models/User'); // For a more advanced implementation

// @route   GET /api/mindmap
// @desc    Get Mermaid code for a mind map
// @access  Private (requires auth)
router.get('/', authMiddleware, async (req, res) => {
    const userId = req.user._id; // User is authenticated
    console.log(`>>> GET /api/mindmap: User=${userId}`);

    try {
        const user = await User.findById(userId).select('uploadedDocuments.filename uploadedDocuments.analysis.mindmap'); // Select only necessary fields
        
        let mindmapCode = null;
        let sourceDocumentName = "Unknown Document";

        if (user && user.uploadedDocuments && user.uploadedDocuments.length > 0) {
            // Find the most recent document that has a mindmap analysis.
            // This assumes higher index means more recent, or you'd sort by an explicit timestamp if available.
            for (let i = user.uploadedDocuments.length - 1; i >= 0; i--) {
                const doc = user.uploadedDocuments[i];
                if (doc.analysis && typeof doc.analysis.mindmap === 'string' && doc.analysis.mindmap.trim() !== "") {
                    mindmapCode = doc.analysis.mindmap.trim();
                    sourceDocumentName = doc.filename || "Untitled Document";
                    console.log(`   Found mindmap for document '${sourceDocumentName}' for user ${userId}.`);
                    break;
                }
            }
        }

        if (mindmapCode) {
            // Basic check if the code starts with a known Mermaid diagram type.
            // This is a simple heuristic. Robust validation is complex.
            const trimmedCode = mindmapCode; // Already trimmed
            const validMermaidPrefixes = ['mindmap', 'graph', 'flowchart', 'sequenceDiagram', 'gantt', 'classDiagram', 'stateDiagram', 'pie', 'erDiagram', 'journey', 'requirementDiagram', 'gitGraph'];
            
            const isPotentiallyValidMermaid = validMermaidPrefixes.some(prefix => 
                trimmedCode.toLowerCase().startsWith(prefix)
            );

            if (!isPotentiallyValidMermaid) {
                // If the stored code doesn't look like Mermaid, prepend 'mindmap'
                // This is an assumption that the stored data *should* be a mindmap if it's in this field.
                console.warn(`   Mindmap code for '${sourceDocumentName}' does not start with a recognized Mermaid type. Prefixing with 'mindmap'.`);
                mindmapCode = `mindmap\n${trimmedCode}`; 
            } else if (!trimmedCode.toLowerCase().startsWith('mindmap')) {
                 // If it's valid Mermaid but not explicitly 'mindmap' (e.g. 'graph TD'),
                 // and the user specifically clicked "Mind Map", it's still okay to send.
                 // The Mermaid library on the frontend can render various diagram types.
                console.log(`   Sending stored analysis as Mermaid diagram. Type: ${trimmedCode.split('\n')[0].trim()}`);
            }
            return res.status(200).json({ mermaidCode: mindmapCode, source: sourceDocumentName });
        } else {
            console.log(`   No mindmap analysis found for user ${userId}. Returning default mindmap.`);
            const defaultMermaidCode = `
mindmap
  root((No Mind Map Available))
    (Please upload a document and ensure its analysis includes a mind map.)
    (Or, no documents processed yet.)
`;
            return res.status(200).json({ mermaidCode: defaultMermaidCode, source: "Default" });
        }

    } catch (error) {
        console.error(`!!! Error in GET /api/mindmap for User ${userId}:`, error);
        res.status(500).json({ message: "Failed to retrieve mind map code due to a server error." });
    }
});

module.exports = router;
```

`server/routes/network.js`

```javascript
const express = require('express');
const router = express.Router();
const os = require('os');

function getAllIPs() {
    const interfaces = os.networkInterfaces();
    const ips = new Set(['localhost']); // Include localhost by default

    for (const [name, netInterface] of Object.entries(interfaces)) {
        // Skip loopback and potentially virtual interfaces if desired
        if (name.includes('lo') || name.toLowerCase().includes('virtual') || name.toLowerCase().includes('vmnet')) continue;

        for (const addr of netInterface) {
            // Focus on IPv4, non-internal addresses
            if (addr.family === 'IPv4' && !addr.internal) {
                ips.add(addr.address);
            }
        }
    }
    return Array.from(ips);
}

router.get('/ip', (req, res) => {
    res.json({
        ips: getAllIPs(),
        // req.ip might be less reliable behind proxies, but can be included
        // currentRequestIp: req.ip
    });
});

module.exports = router;

```

`server/routes/subjects.js`

```javascript
// server/routes/subjects.js
const express = require('express');
const router = express.Router();
const AdminDocument = require('../models/AdminDocument'); // Model for admin-uploaded documents

// @route   GET /api/subjects
// @desc    Get a list of available subject names (derived from admin-uploaded document originalNames)
// @access  Private (Regular User Authenticated via JWT)
router.get('/', async (req, res) => {
    // req.user is available here from authMiddleware
    console.log(`User ${req.user.username} is requesting the list of subjects.`);
    try {
        // Fetch distinct originalName values from the AdminDocument collection
        // and sort them alphabetically.
        const subjectObjects = await AdminDocument.find().sort({ originalName: 1 }).select('originalName').lean();
        const subjectNames = subjectObjects.map(doc => doc.originalName);
        
        // Alternative using distinct, but sorting might be different or need post-processing
        // const subjectNames = await AdminDocument.distinct('originalName').exec();
        // subjectNames.sort((a, b) => a.localeCompare(b));


        res.json({ subjects: subjectNames }); // Send as { subjects: ["Subject 1", "Subject 2", ...] }
    } catch (error) {
        console.error("Error fetching subjects for user display:", error);
        res.status(500).json({ message: "Server error while fetching available subjects." });
    }
});

module.exports = router;
```

`server/routes/syllabus.js`

```javascript
// server/routes/syllabus.js
const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const { authMiddleware } = require('../middleware/authMiddleware'); // Protect the route

const router = express.Router();
const SYLLABI_DIR = path.join(__dirname, '..', 'syllabi');

// --- @route   GET /api/syllabus/:subjectId ---
// --- @desc    Get syllabus content for a specific subject ---
// --- @access  Private (requires auth) ---
router.get('/:subjectId', authMiddleware, async (req, res) => {
    const { subjectId } = req.params;

    // Basic sanitization: Allow only alphanumeric and underscores
    // Prevents directory traversal (e.g., ../../etc/passwd)
    const sanitizedSubjectId = subjectId.replace(/[^a-zA-Z0-9_]/g, '');

    if (!sanitizedSubjectId || sanitizedSubjectId !== subjectId) {
        console.warn(`Syllabus request rejected due to invalid characters: ${subjectId}`);
        return res.status(400).json({ message: 'Invalid subject identifier format.' });
    }

    const filePath = path.join(SYLLABI_DIR, `${sanitizedSubjectId}.md`);

    try {
        // Check if file exists first (more specific error)
        await fs.access(filePath);

        // Read the file content
        const content = await fs.readFile(filePath, 'utf-8');

        res.status(200).json({ syllabus: content });

    } catch (error) {
        if (error.code === 'ENOENT') {
            console.warn(`Syllabus file not found: ${filePath}`);
            return res.status(404).json({ message: `Syllabus for '${subjectId}' not found.` });
        } else {
            console.error(`Error reading syllabus file ${filePath}:`, error);
            return res.status(500).json({ message: 'Server error retrieving syllabus.' });
        }
    }
});

module.exports = router;

```

`server/routes/tools.js`

```javascript
// server/routes/tools.js
const express = require("express");
const axios = require("axios");
const multer = require("multer");
const fs = require("fs");
const path = require("path");
const FormData = require("form-data");
const router = express.Router();
const User = require("../models/User");
const { decrypt } = require("../utils/crypto");

// --- THIS IS THE FIX ---
// We switch from a simple 'dest' to a 'storage' configuration
// to gain control over the temporary filename and preserve the extension.
const quizStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    const tempDir = path.join(__dirname, "..", "temp_uploads");
    // Ensure the temp directory exists
    fs.mkdir(tempDir, { recursive: true }, (err) => cb(err, tempDir));
  },
  filename: function (req, file, cb) {
    // Create a unique filename while preserving the original file's extension
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    const extension = path.extname(file.originalname);
    cb(null, file.fieldname + "-" + uniqueSuffix + extension);
  },
});

const quizUpload = multer({
  storage: quizStorage, // Use our new storage engine
  limits: { fileSize: 20 * 1024 * 1024 }, // 20 MB limit
});

async function getApiKeyForRequest(userId) {
  try {
    const user = await User.findById(userId).select(
      "+encryptedApiKey preferredLlmProvider"
    );
    if (
      user &&
      user.preferredLlmProvider === "gemini" &&
      user.encryptedApiKey
    ) {
      const decryptedKey = decrypt(user.encryptedApiKey);
      if (decryptedKey) {
        return decryptedKey;
      }
    }
  } catch (e) {
    console.error(
      `Failed to get or decrypt user-specific API key for ${userId}, falling back to server key. Error: ${e.message}`
    );
  }

  const serverKey = process.env.GEMINI_API_KEY;
  if (serverKey) {
    return serverKey;
  }

  throw new Error(
    "No valid API key is configured for this AI feature on the server, and the user has not provided one."
  );
}

// ... (existing tool routes like /execute, /analyze-code, etc. remain the same) ...
router.post("/execute", async (req, res) => {
  const { language, code, testCases } = req.body;
  if (!code || !language) {
    return res.status(400).json({ message: "Code and language are required." });
  }
  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    return res
      .status(500)
      .json({ message: "Code execution service is not configured." });
  }
  const executionUrl = `${pythonServiceUrl}/execute_code`;
  try {
    const pythonResponse = await axios.post(
      executionUrl,
      { language, code, testCases },
      { timeout: 15000 }
    );
    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg =
      error.response?.data?.error || error.message || "Failed to execute code.";
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

router.post("/analyze-code", async (req, res) => {
  const { language, code } = req.body;
  if (!code || !language) {
    return res.status(400).json({ message: "Code and language are required." });
  }
  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    return res.status(500).json({ message: "AI service is not configured." });
  }
  const analysisUrl = `${pythonServiceUrl}/analyze_code`;
  try {
    const apiKey = await getApiKeyForRequest(req.user._id);
    const pythonResponse = await axios.post(
      analysisUrl,
      { language, code, apiKey },
      { timeout: 60000 }
    );
    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg = error.response?.data?.error || error.message;
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

router.post("/generate-test-cases", async (req, res) => {
  const { language, code } = req.body;
  if (!code || !language) {
    return res.status(400).json({ message: "Code and language are required." });
  }
  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    return res.status(500).json({ message: "AI service is not configured." });
  }
  const generationUrl = `${pythonServiceUrl}/generate_test_cases`;
  try {
    const apiKey = await getApiKeyForRequest(req.user._id);
    const pythonResponse = await axios.post(
      generationUrl,
      { language, code, apiKey },
      { timeout: 60000 }
    );
    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg = error.response?.data?.error || error.message;
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

router.post("/explain-error", async (req, res) => {
  const { language, code, errorMessage } = req.body;
  if (!code || !language || !errorMessage) {
    return res
      .status(400)
      .json({ message: "Code, language, and errorMessage are required." });
  }
  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    return res.status(500).json({ message: "AI service is not configured." });
  }
  const explanationUrl = `${pythonServiceUrl}/explain_error`;
  try {
    const apiKey = await getApiKeyForRequest(req.user._id);
    const pythonResponse = await axios.post(
      explanationUrl,
      { language, code, errorMessage, apiKey },
      { timeout: 60000 }
    );
    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg = error.response?.data?.error || error.message;
    res.status(error.response?.status || 500).json({ message: errorMsg });
  }
});

// @route   POST /api/tools/generate-quiz
// @desc    Generate a quiz from an uploaded document
// @access  Private
router.post("/generate-quiz", quizUpload.single("file"), async (req, res) => {
  const { quizOption } = req.body;
  const file = req.file;

  if (!file) {
    return res
      .status(400)
      .json({ message: "A file is required to generate a quiz." });
  }
  if (!quizOption) {
    await fs.promises.unlink(file.path);
    return res
      .status(400)
      .json({ message: "Quiz option is required." });
  }

  const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
  if (!pythonServiceUrl) {
    await fs.promises.unlink(file.path);
    return res
      .status(500)
      .json({ message: "Quiz generation service is not configured." });
  }

  const generationUrl = `${pythonServiceUrl}/generate_quiz`;
  const form = new FormData();
  form.append("file", fs.createReadStream(file.path));
  form.append("quiz_option", quizOption);

  try {
    const apiKey = await getApiKeyForRequest(req.user._id);
    form.append("api_key", apiKey);

    console.log(
      `[Node Quiz] Forwarding quiz generation request to Python service.`
    );
    const pythonResponse = await axios.post(generationUrl, form, {
      headers: form.getHeaders(),
      timeout: 300000,
    });

    res.status(200).json(pythonResponse.data);
  } catch (error) {
    const errorMsg =
      error.response?.data?.error ||
      error.message ||
      "Failed to generate quiz.";
    console.error(`[Node Quiz] Error calling Python service: ${errorMsg}`);
    res.status(error.response?.status || 500).json({ message: errorMsg });
  } finally {
    await fs.promises
      .unlink(file.path)
      .catch((err) =>
        console.error(`Failed to delete temp quiz file: ${err.message}`)
      );
  }
});

module.exports = router;

```

`server/routes/upload.js`

```javascript
// server/routes/upload.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs').promises;
const axios = require('axios');
const { authMiddleware } = require('../middleware/authMiddleware');
const User = require('../models/User');
const KnowledgeSource = require('../models/KnowledgeSource');
const { Worker } = require('worker_threads');
const { decrypt } = require('../utils/crypto');

const router = express.Router();

// --- Constants & Multer Config ---
const UPLOAD_DIR = path.join(__dirname, '..', 'assets');
const MAX_FILE_SIZE = 50 * 1024 * 1024; // Increased to 50MB for media
const allowedMimeTypes = {
    // Documents
    'application/pdf': { type: 'document', processor: 'ai_core' },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': { type: 'document', processor: 'ai_core' },
    'text/plain': { type: 'document', processor: 'ai_core' },
    'text/markdown': { type: 'document', processor: 'ai_core' },
    // Media
    'audio/mpeg': { type: 'audio', processor: 'media' },
    'audio/wav': { type: 'audio', processor: 'media' },
    'video/mp4': { type: 'video', processor: 'media' },
    'video/quicktime': { type: 'video', processor: 'media' },
    'image/png': { type: 'image', processor: 'media' },
    'image/jpeg': { type: 'image', processor: 'media' },
};
const allowedExtensions = Object.keys(allowedMimeTypes).flatMap(mime => {
    const extMap = { 'application/pdf': '.pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': '.docx', /* etc */ };
    return extMap[mime] || []; // Simplified, a full map would be needed
}); // This part can be improved if needed

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        if (!req.user || !req.user.email) {
            return cb(new Error("Authentication error: User context not found for upload destination."));
        }
        const sanitizedUsername = req.user.email.split('@')[0].replace(/[^a-zA-Z0-9_-]/g, '_');
        const fileMimeType = file.mimetype.toLowerCase();
        const fileTypeSubfolder = allowedMimeTypes[fileMimeType]?.type || 'others';
        const destinationPath = path.join(UPLOAD_DIR, sanitizedUsername, fileTypeSubfolder);
        fs.mkdir(destinationPath, { recursive: true }).then(() => cb(null, destinationPath)).catch(cb);
    },
    filename: (req, file, cb) => {
        const timestamp = Date.now();
        const fileExt = path.extname(file.originalname).toLowerCase();
        const sanitizedBaseName = path.basename(file.originalname, fileExt)
                                      .replace(/[^a-zA-Z0-9._-]/g, '_').substring(0, 100);
        const uniqueFilename = `${timestamp}-${sanitizedBaseName}${fileExt}`;
        cb(null, uniqueFilename);
    }
});

const upload = multer({ storage, limits: { fileSize: MAX_FILE_SIZE } });

// Main upload route
router.post('/', upload.single('file'), async (req, res) => {
    if (!req.file) return res.status(400).json({ message: "No file received." });
    
    const userId = req.user._id;
    const { originalname: originalName, path: serverPath, mimetype } = req.file;
    
    let newSource;
    try {
        const { type, processor } = allowedMimeTypes[mimetype.toLowerCase()] || {};
        if (!type || !processor) {
            throw new Error(`Unsupported file type: ${mimetype}`);
        }

        newSource = new KnowledgeSource({
            userId,
            sourceType: type,
            title: originalName,
            serverFilename: path.basename(serverPath),
            status: 'processing_extraction'
        });
        await newSource.save();

        res.status(202).json({ 
            message: "File accepted. Processing has started in the background.",
            source: newSource
        });

        // --- Start background processing ---
        const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
        if (!pythonServiceUrl) throw new Error("Python service URL not configured.");

        let pythonEndpoint = '';
        let pythonPayload = {};

        if (processor === 'ai_core') {
            pythonEndpoint = '/add_document';
            pythonPayload = { user_id: userId.toString(), file_path: serverPath, original_name: originalName };
        } else if (processor === 'media') {
            pythonEndpoint = '/process_media_file';
            pythonPayload = { file_path: serverPath, media_type: type };
        }
        
        const extractionResponse = await axios.post(`${pythonServiceUrl}${pythonEndpoint}`, pythonPayload, { timeout: 600000 }); // 10 min timeout for media
        
        const text_content = extractionResponse.data?.text_content || (processor === 'ai_core' ? extractionResponse.data?.raw_text_for_analysis : null);
        
        if (!text_content) throw new Error("Failed to extract text from the source.");
        
        const sourceDoc = await KnowledgeSource.findById(newSource._id);
        sourceDoc.textContent = text_content;
        sourceDoc.status = 'processing_analysis';
        await sourceDoc.save();

        // Trigger analysis and KG workers...
        const user = await User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaModel ollamaUrl').lean();
        const llmProvider = user?.preferredLlmProvider || 'gemini';
        const userApiKey = user.encryptedApiKey ? decrypt(user.encryptedApiKey) : null;
        
        const workerBaseData = {
            sourceId: sourceDoc._id.toString(), userId: userId.toString(), originalName, llmProvider,
            ollamaModel: user.ollamaModel, apiKey: userApiKey, ollamaUrl: user.ollamaUrl
        };
        
        const analysisWorker = new Worker(path.resolve(__dirname, '../workers/analysisWorker.js'), { 
            workerData: { ...workerBaseData, textForAnalysis: text_content }
        });
        analysisWorker.on('error', (err) => console.error(`Analysis Worker Error (File: ${originalName}):`, err));
        
        // KG worker logic for ai_core processed docs (needs refactor for unified chunks)
        const chunksForKg = extractionResponse.data?.chunks_with_metadata || [];
         if (chunksForKg.length > 0) {
            const kgWorker = new Worker(path.resolve(__dirname, '../workers/kgWorker.js'), { 
                workerData: { ...workerBaseData, chunksForKg }
            });
            kgWorker.on('error', (err) => console.error(`KG Worker Error (File: ${originalName}):`, err));
        }


    } catch (error) {
        console.error(`Error processing uploaded file '${originalName}':`, error);
        if (newSource) {
            await KnowledgeSource.updateOne({ _id: newSource._id }, {
                $set: { status: 'failed', failureReason: error.message }
            });
        }
        // If headers not sent, send error to client. This happens for initial errors.
        if (!res.headersSent) {
             res.status(500).json({ message: error.message || "Server error during file processing." });
        }
    }
});

module.exports = router;
```

`server/routes/user.js`

```javascript
// server/routes/user.js
const express = require('express');
const router = express.Router();
const User = require('../models/User');
const { redisClient } = require('../config/redisClient');

// Note: The main 'authMiddleware' will be applied in server.js before this router is used,
// so we don't need to add it to each route here. req.user will be available.

// @route   GET /api/user/profile
// @desc    Get the current user's profile data
// @access  Private
router.get('/profile', async (req, res) => {
    try {
        const user = await User.findById(req.user._id).select('profile');
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }
        // Return the profile object, or an empty object if it doesn't exist
        res.json(user.profile || {});
    } catch (error) {
        console.error('Error fetching user profile:', error);
        res.status(500).json({ message: 'Server error while fetching profile.' });
    }
});

// @route   PUT /api/user/profile
// @desc    Update the current user's profile data
// @access  Private
router.put('/profile', async (req, res) => {
    // 1. Destructure all possible profile fields, including the new ones
    const { name, college, universityNumber, degreeType, branch, year, learningStyle, currentGoals } = req.body;

    // 2. Update validation to include the new required fields
    if (!name || !college || !universityNumber || !degreeType || !branch || !year || !learningStyle) {
        return res.status(400).json({ message: 'All profile fields are required.' });
    }

    try {
        const user = await User.findById(req.user._id);
        if (!user) {
            return res.status(404).json({ message: 'User not found.' });
        }

        // 3. Update the profile sub-document with all fields
        // This ensures a complete and consistent profile object is always saved.
        user.profile = {
            name,
            college,
            universityNumber,
            degreeType,
            branch,
            year,
            learningStyle,
            currentGoals: currentGoals || ''
        };
        // The performanceMetrics field is intentionally not updated here, as it's managed by the system.

        await user.save();
        
        if (redisClient && redisClient.isOpen) {
            const cacheKey = `user:${req.user._id}`;
            await redisClient.del(cacheKey);
            console.log(`[Cache Invalidation] Deleted cache for user ${req.user._id} due to profile update.`);
        }
        res.json({
            message: 'Profile updated successfully!',
            profile: user.profile
        });

    } catch (error) {
        console.error('Error updating user profile:', error);
        res.status(500).json({ message: 'Server error while updating profile.' });
    }
});


module.exports = router;
```

`server/server.js`

```javascript
// server/server.js
const dotenv = require("dotenv");
dotenv.config();

const express = require("express");
const cors = require("cors");
const path = require("path");
const fs = require("fs");
const axios = require("axios");
const mongoose = require("mongoose");

// --- Custom Modules & Middleware ---
const connectDB = require("./config/db");
const { getLocalIPs } = require("./utils/networkUtils");
const { performAssetCleanup } = require("./utils/assetCleanup");
const { authMiddleware } = require("./middleware/authMiddleware");
const {
  fixedAdminAuthMiddleware,
} = require("./middleware/fixedAdminAuthMiddleware");
const { connectRedis } = require("./config/redisClient");

// --- Route Imports ---
const networkRoutes = require("./routes/network");
const authRoutes = require("./routes/auth");
const userRoutes = require("./routes/user");
const chatRoutes = require("./routes/chat");
const uploadRoutes = require("./routes/upload");
// const filesRoutes = require("./routes/files");
const analysisRoutes = require("./routes/analysis");
const adminApiRoutes = require("./routes/admin");
const subjectsRoutes = require("./routes/subjects");
const generationRoutes = require("./routes/generation");
const exportRoutes = require("./routes/export");
const kgRoutes = require("./routes/kg");
const llmConfigRoutes = require("./routes/llmConfig");
const toolsRoutes = require("./routes/tools");
const learningRoutes = require("./routes/learning");
const learningPathRoutes = require("./routes/learningPath");
const knowledgeSourceRoutes = require("./routes/knowledgeSource");

// --- Configuration & Express App Setup ---
const port = process.env.PORT || 5001;
const mongoUri = process.env.MONGO_URI;
const pythonRagUrl = process.env.PYTHON_RAG_SERVICE_URL;

if (!process.env.JWT_SECRET || !process.env.ENCRYPTION_SECRET) {
  console.error(
    "!!! FATAL: JWT_SECRET or ENCRYPTION_SECRET is not set in .env file."
  );
  process.exit(1);
}
if (!mongoUri) {
  console.error("!!! FATAL: MONGO_URI is not set in .env file.");
  process.exit(1);
}

const app = express();
app.use(cors());
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

// --- API Route Mounting ---
app.get("/", (req, res) => res.send("AI Tutor Backend API is running..."));
app.use("/api/network", networkRoutes);
app.use("/api/auth", authRoutes);

// --- Admin Routes ---
// Apply the fixed admin auth middleware to the single admin router.
app.use("/api/admin", fixedAdminAuthMiddleware, adminApiRoutes);

// All subsequent routes are protected by the general JWT authMiddleware
app.use(authMiddleware);
app.use("/api/user", userRoutes);
app.use("/api/chat", chatRoutes);
app.use("/api/learning", learningRoutes);
app.use("/api/learning/paths", learningPathRoutes);
app.use("/api/upload", uploadRoutes);
// app.use("/api/files", filesRoutes);
app.use("/api/analysis", analysisRoutes);
app.use("/api/subjects", subjectsRoutes);
app.use("/api/generate", generationRoutes);
app.use("/api/export", exportRoutes);
app.use("/api/kg", kgRoutes);
app.use("/api/llm", llmConfigRoutes);
app.use("/api/tools", toolsRoutes);
app.use("/api/admin", adminApiRoutes);
app.use("/api/knowledge-sources", knowledgeSourceRoutes);
// --- Centralized Error Handling ---
app.use((err, req, res, next) => {
  console.error("Unhandled Error:", err.stack || err);
  const statusCode = err.status || 500;
  const message = err.message || "An internal server error occurred.";
  if (!res.headersSent) {
    res.status(statusCode).json({ message });
  }
});

// --- Server Startup Logic ---
async function startServer() {
  console.log("\n--- Starting Server Initialization ---");
  try {
    await ensureServerDirectories();
    await connectDB(mongoUri);
    await performAssetCleanup();
    await checkRagService(pythonRagUrl);
    await connectRedis();

    const server = app.listen(port, "0.0.0.0", () => {
      console.log("\n=== Node.js Server Ready ===");
      console.log(`🚀 Server listening on port ${port}`);
      getLocalIPs().forEach((ip) => {
        console.log(`   - http://${ip}:${port}`);
      });
      console.log("============================\n");
    });

    const gracefulShutdown = (signal) => {
      console.log(`\n${signal} received. Shutting down...`);
      server.close(() => {
        mongoose.connection.close(false, () => {
          console.log("MongoDB connection closed.");
          process.exit(0);
        });
      });
    };
    process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
    process.on("SIGINT", () => gracefulShutdown("SIGINT"));
  } catch (error) {
    console.error("!!! Failed to start Node.js server:", error.message);
    process.exit(1);
  }
}

// Helper functions
async function ensureServerDirectories() {
  const dirs = [
    path.join(__dirname, "assets"),
    path.join(__dirname, "backup_assets"),
    path.join(__dirname, "generated_docs"),
  ];
  for (const dir of dirs) {
    if (!fs.existsSync(dir)) await fs.promises.mkdir(dir, { recursive: true });
  }
}
async function checkRagService(url) {
  if (!url) {
    console.warn("! Python RAG service URL not configured.");
    return;
  }
  try {
    const response = await axios.get(`${url}/health`, { timeout: 7000 });
    if (response.data.status === "ok") {
      console.log("✓ Python RAG service is available.");
    } else {
      console.warn(
        `! Python RAG service responded but is not healthy. Status: ${response.data.status}`
      );
    }
  } catch (error) {
    console.warn("! Python RAG service is not reachable.");
  }
}

startServer();

```

`server/services/agentService.js`

```javascript
// server/services/agentService.js
const { CHAT_MAIN_SYSTEM_PROMPT, createSynthesizerPrompt, createAgenticSystemPrompt } = require('../config/promptTemplates.js');
const { availableTools } = require('./toolRegistry.js');
const { createModelContext, createAgenticContext } = require('../protocols/contextProtocols.js');
const geminiService = require('./geminiService.js');
const ollamaService = require('./ollamaService.js');

function parseToolCall(responseText) {
    try {
        const jsonMatch = responseText.match(/```(json)?\s*([\s\S]+?)\s*```/);
        const jsonString = jsonMatch ? jsonMatch[2] : responseText;
        const jsonResponse = JSON.parse(jsonString);
        if (jsonResponse && typeof jsonResponse.tool_call !== 'undefined') {
            return jsonResponse.tool_call;
        }
        return null;
    } catch (e) {
        console.warn(`[AgentService] Failed to parse JSON tool_call from LLM. Response: ${responseText.substring(0, 200)}...`);
        return null;
    }
}

async function processAgenticRequest(
  userQuery,
  chatHistory,
  clientSystemPrompt,
  requestContext
) {
  const {
    llmProvider,
    ollamaModel,
    userId,
    ollamaUrl,
    documentContextName,
    apiKey,
  } = requestContext;

  const llmService = llmProvider === "ollama" ? ollamaService : geminiService;
  const llmOptions = {
    ...(llmProvider === "ollama" && { model: ollamaModel }),
    apiKey: apiKey,
    ollamaUrl: ollamaUrl,
  };

  const modelContext = createModelContext({ availableTools });
  const agenticContext = createAgenticContext({
    systemPrompt: clientSystemPrompt,
  });
  const routerSystemPrompt = createAgenticSystemPrompt(
    modelContext,
    agenticContext,
    { userQuery, ...requestContext }
  );

  console.log(`[AgentService] Performing Router call using ${llmProvider}...`);
  const routerResponseText = await llmService.generateContentWithHistory(
    [],
    "Analyze the query and decide on an action.",
    routerSystemPrompt,
    llmOptions
  );
  const toolCall = parseToolCall(routerResponseText);

  if (requestContext.forceSimple === true || !toolCall || !toolCall.tool_name) {
    if (requestContext.forceSimple === true) {
      console.log(
        "[AgentService] Skipping router/tool logic due to forceSimple flag. Responding directly."
      );
    } else {
      console.log(
        "[AgentService] Router decided a direct answer is best (no tool call). Responding directly."
      );
    }

    const finalSystemPrompt = CHAT_MAIN_SYSTEM_PROMPT();
    const userPrompt = userQuery;
    const directAnswer = await llmService.generateContentWithHistory(
      chatHistory,
      userPrompt,
      finalSystemPrompt,
      llmOptions
    );

    const thinkingMatch = directAnswer.match(
      /<thinking>([\s\S]*?)<\/thinking>/i
    );
    const thinking = thinkingMatch ? thinkingMatch[1].trim() : null;
    const mainContent = thinking
      ? directAnswer.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, "").trim()
      : directAnswer;

    const pipelineSource = requestContext.forceSimple
      ? `${requestContext.llmProvider}-agent-direct-bypass`
      : `${requestContext.llmProvider}-agent-direct-no-tool`;

    return {
      finalAnswer: mainContent,
      thinking: thinking,
      references: [],
      sourcePipeline: pipelineSource,
    };
  }

  console.log(`[AgentService] Decision: Tool Call -> ${toolCall.tool_name}`);
  const mainTool = availableTools[toolCall.tool_name];
  if (!mainTool) {
    return {
      finalAnswer:
        "I tried to use a tool that doesn't exist. Please try again.",
      references: [],
      sourcePipeline: "agent-error-unknown-tool",
    };
  }

  try {
    const toolResult = await mainTool.execute(
      toolCall.parameters,
      requestContext
    );

    let pipeline = `${llmProvider}-agent-${toolCall.tool_name}`;
    if (
      toolCall.tool_name === "rag_search" &&
      requestContext.criticalThinkingEnabled
    ) {
      pipeline += "+kg_enhanced";
    }

    console.log(
      `[AgentService] Performing Synthesizer call using ${llmProvider}...`
    );

    const finalSystemPrompt = CHAT_MAIN_SYSTEM_PROMPT();
    const synthesizerUserQuery = createSynthesizerPrompt(
      userQuery,
      toolResult.toolOutput,
      toolCall.tool_name
    );

    const finalAnswerWithThinking = await llmService.generateContentWithHistory(
      chatHistory,
      synthesizerUserQuery,
      finalSystemPrompt,
      llmOptions
    );

    const thinkingMatch = finalAnswerWithThinking.match(
      /<thinking>([\s\S]*?)<\/thinking>/i
    );
    const thinking = thinkingMatch ? thinkingMatch[1].trim() : null;
    const finalAnswer = thinking
      ? finalAnswerWithThinking
          .replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, "")
          .trim()
      : finalAnswerWithThinking;

    return {
      finalAnswer,
      thinking,
      references: toolResult.references || [],
      sourcePipeline: pipeline,
    };
  } catch (error) {
    console.error(
      `[AgentService] Error executing tool '${toolCall.tool_name}':`,
      error
    );
    return {
      finalAnswer: `I tried to use a tool, but it failed. Error: ${error.message}.`,
      references: [],
      thinking: null,
      sourcePipeline: `agent-error-tool-failed`,
    };
  }
}


module.exports = {
    processAgenticRequest,
};
```

`server/services/criticalThinkingService.js`

```javascript
// server/services/criticalThinkingService.js
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');
const { CRITICAL_THINKING_CUE_TEMPLATE } = require('../config/promptTemplates');

const CUE_GEMINI_MODEL = process.env.PROMPT_COACH_GEMINI_MODEL || 'gemini-1.5-flash-latest';
const CUE_OLLAMA_MODEL = process.env.PROMPT_COACH_OLLAMA_MODEL || 'phi3:mini-instruct';

/**
 * Analyzes an AI's final answer to generate critical thinking cue prompts.
 * @param {string} aiAnswerText - The final text of the AI's response.
 * @param {object} llmConfig - Configuration object containing the user's provider, key, URL, etc.
 * @returns {Promise<object|null>} An object with cue prompts, or null if none are generated or an error occurs.
 */
async function generateCues(aiAnswerText, llmConfig) {
    if (!aiAnswerText || aiAnswerText.trim().length < 50) {
        // Don't generate cues for very short or empty answers
        return null;
    }

    const { llmProvider, ollamaUrl, apiKey } = llmConfig;
    const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;

    const promptForLlm = CRITICAL_THINKING_CUE_TEMPLATE.replace('{aiAnswer}', aiAnswerText.substring(0, 2000)); // Limit context size for speed

    const llmOptions = {
        model: llmProvider === 'ollama' ? CUE_OLLAMA_MODEL : CUE_GEMINI_MODEL,
        apiKey: apiKey,
        ollamaUrl: ollamaUrl,
        temperature: 0.4 // Lower temperature for more deterministic, structured output
    };

    try {
        console.log(`[CriticalThinkingService] Generating cues using ${llmProvider} with model ${llmOptions.model}.`);
        const responseText = await llmService.generateContentWithHistory([], promptForLlm, null, llmOptions);

        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            console.warn("[CriticalThinkingService] LLM response did not contain a valid JSON object.");
            return null;
        }
        
        const parsedResponse = JSON.parse(jsonMatch[0]);

        // Validate that at least one valid key exists
        if (parsedResponse.verificationPrompt || parsedResponse.alternativePrompt || parsedResponse.applicationPrompt) {
            return parsedResponse;
        }

        // Return null if the object is empty ({})
        return null;

    } catch (error) {
        console.error(`[CriticalThinkingService] Failed to generate cues: ${error.message}`);
        // Return null on any error to ensure this feature doesn't block the main response
        return null;
    }
}

module.exports = {
    generateCues
};
```

`server/services/criticalThinkingService.js`

```javascript
// server/services/criticalThinkingService.js
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');
const { CRITICAL_THINKING_CUE_TEMPLATE } = require('../config/promptTemplates');

const CUE_GEMINI_MODEL = process.env.PROMPT_COACH_GEMINI_MODEL || 'gemini-1.5-flash-latest';
const CUE_OLLAMA_MODEL = process.env.PROMPT_COACH_OLLAMA_MODEL || 'phi3:mini-instruct';

/**
 * Analyzes an AI's final answer to generate critical thinking cue prompts.
 * @param {string} aiAnswerText - The final text of the AI's response.
 * @param {object} llmConfig - Configuration object containing the user's provider, key, URL, etc.
 * @returns {Promise<object|null>} An object with cue prompts, or null if none are generated or an error occurs.
 */
async function generateCues(aiAnswerText, llmConfig) {
    if (!aiAnswerText || aiAnswerText.trim().length < 50) {
        // Don't generate cues for very short or empty answers
        return null;
    }

    const { llmProvider, ollamaUrl, apiKey } = llmConfig;
    const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;

    const promptForLlm = CRITICAL_THINKING_CUE_TEMPLATE.replace('{aiAnswer}', aiAnswerText.substring(0, 2000)); // Limit context size for speed

    const llmOptions = {
        model: llmProvider === 'ollama' ? CUE_OLLAMA_MODEL : CUE_GEMINI_MODEL,
        apiKey: apiKey,
        ollamaUrl: ollamaUrl,
        temperature: 0.4 // Lower temperature for more deterministic, structured output
    };

    try {
        console.log(`[CriticalThinkingService] Generating cues using ${llmProvider} with model ${llmOptions.model}.`);
        const responseText = await llmService.generateContentWithHistory([], promptForLlm, null, llmOptions);

        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            console.warn("[CriticalThinkingService] LLM response did not contain a valid JSON object.");
            return null;
        }
        
        const parsedResponse = JSON.parse(jsonMatch[0]);

        // Validate that at least one valid key exists
        if (parsedResponse.verificationPrompt || parsedResponse.alternativePrompt || parsedResponse.applicationPrompt) {
            return parsedResponse;
        }

        // Return null if the object is empty ({})
        return null;

    } catch (error) {
        console.error(`[CriticalThinkingService] Failed to generate cues: ${error.message}`);
        // Return null on any error to ensure this feature doesn't block the main response
        return null;
    }
}

module.exports = {
    generateCues
};
```

`server/services/geminiService.js`

```javascript
// server/services/geminiService.js
const {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} = require("@google/generative-ai");

const FALLBACK_API_KEY = process.env.GEMINI_API_KEY;
const MODEL_NAME = "gemini-1.5-flash-latest"; // Using a more stable model name

const DEFAULT_MAX_OUTPUT_TOKENS_CHAT = 8192; // Standard for Flash
const DEFAULT_MAX_OUTPUT_TOKENS_KG = 8192;

const baseSafetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_NONE,
  },
];

async function generateContentWithHistory(
  chatHistory,
  currentUserQuery,
  systemPromptText = null,
  options = {}
) {
  const apiKeyToUse = options.apiKey || FALLBACK_API_KEY;

  if (!apiKeyToUse) {
    console.error(
      "FATAL ERROR: Gemini API key is not available for this request."
    );
    throw new Error("Gemini API key is missing. Please configure it.");
  }

  try {
    const genAI = new GoogleGenerativeAI(apiKeyToUse);

    if (
      typeof currentUserQuery !== "string" ||
      currentUserQuery.trim() === ""
    ) {
      throw new Error("currentUserQuery must be a non-empty string.");
    }

    const model = genAI.getGenerativeModel({
      model: MODEL_NAME,
      systemInstruction:
        systemPromptText &&
        typeof systemPromptText === "string" &&
        systemPromptText.trim() !== ""
          ? systemPromptText.trim()
          : undefined,
      safetySettings: baseSafetySettings,
    });

    // --- THIS IS THE FIX ---
    // We will use the more stable, stateless `generateContent` method.
    // First, construct the full conversation history including the new query.
    const contents = (chatHistory || [])
      .map((msg) => ({
        role: msg.role,
        parts: Array.isArray(msg.parts)
          ? msg.parts.map((part) => ({ text: part.text || "" }))
          : [{ text: msg.text || "" }],
      }))
      .filter(
        (msg) =>
          msg.role &&
          msg.parts &&
          msg.parts.length > 0 &&
          typeof msg.parts[0].text === "string"
      );

    // Add the current user query as the last part of the contents
    contents.push({ role: "user", parts: [{ text: currentUserQuery }] });
    // --- END OF FIX ---

    const generationConfig = {
      temperature: 0.7,
      maxOutputTokens:
        options.maxOutputTokens || DEFAULT_MAX_OUTPUT_TOKENS_CHAT,
    };

    console.log(
      `Sending message to Gemini via generateContent. History length: ${
        contents.length - 1
      }. System Prompt: ${!!systemPromptText}.`
    );

    // --- THIS IS THE FIX ---
    // Call the stateless `generateContent` with the fully structured payload.
    const result = await model.generateContent({
      contents: contents,
      generationConfig: generationConfig,
    });
    // --- END OF FIX ---

    const response = result.response;
    const candidate = response?.candidates?.[0];

    if (
      candidate &&
      (candidate.finishReason === "STOP" ||
        candidate.finishReason === "MAX_TOKENS")
    ) {
      const responseText = candidate?.content?.parts?.[0]?.text || "";
      if (candidate.finishReason === "MAX_TOKENS") {
        console.warn("Gemini response was truncated due to MAX_TOKENS limit.");
      }
      return responseText;
    } else {
      const finishReason = candidate?.finishReason || "Unknown";
      const safetyRatings = candidate?.safetyRatings;
      console.warn("Gemini response was potentially blocked or had issues.", {
        finishReason,
        safetyRatings,
      });
      let blockMessage = `AI response generation failed or was blocked.`;
      if (finishReason === "SAFETY") {
        blockMessage += ` Reason: SAFETY.`;
        if (safetyRatings) {
          const blockedCategories = safetyRatings
            .filter((r) => r.blocked)
            .map((r) => r.category)
            .join(", ");
          if (blockedCategories)
            blockMessage += ` Blocked Categories: ${blockedCategories}.`;
        }
      } else if (finishReason) {
        blockMessage += ` Reason: ${finishReason}.`;
      }
      const error = new Error(blockMessage);
      error.status = 400;
      throw error;
    }
  } catch (error) {
    console.error("Gemini API Call Error:", error?.message || error);
    let clientMessage = "Failed to get response from AI service.";
    // Keep the detailed error parsing as it's still useful
    if (error.message?.includes("API key not valid")) {
      clientMessage = "Invalid API Key.";
    } else if (error.message?.includes("API key not found")) {
      clientMessage = "API Key not found";
    } else if (error.message?.includes("API_KEY_INVALID")) {
      clientMessage = "API Key not invalid. Please Provide the Valid one.";
    } else if (error.message?.includes("enabled this API recently")) {
      clientMessage =
        "Looks like new API key. Need some time to fully activate.";
    } else if (error.message?.includes("billing account")) {
      clientMessage = "Billing account issue with the provided API Key.";
    } else if (error.message?.includes("blocked due to safety")) {
      clientMessage = "AI response blocked due to safety settings.";
    } else if (error.message?.includes("Invalid JSON payload")) {
      clientMessage = "Invalid request format sent to AI.";
    } else if (error.message?.includes("User location is not supported")) {
      clientMessage = "User location is not supported for this model.";
    } else if (error.message?.includes("model is overloaded")) {
      clientMessage =
        "The AI model is currently overloaded. Please try again in a moment.";
    } else if (error.status === 400) {
      clientMessage = `${error.message}`;
    }
    const enhancedError = new Error(clientMessage);
    enhancedError.status = error.status || 500;
    enhancedError.originalError = error;
    throw enhancedError;
  }
}

module.exports = {
  generateContentWithHistory,
  DEFAULT_MAX_OUTPUT_TOKENS_KG,
};

```

`server/services/kgExtractionService.js`

```javascript
// server/services/kgExtractionService.js
const { decrypt } = require("../utils/crypto");
const User = require("../models/User");
const geminiService = require("./geminiService");
const ollamaService = require("./ollamaService");
const axios = require("axios");
const path = require("path");

const KG_EXTRACTION_PROMPT = `
You are an expert data architect. Your task is to analyze the provided text and extract a detailed knowledge graph of the key concepts and their relationships.

**INSTRUCTIONS:**
1.  **Identify Entities/Nodes**: Identify the top 5-7 most important entities (concepts, technologies, processes). These will be your nodes.
2.  **Identify Relationships/Edges**: Determine how these nodes are connected with descriptive verb phrases (e.g., 'IS_A', 'USES', 'RESULTS_IN').
3.  **Format as JSON**: Your entire output MUST be a single, valid JSON object with "nodes" and "edges".
    -   Nodes: \`[{"id": "NodeID", "description": "A brief, one-sentence description."}]\`
    -   Edges: \`[{"from": "SourceNodeID", "to": "TargetNodeID", "relationship": "RELATIONSHIP_TYPE"}]\`
4.  **Be Concise**: Focus only on the most critical concepts from the provided text.

---
**TEXT TO ANALYZE:**
"{textToAnalyze}"
---

**FINAL KNOWLEDGE GRAPH JSON (start immediately with \`{\`):**
`;

async function extractAndStoreKgFromText(text, sessionId, userId, llmConfig) {
  const logPrefix = `[KG Extraction Service] Session: ${sessionId}`;
  try {
   
    const { preferredLlmProvider, ollamaUrl, ollamaModel, apiKey } = llmConfig; // Use passed-in config

    const llmService =
      preferredLlmProvider === "ollama" ? ollamaService : geminiService;

    if (preferredLlmProvider === "gemini" && !apiKey) {
      throw new Error(
        "User has selected Gemini but has no API key configured."
      );
    }

    const prompt = KG_EXTRACTION_PROMPT.replace(
      "{textToAnalyze}",
      text.substring(0, 4000)
    );
    const llmOptions = {
      apiKey,
      ollamaUrl,
      model: ollamaModel,
      temperature: 0.2,
    };

    console.log(`${logPrefix} Calling LLM to extract KG entities...`);
    const responseText = await llmService.generateContentWithHistory(
      [],
      prompt,
      null,
      llmOptions
    );

    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch)
      throw new Error("LLM did not return a valid JSON object for the KG.");

    const graphData = JSON.parse(jsonMatch[0]);
    if (!graphData.nodes || !graphData.edges)
      throw new Error("LLM JSON is missing 'nodes' or 'edges'.");

    console.log(
      `${logPrefix} Extracted ${graphData.nodes.length} nodes. Sending to Python for ingestion.`
    );

    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl)
      throw new Error("Python service URL not configured.");

    await axios.post(
      `${pythonServiceUrl}/kg`,
      {
        userId: userId.toString(),
        originalName: sessionId,
        nodes: graphData.nodes,
        edges: graphData.edges,
      },
      { timeout: 60000 }
    );

    console.log(`${logPrefix} KG ingestion successful.`);
  } catch (error) {
    console.error(
      `${logPrefix} Failed to extract and store KG:`,
      error.message
    );
  }
}

module.exports = { extractAndStoreKgFromText };
```

`server/services/kgService.js`

```javascript
// server/services/kgService.js
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const {
    KG_GENERATION_SYSTEM_PROMPT,
    KG_BATCH_USER_PROMPT_TEMPLATE
} = require('../config/promptTemplates');


function constructKgPromptForBatch(chunkTexts) {
    let formattedChunkTexts = "";
    chunkTexts.forEach((chunkText, index) => {
        formattedChunkTexts += `
--- START OF CHUNK ${index + 1} ---
${chunkText}
--- END OF CHUNK ${index + 1} ---
`;
    });
    return KG_BATCH_USER_PROMPT_TEMPLATE.replace('{BATCHED_CHUNK_TEXTS_HERE}', formattedChunkTexts);
}

async function _processBatchOfChunksForKg(batchOfChunkObjects, batchIndex, llmProvider, ollamaModel) {
    const logPrefix = `[KG Service Batch ${batchIndex}]`;

    const chunkTextsForPrompt = batchOfChunkObjects.map(chunk => chunk.text_content);

    if (chunkTextsForPrompt.length === 0) {
        console.log(`${logPrefix} No text content in this batch. Skipping.`);
        return [];
    }

    const userPromptForBatch = constructKgPromptForBatch(chunkTextsForPrompt);
    
    // For KG generation, the user prompt contains the data to be processed.
    // The system prompt contains the instructions on HOW to process it.
    const historyForLlm = [
        { role: 'user', parts: [{ text: "Please generate the knowledge graph fragments based on the provided text chunks and your system instructions." }] }
    ];

    try {
        console.log(`${logPrefix} Processing ${chunkTextsForPrompt.length} chunks for KG generation using ${llmProvider}.`);
        let responseText;

        if (llmProvider === 'ollama') {
            responseText = await ollamaService.generateContentWithHistory(
                historyForLlm,
                userPromptForBatch, // Pass the chunks as the "current query"
                KG_GENERATION_SYSTEM_PROMPT, // Pass the KG instructions as the system prompt
                { model: ollamaModel, maxOutputTokens: ollamaService.DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_KG }
            );
        } else { // Default to Gemini
            // --- THIS IS THE CORRECTED CALL ---
            responseText = await geminiService.generateContentWithHistory(
                historyForLlm,                      // Minimal history to kick off the chat
                userPromptForBatch,                 // The user prompt containing the document chunks to be analyzed
                KG_GENERATION_SYSTEM_PROMPT,        // The detailed instructions on how the LLM should behave
                { maxOutputTokens: geminiService.DEFAULT_MAX_OUTPUT_TOKENS_KG } // Pass maxOutputTokens correctly in the options object
            );
            // --- END CORRECTION ---
        }

        if (!responseText) {
            console.warn(`${logPrefix} Empty response from LLM for batch.`);
            return [];
        }

        let cleanedResponseText = responseText.trim();
        if (cleanedResponseText.startsWith("```json")) {
            cleanedResponseText = cleanedResponseText.substring(7);
            if (cleanedResponseText.endsWith("```")) {
                cleanedResponseText = cleanedResponseText.slice(0, -3);
            }
        } else if (cleanedResponseText.startsWith("```")) {
            cleanedResponseText = cleanedResponseText.substring(3);
            if (cleanedResponseText.endsWith("```")) {
                cleanedResponseText = cleanedResponseText.slice(0, -3);
            }
        }
        cleanedResponseText = cleanedResponseText.trim();
        
        const graphFragmentsArray = JSON.parse(cleanedResponseText);

        if (!Array.isArray(graphFragmentsArray)) {
            console.warn(`${logPrefix} LLM response was not a JSON array.`);
            return [];
        }

        if (graphFragmentsArray.length !== batchOfChunkObjects.length) {
            console.warn(`${logPrefix} Mismatch: Expected ${batchOfChunkObjects.length} KG fragments, but received ${graphFragmentsArray.length}.`);
        }
        
        const validFragments = graphFragmentsArray.filter(fragment =>
            fragment && typeof fragment === 'object' && Array.isArray(fragment.nodes) && Array.isArray(fragment.edges)
        );
        
        if (validFragments.length !== graphFragmentsArray.length) {
            console.warn(`${logPrefix} Some fragments from the LLM were malformed and discarded.`);
        }

        console.log(`${logPrefix} Successfully parsed ${validFragments.length} valid KG fragments.`);
        return validFragments;

    } catch (error) {
        console.error(`${logPrefix} Error processing batch:`, error.message);
        if (error.originalError) console.error(`${logPrefix} Original LLM error:`, error.originalError);
        return [];
    }
}


function _mergeGraphFragments(graphFragments) {
    console.log(`[KG Service] Merging ${graphFragments.length} graph fragments...`);
    const finalNodesMap = new Map();
    const finalEdgesSet = new Set();

    for (const fragment of graphFragments) {
        if (!fragment || !fragment.nodes || !fragment.edges) {
            console.warn("[KG Service Merge] Skipping invalid or null graph fragment.");
            continue;
        }
        
        for (const node of fragment.nodes) {
            if (!node || typeof node.id !== 'string' || !node.id.trim()) {
                console.warn("[KG Service Merge] Skipping invalid node (missing/empty ID):", node);
                continue;
            }
            const nodeId = node.id.trim();
            if (!finalNodesMap.has(nodeId)) {
                finalNodesMap.set(nodeId, { ...node, id: nodeId });
            } else {
                const existingNode = finalNodesMap.get(nodeId);
                if (node.description && typeof node.description === 'string' &&
                    (!existingNode.description || node.description.length > existingNode.description.length)) {
                    existingNode.description = node.description;
                }
                if (node.type && (!existingNode.type || existingNode.type === "generic" || existingNode.type.toLowerCase() === "unknown")) {
                    existingNode.type = node.type;
                }
                if (node.parent && !existingNode.parent) {
                    existingNode.parent = node.parent;
                }
            }
        }

        for (const edge of fragment.edges) {
            if (!edge || typeof edge.from !== 'string' || typeof edge.to !== 'string' || typeof edge.relationship !== 'string' ||
                !edge.from.trim() || !edge.to.trim() || !edge.relationship.trim()) {
                console.warn("[KG Service Merge] Skipping invalid edge (missing from/to/relationship or empty):", edge);
                continue;
            }
            const edgeKey = `${edge.from.trim()}|${edge.to.trim()}|${edge.relationship.trim().toUpperCase()}`;
            finalEdgesSet.add(edgeKey);
        }
    }

    const mergedNodes = Array.from(finalNodesMap.values());
    const mergedEdges = Array.from(finalEdgesSet).map(edgeKey => {
        const [from, to, relationship] = edgeKey.split('|');
        return { from, to, relationship };
    });

    console.log(`[KG Service Merge] Merged into ${mergedNodes.length} nodes and ${mergedEdges.length} edges.`);
    return { nodes: mergedNodes, edges: mergedEdges };
}

async function generateAndStoreKg(chunksForKg, userId, originalName, llmProvider, ollamaModel) {
    const logPrefix = `[KG Service Doc: ${originalName}, User: ${userId}]`;
    console.log(`${logPrefix} Starting KG generation with ${chunksForKg.length} initial chunks.`);

    if (!chunksForKg || chunksForKg.length === 0) {
        console.warn(`${logPrefix} No chunks provided for KG generation.`);
        return { success: true, message: "No chunks to process for KG.", finalKgNodesCount: 0, finalKgEdgesCount: 0 };
    }

    const allGraphFragments = [];
    const BATCH_SIZE = parseInt(process.env.KG_GENERATION_BATCH_SIZE) || 25;
    console.log(`${logPrefix} Using batch size: ${BATCH_SIZE}`);
    let batchIndex = 0;

    for (let i = 0; i < chunksForKg.length; i += BATCH_SIZE) {
        batchIndex++;
        const currentBatchOfChunks = chunksForKg.slice(i, i + BATCH_SIZE);
        
        const validChunksInBatch = currentBatchOfChunks.filter(chunk => chunk && chunk.text_content && chunk.text_content.trim() !== '');
        if (validChunksInBatch.length === 0) {
            console.log(`${logPrefix} Batch ${batchIndex} has no valid chunks with text. Skipping.`);
            continue;
        }
        
        console.log(`${logPrefix} Processing batch ${batchIndex} (chunks ${i} to ${Math.min(i + BATCH_SIZE - 1, chunksForKg.length - 1)}), ${validChunksInBatch.length} valid chunks.`);
        
        const fragmentsFromBatch = await _processBatchOfChunksForKg(validChunksInBatch, batchIndex, llmProvider, ollamaModel);
        if (fragmentsFromBatch && fragmentsFromBatch.length > 0) {
            allGraphFragments.push(...fragmentsFromBatch);
        } else {
            console.warn(`${logPrefix} Batch ${batchIndex} yielded no valid graph fragments.`);
        }
    }

    if (allGraphFragments.length === 0) {
        console.warn(`${logPrefix} No valid graph fragments were generated from any batch.`);
        return { success: true, message: "No KG data extracted from any document chunks.", finalKgNodesCount: 0, finalKgEdgesCount: 0 };
    }

    console.log(`${logPrefix} Generated a total of ${allGraphFragments.length} raw graph fragments. Merging...`);
    const finalKg = _mergeGraphFragments(allGraphFragments);
    
    if (!finalKg || finalKg.nodes.length === 0) {
        console.warn(`${logPrefix} Merged KG has no nodes. Nothing to store.`);
         return { success: true, message: "Merged KG was empty after processing all fragments.", finalKgNodesCount: 0, finalKgEdgesCount: 0 };
    }
    console.log(`${logPrefix} Merged KG successfully. Nodes: ${finalKg.nodes.length}, Edges: ${finalKg.edges.length}.`);

    const baseRagUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!baseRagUrl) {
        return { success: false, message: "KG generated, but Python Service URL is not configured. KG not stored." };
    }
    const kgIngestionApiUrl = `${baseRagUrl.replace(/\/$/, '')}/kg`;

    console.log(`${logPrefix} Sending final merged KG to Ingestion API: ${kgIngestionApiUrl}`);
    try {
        const payload = {
            userId: userId,
            originalName: originalName,
            nodes: finalKg.nodes,
            edges: finalKg.edges
        };

        const serviceResponse = await axios.post(kgIngestionApiUrl, payload, {
            timeout: 300000
        });

        const responseData = serviceResponse.data;
        const API_SUCCESS_STATUS_VALUE = "completed";

        if (serviceResponse.status >= 200 && serviceResponse.status < 300 && responseData && responseData.status === API_SUCCESS_STATUS_VALUE) {
            const successMessage = `KG for '${originalName}' successfully processed by Ingestion API.`;
            console.log(`${logPrefix} ${successMessage}`);
            return {
                success: true, message: successMessage,
                finalKgNodesCount: finalKg.nodes.length, finalKgEdgesCount: finalKg.edges.length
            };
        } else {
            const failureMessage = `KG Ingestion API for '${originalName}' indicated failure. API Msg: ${responseData?.message || responseData?.error || 'No specific error from API.'}`;
            console.warn(`${logPrefix} ${failureMessage}`);
            return {
                success: false, message: failureMessage,
                finalKgNodesCount: finalKg.nodes.length, finalKgEdgesCount: finalKg.edges.length
            };
        }
    } catch (error) {
        const errorMsg = error.response?.data?.message || error.response?.data?.error || error.message || "Unknown error calling KG Ingestion API";
        console.error(`${logPrefix} Error calling KG Ingestion API:`, errorMsg);
        return {
            success: false, message: `KG generated, but error calling KG Ingestion API: ${errorMsg}`,
            finalKgNodesCount: finalKg.nodes.length, finalKgEdgesCount: finalKg.edges.length
        };
    }
}

module.exports = { generateAndStoreKg };
```

`server/services/learning/curriculumOrchestrator.js`

```javascript
// server/services/learning/curriculumOrchestrator.js
const LearningPath = require('../../models/LearningPath');
const User = require('../../models/User');
const geminiService = require('../geminiService');
const ollamaService = require('../ollamaService');
const { decrypt } = require('../../utils/crypto');
const { queryPythonRagService } = require('../toolExecutionService');


const GOAL_ANALYSIS_PROMPT = `You are an expert curriculum designer. Your first task is to analyze a user's learning goal to determine if it's specific enough to build a detailed plan, or if it's too broad and requires clarification.

**User's Goal:** "{goal}"

**Instructions:**
Analyze the goal and return a single JSON object with one key, "isSpecific".
- If the goal is specific and actionable (e.g., "learn python decorators", "prepare for my networking exam on the OSI model"), set "isSpecific" to true.
- If the goal is broad and requires more user input to create a meaningful plan (e.g., "learn programming", "get better at math", "learn full stack development"), set "isSpecific" to false.

Your output MUST be ONLY the JSON object.
Example for a specific goal: { "isSpecific": true }
Example for a broad goal: { "isSpecific": false }
`;

const CLARIFICATION_QUESTIONS_PROMPT = `You are an expert curriculum designer. A user has stated a broad learning goal: "{goal}". To create a personalized and effective study plan, you need to ask them a few clarifying questions.

**Instructions:**
1. Generate 2-3 essential multiple-choice or short-answer questions to narrow down the user's goal.
2. The questions should help you understand their preferred technologies, current skill level, and specific interests within the broad topic.
3. Your entire output MUST be a single, valid JSON object with one key, "questions".
4. The "questions" key must hold an array of question objects. Each object must have:
   - "questionText": The question to ask the user.
   - "type": Either "multiple_choice" or "text_input".
   - "options" (for multiple_choice only): An array of strings representing the choices.

**Example JSON Output for "Learn Full Stack Development":**
{
  "questions": [
    {
      "questionText": "Great goal! To start, which technology stack interests you most?",
      "type": "multiple_choice",
      "options": ["MERN Stack (React, Node.js)", "MEAN Stack (Angular, Node.js)", "Something else"]
    },
    {
      "questionText": "What is your current comfort level with frontend development?",
      "type": "multiple_choice",
      "options": ["Complete beginner", "I know some HTML/CSS", "I have experience with a framework"]
    }
  ]
}
`;

const PLAN_GENERATION_PROMPT = `You are a world-class AI academic advisor and curriculum designer for a prestigious university. Your task is to create a detailed, comprehensive, and actionable learning path for a student.

**CONTEXT:**
- **User Profile:**
  - **Level:** {degreeType}, {year}
  - **Field:** {branch}
  - **Preferred Learning Style:** {learningStyle}
  - **Identified Weaknesses:** {knowledgeGaps}
- **User's Ultimate Goal:** "{goal}"

**CRITICAL INSTRUCTIONS:**
1.  **ADAPT PLAN SCALE:** Analyze the user's goal.
    -   If the goal is **broad and long-term** (e.g., "learn full stack development", "master machine learning"), you MUST generate a comprehensive curriculum with **10-15 modules**, broken into logical phases (e.g., "Phase 1: Frontend Fundamentals").
    -   If the goal is **specific and short-term** (e.g., "understand python decorators", "learn how TCP works"), you MUST generate a concise, focused plan of **3-5 modules** that directly addresses the concept.
2.  **MODULE DESIGN:** Each module must be a clear, actionable step. For each module, provide:
    -   A "title" that is specific and descriptive.
    -   A brief "objective" explaining the learning outcome for that module.
    -   An "activity" object containing:
        -   "type": The best tool for the task. Your default choice should be 'direct_answer' (approx. 80% of the time). Use 'web_search' for very modern topics, libraries, or practical tutorials. Use 'academic_search' only for deep, theoretical concepts. Use 'code_executor' for hands-on programming tasks. **DO NOT generate a 'document_review' type.**
        -   "suggestedPrompt": A clear, effective prompt the user can send to the AI to begin the activity. This prompt should be a complete instruction.
3.  **LOGICAL STRUCTURE:** The sequence of modules MUST be pedagogically sound. Start with fundamentals and build complexity. Prioritize modules that address the user's "Identified Weaknesses".

**OUTPUT FORMAT (ABSOLUTELY STRICT):**
-   Your entire output must be a single, valid JSON object.
-   The root object must have one key: "modules".
-   "modules" must be an array of module objects as described above.
-   Do NOT include any extra text, markdown, or explanations outside of the JSON structure.

**EXAMPLE FOR A BROAD GOAL ("Learn MERN Stack"):**
{
  "modules": [
    {
      "title": "Phase 1: Frontend Fundamentals - Module 1: JavaScript ES6+ Core Concepts",
      "objective": "Master the modern JavaScript features essential for React development.",
      "activity": { "type": "direct_answer", "suggestedPrompt": "Explain the following ES6+ JavaScript concepts with code examples: let/const, arrow functions, destructuring, and modules." }
    },
    {
      "title": "Phase 1: Frontend Fundamentals - Module 2: Introduction to React & JSX",
      "objective": "Understand the core concepts of React, components, and JSX syntax.",
      "activity": { "type": "direct_answer", "suggestedPrompt": "What is React and JSX? Provide a simple 'Hello World' example of a React component." }
    },
    {
      "title": "Phase 2: Backend Development - Module 1: Building a Basic Express Server",
      "objective": "Learn to create a simple web server using Node.js and Express.",
      "activity": { "type": "code_executor", "suggestedPrompt": "Guide me step-by-step in building a basic 'Hello World' server with Node.js and Express that listens on port 3000." }
    }
  ]
}`;


/**
 * The intelligent "brain" of the feature. Generates a personalized learning plan.
 * @param {string} goal - The user's learning goal.
 * @param {object} user - The full user object from MongoDB.
 * @returns {Promise<Array>} A promise that resolves to an array of module objects.
 */
async function generateModulesForGoal(goal, user, context) {
    console.log(`[CurriculumOrchestrator] Generating ADVANCED modules for goal: "${goal}"`);

    const { profile, preferredLlmProvider, ollamaUrl, ollamaModel, encryptedApiKey } = user;
    const knowledgeGaps = profile.performanceMetrics && profile.performanceMetrics.size > 0 
        ? Array.from(profile.performanceMetrics.keys()).join(', ') 
        : "None identified yet.";

    const prompt = PLAN_GENERATION_PROMPT
        .replace('{degreeType}', profile.degreeType || 'N/A')
        .replace('{year}', profile.year || 'N/A')
        .replace('{branch}', profile.branch || 'N/A')
        .replace('{learningStyle}', profile.learningStyle || 'N/A')
        .replace('{knowledgeGaps}', knowledgeGaps)
        .replace('{goal}', goal);

    const llmService = preferredLlmProvider === 'ollama' ? ollamaService : geminiService;
    const apiKey = encryptedApiKey ? decrypt(encryptedApiKey) : null;

    if (preferredLlmProvider === 'gemini' && !apiKey) {
        throw new Error("Cannot generate plan: User has selected Gemini but has no API key configured.");
    }

    const llmOptions = { apiKey, ollamaUrl, model: ollamaModel, temperature: 0.5 };
    const responseText = await llmService.generateContentWithHistory([], prompt, null, llmOptions);
    
    // Find and parse the JSON object from the response
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
        console.error("LLM did not return a valid JSON object. Response:", responseText);
        throw new Error("The AI failed to generate a structured learning plan. Please try rephrasing your goal.");
    }
    const jsonString = jsonMatch[0];
    const result = JSON.parse(jsonString);

    if (!result.modules || !Array.isArray(result.modules)) {
        throw new Error("LLM returned an invalid format for the learning plan's modules.");
    }
    
    // ** The flawed RAG search post-processing step has been REMOVED **

    // Set initial status for the modules
    if (result.modules.length > 0) {
        result.modules[0].status = 'not_started';
        for (let i = 1; i < result.modules.length; i++) {
            result.modules[i].status = 'locked';
        }
    }

    return result.modules;
}


/**
 * Main orchestrator function. Creates and saves a new learning path OR returns clarification questions.
 * @param {string} userId - The ID of the user.
 * @param {string} goal - The user's stated learning goal.
 * @param {object} [context] - Optional context, including answers to clarification questions.
 * @returns {Promise<Object>} Either the newly created LearningPath document or a questionnaire object.
 */
async function createLearningPath(userId, goal, context = {}) {
    if (!userId || !goal) {
        throw new Error("User ID and a learning goal are required.");
    }

    const user = await User.findById(userId).select(
        'profile preferredLlmProvider ollamaUrl ollamaModel +encryptedApiKey'
    );
    if (!user) {
        throw new Error("User not found.");
    }

    const { preferredLlmProvider, ollamaUrl, ollamaModel, encryptedApiKey } = user;
    const llmService = preferredLlmProvider === 'ollama' ? ollamaService : geminiService;
    const apiKey = encryptedApiKey ? decrypt(encryptedApiKey) : null;

    if (preferredLlmProvider === 'gemini' && !apiKey) {
        throw new Error("Cannot process plan: User has selected Gemini but has no API key.");
    }
    const llmOptions = { apiKey, ollamaUrl, model: ollamaModel, temperature: 0.3 };

    // --- RESTRUCTURED LOGIC ---

    // SCENARIO 1: The frontend has provided answers, so we must generate the final plan.
    if (context && context.clarificationAnswers) {
        console.log(`[CurriculumOrchestrator] Received clarification answers. Generating final plan.`);
        const refinedGoal = `${goal} - Specifics: ${JSON.stringify(context.clarificationAnswers)}`;
        const modules = await generateModulesForGoal(refinedGoal, user, context);

        if (!modules || modules.length === 0) {
            throw new Error("The curriculum orchestrator failed to generate any modules for this goal.");
        }

        const newLearningPath = new LearningPath({ userId, title: goal, modules });
        await newLearningPath.save();
        
        await User.updateOne({ _id: userId }, { $push: { learningPaths: newLearningPath._id } });

        console.log(`[CurriculumOrchestrator] Saved new intelligent learning path "${goal}" for user ${userId}.`);
        return newLearningPath;
    }

    // SCENARIO 2: This is the initial request. Analyze the goal's specificity.
    console.log(`[CurriculumOrchestrator] Analyzing initial goal for specificity: "${goal}"`);
    const analysisPrompt = GOAL_ANALYSIS_PROMPT.replace('{goal}', goal);
    const analysisResponseText = await llmService.generateContentWithHistory([], analysisPrompt, null, llmOptions);
    const analysisResult = JSON.parse(analysisResponseText.match(/\{[\s\S]*\}/)[0]);

    if (analysisResult.isSpecific === false) {
        // Goal is broad, generate and return the questionnaire.
        console.log(`[CurriculumOrchestrator] Goal is broad. Generating clarification questions.`);
        const questionsPrompt = CLARIFICATION_QUESTIONS_PROMPT.replace('{goal}', goal);
        const questionsResponseText = await llmService.generateContentWithHistory([], questionsPrompt, null, llmOptions);
        const questionsResult = JSON.parse(questionsResponseText.match(/\{[\s\S]*\}/)[0]);
        return { isQuestionnaire: true, ...questionsResult };
    } else {
        // Goal is specific, generate the plan directly.
        console.log(`[CurriculumOrchestrator] Goal is specific. Proceeding to generate modules directly.`);
        const modules = await generateModulesForGoal(goal, user, context);
        
        if (!modules || modules.length === 0) {
            throw new Error("The curriculum orchestrator failed to generate any modules for this goal.");
        }
        
        const newLearningPath = new LearningPath({ userId, title: goal, modules });
        await newLearningPath.save();
        
        await User.updateOne({ _id: userId }, { $push: { learningPaths: newLearningPath._id } });

        console.log(`[CurriculumOrchestrator] Saved new intelligent learning path "${goal}" for user ${userId}.`);
        return newLearningPath;
    }
}


module.exports = {
    createLearningPath,
};
```

`server/services/ollamaService.js`

```javascript
//ollama service

// server/services/ollamaService.js
const axios = require('axios');

const SERVER_DEFAULT_OLLAMA_URL = process.env.OLLAMA_API_BASE_URL || 'https://angels-himself-fixtures-unknown.trycloudflare.com';
const DEFAULT_OLLAMA_MODEL = process.env.OLLAMA_DEFAULT_MODEL || 'qwen2.5:14b-instruct';

const DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_CHAT = 29000;
const DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_KG = 29000;

// This function formats history for the /api/chat endpoint
function formatHistoryForOllamaChat(chatHistory) {
    return chatHistory.map(msg => ({
        role: msg.role === 'model' ? 'assistant' : 'user',
        content: msg.parts?.[0]?.text || ''
    }));
}

async function generateContentWithHistory(
    chatHistory,
    currentUserQuery,
    systemPromptText = null,
    options = {}
) {
    const baseUrlToUse = options.ollamaUrl || SERVER_DEFAULT_OLLAMA_URL;
    const modelToUse = options.model || DEFAULT_OLLAMA_MODEL;
    const effectiveMaxOutputTokens = options.maxOutputTokens || DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_CHAT;
    
    const headers = { 'Content-Type': 'application/json' };
    if (options.apiKey) {
        headers['Authorization'] = `Bearer ${options.apiKey}`;
    }

    // --- THIS IS THE FIX ---
    // Decide which endpoint to use based on whether there's a real history.
    // Our Router call sends an empty history, so it will use /api/generate.
    // Real chat calls will have history and use /api/chat.
    let endpoint;
    let requestPayload;

    if (!chatHistory || chatHistory.length === 0) {
        // Use /api/generate for one-shot requests like the Router agent
        endpoint = `${baseUrlToUse}/api/generate`;
        console.log(`Ollama Service: Using /api/generate endpoint for one-shot request.`);
        requestPayload = {
            model: modelToUse,
            prompt: currentUserQuery, // The user query is the full prompt
            system: systemPromptText || "You are a helpful AI assistant.",
            stream: false,
            options: {
                temperature: options.temperature || 0.7,
                num_predict: effectiveMaxOutputTokens,
            }
        };
    } else {
        // Use /api/chat for actual conversations with history
        endpoint = `${baseUrlToUse}/api/chat`;
        console.log(`Ollama Service: Using /api/chat endpoint for conversation with history.`);
        const messages = formatHistoryForOllamaChat(chatHistory);
        messages.push({ role: 'user', content: currentUserQuery }); // Add the current query
        
        requestPayload = {
            model: modelToUse,
            messages: messages,
            stream: false,
            options: {
                temperature: options.temperature || 0.7,
                // num_predict is often not needed for /chat, but can be included
            }
        };
        // For /chat, the system prompt is part of the messages array if needed
        if (systemPromptText) {
             messages.unshift({ role: 'system', content: systemPromptText });
        }
    }
    // --- END OF FIX ---

    console.log(`Ollama Service: Sending request to ${endpoint} for model ${modelToUse}.`);

    console.log("\n==================== START OLLAMA FINAL INPUT ====================");
    console.log(`--- Endpoint: ${endpoint} ---`);
    console.log("--- Request Payload Sent to Model ---");
    console.log(JSON.stringify(requestPayload, null, 2));
    console.log("==================== END OLLAMA FINAL INPUT ====================\n");

    
    try {
        const response = await axios.post(endpoint, requestPayload, { 
            headers,
            timeout: 120000 
        });

        // Handle different response structures from /generate and /chat
        let responseText = '';
        if (response.data && response.data.response) { // from /api/generate
            responseText = response.data.response;
        } else if (response.data && response.data.message && response.data.message.content) { // from /api/chat
            responseText = response.data.message.content;
        } else {
            throw new Error("Ollama service returned an invalid or unrecognized response structure.");
        }

        return responseText.trim();
        
    } catch (error) {
        console.error("Ollama API Call Error:", error.message);
        const clientMessage = error.response?.data?.error || "Failed to get response from Ollama service.";
        const enhancedError = new Error(clientMessage);
        enhancedError.status = error.response?.status || 503;
        throw enhancedError;
    }
}

module.exports = {
    generateContentWithHistory,
    DEFAULT_OLLAMA_MODEL,
    DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_CHAT,
    DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_KG,
};
```

`server/services/promptCoachService.js`

```javascript
// server/services/promptCoachService.js
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');
const { PROMPT_COACH_TEMPLATE } = require('../config/promptTemplates');
const User = require('../models/User');
const { decrypt } = require('../utils/crypto');

const COACH_GEMINI_MODEL = process.env.PROMPT_COACH_GEMINI_MODEL || 'gemini-1.5-flash-latest';
const COACH_OLLAMA_MODEL = process.env.PROMPT_COACH_OLLAMA_MODEL || 'phi3:mini-instruct';

/**
 * Analyzes a user's prompt using a lightweight, fast LLM based on their preference.
 * @param {string} userId - The ID of the user requesting the analysis.
 * @param {string} userPrompt - The raw prompt text from the user.
 * @returns {Promise<{improvedPrompt: string, explanation: string}>} The analyzed result.
 */
async function analyzePrompt(userId, userPrompt) {
    const user = await User.findById(userId).select('+encryptedApiKey preferredLlmProvider ollamaUrl');
    if (!user) {
        throw new Error("User not found.");
    }

    const { preferredLlmProvider, ollamaUrl } = user;
    const promptForLlm = PROMPT_COACH_TEMPLATE.replace('{userPrompt}', userPrompt);
    
    let responseText;
    let llmOptions = {};

    console.log(`[PromptCoachService] Analyzing prompt for user ${userId} using preferred provider: ${preferredLlmProvider}`);

    try {
        if (preferredLlmProvider === 'ollama') {
            llmOptions = {
                model: COACH_OLLAMA_MODEL,
                ollamaUrl: ollamaUrl
            };
            responseText = await ollamaService.generateContentWithHistory([], promptForLlm, null, llmOptions);
        } else { // Default to Gemini
            const apiKey = user.encryptedApiKey ? decrypt(user.encryptedApiKey) : null;
            if (!apiKey) {
                throw new Error("User has selected Gemini but has no API key configured.");
            }
            llmOptions = {
                model: COACH_GEMINI_MODEL, // This is specific to Gemini, not needed in options object
                apiKey: apiKey
            };
            // Note: The geminiService itself will use the correct model name.
            responseText = await geminiService.generateContentWithHistory([], promptForLlm, null, llmOptions);
        }

        // --- JSON Parsing Logic ---
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error("AI response did not contain a valid JSON object.");
        }
        const jsonString = jsonMatch[0];
        const parsedResponse = JSON.parse(jsonString);

        if (!parsedResponse.improvedPrompt || !parsedResponse.explanation) {
            throw new Error("AI response JSON is missing required 'improvedPrompt' or 'explanation' keys.");
        }

        return parsedResponse;

    } catch (error) {
        console.error(`[PromptCoachService] Error during prompt analysis: ${error.message}`);
        // Re-throw a user-friendly error
        throw new Error(`The AI Coach failed to analyze the prompt. ${error.message}`);
    }
}

module.exports = {
    analyzePrompt
};
```

`server/services/ragQueryService.js`

```javascript
// server/services/ragQueryService.js
const axios = require('axios');

async function queryPythonRagService(
    query, documentContextNameToPass, criticalThinkingEnabled, clientFilter = null, k = 5
) {
    // ... (function logic is identical) ...
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        console.error("PYTHON_RAG_SERVICE_URL is not set. RAG features disabled for this request.");
        return { references: [], toolOutput: "RAG service is not configured on the server." };
    }
    const searchUrl = `${pythonServiceUrl}/query`;
    console.log(`[ragQueryService] Querying Python RAG: Query="${query.substring(0, 50)}...", DocContext=${documentContextNameToPass}`);

    const payload = {
        query: query,
        k: k,
        user_id: "agent_user",
        use_kg_critical_thinking: !!criticalThinkingEnabled,
        documentContextName: documentContextNameToPass || null
    };
    if (clientFilter && typeof clientFilter === 'object' && Object.keys(clientFilter).length > 0) {
        payload.filter = clientFilter;
    }

    try {
        const response = await axios.post(searchUrl, payload, {
            headers: { 'Content-Type': 'application/json' },
            timeout: process.env.PYTHON_RAG_TIMEOUT || 30000
        });

        const relevantDocs = response.data?.retrieved_documents_list || [];
        const references = relevantDocs.map((doc, index) => ({
            number: index + 1,
            source: doc.metadata?.file_name || doc.metadata?.original_name || 'Unknown Document',
            content_preview: (doc.page_content || "").substring(0, 100) + "...",
        }));
        
        const toolOutput = relevantDocs.length > 0
            ? response.data.formatted_context_snippet
            : "No relevant context was found in the specified documents for this query.";

        return { references, toolOutput };

    } catch (error) {
        let errorMsg = error.message;
        if (error.response?.data?.error) errorMsg = `Python Service Error: ${error.response.data.error}`;
        else if (error.code === 'ECONNABORTED') errorMsg = 'Python RAG service request timed out.';
        console.error(`[ragQueryService] Error calling Python RAG service at ${searchUrl}:`, errorMsg);
        throw new Error(errorMsg);
    }
}

module.exports = {
    queryPythonRagService,
};
```

`server/services/sessionAnalysisService.js`

```javascript
// server/services/sessionAnalysisService.js
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');

const SUMMARY_GAPS_PROMPT = `You are an expert educational analyst. Your task is to analyze the provided chat transcript and perform three actions. Your entire output MUST be a single, valid JSON object with NO other text before or after it.

The JSON object MUST have three keys:
1.  "summary": A string containing an updated, cumulative summary of the conversation. Incorporate the "Existing Summary" with insights from the "New Messages".
2.  "keyTopics": An array of strings listing the 3-4 most important topics discussed in the conversation (e.g., ["Python Decorators", "Machine Learning Applications"]). This must be generated regardless of user proficiency.
3.  "knowledgeGaps": An array of objects, each with "topic" (string) and "proficiencyScore" (a number from 0.0 to 1.0).

**CRITICAL INSTRUCTIONS FOR "knowledgeGaps":**
- A knowledge gap exists if the user **explicitly states confusion** (e.g., "I have a gap in X", "I don't understand Y"), even if you provided a good explanation later.
- A knowledge gap exists if the user asks **multiple, basic clarifying questions** about the same foundational topic.
- Assign a **low proficiencyScore (e.g., 0.3 - 0.5)** to any topic where the user stated a "huge gap" or significant confusion at the start.
- Only include topics where the user's proficiency appears to be below 0.8 by the end of the conversation. If they seem to understand everything perfectly, this array should be empty.

Example Output:
{
  "summary": "The user stated a significant gap in their understanding of the Software Development Life Cycle (SDLC) and Separation of Concerns (SoC). A detailed explanation of SoC was provided, covering its goals and analogies.",
  "keyTopics": ["Separation of Concerns (SoC)", "Software Design Principles", "System Complexity Management"],
  "knowledgeGaps": [
    {
      "topic": "Separation of Concerns (SoC)",
      "proficiencyScore": 0.4
    }
  ]
}`;



// --- NEW, FOCUSED PROMPT 2: For Recommendations ---
const RECOMMENDATIONS_PROMPT = `You are an expert academic advisor. Based on the provided list of topics from a recent study session, your task is to generate 3 strategic "next step" recommendations. Your entire output MUST be a single, valid JSON object with ONE key, "recommendations", containing an array of objects.

For each topic, suggest a logical follow-up action.
- Suggest 'direct_answer' for a related, more advanced concept.
- Suggest 'web_search' for practical applications or recent news.
- Suggest 'academic_search' for deeper, theoretical research.

Each recommendation object MUST have these keys:
- "topic": The string for the NEW recommended topic.
- "actionType": A string, must be one of 'web_search', 'academic_search', or 'direct_answer'.
- "suggestion_text": A string containing a brief, encouraging sentence explaining what the user will learn next.

Example Input Topics: ["Machine Learning Definition", "Real-world AI Applications"]
Example Output:
{
  "recommendations": [
    {
      "topic": "Supervised vs. Unsupervised Learning",
      "actionType": "direct_answer",
      "suggestion_text": "Now that you know what ML is, let's explore its main learning paradigms."
    },
    {
      "topic": "AI in Healthcare",
      "actionType": "web_search",
      "suggestion_text": "Discover how the applications we discussed are being used in the medical field today."
    },
    {
      "topic": "Neural Network Architectures",
      "actionType": "academic_search",
      "suggestion_text": "Dive deeper into the technical foundations of modern AI by exploring research papers."
    }
  ]
}`;



/**
 * STEP A: Gets the summary and knowledge gaps from a transcript.
 */
async function getSummaryAndGaps(transcript, existingSummary, llmProvider, ollamaModel, userApiKey, userOllamaUrl) {
    // Add keyTopics to the default response for safety.
    const defaultResponse = { summary: existingSummary || "", knowledgeGaps: [], keyTopics: [] };
    const userPrompt = `Existing Summary:\n"""\n${existingSummary || "None"}\n"""\n\nNew Messages:\n"""\n${transcript}\n"""\n\nPlease provide your analysis in the required JSON format.`;
    
    console.log(`[SessionAnalysisService] Requesting summary, gaps, and key topics using ${llmProvider}.`);
    
    try {
        const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;
        const llmOptions = { apiKey: userApiKey, ollamaUrl: userOllamaUrl, model: ollamaModel, temperature: 0.2 };
        const responseText = await llmService.generateContentWithHistory([], userPrompt, SUMMARY_GAPS_PROMPT, llmOptions);

        // Find and parse the JSON block from the LLM's response.
        const jsonMatch = responseText.match(/```(json)?\s*([\s\S]+?)\s*```/);
        const jsonString = jsonMatch ? jsonMatch[2].trim() : responseText.trim();
        const result = JSON.parse(jsonString);

        // Safely extract each piece of data, providing fallbacks.
        const finalSummary = result.summary || existingSummary || "";
        const knowledgeGaps = (result.knowledgeGaps && Array.isArray(result.knowledgeGaps)) ? result.knowledgeGaps : [];
        const keyTopics = (result.keyTopics && Array.isArray(result.keyTopics)) ? result.keyTopics : [];
        
        console.log(`[SessionAnalysisService] Analysis successful. Found ${knowledgeGaps.length} gaps and ${keyTopics.length} key topics.`);
        
        // Return all three pieces of data in the final object.
        return { summary: finalSummary, knowledgeGaps, keyTopics };
        
    } catch (error) {
        console.error(`[SessionAnalysisService] Error during summary/gap/topic analysis: ${error.message}`);
        return defaultResponse; // Return a safe default on any error.
    }
}

/**
 * STEP B: Gets recommendations based on knowledge gaps.
 */
async function generateRecommendations(knowledgeGaps, llmProvider, ollamaModel, userApiKey, userOllamaUrl) {
    if (!knowledgeGaps || knowledgeGaps.length === 0) {
        return []; // No gaps, no recommendations needed.
    }
    
    const userPrompt = `Knowledge Gaps Identified:\n${JSON.stringify(knowledgeGaps, null, 2)}\n\nPlease provide your recommendations in the required JSON format.`;
    console.log(`[SessionAnalysisService] Requesting recommendations for ${knowledgeGaps.length} knowledge gaps.`);

    try {
        const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;
        const llmOptions = { apiKey: userApiKey, ollamaUrl: userOllamaUrl, model: ollamaModel, temperature: 0.5 };
        const responseText = await llmService.generateContentWithHistory([], userPrompt, RECOMMENDATIONS_PROMPT, llmOptions);

        const jsonMatch = responseText.match(/```(json)?\s*([\s\S]+?)\s*```/);
        const jsonString = jsonMatch ? jsonMatch[2].trim() : responseText.trim();
        const result = JSON.parse(jsonString);

        const recommendations = (result.recommendations && Array.isArray(result.recommendations)) ? result.recommendations.slice(0, 3) : [];
        console.log(`[SessionAnalysisService] Recommendation generation successful. Generated ${recommendations.length} recommendations.`);
        return recommendations;
    } catch (error) {
        console.error(`[SessionAnalysisService] Error during recommendation generation: ${error.message}`);
        return []; // Return empty array on error
    }
}

/**
 * Orchestrates the full analysis pipeline.
 * @returns {Promise<{summary: string, knowledgeGaps: Map<string, number>, recommendations: Array<Object>}>}
 */
async function analyzeAndRecommend(messagesToSummarize, existingSummary, llmProvider, ollamaModel, userApiKey, userOllamaUrl) {
    const defaultResponse = { summary: existingSummary || "", knowledgeGaps: new Map(), recommendations: [] };
    if (!messagesToSummarize || messagesToSummarize.length < 2) {
        return defaultResponse;
    }
    
    const transcript = messagesToSummarize.map(msg => `${msg.role === 'model' ? 'Tutor' : 'Student'}: ${msg.parts?.[0]?.text || ''}`).join('\n---\n');

    // Step A: Get Summary, Gaps, and NOW Key Topics
    const { summary, knowledgeGaps, keyTopics } = await getSummaryAndGaps(transcript, existingSummary, llmProvider, ollamaModel, userApiKey, userOllamaUrl);

    // Step B: Generate Recommendations FROM THE KEY TOPICS
    // We now pass keyTopics to the recommendation generator instead of knowledgeGaps
    const recommendations = await generateRecommendations(keyTopics, llmProvider, ollamaModel, userApiKey, userOllamaUrl);
    
    // ... (rest of the function converting knowledgeGaps to a Map remains the same)
    const knowledgeGapsMap = new Map();
    if (knowledgeGaps) {
        knowledgeGaps.forEach(item => {
            if (typeof item.topic === 'string' && typeof item.proficiencyScore === 'number') {
                knowledgeGapsMap.set(item.topic, item.proficiencyScore);
            }
        });
    }

        return { summary, knowledgeGaps: knowledgeGapsMap, recommendations, keyTopics };}


module.exports = { analyzeAndRecommend }; 
```

`server/services/toolExecutionService.js`

```javascript
// server/services/toolExecutionService.js
const axios = require('axios');

const PYTHON_SERVICE_URL = process.env.PYTHON_RAG_SERVICE_URL;

async function queryPythonRagService(query, documentContextName, clientFilter = null, k = 5) {
    if (!PYTHON_SERVICE_URL) {
        throw new Error("RAG service is not configured on the server.");
    }
    const searchUrl = `${PYTHON_SERVICE_URL}/query`;
    
    const payload = {
        query: query,
        k: k,
        user_id: "agent_user", // The user is validated in Node.js; agent uses a generic ID for Python
        documentContextName: documentContextName || null,
        // CRITICAL FIX: Ensure filter is always an object, even if empty.
        // The Python service expects the key to exist.
        filter: clientFilter || {} 
    };

    try {
        const response = await axios.post(searchUrl, payload, {
            headers: { 'Content-Type': 'application/json' },
            timeout: process.env.PYTHON_RAG_TIMEOUT || 30000
        });
        
        const relevantDocs = response.data?.retrieved_documents_list || [];
        
        const references = relevantDocs.map((doc, index) => ({
            number: index + 1,
            source: doc.metadata?.file_name || doc.metadata?.original_name || 'Unknown Document',
            content_preview: (doc.page_content || "").substring(0, 150) + "...",
        }));
        
        const toolOutput = relevantDocs.length > 0
            ? response.data.formatted_context_snippet
            : "No relevant documents were found for this topic."; // More specific message
        
        return { references, toolOutput, retrieved_documents_list: relevantDocs }; // Pass full list back

    } catch (error) {
        let errorMsg = error.message;
        if (error.response?.data?.error) errorMsg = `Python Service Error: ${error.response.data.error}`;
        else if (error.code === 'ECONNABORTED') errorMsg = 'Python RAG service request timed out.';
        console.error(`[toolExecutionService] Error calling Python RAG service at ${searchUrl}:`, errorMsg);
        throw new Error(errorMsg);
    }
}


async function queryKgService(query, documentName, userId) {
    if (!PYTHON_SERVICE_URL) {
        throw new Error("Knowledge Graph service is not configured on the server.");
    }
    // Assuming the Python endpoint for KG search is /query_kg
    const kgUrl = `${PYTHON_SERVICE_URL}/query_kg`; 
    try {
        const response = await axios.post(kgUrl, {
            query: query,
            document_name: documentName,
            user_id: userId,
        }, { timeout: 20000 });

        return {
            references: [], // KG search doesn't produce citable references in the same way
            toolOutput: response.data?.facts || "No specific facts were found in the knowledge graph for this query."
        };
    } catch (error) {
        const errorMsg = error.response?.data?.error || `KG Service Error: ${error.message}`;
        console.error(`[toolExecutionService] Error calling KG service:`, errorMsg);
        // Return a user-friendly message within the tool's output
        return {
            references: [],
            toolOutput: `Could not retrieve facts from knowledge graph: ${errorMsg}`
        };
    }
}

module.exports = {
    queryPythonRagService,
    queryKgService
};
```

`server/services/toolRegistry.js`

```javascript
// server/services/toolRegistry.js
const { performWebSearch } = require('./webSearchService.js');
const { queryPythonRagService, queryKgService } = require('./toolExecutionService.js');
const axios = require('axios');

async function queryAcademicService(query) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        throw new Error("Academic search service is not configured on the server.");
    }
    const searchUrl = `${pythonServiceUrl}/academic_search`;
    
    try {
        console.log(`[toolRegistry] Calling Python academic search at ${searchUrl} for query: "${query}"`);
        const response = await axios.post(searchUrl, { query }, { timeout: 45000 });
        const papers = response.data?.results || [];
        
        const toolOutput = papers.length > 0
            ? "Found the following relevant academic papers:\n\n" + papers.map((p, index) => 
                `[${index + 1}] **${p.title || 'Untitled Paper'}**\n` +
                `   - Source: ${p.source || 'Unknown'}\n` +
                `   - URL: ${p.url || '#'}\n` +
                `   - Summary: ${p.summary ? p.summary.substring(0, 300) + '...' : 'No summary.'}`
              ).join('\n\n')
            : "No relevant academic papers were found for this query.";
            
        const references = papers.map((p, index) => ({
            number: index + 1,
            source: `${p.title || 'Untitled Paper'} (${p.source || 'N/A'})`,
            url: p.url || '#',
        }));

        return { references, toolOutput };

    } catch (error) {
        const errorMsg = error.response?.data?.error || `Academic Service Error: ${error.message}`;
        throw new Error(errorMsg);
    }
}

const availableTools = {
  web_search: {
    description: "Searches the internet for real-time, up-to-date information on current events, public figures, or general knowledge.",
    execute: async (params) => {
        const { toolOutput, references } = await performWebSearch(params.query);
        return { references, toolOutput: toolOutput || "No results found from web search." };
    },
    requiredParams: ['query'],
  },
  rag_search: {
    description: "Searches the content of a specific, user-provided document to answer questions based on its text.",
    execute: async (params, context) => {
        return await queryPythonRagService(params.query, context.documentContextName, context.filter);
    },
    requiredParams: ['query'],
  },
  kg_search: {
    description: "Finds structured facts and relationships within a document's pre-built knowledge graph. Use this to complement RAG search.",
     execute: async (params, context) => {
        const facts = await queryKgService(params.query, context.documentContextName, context.userId);
        return { references: [], toolOutput: facts };
    },
    requiredParams: ['query'],
  },
  academic_search: {
    description: "Finds academic papers, research articles, and scholarly publications from scientific databases.",
    execute: async (params) => {
        return await queryAcademicService(params.query);
    },
    requiredParams: ['query'],
  }
};

module.exports = { availableTools };
```

`server/services/totOrchestrator.js`

```javascript
// server/services/totOrchestrator.js

const { processAgenticRequest } = require('./agentService');
const geminiService = require('./geminiService');
const ollamaService = require('./ollamaService');
const { PLANNER_PROMPT_TEMPLATE, EVALUATOR_PROMPT_TEMPLATE, createSynthesizerPrompt } = require('../config/promptTemplates');

async function isQueryComplex(query) {
    const isComplex = (query.match(/\?/g) || []).length > 1 || query.split(' ').length > 20;
    console.log(`[ToT] Step 1: Complexity Gate. Query: "${query.substring(0, 30)}...". Decision: ${isComplex ? 'COMPLEX' : 'SIMPLE'}`);
    return isComplex;
}

async function generatePlans(query, requestContext) {
    console.log('[ToT] Step 2: Planner. Generating plans via LLM...');
    const { llmProvider, ...llmOptions } = requestContext;
    const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;

    const plannerPrompt = PLANNER_PROMPT_TEMPLATE.replace("{userQuery}", query);

    try {
        const responseText = await llmService.generateContentWithHistory(
            [], plannerPrompt, "You are a planning agent.", llmOptions
        );
        const jsonMatch = responseText.match(/```(json)?\s*([\s\S]+?)\s*```/);
        const jsonString = jsonMatch ? jsonMatch[2] : responseText;
        const parsedResponse = JSON.parse(jsonString);

        if (parsedResponse.plans && Array.isArray(parsedResponse.plans) && parsedResponse.plans.length > 0) {
            parsedResponse.plans.forEach(plan => {
                if (plan.steps && Array.isArray(plan.steps)) {
                    plan.steps = plan.steps.map(step => (typeof step === 'object') ? JSON.stringify(step) : String(step));
                }
            });
            console.log(`[ToT] Planner: Successfully generated and validated ${parsedResponse.plans.length} plans.`);
            return parsedResponse.plans;
        }
    } catch (error) {
        console.error(`[ToT] Planner: LLM call failed or returned invalid JSON. Error: ${error.message}. Falling back to default plan.`);
    }

    return [{
        name: "Default Direct Search Plan",
        steps: [`Directly address the user's query: "${query}"`]
    }];
}

async function evaluatePlans(plans, query, requestContext) {
    console.log('[ToT] Step 3: Evaluator. Evaluating plans via LLM...');
    if (!plans || plans.length === 0) throw new Error("No plans provided to evaluate.");
    if (plans.length === 1) {
        console.log('[ToT] Evaluator: Only one plan available. Selecting it by default.');
        return plans[0];
    }

    const { llmProvider, ...llmOptions } = requestContext;
    const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;
    const plansJsonString = JSON.stringify(plans, null, 2);

    const evaluatorPrompt = EVALUATOR_PROMPT_TEMPLATE.replace("{userQuery}", query).replace("{plansJsonString}", plansJsonString);

    try {
        const responseText = await llmService.generateContentWithHistory(
            [], evaluatorPrompt, "You are an evaluating agent.", llmOptions
        );
        const jsonMatch = responseText.match(/```(json)?\s*([\s\S]+?)\s*```/);
        const jsonString = jsonMatch ? jsonMatch[2] : responseText;
        const parsedResponse = JSON.parse(jsonString);

        if (parsedResponse.best_plan_name) {
            const winningPlan = plans.find(p => p.name === parsedResponse.best_plan_name);
            if (winningPlan) {
                console.log(`[ToT] Evaluator: LLM selected winning plan: "${winningPlan.name}"`);
                return winningPlan;
            }
        }
    } catch (error) {
        console.error(`[ToT] Evaluator: LLM call failed or returned invalid JSON. Error: ${error.message}. Falling back to first plan.`);
    }
    
    console.log(`[ToT] Evaluator: Fallback selected. Winning plan: "${plans[0].name}"`);
    return plans[0];
}


async function executePlan(winningPlan, originalQuery, requestContext, streamCallback) {
    console.log('[ToT] Step 4: Executor. Starting execution of plan...');
    let collectedContexts = [];
    let collectedReferences = [];
    let cumulativeContext = ""; 

    for (let i = 0; i < winningPlan.steps.length; i++) {
        const stepDescription = winningPlan.steps[i];
        
        const systemPromptForStep = `You are one step in a multi-step reasoning plan.
Original User Query: "${originalQuery}"

--- PREVIOUS CONTEXT (Memory from prior steps) ---
${cumulativeContext || "This is the first step, so there is no previous context."}
--- END PREVIOUS CONTEXT ---

Your Specific Sub-Task for THIS step is: "${stepDescription}"

Use the PREVIOUS CONTEXT if it's relevant to complete your sub-task.
`;

        const agentResponse = await processAgenticRequest(
            stepDescription,     
            [],                
            systemPromptForStep,
            requestContext
        );

        const monologue = agentResponse.thinking || `The step was executed, but no detailed thinking was provided.`;
        const thoughtContent = `**Step ${i + 1}/${winningPlan.steps.length}: ${stepDescription}**\n*Thinking:* ${monologue}\n\n`;
        streamCallback({ type: 'thought', content: thoughtContent });
        
        console.log(`[ToT] Executor: Step ${i+1} completed.`);
        
        const stepResult = `--- Context from Step ${i + 1} (${agentResponse.sourcePipeline}) ---\n${agentResponse.finalAnswer}`;
        collectedContexts.push(stepResult);

        cumulativeContext += stepResult + "\n\n";

        if (agentResponse.references && agentResponse.references.length > 0) {
            collectedReferences.push(...agentResponse.references);
        }
    }

    console.log(`[ToT] Step 4: Executor. All steps executed. Collected ${collectedReferences.length} references.`);
    return {
        finalContext: collectedContexts.join('\n\n'),
        allReferences: collectedReferences
    };
}

async function synthesizeFinalAnswer(originalQuery, finalContext, chatHistory, requestContext) {
    console.log('[ToT] Step 5: Synthesizer. Creating final response...');
    const { llmProvider, ...llmOptions } = requestContext;
    const llmService = llmProvider === 'ollama' ? ollamaService : geminiService;

    const synthesizerUserQuery = createSynthesizerPrompt(
        originalQuery, finalContext, 'tree_of_thought_synthesis'
    );

    const finalAnswer = await llmService.generateContentWithHistory(
        chatHistory, synthesizerUserQuery, requestContext.systemPrompt, llmOptions
    );
    return finalAnswer;
}

async function processQueryWithToT_Streaming(query, chatHistory, requestContext, streamCallback) {
    const allThoughts = [];
    const streamAndStoreThought = (content) => {
        streamCallback({ type: 'thought', content });
        allThoughts.push(content);
    };

    const isComplex = await isQueryComplex(query);

    if (!isComplex) {
        // Step 1: Stream the initial classification thought. This gives immediate feedback.
        streamAndStoreThought(`**Analyzing Query**\nQuery classified as straightforward. Bypassing complex planning to generate a direct response.\n\n`);
        
        // Step 2: Get the direct response. This now includes the LLM's own thinking process.
        const directResponse = await processAgenticRequest(
            query,
            chatHistory,
            requestContext.systemPrompt,
            { ...requestContext, forceSimple: true }
        );

        // Step 3: Check for and stream the detailed thinking from the direct answer.
        if (directResponse.thinking) {
            // This is the new, crucial part. We stream the thinking we just received.
            const thinkingHeader = `**Direct Response Plan**\n`;
            streamAndStoreThought(thinkingHeader + directResponse.thinking);
        }

        // Step 4: The final object is now built from all thoughts that were streamed.
        const finalThoughts = allThoughts.join(''); // Join without extra separators, as they are in the content.

        return { 
            finalAnswer: directResponse.finalAnswer, 
            thoughts: finalThoughts, 
            references: directResponse.references, 
            sourcePipeline: directResponse.sourcePipeline 
        };
    }


    streamAndStoreThought("**Starting Complex Reasoning**\nQuery detected as complex. Initiating multi-step Tree of Thought process.\n\n");
    
    const plans = await generatePlans(query, requestContext);
    streamAndStoreThought(`**Planning Stage**\nGenerated ${plans.length} potential plans. Now evaluating the best approach.\n\n`);
    
    const winningPlan = await evaluatePlans(plans, query, requestContext);
    streamAndStoreThought(`**Evaluation Stage**\nBest plan selected: "${winningPlan.name}". Beginning execution.\n\n`);

    const { finalContext, allReferences } = await executePlan(winningPlan, query, requestContext, streamCallback);
    
    streamAndStoreThought("**Synthesizing Final Answer**\nAll information has been gathered. Compiling the final, comprehensive response.\n\n");

    const finalAnswerWithThinking = await synthesizeFinalAnswer(query, finalContext, chatHistory, requestContext);

    const thinkingMatch = finalAnswerWithThinking.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    const thinking = thinkingMatch ? thinkingMatch[1].trim() : null;
    const finalAnswer = thinking ? finalAnswerWithThinking.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim() : finalAnswerWithThinking;

    allThoughts.push(thinking);
    const finalThoughts = allThoughts.filter(Boolean).join('');
    
    console.log('--- ToT Streaming Orchestration Finished ---');
    return {
        finalAnswer,
        thoughts: finalThoughts,
        references: allReferences,
        sourcePipeline: `tot-${requestContext.llmProvider}`
    };
}

module.exports = {
    processQueryWithToT_Streaming
};
```

`server/services/webSearchService.js`

```javascript
// server/services/webSearchService.js
const axios = require('axios');

async function performWebSearch(query) {
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;

    if (!pythonServiceUrl) {
        console.warn("[WebSearch Service] PYTHON_RAG_SERVICE_URL is not set. Web search is disabled.");
        throw new Error("Web search tool is not configured on the server.");
    }

    const searchUrl = `${pythonServiceUrl}/web_search`;

    try {
        console.log(`[WebSearch Service] Calling Python endpoint for search: ${searchUrl}`);
        const response = await axios.post(searchUrl, { query: query }, { timeout: 15000 });

        if (response.data && Array.isArray(response.data) && response.data.length > 0) {
            const topResults = response.data;

            // 1. Create the `references` array for the UI
            const references = topResults.map((result, index) => ({
                number: index + 1,
                source: result.title || 'Untitled Web Page',
                url: result.url || '#',
                content_preview: (result.content || "").substring(0, 150) + "..."
            }));

            // 2. Format the `toolOutput` string for the synthesizer prompt
            const toolOutput = "[WEB SEARCH RESULTS]\n" + topResults.map((result, index) => {
                const title = result.title || 'No Title';
                const url = result.url || '#';
                const content = result.content ? result.content.replace(/[\n\r]+/g, ' ').trim() : 'No content preview.';
                return `[${index + 1}] Title: ${title}\nSource: ${url}\nContent: ${content}`;
            }).join('\n\n');
            
            // 3. Return the object with both properties
            return { toolOutput, references };
            
        } else {
            console.log(`[WebSearch Service] Python service returned no results for query: "${query}"`);
            // Return the correct object structure even on no results
            return { 
                toolOutput: "Web search did not return any results for this query.",
                references: []
            };
        }
    } catch (error) {
        let errorMessage = `Error calling Python service for query "${query}": `;
        if (error.response) {
            errorMessage += `Status ${error.response.status} - ${JSON.stringify(error.response.data)}`;
        } else if (error.request) {
            errorMessage += `No response received from Python service at ${searchUrl}.`;
        } else {
            errorMessage += error.message;
        }
        console.error(errorMessage);
        // Throw the error to be caught by the agent service
        throw new Error(error.message);
    }
}

module.exports = { performWebSearch };
```

`server/utils/assetCleanup.js`

```javascript
const fs = require('fs').promises; // Use fs.promises for async operations
const path = require('path');

// Define constants relative to this file's location (server/utils)
const ASSETS_DIR = path.join(__dirname, '..', 'assets'); // Go up one level to server/assets
const BACKUP_DIR = path.join(__dirname, '..', 'backup_assets'); // Go up one level to server/backup_assets
const FOLDER_TYPES = ['docs', 'images', 'code', 'others']; // Folders within each user's asset dir

/**
 * Moves existing user asset folders (docs, images, code, others) to a timestamped
 * backup location and recreates empty asset folders for each user on server startup.
 */
async function performAssetCleanup() {
    console.log("\n--- Starting Asset Cleanup ---");
    try {
        // Ensure backup base directory exists
        await fs.mkdir(BACKUP_DIR, { recursive: true });

        // List potential user directories in assets
        let userDirs = [];
        try {
            userDirs = await fs.readdir(ASSETS_DIR);
        } catch (err) {
            if (err.code === 'ENOENT') {
                console.log("Assets directory doesn't exist yet, creating it and skipping cleanup.");
                await fs.mkdir(ASSETS_DIR, { recursive: true }); // Ensure assets dir exists
                console.log("--- Finished Asset Cleanup (No existing assets found) ---");
                return; // Nothing to clean up
            }
            throw err; // Re-throw other errors accessing assets dir
        }

        if (userDirs.length === 0) {
             console.log("Assets directory is empty. Skipping backup/move operations.");
             console.log("--- Finished Asset Cleanup (No user assets found) ---");
             return;
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); // Create a safe timestamp string

        for (const userName of userDirs) {
            const userAssetPath = path.join(ASSETS_DIR, userName);
            const userBackupPathBase = path.join(BACKUP_DIR, userName);
            const userTimestampBackupPath = path.join(userBackupPathBase, `backup_${timestamp}`);

            try {
                // Check if the item in assets is actually a directory
                const stats = await fs.stat(userAssetPath);
                if (!stats.isDirectory()) {
                    console.log(`  Skipping non-directory item in assets: ${userName}`);
                    continue;
                }

                console.log(`  Processing assets for user: [${userName}]`);
                let backupDirCreated = false; // Track if backup dir was created for this user/run
                let movedSomething = false; // Track if anything was actually moved

                // Process each defined folder type (docs, images, etc.)
                for (const type of FOLDER_TYPES) {
                    const sourceTypePath = path.join(userAssetPath, type);
                    try {
                        // Check if the source type directory exists before trying to move
                        await fs.access(sourceTypePath);

                        // If source exists, ensure the timestamped backup directory is ready
                        if (!backupDirCreated) {
                            await fs.mkdir(userTimestampBackupPath, { recursive: true });
                            backupDirCreated = true;
                            // console.log(`    Created backup directory: ${userTimestampBackupPath}`);
                        }

                        // Define the destination path in the backup folder
                        const backupTypePath = path.join(userTimestampBackupPath, type);
                        // console.log(`    Moving ${sourceTypePath} to ${backupTypePath}`);
                        // Move the existing type folder to the backup location
                        await fs.rename(sourceTypePath, backupTypePath);
                        movedSomething = true;

                    } catch (accessErr) {
                        // Ignore error if the source directory doesn't exist (ENOENT)
                        if (accessErr.code !== 'ENOENT') {
                            console.error(`    Error accessing source folder ${sourceTypePath}:`, accessErr.message);
                        }
                        // If ENOENT, the folder doesn't exist, nothing to move.
                    }

                    // Always ensure the empty type directory exists in the main assets folder
                    try {
                        // console.log(`    Ensuring empty directory: ${sourceTypePath}`);
                        await fs.mkdir(sourceTypePath, { recursive: true });
                    } catch (mkdirErr) {
                         console.error(`    Failed to recreate directory ${sourceTypePath}:`, mkdirErr.message);
                    }
                } // End loop through FOLDER_TYPES

                 if (movedSomething) {
                     console.log(`  Finished backup for user [${userName}] to backup_${timestamp}`);
                 } else {
                     console.log(`  No existing asset types found to backup for user [${userName}]`);
                 }


            } catch (userDirStatErr) {
                 // Error checking if the item in assets is a directory
                 console.error(`Error processing potential user asset directory ${userAssetPath}:`, userDirStatErr.message);
            }
        } // End loop through userDirs

        console.log("--- Finished Asset Cleanup ---");

    } catch (error) {
        // Catch errors related to backup dir creation or reading the main assets dir
        console.error("!!! Critical Error during Asset Cleanup process:", error);
    }
}

// Export the function to be used elsewhere
module.exports = { performAssetCleanup };

```

`server/utils/crypto.js`

```javascript
// server/utils/crypto.js
const crypto = require("crypto");

const ALGORITHM = "aes-256-cbc";
const IV_LENGTH = 16;

let ENCRYPTION_KEY_BUFFER;
try {
  if (
    !process.env.ENCRYPTION_SECRET ||
    process.env.ENCRYPTION_SECRET.length !== 64
  ) {
    throw new Error(
      "ENCRYPTION_SECRET must be a 64-character hexadecimal string."
    );
  }
  ENCRYPTION_KEY_BUFFER = Buffer.from(process.env.ENCRYPTION_SECRET, "hex");
  if (ENCRYPTION_KEY_BUFFER.length !== 32) {
    throw new Error(
      "Derived encryption key is not 32 bytes long. Check ENCRYPTION_SECRET format."
    );
  }
} catch (e) {
  console.error(`FATAL CRYPTO CONFIG ERROR: ${e.message}`);
  ENCRYPTION_KEY_BUFFER = null;
}

function encrypt(text) {
  if (!text) return null;
  if (!ENCRYPTION_KEY_BUFFER) {
    console.error(
      "FATAL: Encryption service is not properly configured. Cannot encrypt."
    );
    throw new Error("Encryption service is not properly configured.");
  }
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY_BUFFER, iv);
  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");
  return iv.toString("hex") + ":" + encrypted;
}

function decrypt(text) {
  if (!text) return null;
  if (!ENCRYPTION_KEY_BUFFER) {
    console.error(
      "FATAL: Decryption service is not properly configured. Cannot decrypt."
    );
    throw new Error("Decryption service is not properly configured.");
  }
  try {
    const textParts = text.split(":");
    if (textParts.length !== 2) {
      console.error("Decryption failed: Invalid encrypted text format.");
      return null;
    }
    const iv = Buffer.from(textParts.shift(), "hex");
    const encryptedText = Buffer.from(textParts.join(":"), "hex");
    const decipher = crypto.createDecipheriv(
      ALGORITHM,
      ENCRYPTION_KEY_BUFFER,
      iv
    );
    let decrypted = decipher.update(encryptedText, "hex", "utf8");
    decrypted += decipher.final("utf8");

    return decrypted.toString();
  } catch (error) {
    console.error("Decryption failed for text:", text, "Error:", error.message);
    return null;
  }
}

module.exports = { encrypt, decrypt };

```

`server/utils/networkUtils.js`

```javascript
const os = require('os');

function getLocalIPs() {
    const interfaces = os.networkInterfaces();
    const ips = new Set(['localhost']); // Include localhost

    for (const iface of Object.values(interfaces)) {
        for (const addr of iface) {
            // Include IPv4 non-internal addresses
            if (addr.family === 'IPv4' && !addr.internal) {
                ips.add(addr.address);
            }
        }
    }
    return Array.from(ips);
}

function getPreferredLocalIP() {
    const ips = getLocalIPs();
    // Prioritize non-localhost, non-link-local (169.254) IPs
    // Often 192.168.* or 10.* or 172.16-31.* are common private ranges
    return ips.find(ip => !ip.startsWith('169.254.') && ip !== 'localhost' && (ip.startsWith('192.168.') || ip.startsWith('10.') || ip.match(/^172\.(1[6-9]|2[0-9]|3[0-1])\./))) ||
           ips.find(ip => !ip.startsWith('169.254.') && ip !== 'localhost') || // Any other non-link-local
           'localhost'; // Fallback
}

module.exports = { getLocalIPs, getPreferredLocalIP };

```

`server/workers/adminAnalysisWorker.js`

```javascript
// server/workers/adminAnalysisWorker.js
const { workerData, parentPort } = require('worker_threads');
const mongoose = require('mongoose');
const path = require('path');

const AdminDocument = require('../models/AdminDocument');
const connectDB = require('../config/db');
const geminiService = require('../services/geminiService');
const { ANALYSIS_PROMPTS } = require('../config/promptTemplates');

// Load .env variables from the server directory for the worker
require('dotenv').config({ path: path.resolve(__dirname, '..', '.env') });


async function performAdminDocAnalysis(adminDocumentId, originalName, textForAnalysis) {
    const logPrefix = `[AdminAnalysisWorker ${process.pid}, Doc: ${originalName}]`;
    console.log(`${logPrefix} Starting analysis. Text length: ${textForAnalysis ? textForAnalysis.length : 0}`);

    const analysisResults = { faq: "", topics: "", mindmap: "" };
    let allIndividualAnalysesSuccessful = true;

    // --- THIS IS THE FIX ---
    // The worker is a system process, so it must use the server's global API key.
    const serverApiKey = process.env.GEMINI_API_KEY;
    if (!serverApiKey) {
        console.error(`${logPrefix} FATAL: Server's GEMINI_API_KEY is not defined in the worker's environment.`);
        // Return a clear error message for all fields
        const errorMessage = "Error generating analysis: Server API key is not configured.";
        return { 
            success: false, 
            results: { faq: errorMessage, topics: errorMessage, mindmap: errorMessage }
        };
    }
    // --- END OF FIX ---

    async function generateSingleAnalysis(type, promptContentForLLM) {
        try {
            console.log(`${logPrefix} Generating ${type}...`);
            const historyForGemini = [{ role: 'user', parts: [{ text: "Perform the requested analysis based on the system instruction and provided document text." }] }];
            
            const generatedText = await geminiService.generateContentWithHistory(
                historyForGemini,
                promptContentForLLM,
                null, // No system prompt needed, it's in the user prompt template
                { apiKey: serverApiKey } // Explicitly pass the server's API key
            );

            if (!generatedText || typeof generatedText !== 'string' || generatedText.trim() === "") {
                console.warn(`${logPrefix} Gemini returned empty content for ${type}.`);
                return { success: false, content: `Notice: No content generated by the AI for ${type}.` };
            }
            console.log(`${logPrefix} ${type} generation successful.`);
            return { success: true, content: generatedText.trim() };
        } catch (error) {
            console.error(`${logPrefix} Error during ${type} generation: ${error.message}`);
            allIndividualAnalysesSuccessful = false;
            return { success: false, content: `Error generating ${type}: ${error.message.split('\n')[0].substring(0, 250)}` };
        }
    }

    if (!textForAnalysis || textForAnalysis.trim() === "") {
        console.warn(`${logPrefix} No text provided for analysis. Skipping generation.`);
        analysisResults.faq = "Skipped: No text content provided.";
        analysisResults.topics = "Skipped: No text content provided.";
        analysisResults.mindmap = "Skipped: No text content provided.";
    } else {
        const analysisPromises = [
            generateSingleAnalysis('FAQ', ANALYSIS_PROMPTS.faq.getPrompt(textForAnalysis)),
            generateSingleAnalysis('Topics', ANALYSIS_PROMPTS.topics.getPrompt(textForAnalysis)),
            generateSingleAnalysis('Mindmap', ANALYSIS_PROMPTS.mindmap.getPrompt(textForAnalysis))
        ];

        const [faqOutcome, topicsOutcome, mindmapOutcome] = await Promise.allSettled(analysisPromises);

        if (faqOutcome.status === 'fulfilled') {
            analysisResults.faq = faqOutcome.value.content;
            if (!faqOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.faq = `Error generating FAQ: ${faqOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }

        if (topicsOutcome.status === 'fulfilled') {
            analysisResults.topics = topicsOutcome.value.content;
            if (!topicsOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.topics = `Error generating Topics: ${topicsOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }

        if (mindmapOutcome.status === 'fulfilled') {
            analysisResults.mindmap = mindmapOutcome.value.content;
            if (!mindmapOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.mindmap = `Error generating Mindmap: ${mindmapOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }
    }
    
    try {
        await AdminDocument.updateOne(
            { _id: adminDocumentId },
            {
                $set: {
                    "analysis.faq": analysisResults.faq,
                    "analysis.topics": analysisResults.topics,
                    "analysis.mindmap": analysisResults.mindmap,
                    "analysisUpdatedAt": new Date()
                }
            }
        );
        console.log(`${logPrefix} Analysis results stored in DB.`);
        return { success: allIndividualAnalysesSuccessful, message: `Analysis ${allIndividualAnalysesSuccessful ? 'completed' : 'completed with some failures'}.`, results: analysisResults };
    } catch (dbError) {
        console.error(`${logPrefix} DB Error storing analysis results:`, dbError);
        return { success: false, message: `DB Error storing analysis: ${dbError.message}`, results: analysisResults };
    }
}

async function run() {
    // ... (The run function that orchestrates the worker remains the same)
    const { adminDocumentId, originalName, textForAnalysis } = workerData;
    let dbConnected = false;
    let overallTaskSuccess = false;
    let finalMessageToParent = "Admin analysis worker encountered an issue.";

    try {
        await connectDB(process.env.MONGO_URI);
        dbConnected = true;
        const analysisServiceResult = await performAdminDocAnalysis(adminDocumentId, originalName, textForAnalysis);
        overallTaskSuccess = analysisServiceResult.success;
        finalMessageToParent = analysisServiceResult.message;
        if (parentPort) {
            parentPort.postMessage({
                success: overallTaskSuccess,
                originalName: originalName,
                adminDocumentId: adminDocumentId,
                message: finalMessageToParent
            });
        }
    } catch (error) {
        console.error(`[AdminAnalysisWorker] Critical error in worker:`, error);
        finalMessageToParent = error.message || "Unknown critical error.";
        if (parentPort) {
            parentPort.postMessage({ success: false, originalName, adminDocumentId, error: finalMessageToParent });
        }
    } finally {
        if (dbConnected) {
            await mongoose.disconnect();
        }
        console.log(`[AdminAnalysisWorker] Finished task for ${originalName}. Overall Success: ${overallTaskSuccess}`);
    }
}

run();
```

`server/workers/analysisWorker.js`

```javascript
// server/workers/analysisWorker.js
const { workerData, parentPort } = require('worker_threads');
const mongoose = require('mongoose');
const path = require('path');

// --- THIS IS THE NEW MODEL ---
const KnowledgeSource = require('../models/KnowledgeSource');
const connectDB = require('../config/db');
const geminiService = require('../services/geminiService');
const ollamaService = require('../services/ollamaService');
const { ANALYSIS_PROMPTS } = require('../config/promptTemplates');

require('dotenv').config({ path: path.resolve(__dirname, '..', '.env') });

async function performFullAnalysis(sourceId, textForAnalysis, llmProvider, ollamaModel, apiKey, ollamaUrl) {
    const logPrefix = `[AnalysisWorker ${process.pid}, SourceID: ${sourceId}]`;
    console.log(`${logPrefix} Starting analysis. Using provider: ${llmProvider}`);

    const analysisResults = { faq: "", topics: "", mindmap: "" };
    let allIndividualAnalysesSuccessful = true;

    if (llmProvider === 'gemini' && !apiKey) {
        const errorMessage = "Error: Analysis failed because no valid Gemini API key was provided to the worker.";
        console.error(`${logPrefix} ${errorMessage}`);
        return { 
            success: false, 
            results: { faq: errorMessage, topics: errorMessage, mindmap: errorMessage }
        };
    }

    async function generateSingleAnalysis(type, promptContentForLLM) {
        try {
            console.log(`${logPrefix} Generating ${type}...`);
            const historyForLLM = [{ role: 'user', parts: [{ text: "Perform the requested analysis based on the system instruction provided." }] }];
            
            const llmOptions = { 
                apiKey,
                ollamaUrl,
                model: ollamaModel,
                // Using a larger token limit for analysis tasks
                maxOutputTokens: ollamaService.DEFAULT_MAX_OUTPUT_TOKENS_OLLAMA_KG 
            };

            const generatedText = llmProvider === 'ollama'
                ? await ollamaService.generateContentWithHistory(historyForLLM, promptContentForLLM, null, llmOptions)
                : await geminiService.generateContentWithHistory(historyForLLM, promptContentForLLM, null, llmOptions);

            if (!generatedText || typeof generatedText !== 'string' || generatedText.trim() === "") {
                console.warn(`${logPrefix} LLM returned empty content for ${type}.`);
                return { success: false, content: `Notice: No content generated for ${type}.` };
            }
            console.log(`${logPrefix} ${type} generation successful.`);
            return { success: true, content: generatedText.trim() };
        } catch (error) {
            console.error(`${logPrefix} Error during ${type} generation: ${error.message}`);
            allIndividualAnalysesSuccessful = false;
            return { success: false, content: `Error generating ${type}: ${error.message.substring(0, 250)}` };
        }
    }

    const analysisPromises = [
        generateSingleAnalysis('FAQ', ANALYSIS_PROMPTS.faq.getPrompt(textForAnalysis)),
        generateSingleAnalysis('Topics', ANALYSIS_PROMPTS.topics.getPrompt(textForAnalysis)),
        generateSingleAnalysis('Mindmap', ANALYSIS_PROMPTS.mindmap.getPrompt(textForAnalysis))
    ];
    const outcomes = await Promise.allSettled(analysisPromises);

    outcomes.forEach((outcome, index) => {
        const type = ['faq', 'topics', 'mindmap'][index];
        if (outcome.status === 'fulfilled') {
            analysisResults[type] = outcome.value.content;
            if (!outcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults[type] = `Error generating ${type}: ${outcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
        }
    });
    
    try {
        // --- REFACTORED DB UPDATE ---
        // Now updates the KnowledgeSource document directly.
        await KnowledgeSource.updateOne(
            { _id: sourceId },
            {
                $set: {
                    "analysis.faq": analysisResults.faq,
                    "analysis.topics": analysisResults.topics,
                    "analysis.mindmap": analysisResults.mindmap,
                    "status": allIndividualAnalysesSuccessful ? "completed" : "failed",
                    "failureReason": allIndividualAnalysesSuccessful ? "" : "One or more analysis steps failed."
                }
            }
        );
        console.log(`${logPrefix} Analysis results stored in DB.`);
        return { success: allIndividualAnalysesSuccessful, message: `Analysis ${allIndividualAnalysesSuccessful ? 'completed' : 'completed with some failures'}.` };
        // --- END REFACTOR ---
    } catch (dbError) {
        console.error(`${logPrefix} DB Error storing analysis results:`, dbError);
        return { success: false, message: `DB Error storing analysis: ${dbError.message}` };
    }
}

async function run() {
    const { sourceId, textForAnalysis, llmProvider, ollamaModel, apiKey, ollamaUrl } = workerData;
    let dbConnected = false;

    try {
        if (!process.env.MONGO_URI || !sourceId) {
            throw new Error("Worker started with incomplete data (MONGO_URI or sourceId missing).");
        }
        
        await connectDB(process.env.MONGO_URI);
        dbConnected = true;

        if (!textForAnalysis || textForAnalysis.trim() === '') {
            await KnowledgeSource.updateOne({ _id: sourceId }, {
                $set: { status: "failed", failureReason: "Analysis skipped: No text content was extracted." }
            });
        } else {
            await performFullAnalysis(
                sourceId, textForAnalysis, llmProvider, ollamaModel, apiKey, ollamaUrl
            );
        }

    } catch (error) {
        console.error(`[Analysis Worker] Critical error for sourceId '${sourceId}':`, error);
        if (dbConnected && sourceId) {
            try {
                await KnowledgeSource.updateOne(
                    { _id: sourceId },
                    { $set: { status: "failed", failureReason: `Critical worker error: ${error.message}` } }
                );
            } catch (dbUpdateError) {
                console.error(`[Analysis Worker] Failed to update status to 'failed_critical':`, dbUpdateError);
            }
        }
    } finally {
        if (dbConnected) {
            await mongoose.disconnect();
        }
        console.log(`[Analysis Worker] Finished task for sourceId ${sourceId}.`);
    }
}

run();
```

`server/workers/kgWorker.js`

```javascript
// server/workers/kgWorker.js
const { workerData, parentPort } = require('worker_threads');
const mongoose = require('mongoose');

// --- REFACTORED MODELS ---
const KnowledgeSource = require('../models/KnowledgeSource');
const connectDB = require('../config/db');
const kgService = require('../services/kgService');

async function runKgGeneration() {
    // --- REFACTORED DESTRUCTURING ---
    const { chunksForKg, userId, originalName, llmProvider, ollamaModel, sourceId } = workerData;
    
    let dbConnected = false;
    let overallSuccess = false;
    let finalMessage = "KG processing encountered an issue.";
    const logPrefix = `[KG Worker ${process.pid}, SourceID: ${sourceId}]`;

    try {
        console.log(`${logPrefix} Received task. Chunks: ${chunksForKg ? chunksForKg.length : 0}`);
        if (!process.env.MONGO_URI || !sourceId || !userId || !originalName) {
            throw new Error("Missing critical worker data (MONGO_URI, sourceId, userId, or originalName).");
        }

        await connectDB(process.env.MONGO_URI);
        dbConnected = true;
        console.log(`${logPrefix} DB Connected.`);

        // --- REFACTORED DB UPDATE LOGIC ---
        await KnowledgeSource.updateOne({ _id: sourceId }, { $set: { "kgStatus": "processing" } });
        console.log(`${logPrefix} Status set to 'processing'.`);

        if (!chunksForKg || chunksForKg.length === 0) {
            finalMessage = "No chunks provided for KG generation.";
            await KnowledgeSource.updateOne({ _id: sourceId }, { $set: { "kgStatus": "skipped_no_chunks" } });
            overallSuccess = true;
        } else {
            // NOTE: The `userId` and `originalName` are still passed to kgService for populating metadata in Neo4j.
            const kgExtractionResult = await kgService.generateAndStoreKg(chunksForKg, userId, originalName, llmProvider, ollamaModel);

            if (kgExtractionResult && kgExtractionResult.success) {
                await KnowledgeSource.updateOne(
                    { _id: sourceId }, 
                    { $set: { "kgStatus": "completed" } }
                );
                overallSuccess = true;
                finalMessage = kgExtractionResult.message || "KG generation and storage completed successfully.";
            } else {
                await KnowledgeSource.updateOne({ _id: sourceId }, { $set: { "kgStatus": "failed_extraction" } });
                finalMessage = kgExtractionResult?.message || "KG detailed extraction or storage failed.";
                overallSuccess = false;
            }
        }
        // --- END REFACTOR ---

    } catch (error) {
        console.error(`${logPrefix} CRITICAL error:`, error);
        finalMessage = error.message || "Unknown critical error in KG worker.";
        overallSuccess = false;
        if (dbConnected && sourceId) {
            try {
                await KnowledgeSource.updateOne({ _id: sourceId }, { $set: { "kgStatus": "failed_critical" } });
            } catch (dbUpdateError) {
                console.error(`${logPrefix} DB update error on critical fail:`, dbUpdateError);
            }
        }
    } finally {
        if (dbConnected) {
            await mongoose.disconnect();
        }
        console.log(`${logPrefix} Finished task. Overall Success: ${overallSuccess}`);
    }
}

runKgGeneration();
```

