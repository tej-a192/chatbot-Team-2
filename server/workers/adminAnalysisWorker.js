// server/workers/adminAnalysisWorker.js
const { workerData, parentPort } = require('worker_threads');
const mongoose = require('mongoose');
const path = require('path'); // For resolving .env path

// Adjust paths if your project structure is different
const AdminDocument = require('../models/AdminDocument'); // Specific model for admin docs
const connectDB = require('../config/db');
const geminiService = require('../services/geminiService');
const { ANALYSIS_PROMPTS } = require('../config/promptTemplates');

// Load .env variables from the server directory for the worker
require('dotenv').config({ path: path.resolve(__dirname, '..', '.env') });


async function performAdminDocAnalysis(adminDocumentId, originalName, textForAnalysis) {
    const logPrefix = `[AdminAnalysisWorker ${process.pid}, Doc: ${originalName}, ID: ${adminDocumentId}]`;
    console.log(`${logPrefix} Starting analysis. Text length: ${textForAnalysis ? textForAnalysis.length : 0}`);

    const analysisResults = { faq: "", topics: "", mindmap: "" };
    let allIndividualAnalysesSuccessful = true;

    async function generateSingleAnalysis(type, promptContentForLLM) {
        try {
            console.log(`${logPrefix} Generating ${type}...`);
            // For admin docs, we don't have a "user" in the same sense for history.
            // We send a simple instruction to perform the task.
            const historyForGemini = [{ role: 'user', parts: [{ text: "Perform the requested analysis based on the system instruction and provided document text." }] }];
            
            const generatedText = await geminiService.generateContentWithHistory(
                historyForGemini,
                promptContentForLLM // This is the full prompt from ANALYSIS_PROMPTS including the document text
            );

            if (!generatedText || typeof generatedText !== 'string' || generatedText.trim() === "") {
                console.warn(`${logPrefix} Gemini returned empty content for ${type}.`);
                return { success: false, content: `Notice: No content generated by the AI for ${type}.` };
            }
            console.log(`${logPrefix} ${type} generation successful.`);
            return { success: true, content: generatedText.trim() };
        } catch (error) {
            console.error(`${logPrefix} Error during ${type} generation: ${error.message}`);
            allIndividualAnalysesSuccessful = false;
            return { success: false, content: `Error generating ${type}: ${error.message.split('\n')[0].substring(0, 250)}` };
        }
    }

    if (!textForAnalysis || textForAnalysis.trim() === "") {
        console.warn(`${logPrefix} No text provided for analysis. Skipping generation.`);
        allIndividualAnalysesSuccessful = true; // Not a failure, just nothing to do.
        analysisResults.faq = "Skipped: No text content provided.";
        analysisResults.topics = "Skipped: No text content provided.";
        analysisResults.mindmap = "Skipped: No text content provided.";
    } else {
        // --- Generate FAQ, Topics, and Mindmap IN PARALLEL ---
        const analysisPromises = [
            generateSingleAnalysis('FAQ', ANALYSIS_PROMPTS.faq.getPrompt(textForAnalysis)),
            generateSingleAnalysis('Topics', ANALYSIS_PROMPTS.topics.getPrompt(textForAnalysis)),
            generateSingleAnalysis('Mindmap', ANALYSIS_PROMPTS.mindmap.getPrompt(textForAnalysis))
        ];

        const [faqOutcome, topicsOutcome, mindmapOutcome] = await Promise.allSettled(analysisPromises);

        if (faqOutcome.status === 'fulfilled') {
            analysisResults.faq = faqOutcome.value.content;
            if (!faqOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.faq = `Error generating FAQ: ${faqOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
            console.error(`${logPrefix} FAQ generation promise rejected:`, faqOutcome.reason);
        }

        if (topicsOutcome.status === 'fulfilled') {
            analysisResults.topics = topicsOutcome.value.content;
            if (!topicsOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.topics = `Error generating Topics: ${topicsOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
            console.error(`${logPrefix} Topics generation promise rejected:`, topicsOutcome.reason);
        }

        if (mindmapOutcome.status === 'fulfilled') {
            analysisResults.mindmap = mindmapOutcome.value.content;
            if (!mindmapOutcome.value.success) allIndividualAnalysesSuccessful = false;
        } else {
            analysisResults.mindmap = `Error generating Mindmap: ${mindmapOutcome.reason?.message?.substring(0,100) || 'Promise rejected'}`;
            allIndividualAnalysesSuccessful = false;
            console.error(`${logPrefix} Mindmap generation promise rejected:`, mindmapOutcome.reason);
        }
    }
    
    // Update MongoDB with all results
    // Note: This worker doesn't set 'analysisStatus' as it's not in the simplified AdminDocument model.
    // It directly updates the analysis fields.
    try {
        const updateResult = await AdminDocument.updateOne(
            { _id: adminDocumentId }, // Find by the document's MongoDB _id
            {
                $set: {
                    "analysis.faq": analysisResults.faq,
                    "analysis.topics": analysisResults.topics,
                    "analysis.mindmap": analysisResults.mindmap,
                    "analysisUpdatedAt": new Date()
                }
            }
        );

        if (updateResult.matchedCount === 0) {
            console.error(`${logPrefix} DB Error: AdminDocument with ID ${adminDocumentId} not found for update.`);
            return { success: false, message: `AdminDocument not found in DB (ID: ${adminDocumentId}).`, results: analysisResults };
        }
        if (updateResult.modifiedCount === 0 && updateResult.matchedCount === 1) {
            console.warn(`${logPrefix} Analysis results for already matched existing content in DB (ID: ${adminDocumentId}). No change made or content was identical.`);
        } else {
             console.log(`${logPrefix} Analysis results stored in DB.`);
        }
        return { success: allIndividualAnalysesSuccessful, message: `Analysis ${allIndividualAnalysesSuccessful ? 'completed' : 'completed with some failures'}.`, results: analysisResults };
    } catch (dbError) {
        console.error(`${logPrefix} DB Error storing analysis results:`, dbError);
        return { success: false, message: `DB Error storing analysis: ${dbError.message}`, results: analysisResults };
    }
}

async function run() {
    const { adminDocumentId, originalName, textForAnalysis } = workerData;
    let dbConnected = false;
    let overallTaskSuccess = false;
    let finalMessageToParent = "Admin analysis worker encountered an issue.";
    const logPrefix = `[AdminAnalysisWorker ${process.pid}, Doc: ${originalName}, ID: ${adminDocumentId}]`;

    try {
        console.log(`${logPrefix} Worker received task.`);
        if (!process.env.MONGO_URI) throw new Error("MONGO_URI not set in AdminAnalysisWorker environment.");
        if (!adminDocumentId || !originalName) throw new Error("Missing adminDocumentId or originalName in workerData.");
        
        await connectDB(process.env.MONGO_URI);
        dbConnected = true;
        console.log(`${logPrefix} DB Connected.`);

        const analysisServiceResult = await performAdminDocAnalysis(adminDocumentId, originalName, textForAnalysis);
        overallTaskSuccess = analysisServiceResult.success;
        finalMessageToParent = analysisServiceResult.message;

        if (parentPort) {
            parentPort.postMessage({
                success: overallTaskSuccess,
                originalName: originalName, // For logging on main thread
                adminDocumentId: adminDocumentId,
                message: finalMessageToParent
            });
        }

    } catch (error) {
        console.error(`${logPrefix} Critical error in worker:`, error.message, error.stack);
        finalMessageToParent = error.message || "Unknown critical error in AdminAnalysisWorker.";
        overallTaskSuccess = false;
        // Note: We don't update a status field here as the simplified model doesn't have one.
        // The main thread (adminDocuments.js) might log this worker failure.
        if (parentPort) {
            parentPort.postMessage({ success: false, originalName, adminDocumentId, error: finalMessageToParent });
        }
    } finally {
        if (dbConnected) {
            await mongoose.disconnect().catch(e => console.error(`${logPrefix} Error disconnecting DB:`, e));
            console.log(`${logPrefix} DB Disconnected.`);
        }
        console.log(`${logPrefix} Finished task. Overall Success: ${overallTaskSuccess}`);
        // Worker exits automatically if parentPort exists and main thread doesn't keep it alive,
        // or if it's the end of the run() promise.
    }
}

run();