OOPS 

ðŸŽ¯ Gunshot Answer:
OOPs is a way of programming using classes and objects that focuses on organizing code by grouping
related data and behavior together, making code reusable, modular, and easier to maintain.

ðŸ’¡ Core Pillars (4):
Encapsulation â€“ Hiding internal details using access modifiers.
Abstraction â€“ Showing only essential features, hiding the complexity.
Inheritance â€“ Reusing code from parent classes.
Polymorphism â€“ Same function behaves differently based on context (overloading/overriding).



https://www.geeksforgeeks.org/python/python-oops-concepts/



deltax inetview

graph coloring
knapsack -0/1
json application
correct an email address without using inbuilt functions (strings and json)
the puzze master of puzzleville


give an valid url and the names of one or more query parameters as key , determine the value fot those keys in the url without regrex or buultin parsers
Note:wurey parameters are define




Phone number::


function is_all_digits(text):
  // An empty string is not considered a number of digits
  if length of text == 0:
    return False
  
  // Define the set of allowed digit characters
  valid_digits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
  
  // Check every character
  for each character 'c' in text:
    if 'c' is not in valid_digits:
      return False // Found a non-digit, so it's invalid
  
  // If the loop finishes, all characters were digits
  return True


function validate_phone_number(s):
  string_length = length of s

  // Case 1: International format "+91 xxxxxxxxxx"
  if string_length == 14:
    // Manual 'startswith' check
    if s[0]=='+' and s[1]=='9' and s[2]=='1' and s[3]==' ':
      number_part = slice of s from index 4 to end
      // Manual 'isdigit' check and first digit check
      if is_all_digits(number_part) and number_part[0] in {'7','8','9'}:
        return True

  // Case 2: National format "0xxxxx xxxxx"
  else if string_length == 12:
    // Check prefix '0' and the space at index 6
    if s[0]=='0' and s[6]==' ':
      part1 = slice of s from index 1 to 6
      part2 = slice of s from index 7 to end
      // Manual 'isdigit' check for both parts
      if is_all_digits(part1) and is_all_digits(part2):
        // The first digit of the actual 10-digit number is s[1]
        if s[1] in {'7','8','9'}:
          return True

  // Case 3: Direct 10-digit format
  else if string_length == 10:
    // Manual 'isdigit' check and first digit check
    if is_all_digits(s) and s[0] in {'7','8','9'}:
      return True

  // If none of the conditions passed
  return False



url :::



def get_query_parameters():
    url = input()
    params_dict = {}

    # This section replaces: url.split('?')[1]
    query_string = ""
    found_q_mark = False
    for char in url:
        if found_q_mark:
            query_string += char
        if char == '?':
            found_q_mark = True

    if query_string:
        # This section replaces: query_part.split('&')
        param_pairs = []
        current_pair = ""
        for char in query_string:
            if char == '&':
                param_pairs.append(current_pair)
                current_pair = ""
            else:
                current_pair += char
        param_pairs.append(current_pair)

        # This section replaces: pair.split('=')
        for pair in param_pairs:
            key = ""
            value = ""
            found_equals = False
            for char in pair:
                if char == '=' and not found_equals: # Important to only split on the first '='
                    found_equals = True
                elif not found_equals:
                    key += char
                else:
                    value += char
            
            if key: # Make sure the key is not empty
                params_dict[key] = value

    # Your lookup logic is perfect and needs no changes
    try:
        N = int(input())
        for _ in range(N):
            key_to_find = input()
            # .get() is a basic dictionary method, not a parser. It is allowed.
            print(params_dict.get(key_to_find, "-1"))
    except (ValueError, EOFError):
        pass

# Run the main function
get_query_parameters()



json -- formatter ::

import json  # 1. For parsing and generating JSON strings

# 2. Read input JSON string
s = input().strip()

# 3. Parse into Python object
obj = json.loads(s)

# 4. New dict for cleaned data
cleaned = {}

# 5. Iterate over outer keys
for key, val in obj.items():
    if isinstance(val, dict):
        # 6. Clean nested dict if present
        nested = {}
        for nk, nv in val.items():
            if nv is not None and nv != "":
                nested[nk] = nv
        if nested:
            cleaned[key] = nested
    else:
        # 7. Keep non-null/non-empty values
        if val is not None and val != "":
            cleaned[key] = val

# 8. Sort keys lexicographically
cleaned = dict(sorted(cleaned.items()))

# 9. Convert back to formatted JSON string
print(json.dumps(cleaned, indent=2))





json line sntaizer::

def format_json_bhai(json_str):
    star_count = 0            # this is the number of * to print
    result = []               # final lines
    line = ""                 # current line

    for ch in json_str:
        if ch == '{' or ch == '[':
            # You saw '{' â†’ print it â†’ next line will start with more *
            line += ch
            result.append('*' * star_count + line)
            star_count += 1   # increase star level
            line = ""
        elif ch == ',':
            # You saw ',' â†’ print line with * â†’ next line continues same *
            line += ch
            result.append('*' * star_count + line.strip())
            line = ""
        elif ch == '}' or ch == ']':
            # You saw '}' â†’ first print current line (if exists), then reduce stars, then print *}
            if line.strip() != "":
                result.append('*' * star_count + line.strip())
            star_count -= 1   # decrease star level
            result.append('*' * star_count + ch)
            line = ""
        else:
            # build up line
            line += ch

    # if anything left at the end, print it
    if line.strip() != "":
        result.append('*' * star_count + line.strip())

    # return final joined string
    return "\n".join(result)





