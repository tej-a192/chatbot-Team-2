`.env`

```
#REACT_APP_API_BASE_URL=http://localhost:5001/api
# OR for Vite:
VITE_API_BASE_URL=http://localhost:5001/api
VITE_ADMIN_USERNAME=admin
VITE_ADMIN_PASSWORD=admin123
```

`code.txt`

```

```

`eslint.config.js`

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

```

`index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI TUTOR</title>

    <script src="https://cdn.jsdelivr.net/npm/d3@6"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-lib@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-view@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@latest/dist/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js"></script>
    
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        if (typeof mermaid !== 'undefined') {
          mermaid.initialize({ startOnLoad: false, theme: 'neutral' }); 
          console.log("Mermaid.js initialized globally with 'neutral' theme via index.html.");
        } else {
          console.error("Mermaid.js not found on window after script load. Mermaid diagrams may not render.");
        }
      });
    </script>

  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

`postcss.config.js`

```javascript
export default {
  plugins: {
    'postcss-nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

`src/App.css`

```css
/* #root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
} */

```

`src/App.jsx`

```javascript
// frontend/src/App.jsx
import React, { useState, useEffect, useCallback } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useNavigate, useLocation } from 'react-router-dom';

import { useAuth as useRegularAuth } from './hooks/useAuth.jsx'; // For regular user login/state
import { useAppState } from './contexts/AppStateContext.jsx';   // For isAdminSessionActive and other global states

// --- Regular User Components ---
import AuthModal from './components/auth/AuthModal.jsx';
import TopNav from './components/layout/TopNav.jsx';
import LeftPanel from './components/layout/LeftPanel.jsx';
import CenterPanel from './components/layout/CenterPanel.jsx';
import RightPanel from './components/layout/RightPanel.jsx';
import LeftCollapsedNav from './components/layout/LeftCollapsedNav.jsx';
import RightCollapsedNav from './components/layout/RightCollapsedNav.jsx';
import ChatHistoryModal from './components/chat/ChatHistoryModal.jsx';

// --- Admin Specific Components ---
import AdminDashboardPage from './components/admin/AdminDashboardPage.jsx'; // Make sure this exists
import AdminProtectedRoute from './components/admin/AdminProtectedRoute.jsx'; // You've updated this

// --- Services & Utils ---
import api from './services/api.js'; // For regular user API calls
import toast from 'react-hot-toast';
import { motion, AnimatePresence } from 'framer-motion';

// Main application layout for authenticated REGULAR users
function MainAppLayout() {
    const { user: regularUser, logout: regularUserLogout } = useRegularAuth();
    const {
        orchestratorStatus, // Assuming this is fetched and managed by App or AppStateContext
        currentSessionId,
        isLeftPanelOpen,
        isRightPanelOpen,
        setSessionId: setGlobalSessionId, // Renamed for clarity from AppStateContext
    } = useAppState();

    const [appStateMessages, setAppStateMessages] = useState([]); // Local to MainAppLayout
    const [appStateChatStatus, setAppStateChatStatus] = useState('Ready.'); // Local to MainAppLayout
    const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false);

    const handleRegularUserLogout = () => {
        regularUserLogout(); // Clears token and user in AuthContext
        setGlobalSessionId(null); // Clear session from AppStateContext
        localStorage.removeItem('aiTutorSessionId');
        setAppStateMessages([]);
        setAppStateChatStatus("Logged out. Please login.");
        toast.success("Logged out successfully.");
        // App.jsx routing will handle redirecting to show AuthModal if necessary
    };

    const handleNewChat = async () => {
        try {
            const data = await api.startNewSession(); // Regular user API
            if (data && data.sessionId) {
                setGlobalSessionId(data.sessionId);
                setAppStateMessages([]);
                setAppStateChatStatus("New chat started.");
                toast.success("New chat started!");
            } else {
                toast.error("Could not start new chat session.");
            }
        } catch (error) {
            toast.error("Failed to start new chat.");
        }
    };

    const handleSelectSessionFromHistory = (sessionId) => {
        if (sessionId && sessionId !== currentSessionId) {
            setGlobalSessionId(sessionId);
            // Chat history fetching will be triggered by useEffect watching currentSessionId
            toast.success(`Loading session...`);
        } else if (sessionId === currentSessionId) {
            toast.info("This session is already loaded.");
        }
        setIsHistoryModalOpen(false);
    };

    const { token: regularUserTokenValue } = useRegularAuth(); // Get token for API calls

    const fetchChatHistory = useCallback(async (sid) => {
        if (!sid || !regularUserTokenValue) {
            setAppStateMessages([]);
            setAppStateChatStatus(regularUserTokenValue ? "Start or select a chat." : "Please login.");
            return;
        }
        setAppStateChatStatus("Loading chat history...");
        try {
            const historyData = await api.getChatHistory(sid); // Regular user API
            const formattedMessages = (Array.isArray(historyData) ? historyData : []).map(msg => ({
                id: msg.id || msg._id || String(Math.random() + Date.now()),
                sender: msg.sender || (msg.role === 'model' ? 'bot' : 'user'),
                text: msg.parts?.[0]?.text || msg.text || '',
                thinking: msg.thinking, references: msg.references || [],
                timestamp: msg.timestamp || new Date().toISOString(),
                source_pipeline: msg.source_pipeline
            }));
            setAppStateMessages(formattedMessages);
            setAppStateChatStatus(formattedMessages.length > 0 ? "History loaded." : "Chat is empty.");
        } catch (error) {
            toast.error(`History load failed: ${error.message}`);
            setAppStateChatStatus("Error loading history.");
        }
    }, [regularUserTokenValue]); // Dependencies for fetchChatHistory

    useEffect(() => {
        if (currentSessionId && regularUserTokenValue) {
            fetchChatHistory(currentSessionId);
        } else if (!regularUserTokenValue) { // If regular user logs out
            setAppStateMessages([]);
            setAppStateChatStatus("Please login.");
        }
    }, [currentSessionId, regularUserTokenValue, fetchChatHistory]);

    // Assuming orchestratorStatus is fetched in the top-level App component
    // and passed down if MainAppLayout needs it directly for TopNav.
    // For simplicity, I'll pass it as a prop to MainAppLayout.

    return (
        <>
            <TopNav
                user={regularUser} // regularUser object from AuthContext (includes role if backend sends it)
                onLogout={handleRegularUserLogout}
                onNewChat={handleNewChat}
                onHistoryClick={() => setIsHistoryModalOpen(true)}
                orchestratorStatus={orchestratorStatus}
            />
            <div className="flex flex-1 overflow-hidden pt-16 bg-background-light dark:bg-background-dark">
                <AnimatePresence mode="wait">
                    {isLeftPanelOpen ? (
                        <motion.aside
                            key="left-panel-main"
                            initial={{ x: '-100%', opacity: 0 }}
                            animate={{ x: '0%', opacity: 1 }}
                            exit={{ x: '-100%', opacity: 0 }}
                            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                            className="w-full md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-r border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
                        >
                            <LeftPanel />
                        </motion.aside>
                    ) : (
                        <LeftCollapsedNav />
                    )}
                </AnimatePresence>

                <main className={`flex-1 flex flex-col overflow-hidden p-1 sm:p-2 md:p-4
                                 transition-all duration-300 ease-in-out
                                 ${isLeftPanelOpen ? 'lg:ml-0' : 'lg:ml-16 md:ml-14'}
                                 ${isRightPanelOpen ? 'lg:mr-0' : 'lg:mr-16 md:mr-14'}`}>
                    <CenterPanel
                        messages={appStateMessages}
                        setMessages={setAppStateMessages}
                        currentSessionId={currentSessionId}
                        chatStatus={appStateChatStatus}
                        setChatStatus={setAppStateChatStatus}
                    />
                </main>

                <AnimatePresence mode="wait">
                    {isRightPanelOpen ? (
                        <motion.aside
                            key="right-panel-main"
                            initial={{ x: '100%', opacity: 0 }}
                            animate={{ x: '0%', opacity: 1 }}
                            exit={{ x: '100%', opacity: 0 }}
                            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                            className="hidden md:flex md:flex-col md:w-72 lg:w-80 xl:w-96 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark overflow-y-auto p-3 sm:p-4 shadow-lg flex-shrink-0 custom-scrollbar"
                        >
                            <RightPanel />
                        </motion.aside>
                    ) : (
                        <RightCollapsedNav />
                    )}
                </AnimatePresence>
            </div>
            <ChatHistoryModal
                isOpen={isHistoryModalOpen}
                onClose={() => setIsHistoryModalOpen(false)}
                onSelectSession={handleSelectSessionFromHistory}
            />
        </>
    );
}


// Main App Component - Handles top-level routing and auth state logic
function App() {
    const { token: regularUserToken, user: regularUser, loading: regularUserAuthLoading, setUser: setRegularUserInAuthContext } = useRegularAuth();
    const { theme, setSessionId: setGlobalSessionId, currentSessionId, isAdminSessionActive } = useAppState(); // Removed setIsAdminSessionActive as it's set by AuthModal
    
    const navigate = useNavigate();
    const location = useLocation();

    const [appInitializing, setAppInitializing] = useState(true);
    const [showAuthModal, setShowAuthModal] = useState(false);
    const [orchestratorStatus, setOrchestratorStatus] = useState({ status: "loading", message: "Connecting..." });

    // Effect for theme
    useEffect(() => {
        const rootHtmlElement = document.documentElement;
        rootHtmlElement.classList.remove('light', 'dark');
        rootHtmlElement.classList.add(theme);
        document.body.className = '';
        document.body.classList.add(theme === 'dark' ? 'bg-background-dark' : 'bg-background-light');
    }, [theme]);

    // Effect for orchestrator status
    useEffect(() => {
        api.getOrchestratorStatus().then(setOrchestratorStatus);
    }, []);

    // Effect for Authentication, Initialization, and Routing
    useEffect(() => {
        // console.log("App.jsx: Auth/Init Effect | regularUserAuthLoading:", regularUserAuthLoading, "| regularUserToken:", !!regularUserToken, "| regularUser:", regularUser, "| isAdminSessionActive:", isAdminSessionActive, "| Path:", location.pathname);

        // Prioritize admin session: if active, ensure they are on admin path
        if (isAdminSessionActive) {
            setAppInitializing(false); // Admin is active, app is considered initialized for this path
            setShowAuthModal(false);   // Don't show regular login modal
            if (!location.pathname.startsWith('/admin')) {
                // console.log("App.jsx: Admin session active, redirecting to /admin/dashboard from", location.pathname);
                navigate('/admin/dashboard', { replace: true });
            }
            return; // Early exit for active admin session
        }

        // If admin session is not active, proceed with regular user auth logic
        if (regularUserAuthLoading) {
            // console.log("App.jsx: Regular user auth is loading...");
            setAppInitializing(true); // Show loader while regular auth context determines state
            return;
        }

        setAppInitializing(false); // Regular auth has finished loading

        if (regularUserToken && regularUser) {
            // Regular user is authenticated
            setShowAuthModal(false);
            if (location.pathname.startsWith('/admin')) {
                // A regular user tried to access an admin path, redirect them
                // console.log("App.jsx: Regular user on admin path, redirecting to /");
                navigate('/', { replace: true });
            } else if (!currentSessionId && !location.pathname.startsWith('/admin')) { // Only start session if not on admin path
                // console.log("App.jsx: Regular user logged in, no session, starting new one.");
                api.startNewSession().then(data => {
                    if (data && data.sessionId) {
                        setGlobalSessionId(data.sessionId);
                    }
                }).catch(err => {
                    toast.error("Failed to start new session (initial).");
                    console.error("App.jsx: Error starting new session (initial):", err);
                });
            }
        } else {
            // No regular user token/user, and not an admin session
            // Show AuthModal if not trying to access an admin path (like /admin/login which doesn't exist anymore)
            // or any other non-auth-modal related path.
            if (!location.pathname.startsWith('/admin')) { // If not on an admin path
                 // console.log("App.jsx: No active regular or admin session. Showing AuthModal.");
                 setShowAuthModal(true);
            }
        }
    }, [
        regularUserAuthLoading, regularUserToken, regularUser,
        isAdminSessionActive,
        currentSessionId, setGlobalSessionId,
        navigate, location.pathname
    ]);

    const handleAuthSuccess = (authDataFromModal) => {
        // console.log("App.jsx handleAuthSuccess: Received from AuthModal:", authDataFromModal);
        // AuthModal now handles setting isAdminSessionActive and navigating for admin.
        // For regular users, AuthContext handles setting token/user.
        // This callback primarily ensures the modal closes and session ID is handled for regular users.
        setShowAuthModal(false);

        if (authDataFromModal && !authDataFromModal.isAdminLogin && authDataFromModal.token) {
            // Regular user login was successful
            if (authDataFromModal.sessionId) {
                setGlobalSessionId(authDataFromModal.sessionId);
            } else if (regularUserToken && !currentSessionId) { // Fallback if session ID wasn't in authData
                api.startNewSession().then(data => {
                    if (data && data.sessionId) setGlobalSessionId(data.sessionId);
                });
            }
             // If backend provides more complete user info (including role for regular user), update AuthContext
            if (authDataFromModal.username && authDataFromModal._id && authDataFromModal.role) {
                setRegularUserInAuthContext({
                    id: authDataFromModal._id,
                    username: authDataFromModal.username,
                    role: authDataFromModal.role
                });
            }
        } else if (authDataFromModal && authDataFromModal.isAdminLogin) {
            // Admin "login" handled by AuthModal. useEffect will handle navigation.
            // console.log("App.jsx: Admin login processed by AuthModal.");
        } else {
             // Modal closed manually or other non-success scenario
             // The useEffect will re-evaluate and show AuthModal if needed.
        }
    };

    if (appInitializing) {
        return (
            <div className="fixed inset-0 flex flex-col items-center justify-center bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
                <div className="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-primary mb-4"></div>
                <p className="text-xl">Initializing AI Tutor...</p>
            </div>
        );
    }

    return (
        <div className={`flex flex-col h-screen overflow-hidden font-sans ${theme}`}>
            <AnimatePresence>
                {showAuthModal && !regularUserToken && !isAdminSessionActive && !location.pathname.startsWith('/admin') && (
                    <AuthModal isOpen={showAuthModal} onClose={handleAuthSuccess} />
                )}
            </AnimatePresence>

            <Routes>
                <Route path="/admin/dashboard" element={
                    <AdminProtectedRoute> {/* This checks AppStateContext.isAdminSessionActive */}
                        <AdminDashboardPage />
                    </AdminProtectedRoute>
                } />

                {/* Default route / Catch-all for the main application */}
                <Route path="/*" element={
                    isAdminSessionActive ? <Navigate to="/admin/dashboard" replace /> : // If admin is active, always go to dashboard
                    (regularUserToken && regularUser) ? <MainAppLayout orchestratorStatus={orchestratorStatus} /> : // If regular user, show main app
                    (location.pathname.startsWith('/admin')) ? <Navigate to="/" replace /> : // If on admin path but not admin, go to main (will show modal)
                    null // Fallback - AuthModal will be shown by useEffect if conditions are met
                } />
            </Routes>
        </div>
    );
}

// AppWrapper to provide Router context
function AppWrapper() {
    return (
        <Router>
            <App />
        </Router>
    );
}

export default AppWrapper;
```

`src/components/admin/AdminDashboardPage.jsx`

```javascript
// frontend/src/pages/AdminDashboardPage.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // For admin session logout
import * as adminApi from '../services/adminApi.js'; // Service for admin API calls
import Button from '../components/core/Button.jsx';
import IconButton from '../components/core/IconButton.jsx';
import Modal from '../components/core/Modal.jsx';
import { UploadCloud, FileText, Trash2, Eye, LogOut, Loader2, AlertTriangle, CheckCircle, RefreshCw } from 'lucide-react';
import toast from 'react-hot-toast';
import { format } from 'date-fns'; // For formatting dates

// --- AdminDocumentUpload Component (child of AdminDashboardPage) ---
function AdminDocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);
    const fileInputRef = useRef(null);

    const handleFileChange = (e) => {
        if (isUploading) return;
        const file = e.target.files && e.target.files[0];
        if (file) setSelectedFile(file);
        else setSelectedFile(null);
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            toast.error("Please select a file to upload.");
            return;
        }
        setIsUploading(true);
        const toastId = toast.loading(`Uploading "${selectedFile.name}"...`);
        const formData = new FormData();
        formData.append('file', selectedFile);

        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders(); // Get Basic Auth headers
            const response = await adminApi.uploadAdminDocument(formData, authHeaders);
            toast.success(response.message || `Admin document "${selectedFile.name}" uploaded. Analysis initiated.`, { id: toastId });
            onUploadSuccess(); // Callback to refresh document list in parent
            setSelectedFile(null);
            if (fileInputRef.current) fileInputRef.current.value = null;
        } catch (error) {
            // error.message now comes from makeAdminApiRequest's error handling
            toast.error(error.message || `Failed to upload admin document "${selectedFile.name}".`, { id: toastId });
        } finally {
            setIsUploading(false);
        }
    };

    return (
        <div className="card-base p-4 mb-6">
            <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark">Upload New Admin Document</h2>
            <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
                <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    className="input-field flex-grow text-sm p-2.5 min-h-[44px]"
                    accept=".pdf,.docx,.txt,.md" // Should match allowedAdminExtensions in backend multer
                    disabled={isUploading}
                />
                <Button
                    onClick={handleUpload}
                    isLoading={isUploading}
                    disabled={!selectedFile || isUploading}
                    leftIcon={<UploadCloud size={16} />}
                    size="md" // Consistent with other buttons
                    className="w-full sm:w-auto !py-2.5" // Tailwind class for padding
                >
                    Upload
                </Button>
            </div>
            {selectedFile && !isUploading && (
                <p className="text-xs mt-2 text-text-muted-light dark:text-text-muted-dark">
                    Selected: {selectedFile.name} ({(selectedFile.size / 1024).toFixed(1)} KB)
                </p>
            )}
        </div>
    );
}

// --- Main AdminDashboardPage Component ---
function AdminDashboardPage() {
    const { setIsAdminSessionActive } = useAppState(); // For admin logout
    const navigate = useNavigate();

    const [documents, setDocuments] = useState([]); // List of admin documents
    const [isLoading, setIsLoading] = useState(true); // Loading state for document list
    const [error, setError] = useState(''); // Error message for document list fetching

    const [isAnalysisModalOpen, setIsAnalysisModalOpen] = useState(false);
    const [currentDocForModal, setCurrentDocForModal] = useState(null); // Doc whose analysis is being viewed
    const [analysisContent, setAnalysisContent] = useState(null); // {faq, topics, mindmap}
    const [isLoadingAnalysis, setIsLoadingAnalysis] = useState(false); // Loading state for fetching analysis

    const adminLogoutHandler = () => {
        setIsAdminSessionActive(false); // Clear the admin session flag in AppState
        toast.success("Admin logged out.");
        navigate('/'); // Navigate to the main page (AuthModal will show if no regular user)
    };

    const fetchAdminDocs = useCallback(async (showLoadingToast = false) => {
        let toastId;
        if (showLoadingToast) {
            toastId = toast.loading("Refreshing document list...");
        } else {
            setIsLoading(true); // For initial load or non-toast refresh
        }
        setError('');
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.getAdminDocuments(authHeaders);
            setDocuments(Array.isArray(response.documents) ? response.documents : []);
            if (showLoadingToast) toast.success("Document list refreshed.", { id: toastId });
        } catch (err) {
            const errorMessage = err.message || "Failed to fetch admin documents.";
            setError(errorMessage);
            if (showLoadingToast) toast.error(errorMessage, { id: toastId });
            else toast.error(errorMessage); // Show toast on initial load failure too
        } finally {
            if (!showLoadingToast) setIsLoading(false);
        }
    }, []); // No dependencies that change frequently, getFixedAdminAuthHeaders is stable

    useEffect(() => {
        fetchAdminDocs(); // Fetch documents when component mounts
    }, [fetchAdminDocs]);

    const handleDeleteDocument = async (serverFilename, originalName) => {
        if (!window.confirm(`Are you sure you want to delete admin document "${originalName}"? This action will remove its record and any associated analysis.`)) return;
        
        const toastId = toast.loading(`Deleting "${originalName}"...`);
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            await adminApi.deleteAdminDocument(serverFilename, authHeaders);
            toast.success(`Admin document "${originalName}" deleted.`, { id: toastId });
            fetchAdminDocs(); // Refresh the list
            if (isAnalysisModalOpen && currentDocForModal?.serverFilename === serverFilename) {
                setIsAnalysisModalOpen(false); // Close modal if the deleted doc was being viewed
            }
        } catch (err) {
            toast.error(err.message || `Failed to delete "${originalName}".`, { id: toastId });
        }
    };

    const handleViewAnalysis = async (doc) => {
        setCurrentDocForModal(doc);
        setAnalysisContent(null);      // Clear previous analysis
        setIsAnalysisModalOpen(true); // Open modal
        setIsLoadingAnalysis(true);   // Set loading state for analysis
        try {
            const authHeaders = adminApi.getFixedAdminAuthHeaders();
            const response = await adminApi.getAdminDocumentAnalysis(doc.serverFilename, authHeaders);
            setAnalysisContent(response.analysis); // response.analysis = {faq, topics, mindmap}
            // toast.success(`Analysis loaded for ${doc.originalName}`); // Optional success toast
        } catch (err) {
            toast.error(`Failed to load analysis for ${doc.originalName}: ${err.message}`);
            setAnalysisContent({ error: `Failed to load analysis: ${err.message}` }); // Show error in modal
        } finally {
            setIsLoadingAnalysis(false);
        }
    };

    const renderAnalysisModalContent = () => {
        if (!currentDocForModal) return null; // Should not happen if modal is open

        if (isLoadingAnalysis) {
            return <div className="p-6 text-center"><Loader2 className="animate-spin text-primary inline-block mr-2"/>Loading analysis content...</div>;
        }
        if (!analysisContent) {
            return <div className="p-4 text-text-muted-light dark:text-text-muted-dark">No analysis data currently available for this document. It might still be processing or was skipped.</div>;
        }
        if (analysisContent.error) {
            return <div className="p-4 text-red-500 dark:text-red-400 text-sm">Error: {analysisContent.error}</div>;
        }

        // Check if all analysis fields are effectively empty or placeholder messages
        const isEmpty = (str) => !str || str.trim() === "" || str.toLowerCase().startsWith("skipped:") || str.toLowerCase().startsWith("notice:");
        const allAnalysesEmpty = isEmpty(analysisContent.faq) && isEmpty(analysisContent.topics) && isEmpty(analysisContent.mindmap);

        if (allAnalysesEmpty) {
            return <div className="p-4 text-text-muted-light dark:text-text-muted-dark">Analysis processing may have been skipped or resulted in no content for all types.</div>;
        }

        return (
            <div className="space-y-3 max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2">
                {Object.entries(analysisContent).map(([key, value]) => {
                    const displayValue = (typeof value === 'string' && value.trim()) ? value : `No content generated for ${key}.`;
                    return (
                        <details key={key} className="text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-surface-dark" open>
                            <summary className="font-medium cursor-pointer capitalize p-2 bg-gray-50 dark:bg-gray-700/60 hover:bg-gray-100 dark:hover:bg-gray-600/60 rounded-t-md transition-colors">
                                {key.replace(/([A-Z])/g, ' $1').trim()} {/* e.g., mindmap -> Mind Map */}
                            </summary>
                            <pre className="p-2.5 bg-white dark:bg-gray-800 text-text-light dark:text-text-dark text-[0.7rem] max-h-60 overflow-y-auto custom-scrollbar whitespace-pre-wrap break-words rounded-b-md">
                                <code>{displayValue}</code>
                            </pre>
                        </details>
                    );
                })}
            </div>
        );
    };
    
    // --- Main JSX for AdminDashboardPage ---
    return (
        <div className="min-h-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark p-4 sm:p-6">
            <header className="flex items-center justify-between mb-6 pb-3 border-b border-border-light dark:border-border-dark">
                <h1 className="text-2xl font-bold">Admin Dashboard</h1>
                <div className="flex items-center gap-2">
                    <IconButton
                        icon={RefreshCw}
                        onClick={() => fetchAdminDocs(true)} // Pass true to show loading toast
                        title="Refresh Document List"
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                    />
                    <Button onClick={adminLogoutHandler} variant="danger" size="sm" leftIcon={<LogOut size={16}/>}>
                        Logout Admin
                    </Button>
                </div>
            </header>

            <AdminDocumentUpload onUploadSuccess={() => fetchAdminDocs(false)} /> {/* Don't show toast for auto-refresh */}

            <div className="card-base p-0 sm:p-4">
                <h2 className="text-lg font-semibold mb-3 text-text-light dark:text-text-dark px-4 sm:px-0 pt-4 sm:pt-0">
                    Uploaded Admin Documents
                </h2>
                {isLoading && (
                    <div className="flex items-center justify-center p-6">
                        <Loader2 size={24} className="animate-spin text-primary mr-2" /> Loading documents...
                    </div>
                )}
                {error && (
                    <div className="p-3 my-3 mx-4 sm:mx-0 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
                        <AlertTriangle size={18} /> {error}
                        <button onClick={() => fetchAdminDocs(true)} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
                    </div>
                )}
                {!isLoading && !error && documents.length === 0 && (
                    <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark py-6 px-4 sm:px-0">
                        No admin documents uploaded yet.
                    </p>
                )}
                {!isLoading && !error && documents.length > 0 && (
                    <div className="overflow-x-auto custom-scrollbar">
                        <table className="w-full text-sm text-left">
                            <thead className="bg-gray-50 dark:bg-gray-800">
                                <tr>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium">Original Name</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium hidden md:table-cell">Uploaded</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium">Analysis Status</th>
                                    <th className="px-3 sm:px-4 py-2.5 font-medium text-center">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {documents.map((doc) => (
                                    <tr key={doc.serverFilename} className="border-b border-border-light dark:border-border-dark hover:bg-gray-50/50 dark:hover:bg-gray-700/30 transition-colors">
                                        <td className="px-3 sm:px-4 py-2 truncate max-w-[150px] sm:max-w-xs" title={doc.originalName}>{doc.originalName}</td>
                                        <td className="px-3 sm:px-4 py-2 whitespace-nowrap hidden md:table-cell">
                                            {doc.uploadedAt ? format(new Date(doc.uploadedAt), 'MMM d, yyyy HH:mm') : 'N/A'}
                                        </td>
                                        <td className="px-3 sm:px-4 py-2">
                                            {(doc.hasFaq || doc.hasTopics || doc.hasMindmap) ? (
                                                <span className="flex items-center text-green-600 dark:text-green-400 text-xs">
                                                    <CheckCircle size={14} className="mr-1"/> Generated
                                                </span>
                                            ) : (
                                                doc.analysisUpdatedAt ? // If updated but still no content, means it was empty
                                                <span className="text-gray-500 dark:text-gray-400 text-xs">Empty/Skipped</span> :
                                                <span className="text-yellow-500 dark:text-yellow-400 text-xs">Pending</span>
                                            )}
                                        </td>
                                        <td className="px-1 sm:px-4 py-2 text-center whitespace-nowrap">
                                            <IconButton
                                                icon={Eye}
                                                title="View Analysis"
                                                size="sm"
                                                variant="ghost"
                                                className="text-primary hover:text-primary-dark dark:text-primary-light dark:hover:text-primary-darker mr-0.5 sm:mr-1"
                                                onClick={() => handleViewAnalysis(doc)}
                                                disabled={isLoadingAnalysis && currentDocForModal?.serverFilename === doc.serverFilename}
                                            />
                                            <IconButton
                                                icon={Trash2}
                                                title="Delete Document"
                                                size="sm"
                                                variant="ghost"
                                                className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                                                onClick={() => handleDeleteDocument(doc.serverFilename, doc.originalName)}
                                            />
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                )}
            </div>

            <Modal
                isOpen={isAnalysisModalOpen}
                onClose={() => setIsAnalysisModalOpen(false)}
                title={`Analysis Results: ${currentDocForModal?.originalName || 'Document'}`}
                size="2xl"
            >
                {renderAnalysisModalContent()}
            </Modal>
        </div>
    );
}

export default AdminDashboardPage;
```

`src/components/admin/AdminProtectedRoute.jsx`

```javascript
// frontend/src/components/admin/AdminProtectedRoute.jsx
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAppState } from '../../contexts/AppStateContext.jsx'; // Using AppStateContext
import toast from 'react-hot-toast'; // Optional: for a message if redirecting

function AdminProtectedRoute({ children }) { // Accept children for different react-router-dom versions
    const { isAdminSessionActive } = useAppState(); // Get the admin session flag
    const location = useLocation();

    if (!isAdminSessionActive) {
        // If admin session is not active, redirect the user.
        // Redirecting to the main page ('/') is a common approach.
        // The main App component's logic will then likely show the AuthModal
        // if no regular user is logged in either.
        console.log("AdminProtectedRoute: Admin session not active. Redirecting from", location.pathname);
        toast.error("Admin access required. Please log in as admin."); // Optional feedback
        return <Navigate to="/" state={{ from: location }} replace />;
    }

    // If admin session is active, render the child components (the protected route's content)
    return children ? children : <Outlet />; // Outlet is for v6 nested routes, children for direct wrapping
}

export default AdminProtectedRoute;
```

`src/components/analysis/AnalysisTool.jsx`

```javascript
// frontend/src/components/analysis/AnalysisTool.jsx
import React, { useState } from 'react';
import api from '../../services/api.js'; // Assuming .js for services
import toast from 'react-hot-toast';
import MindmapViewer from './MindmapViewer.jsx';
import { ChevronDown, ChevronUp, Loader2, AlertTriangle } from 'lucide-react'; // Loader2 is imported once here
import * as LucideIcons from 'lucide-react'; // For dynamic icon selection by name
import { marked } from 'marked';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx'; // Import IconButton
import { motion } from 'framer-motion'; // Import motion
import DOMPurify from 'dompurify';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    const rawHtml = marked.parse(markdownText);
    const cleanHtml = DOMPurify.sanitize(rawHtml);
    return { __html: cleanHtml };
};

const escapeHtml = (unsafe) => { // Helper for <pre> tags if thinking content isn't markdown
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

function AnalysisTool({ toolType, title, iconName, selectedDocumentFilename }) {
    const [isOpen, setIsOpen] = useState(false);
    const [result, setResult] = useState(null);
    const [thinking, setThinking] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [isFetchingStored, setIsFetchingStored] = useState(false); // For fetching stored data


    // Dynamically select icon component based on iconName prop
    const IconComponent = LucideIcons[iconName] || LucideIcons.HelpCircle; // Default to HelpCircle if not found
    console.log('selectedDocumentFilename :::: ', selectedDocumentFilename);
    

    


    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document from the left panel first.");
            return;
        }
        setIsLoading(true);
        setError('');
        setResult(null);
        setThinking(null);
        const toastId = toast.loading(`Generating ${title} for ${selectedDocumentFilename}...`);

        try {
            
            const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
            const response = await api.requestAnalysis(payload); // Mocked in V1
            setResult(response.content);
            setThinking(response.thinking);
            setIsOpen(true); 
            toast.success(`${title} generated (mock data)!`, { id: toastId });
        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || `Failed to generate ${title}.`;
            setError(errorMessage);
            toast.error(errorMessage, { id: toastId });
            console.error("AnalysisTool Error:", err);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="card-base p-3"> {/* Use themed card style from index.css */}
            <div className="flex items-center justify-between">
                <button 
                    onClick={() => setIsOpen(!isOpen)}
                    className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left hover:text-primary dark:hover:text-primary-light transition-colors"
                    aria-expanded={isOpen}
                >
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </button>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button
                        onClick={handleRunAnalysis}
                        variant="primary" 
                        size="sm"
                        className="!px-3 !py-1 text-xs" // Override Button padding for smaller size
                        isLoading={isLoading} // Button component handles its own loader icon
                        disabled={isLoading || !selectedDocumentFilename}
                        title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}
                    >
                       Run
                    </Button>
                    <IconButton 
                        icon={isOpen ? ChevronUp : ChevronDown} 
                        onClick={() => setIsOpen(!isOpen)} 
                        size="sm" 
                        variant="ghost"
                        className="p-1" // Ensure IconButton has padding if its default is too large
                        aria-label={isOpen ? "Collapse section" : "Expand section"}
                    />
                </div>
            </div>

            {isOpen && (
                <motion.div 
                    initial={{ height: 0, opacity: 0 }} 
                    animate={{ height: 'auto', opacity: 1 }} 
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden" 
                >
                    <div className="space-y-2"> {/* Added wrapper for consistent spacing */}
                        {isLoading && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center gap-2">
                                <Loader2 size={14} className="animate-spin"/>Generating...
                            </p>
                        )}
                        {error && (
                            <div className="p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1">
                                <AlertTriangle size={14} /> {error}
                            </div>
                        )}
                        {thinking && !error && (
                            <details className="text-xs" open={!!result}> {/* Open if result is also present */}
                                <summary className="cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light font-medium">
                                    AI Reasoning
                                </summary>
                                <pre className="mt-1 p-1.5 bg-gray-100 dark:bg-gray-900 rounded text-[0.7rem] max-h-28 overflow-y-auto custom-scrollbar whitespace-pre-wrap break-words">
                                    <code>{escapeHtml(thinking)}</code>
                                </pre>
                            </details>
                        )}
                        {result && !error && (
                            toolType === 'mindmap' ? (
                                <MindmapViewer markdownContent={result} />
                            ) : (
                                <div 
                                    className="prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed"
                                    dangerouslySetInnerHTML={createMarkup(result)}
                                />
                            )
                        )}
                        {!isLoading && !result && !error && !selectedDocumentFilename && (
                             <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">Select a document to run analysis.</p>
                        )}
                         {!isLoading && !result && !error && selectedDocumentFilename && (
                             <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">Click "Run" to generate analysis.</p>
                        )}
                    </div>
                </motion.div>
            )}
        </div>
    );
}
export default AnalysisTool;
```

`src/components/analysis/AnalysisToolRunner.jsx`

```javascript
// src/components/analysis/AnalysisToolRunner.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { ChevronDown, ChevronUp, Loader2, Eye, AlertTriangle, Sparkles, HelpCircle as DefaultIcon, Download } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import Modal from '../core/Modal.jsx';
import { marked } from 'marked';
import MindmapViewer from './MindmapViewer.jsx'; 
import DOMPurify from 'dompurify';
import Prism from 'prismjs'; 
import { renderMathInHtml } from '../../utils/markdownUtils';
import { useAppState } from '../../contexts/AppStateContext.jsx'; 

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
    if (!markdownText) return { __html: '' };
    let html = marked.parse(markdownText);
    html = renderMathInHtml(html); 
    const cleanHtml = DOMPurify.sanitize(html, {
        USE_PROFILES: { html: true, mathMl: true, svg: true }, 
        ADD_TAGS: ['iframe'], 
        ADD_ATTR: ['allow', 'allowfullscreen', 'frameborder', 'scrolling'],
    });
    return { __html: cleanHtml };
};

const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, '"').replace(/'/g, "'");
};

const ENGAGEMENT_TEXTS = {
    faq: ["Analyzing FAQs...", "Identifying questions...", "Compiling answers..."],
    topics: ["Extracting topics...", "Identifying themes...", "Summarizing points..."],
    mindmap: ["Generating mind map...", "Structuring concepts...", "Visualizing..."],
    default: ["Processing...", "Thinking...", "Working on it..."]
};

// Placeholder messages to check against for AI Reasoning section
const placeholderReasoningMessages = [
    "Retrieved stored analysis. No detailed AI reasoning provided.",
    "AI reasoning not available.",
    "Mock generation for",
    "Retrieved stored mindmap data. No specific thinking process recorded in content."
];

function AnalysisToolRunner({ toolType, title, iconName, selectedDocumentFilename }) {
    const [isSectionOpen, setIsSectionOpen] = useState(true);
    const [isDropdownOpen, setIsDropdownOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [analysisContent, setAnalysisContent] = useState(null);
    const [aiReasoning, setAiReasoning] = useState(null);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [currentEngagementText, setCurrentEngagementText] = useState('');

    const IconComponent = LucideIcons[iconName] || DefaultIcon;
    const modalAnalysisContentRef = useRef(null);
    const aiReasoningContentRef = useRef(null);
    const mindmapViewerRef = useRef(null); 
    const { theme: appTheme } = useAppState(); 

    useEffect(() => {
        let intervalId;
        if (isLoading) {
            const texts = ENGAGEMENT_TEXTS[toolType] || ENGAGEMENT_TEXTS.default;
            let textIndex = 0;
            setCurrentEngagementText(texts[0]);
            intervalId = setInterval(() => {
                textIndex = (textIndex + 1) % texts.length;
                setCurrentEngagementText(texts[textIndex]);
            }, 1800);
        } else {
            setCurrentEngagementText('');
        }
        return () => clearInterval(intervalId);
    }, [isLoading, toolType]);

    useEffect(() => {
        if (!selectedDocumentFilename) {
            setIsLoading(false);
            setError('');
            setAnalysisContent(null);
            setAiReasoning(null);
            setIsDropdownOpen(false);
        } else {
            // When a new document is selected, optionally reset previous results
            // to avoid showing old data before a new "Run"
             setAnalysisContent(null);
             setAiReasoning(null);
             setIsDropdownOpen(false);
             setError('');
             setIsLoading(false); // Ensure loading state is reset
        }
    }, [selectedDocumentFilename]);

    useEffect(() => {
        if (isModalOpen && analysisContent && toolType !== 'mindmap' && modalAnalysisContentRef.current) {
            const timer = setTimeout(() => {
                if (modalAnalysisContentRef.current) Prism.highlightAllUnder(modalAnalysisContentRef.current);
            }, 50);
            return () => clearTimeout(timer);
        }
    }, [isModalOpen, analysisContent, toolType]);

    useEffect(() => {
        if (aiReasoningContentRef.current && aiReasoning && isDropdownOpen) {
            const timer = setTimeout(() => {
                if (aiReasoningContentRef.current) Prism.highlightAllUnder(aiReasoningContentRef.current);
            }, 0);
            return () => clearTimeout(timer);
        }
    }, [aiReasoning, isDropdownOpen]);

    const handleRunAnalysis = async () => {
        if (!selectedDocumentFilename) {
            toast.error("Please select a document first.");
            return;
        }
        setIsLoading(true);
        setError('');
        setAnalysisContent(null);
        setAiReasoning(null);
        setIsDropdownOpen(false);

        const payload = { filename: selectedDocumentFilename, analysis_type: toolType };
        const toastId = toast.loading(`Generating ${title} for "${selectedDocumentFilename}"...`);

        try {
            const response = await api.requestAnalysis(payload);
            toast.dismiss(toastId);

            if (response) {
                if (response.content && response.content.trim() !== "" && !response.content.startsWith("Error:")) {
                    setAnalysisContent(response.content);
                    toast.success(`${title} analysis complete! Click 'View Full ${title}' to see details.`);
                } else if (response.content && response.content.startsWith("Error:")) {
                    setError(response.content);
                    toast.error(`Error in ${title}: ${response.content.substring(0, 100)}...`);
                } else {
                    setError(`No content returned for ${title}.`);
                    toast.warn(`No content was generated for ${title}.`);
                }

                if (response.thinking && response.thinking.trim() !== "") {
                    setAiReasoning(response.thinking);
                } else {
                    setAiReasoning(response.content ? "Retrieved stored analysis. No detailed AI reasoning provided." : "AI reasoning not available.");
                }
                setIsDropdownOpen(true);
            } else {
                throw new Error("Empty response from analysis service.");
            }
        } catch (err) {
            toast.dismiss(toastId);
            const errorMessage = err.message || `Failed to generate or fetch ${title}.`;
            setError(errorMessage);
            toast.error(errorMessage);
            console.error(`Run ${title} Analysis Error:`, err);
            setIsDropdownOpen(false);
        } finally {
            setIsLoading(false);
        }
    };

    const handleDownloadMindmap = async (format = 'svg') => {
        if (mindmapViewerRef.current && mindmapViewerRef.current.getSvgElement) {
            const svgElement = mindmapViewerRef.current.getSvgElement();
            if (!svgElement) {
                toast.error("Mindmap SVG element not found or not rendered yet.");
                return;
            }

            const filenameBase = selectedDocumentFilename ? selectedDocumentFilename.split('.')[0] : 'mindmap';
            const filename = `${filenameBase}_${toolType}.${format}`;

            if (format === 'svg') {
                const serializer = new XMLSerializer();
                let svgString = serializer.serializeToString(svgElement);
                svgString = '<?xml version="1.0" standalone="no"?>\r\n' + svgString;
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                toast.success("SVG downloaded!");
            } else if (format === 'png') {
                const pngToastId = toast.loading("Preparing PNG download...");
                try {
                    // Ensure save-svg-as-png is available (e.g., npm install save-svg-as-png)
                    // If it's not working, common issues include:
                    // 1. Library not installed/imported correctly.
                    // 2. Complex SVG features (e.g., foreignObject, certain CSS filters) that the library doesn't support.
                    // 3. Browser security restrictions if the SVG contains external resources (unlikely for Mermaid).
                    // 4. Very large SVGs causing memory issues.
                    const { saveSvgAsPng } = await import('save-svg-as-png');
                    if (saveSvgAsPng) {
                        saveSvgAsPng(svgElement, filename, { 
                            scale: 2, 
                            backgroundColor: appTheme === 'dark' ? '#1E293B' : '#FFFFFF' 
                        });
                        toast.success("PNG download started!", { id: pngToastId });
                    } else {
                        throw new Error("saveSvgAsPng function not found after import.");
                    }
                } catch (e) {
                    console.error("Error loading/using save-svg-as-png:", e);
                    toast.error(`Failed to export PNG: ${e.message}. SVG export is available. Consider checking console for details if library is missing.`, { id: pngToastId });
                }
            }
        } else {
            toast.error("Mindmap viewer component not ready or SVG not available.");
        }
    };
    
    const renderModalContent = () => {
        if (isLoading && !analysisContent) {
            return (
                <div className="flex items-center justify-center h-48">
                    <Loader2 size={32} className="animate-spin text-primary" />
                    <p className="ml-2 text-text-muted-light dark:text-text-muted-dark">Loading analysis...</p>
                </div>
            );
        }
        if (error && !analysisContent) {
             return <p className="p-4 text-center text-red-500 dark:text-red-400">{error}</p>;
        }
        if (!analysisContent) {
            return <p className="p-4 text-center text-text-muted-light dark:text-text-muted-dark">No analysis content available to display.</p>;
        }

        if (toolType === 'mindmap') {
            return (
                <div className="mindmap-modal-content-wrapper min-h-[60vh] h-[calc(70vh-80px)] flex justify-center items-center">
                     <MindmapViewer mermaidCode={analysisContent} ref={mindmapViewerRef} />
                </div>
            );
        }
        return (
            <div
                ref={modalAnalysisContentRef}
                className="prose prose-sm dark:prose-invert max-w-none text-text-light dark:text-text-dark p-1 custom-scrollbar text-[0.8rem] leading-relaxed"
                dangerouslySetInnerHTML={createMarkup(analysisContent)}
            />
        );
    };

    // Determine if AI reasoning is substantial or just a placeholder
    const showReasoning = aiReasoning && !placeholderReasoningMessages.some(msg => aiReasoning.includes(msg));

    return (
        <div className="card-base p-3">
            <div className="flex items-center justify-between">
                <div
                    className="flex items-center gap-2 text-sm font-medium text-text-light dark:text-text-dark focus:outline-none w-full text-left cursor-pointer hover:text-primary dark:hover:text-primary-light transition-colors"
                    onClick={() => setIsSectionOpen(!isSectionOpen)}
                    aria-expanded={isSectionOpen}
                >
                    <IconComponent size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
                    <span className="flex-grow">{title}</span>
                </div>
                <div className="flex items-center gap-1 flex-shrink-0">
                    <Button
                        onClick={handleRunAnalysis}
                        variant="primary"
                        size="sm"
                        className="!px-3 !py-1 text-xs"
                        isLoading={isLoading}
                        disabled={!selectedDocumentFilename || isLoading}
                        title={!selectedDocumentFilename ? "Select a document first" : `Run ${title} Analysis`}
                    >
                       {isLoading ? (currentEngagementText.split(' ')[0] || "...") : "Run"}
                    </Button>
                    <IconButton
                        icon={isSectionOpen ? ChevronUp : ChevronDown}
                        onClick={() => setIsSectionOpen(!isSectionOpen)}
                        size="sm"
                        variant="ghost"
                        className="p-1"
                        aria-label={isSectionOpen ? "Collapse section" : "Expand section"}
                        disabled={isLoading && isSectionOpen}
                    />
                </div>
            </div>

            <AnimatePresence>
                {isSectionOpen && (
                    <motion.div
                        key="tool-section-content"
                        initial={{ height: 0, opacity: 0 }}
                        animate={{ height: 'auto', opacity: 1 }}
                        exit={{ height: 0, opacity: 0 }}
                        transition={{ duration: 0.25, ease: "easeInOut" }}
                        className="mt-2 pt-2 border-t border-border-light dark:border-border-dark overflow-hidden"
                    >
                        {isLoading && (
                            <div className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 flex items-center justify-center gap-2 animate-fadeIn">
                                <Loader2 size={14} className="animate-spin"/> {currentEngagementText}
                            </div>
                        )}

                        {error && !isLoading && (
                            <div className="my-2 p-2 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-xs flex items-center gap-1">
                                <AlertTriangle size={14} /> {error.length > 150 ? error.substring(0,147) + "..." : error}
                            </div>
                        )}

                        {!isLoading && !error && (analysisContent || aiReasoning) && isDropdownOpen && (
                            <motion.div
                                key="analysis-dropdown"
                                initial={{ opacity: 0, y: -10 }}
                                animate={{ opacity: 1, y: 0 }}
                                exit={{ opacity: 0, y: -10 }}
                                transition={{ duration: 0.2 }}
                                className="mt-2 space-y-2"
                            >
                                {showReasoning && aiReasoning && ( // Conditionally render based on showReasoning
                                    <details className="group text-xs rounded-md border border-border-light dark:border-border-dark bg-surface-light dark:bg-gray-800 shadow-sm">
                                        <summary className="flex items-center justify-between gap-1 p-2 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors rounded-t-md">
                                            <span className="flex items-center gap-1.5 font-medium">
                                                <Sparkles size={14} className="text-accent" /> AI Reasoning
                                            </span>
                                            <ChevronDown size={16} className="group-open:rotate-180 transition-transform" />
                                        </summary>
                                        <div
                                            ref={aiReasoningContentRef}
                                            className="p-2.5 prose prose-xs dark:prose-invert max-w-none text-text-light dark:text-text-dark max-h-60 overflow-y-auto custom-scrollbar text-[0.75rem] leading-relaxed bg-gray-50 dark:bg-gray-900/50 rounded-b-md"
                                            dangerouslySetInnerHTML={createMarkup(aiReasoning)}
                                        />
                                    </details>
                                )}

                                {analysisContent && ( 
                                     <Button
                                        onClick={() => setIsModalOpen(true)}
                                        variant="outline" 
                                        size="sm"
                                        fullWidth
                                        leftIcon={<Eye size={14}/>}
                                        className="!py-1.5 text-xs border-primary/70 text-primary hover:bg-primary/10 dark:border-primary-light/70 dark:text-primary-light dark:hover:bg-primary-light/10"
                                    >
                                       View Full {title}
                                    </Button>
                                )}
                            </motion.div>
                        )}
                        
                        {!isLoading && !isDropdownOpen && !error && (
                            <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2 text-center">
                                {selectedDocumentFilename ? `Click "Run" to generate ${title} for "${selectedDocumentFilename}".` : "Select a document to enable analysis."}
                            </p>
                        )}
                    </motion.div>
                )}
            </AnimatePresence>

            <Modal
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                title={`${title} for "${selectedDocumentFilename || 'document'}"`}
                size={toolType === 'mindmap' ? "3xl" : "xl"}
                footerContent={
                    <>
                        {toolType === 'mindmap' && analysisContent && (
                            <>
                                <Button onClick={() => handleDownloadMindmap('svg')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>SVG</Button>
                                {/* <Button onClick={() => handleDownloadMindmap('png')} variant="outline" size="sm" className="text-xs" leftIcon={<Download size={14}/>}>PNG</Button> */}
                                <div className="flex-grow"></div> {/* Spacer */}
                            </>
                        )}
                        <Button onClick={() => setIsModalOpen(false)} variant="secondary" size="sm" className="text-xs">Close</Button>
                    </>
                }
            >
                <div className={`max-h-[70vh] overflow-y-auto custom-scrollbar p-1 pr-2 rounded-md shadow-inner ${toolType === 'mindmap' ? 'bg-transparent dark:bg-transparent' : 'bg-gray-50 dark:bg-gray-800'}`}>
                    {selectedDocumentFilename && (
                        <p className="text-xs text-text-muted-light dark:text-text-muted-dark mb-2 border-b border-border-light dark:border-border-dark pb-1.5">
                            Source Document: <strong>{selectedDocumentFilename}</strong>
                        </p>
                    )}
                    {renderModalContent()}
                </div>
            </Modal>
        </div>
    );
}
export default AnalysisToolRunner;
```

`src/components/analysis/MindmapViewer.jsx`

```javascript
// frontend/src/components/analysis/MindmapViewer.jsx
import React, { useEffect, useRef, useState, useImperativeHandle, forwardRef } from 'react';
import toast from 'react-hot-toast';
import { escapeHtml } from '../../utils/helpers.js'; // Import escapeHtml helper

const MindmapViewer = forwardRef(({ mermaidCode }, ref) => {
    const svgContainerRef = useRef(null);
    const [error, setError] = useState(null);
    const [isMermaidReady, setIsMermaidReady] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    const [uniqueId] = useState(() => `mermaid-graph-${Math.random().toString(36).substr(2, 9)}`);

    useImperativeHandle(ref, () => ({
        getSvgElement: () => {
            return svgContainerRef.current?.querySelector('svg');
        }
    }));

    useEffect(() => {
        if (typeof window.mermaid !== 'undefined') {
            setIsMermaidReady(true);
        } else {
            const intervalId = setInterval(() => {
                if (typeof window.mermaid !== 'undefined') {
                    setIsMermaidReady(true);
                    clearInterval(intervalId);
                }
            }, 100);
            return () => clearInterval(intervalId);
        }
    }, []);

    useEffect(() => {
        if (!isMermaidReady || !mermaidCode || !svgContainerRef.current) {
            if (svgContainerRef.current) svgContainerRef.current.innerHTML = '';
            setError(null);
            setIsLoading(false);
            return;
        }

        const renderMermaidDiagram = async () => {
            setIsLoading(true);
            setError(null);
            if (!svgContainerRef.current) {
                setIsLoading(false);
                return;
            }
            svgContainerRef.current.innerHTML = '<div class="flex justify-center items-center h-full w-full text-sm text-text-muted-light dark:text-text-muted-dark"><div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-primary mr-2"></div>Rendering diagram...</div>';
            
            let codeToRender = mermaidCode.trim();
            // Remove Markdown code fences: ```mermaid ... ``` or ``` ... ```
            // Regex explanation:
            // ^```         - Matches starting triple backticks
            // (?:mermaid\b)? - Optionally matches "mermaid" followed by a word boundary (case-insensitive due to i flag)
            // \s*          - Matches any whitespace (including newlines) after "mermaid" or ```
            // ([\s\S]*?)  - Captures the actual Mermaid code (non-greedy)
            // \s*          - Matches any whitespace before closing backticks
            // ```$         - Matches closing triple backticks at the end of the string
            // i            - Case-insensitive flag (for "mermaid" keyword)
            const fenceRegex = /^```(?:mermaid\b)?\s*([\s\S]*?)\s*```$/i;
            const match = codeToRender.match(fenceRegex);
            if (match && match[1]) {
                codeToRender = match[1].trim(); // Use the captured group
            }
            
            try {
                if (typeof window.mermaid === 'undefined') {
                    throw new Error("Mermaid library failed to load or initialize properly.");
                }

                const { svg, bindFunctions } = await window.mermaid.render(uniqueId, codeToRender);
                
                if (svgContainerRef.current) {
                    svgContainerRef.current.innerHTML = svg;
                    if (bindFunctions) {
                        bindFunctions(svgContainerRef.current);
                    }
                    const svgElement = svgContainerRef.current.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.width = '100%';
                        svgElement.style.height = 'auto'; 
                        svgElement.style.maxWidth = '100%'; 
                        svgElement.style.display = 'block';
                    }
                }
            } catch (e) {
                console.error("Error rendering Mermaid diagram with input:", codeToRender, e);
                const errorMsg = e.message || "Failed to render mind map. Invalid Mermaid syntax?";
                setError(errorMsg);
                if (svgContainerRef.current) {
                    const codeSnippet = escapeHtml(codeToRender.substring(0, 200) + (codeToRender.length > 200 ? "..." : ""));
                    svgContainerRef.current.innerHTML = `<div class="p-4 text-center text-red-500 dark:text-red-400 text-xs break-all"><strong>Error rendering:</strong> ${escapeHtml(errorMsg)}<br><strong class='mt-2 block'>Input Code (first 200 chars):</strong><pre class='text-left text-xs bg-gray-100 dark:bg-gray-700 p-2 rounded mt-1 whitespace-pre-wrap'>${codeSnippet}</pre></div>`;
                }
            } finally {
                setIsLoading(false);
            }
        };

        const timer = setTimeout(renderMermaidDiagram, 100); 
        return () => clearTimeout(timer);
        
    }, [mermaidCode, uniqueId, isMermaidReady]);

    if (!isMermaidReady && !error) {
      return <div className="p-4 text-center text-text-muted-light dark:text-text-muted-dark text-xs">Waiting for Mermaid.js library...</div>;
    }
    if (error && (!isLoading || (svgContainerRef.current && svgContainerRef.current.innerHTML.includes('Error rendering')))) {
        return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
                {/* Error message will be injected by useEffect's catch block */}
               </div>;
    }
    
    if (isLoading) { 
         return <div ref={svgContainerRef} className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md">
            {/* Loading message is set by renderMermaidDiagram's initial innerHTML write */}
         </div>;
    }

    if (!mermaidCode && !error && isMermaidReady) { 
        return <p className="text-xs text-center text-text-muted-light dark:text-text-muted-dark p-4">No mind map data to display.</p>;
    }
    
    return (
        <div 
            ref={svgContainerRef} 
            className="mermaid-diagram-render-area w-full h-full flex justify-center items-center bg-gray-50 dark:bg-gray-800/50 p-2 rounded-md"
        >

        </div>
    );
});

export default MindmapViewer;
```

`src/components/analysis/RightPanel.jsx`

```javascript
// frontend/src/components/layout/RightPanel.jsx
import React, { useState } from 'react';
import { useAppState } from '../../contexts/AppStateContext';
import AnalysisTool from '../analysis/AnalysisTool.jsx'; // Added .jsx
import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Added .jsx
import { motion } from 'framer-motion';

function RightPanel() {
    const { setIsRightPanelOpen, selectedDocumentForAnalysis } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    const currentSelectedDocFilename = selectedDocumentForAnalysis?.originalName || null;

    return (
        <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                <IconButton 
                    icon={PanelRightClose} 
                    onClick={() => setIsRightPanelOpen(false)} 
                    title="Close Analyzer Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>
            
            <button 
                onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
                className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
            >
                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </button>

            {isAnalyzerOpen && (
                <motion.div 
                    initial={{ height: 0, opacity: 0 }} 
                    animate={{ height: 'auto', opacity: 1 }} 
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
                >
                    {!currentSelectedDocFilename && (
                        <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable analysis tools.</p>
                        </div>
                    )}
                    <AnalysisTool toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} />
                    <AnalysisTool toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} />
                    <AnalysisTool toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} />
                </motion.div>
            )}
        </div>
    );
}
export default RightPanel;
```

`src/components/auth/AuthModal.jsx`

```javascript
// frontend/src/components/auth/AuthModal.jsx
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom'; // For admin navigation
import { useAuth } from '../../hooks/useAuth.jsx'; // For regular user login/signup
import { useAppState } from '../../contexts/AppStateContext.jsx'; // For setting admin session flag
import LLMSelection from './LLMSelection.jsx';
import api from '../../services/api.js'; // For regular user LLM config updates
import toast from 'react-hot-toast';
import { LogIn, UserPlus, X, Terminal, KeyRound, Link2, User as UserIcon, AlertCircle } from 'lucide-react';
import Button from '../core/Button.jsx';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

// Get admin credentials from .env (ensure VITE_ prefix for Vite)
const ADMIN_USERNAME_FRONTEND = import.meta.env.VITE_ADMIN_USERNAME || 'admin';
const ADMIN_PASSWORD_FRONTEND = import.meta.env.VITE_ADMIN_PASSWORD || 'admin123';

function AuthModal({ isOpen, onClose }) { // onClose expects authData or {isAdminLogin: true} or null
    const {
        login: regularUserLogin, // Renamed to avoid conflict
        signup: regularUserSignup, // Renamed
        devLogin,
        DEV_MODE_ALLOW_DEV_LOGIN,
        MOCK_DEV_USERNAME, MOCK_DEV_PASSWORD
    } = useAuth();
    const {
        selectedLLM: globalSelectedLLM,
        switchLLM: setGlobalLLM,
        setIsAdminSessionActive // Function from AppStateContext
    } = useAppState();
    const navigate = useNavigate();

    const [isLoginView, setIsLoginView] = useState(true);
    const [username, setUsername] = useState(DEV_MODE_ALLOW_DEV_LOGIN && isLoginView ? (MOCK_DEV_USERNAME || '') : '');
    const [password, setPassword] = useState(DEV_MODE_ALLOW_DEV_LOGIN && isLoginView ? (MOCK_DEV_PASSWORD || '') : '');
    const [localSelectedLLM, setLocalSelectedLLM] = useState(globalSelectedLLM || 'ollama');
    const [geminiApiKey, setGeminiApiKey] = useState('');
    const [ollamaApiUrl, setOllamaApiUrl] = useState('');

    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const [devLoginLoading, setDevLoginLoading] = useState(false);

    useEffect(() => {
        if (isOpen) {
            setError('');
            // Reset username/password based on view, unless dev mode pre-fills for login
            if (isLoginView) {
                setUsername(DEV_MODE_ALLOW_DEV_LOGIN ? (MOCK_DEV_USERNAME || '') : '');
                setPassword(DEV_MODE_ALLOW_DEV_LOGIN ? (MOCK_DEV_PASSWORD || '') : '');
            } else { // Signup view
                setUsername('');
                setPassword('');
            }
            setLocalSelectedLLM(globalSelectedLLM || 'ollama');
            setGeminiApiKey('');
            setOllamaApiUrl('');
        }
    }, [isOpen, isLoginView, DEV_MODE_ALLOW_DEV_LOGIN, MOCK_DEV_USERNAME, MOCK_DEV_PASSWORD, globalSelectedLLM]);

    const handleLlmChange = (llm) => setLocalSelectedLLM(llm);

    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!username.trim() || !password.trim()) {
            setError("Username and password are required.");
            toast.error("Username and password are required.");
            return;
        }

        setError('');
        setLoading(true);
        const toastId = toast.loading(isLoginView ? 'Logging in...' : 'Signing up...');

        // --- SPECIAL ADMIN LOGIN CHECK (FRONTEND ONLY) ---
        if (isLoginView && username.trim() === ADMIN_USERNAME_FRONTEND && password === ADMIN_PASSWORD_FRONTEND) {
            toast.dismiss(toastId);
            toast.success("Admin login successful!");
            setIsAdminSessionActive(true); // Notify AppState that admin is active
            
            // Option 1: Let App.jsx handle navigation based on isAdminSessionActive
            onClose({ isAdminLogin: true }); 

            // Option 2: Navigate directly from here (can sometimes cause issues if App.jsx also navigates)
            // navigate('/admin/dashboard', { replace: true }); 
            // if (typeof onClose === 'function') onClose({ isAdminLogin: true });


            setLoading(false);
            return; // Stop further processing for admin
        }
        // --- END SPECIAL ADMIN LOGIN CHECK ---

        // --- Regular user login/signup flow (calls backend API) ---
        try {
            let authDataResponse; // This will contain { token, _id, username, role, sessionId?, message }
            const apiPayload = { username: username.trim(), password };

            if (isLoginView) {
                authDataResponse = await regularUserLogin(apiPayload); // From AuthContext
            } else { // Signup view
                authDataResponse = await regularUserSignup(apiPayload); // From AuthContext
                
                // If signup is successful, update global LLM preference and save user-specific LLM config
                setGlobalLLM(localSelectedLLM);
                if (localSelectedLLM === 'gemini' && geminiApiKey.trim()) {
                    try {
                        await api.updateUserLLMConfig({ llmProvider: 'gemini', apiKey: geminiApiKey.trim() });
                    } catch (configErr) { toast.error(`Note: Could not save Gemini config: ${configErr.message}`);}
                }
                if (localSelectedLLM === 'ollama' && ollamaApiUrl.trim()) {
                    try {
                         await api.updateUserLLMConfig({ llmProvider: 'ollama', ollamaUrl: ollamaApiUrl.trim() });
                    } catch (configErr) { toast.error(`Note: Could not save Ollama config: ${configErr.message}`);}
                }
            }
            toast.dismiss(toastId);
            toast.success(authDataResponse.message || (isLoginView ? 'Login Successful!' : 'Signup Successful!'));
            if (typeof onClose === 'function') onClose(authDataResponse); // Pass full authData from AuthContext to App.jsx
        } catch (err) {
            toast.dismiss(toastId);
            // The `login` and `signup` functions from AuthContext should throw an error
            // that already contains a user-friendly message if possible.
            const errorMessage = err.response?.data?.message || err.message || `Failed: ${isLoginView ? 'login' : 'signup'}`;
            setError(errorMessage);
            toast.error(errorMessage);
        } finally { setLoading(false); }
    };

    const handleDevLogin = async () => {
        if (!devLogin) {
            toast.error("Dev Quick Login is not available in current setup.");
            return;
        }
        setDevLoginLoading(true); setError('');
        const toastId = toast.loading("Attempting Dev Quick Login...");
        try {
            const devAuthData = await devLogin(); // From AuthContext
            toast.dismiss(toastId);
            toast.success(devAuthData.message || "Dev Quick Login Successful!");
            if (typeof onClose === 'function') onClose(devAuthData);
        } catch(err) {
            toast.dismiss(toastId);
            const errorMessage = err.response?.data?.message || err.message || "Dev Quick Login encountered an error.";
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setDevLoginLoading(false);
        }
    };

    if (!isOpen) return null;

    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark pointer-events-none";
    const inputFieldStyledClass = "input-field pl-10 py-2.5 text-sm";

    return (
        <div className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4 animate-fadeIn">
            <motion.div 
                key="auth-modal-content"
                initial={{ opacity: 0, scale: 0.95, y: -10 }}
                animate={{ opacity: 1, scale: 1, y: 0 }}
                exit={{ opacity: 0, scale: 0.95, y: 10 }}
                transition={{ type: "spring", stiffness: 400, damping: 25 }}
                className="card-base p-6 sm:p-8 w-full max-w-md glass-effect" // Ensure `glass-effect` is defined in your CSS if you want it
            >
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-xl sm:text-2xl font-bold text-text-light dark:text-text-dark">
                        {isLoginView ? 'Welcome Back' : 'Create Your Account'}
                    </h2>
                    <IconButton 
                        icon={X} 
                        onClick={() => { if (typeof onClose === 'function') onClose(null); }} // Pass null if modal closed manually
                        variant="ghost" 
                        size="sm" 
                        title="Close" 
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-red-500 dark:hover:text-red-400"
                    />
                </div>

                {error && (
                    <div className="mb-4 p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm animate-fadeIn flex items-center gap-2">
                        <AlertCircle size={16}/>{error}
                    </div>
                )}

                <form onSubmit={handleSubmit} className="space-y-5">
                    <div className={inputWrapperClass}>
                        <UserIcon className={inputIconClass} />
                        <input 
                            type="text" 
                            id="auth-username" // More specific ID
                            className={inputFieldStyledClass} 
                            placeholder="Username" 
                            value={username} 
                            onChange={(e) => setUsername(e.target.value)} 
                            required 
                            disabled={loading || devLoginLoading}
                        />
                    </div>
                    <div className={inputWrapperClass}>
                        <KeyRound className={inputIconClass} />
                        <input 
                            type="password" 
                            id="auth-password" // More specific ID
                            className={inputFieldStyledClass} 
                            placeholder="Password (min. 6 characters)" 
                            value={password} 
                            onChange={(e) => setPassword(e.target.value)} 
                            required 
                            minLength="6" 
                            disabled={loading || devLoginLoading}
                        />
                    </div>

                    {!isLoginView && (
                        <div className="space-y-4 pt-2 animate-fadeIn">
                            <LLMSelection 
                                selectedLLM={localSelectedLLM} 
                                onLlmChange={handleLlmChange} 
                                disabled={loading || devLoginLoading}
                            />
                            {localSelectedLLM === 'gemini' && (
                                <div className="mt-3 space-y-1">
                                    <label htmlFor="geminiApiKeyModal" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Gemini API Key (Optional)</label>
                                    <div className={inputWrapperClass}>
                                        <KeyRound className={inputIconClass} />
                                        <input 
                                            type="password" 
                                            id="geminiApiKeyModal" 
                                            className={inputFieldStyledClass} 
                                            placeholder="Enter your Gemini API Key" 
                                            value={geminiApiKey} 
                                            onChange={(e) => setGeminiApiKey(e.target.value)} 
                                            disabled={loading || devLoginLoading}
                                        />
                                    </div>
                                </div>
                            )}
                            {localSelectedLLM === 'ollama' && (
                                <div className="mt-3 space-y-1">
                                    <label htmlFor="ollamaApiUrlModal" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark">Ollama API URL (Optional)</label>
                                     <div className={inputWrapperClass}>
                                        <Link2 className={inputIconClass} />
                                        <input 
                                            type="text" 
                                            id="ollamaApiUrlModal" 
                                            className={inputFieldStyledClass} 
                                            placeholder="Default: http://localhost:11434" 
                                            value={ollamaApiUrl} 
                                            onChange={(e) => setOllamaApiUrl(e.target.value)} 
                                            disabled={loading || devLoginLoading}
                                        />
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    <Button 
                        type="submit" 
                        fullWidth 
                        isLoading={loading} 
                        disabled={devLoginLoading || loading} // Disable if either general loading or dev login loading
                        leftIcon={isLoginView ? <LogIn size={18}/> : <UserPlus size={18}/>} 
                        className="py-2.5 !text-base"
                    >
                        {isLoginView ? 'Login' : 'Sign Up'}
                    </Button>
                </form>

                <p className="mt-6 text-center text-sm">
                    <button 
                        onClick={() => { setIsLoginView(!isLoginView); setError(''); }}
                        className="font-medium text-primary hover:text-primary-dark dark:text-primary-light dark:hover:text-primary-darker transition-colors"
                        disabled={loading || devLoginLoading}
                    >
                        {isLoginView ? "Don't have an account? Sign Up" : "Already have an account? Login"}
                    </button>
                </p>

                {DEV_MODE_ALLOW_DEV_LOGIN && devLogin && (
                    <div className="mt-4 pt-4 border-t border-border-light dark:border-border-dark">
                        <Button
                            type="button" onClick={handleDevLogin} fullWidth 
                            className="bg-yellow-500 hover:bg-yellow-600 dark:bg-yellow-600 dark:hover:bg-yellow-700 !text-white dark:!text-gray-900 font-semibold py-2.5 !text-base"
                            leftIcon={<Terminal size={18} />}
                            isLoading={devLoginLoading} 
                            disabled={loading} 
                        >
                            Dev Quick Login
                        </Button>
                    </div>
                )}
            </motion.div>
        </div>
    );
}
export default AuthModal;
```

`src/components/auth/LLMSelection.jsx`

```javascript
// frontend/src/components/auth/LLMSelection.jsx
import React from 'react';
import { HardDrive, Cloud } from 'lucide-react';

function LLMSelection({ selectedLLM, onLlmChange, disabled = false }) {
    const llms = [
        { id: 'ollama', name: 'Ollama LLM', description: 'Local & Private. Requires Ollama running.', Icon: HardDrive },
        { id: 'gemini', name: 'Gemini LLM', description: 'Cloud-based by Google. API Key may be required.', Icon: Cloud },
    ];

    return (
        <div>
            <label className="block text-sm font-medium text-text-light dark:text-text-dark mb-2">
                Choose Your LLM Provider
            </label>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                {llms.map((llm) => {
                    const isSelected = selectedLLM === llm.id;
                    return (
                        <button
                            key={llm.id}
                            type="button"
                            onClick={() => onLlmChange(llm.id)}
                            disabled={disabled}
                            className={`p-4 border rounded-lg text-left transition-all duration-150 focus:outline-none group focus:ring-2 focus:ring-offset-2 dark:focus:ring-offset-surface-dark focus:ring-primary
                                ${isSelected 
                                    ? 'bg-primary dark:bg-primary border-primary dark:border-primary-dark ring-2 ring-primary dark:ring-primary-dark shadow-lg' 
                                    : 'bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark hover:border-primary-light dark:hover:border-primary-dark hover:shadow-md'
                                }
                                ${disabled ? 'opacity-70 cursor-not-allowed' : ''}
                            `}
                        >
                            <div className="flex items-center mb-1">
                                <llm.Icon size={20} className={`mr-2 transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-blue-100' // High contrast for selected
                                        : 'text-text-muted-light dark:text-text-muted-dark group-hover:text-primary dark:group-hover:text-primary-light'}`} />
                                <span className={`font-semibold transition-colors 
                                    ${isSelected 
                                        ? 'text-white dark:text-white' // High contrast for selected
                                        : 'text-text-light dark:text-text-dark group-hover:text-primary dark:group-hover:text-primary-light'}`}>
                                    {llm.name}
                                </span>
                            </div>
                            <p className={`text-xs transition-colors 
                                ${isSelected 
                                    ? 'text-blue-100 dark:text-blue-200' // High contrast for selected
                                    : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                {llm.description}
                            </p>
                        </button>
                    );
                })}
            </div>
        </div>
    );
}

export default LLMSelection;
```

`src/components/chat/ChatHistory.jsx`

```javascript
// src/components/chat/ChatHistory.jsx
import React, { useRef, useEffect } from 'react';
import MessageBubble from './MessageBubble';
import { motion, AnimatePresence } from 'framer-motion';

function ChatHistory({ messages, isLoading }) {
    const chatHistoryRef = useRef(null);

    useEffect(() => {
        if (chatHistoryRef.current) {
            // Smart scroll: only scroll if user is already near the bottom
            const { scrollHeight, clientHeight, scrollTop } = chatHistoryRef.current;
            const isScrolledToBottom = scrollHeight - clientHeight <= scrollTop + 100; // 100px tolerance
            if (isScrolledToBottom) {
                chatHistoryRef.current.scrollTop = chatHistoryRef.current.scrollHeight;
            }
        }
    }, [messages]);

    return (
        <div ref={chatHistoryRef} className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
            <AnimatePresence initial={false}>
                {messages.map((msg, index) => ( // Ensure msg.id is unique and stable
                    <motion.div
                        key={msg.id || `msg-${index}-${msg.timestamp}`} // Fallback key if id is missing
                        layout
                        initial={{ opacity: 0, y: 20 }}
                        animate={{ opacity: 1, y: 0 }}
                        exit={{ opacity: 0, y: -10, transition: { duration: 0.15 } }}
                        transition={{ duration: 0.3, ease: "easeOut" }}
                    >
                        <MessageBubble
                            id={msg.id || `msg-${index}-${msg.timestamp}`} // Pass the ID
                            sender={msg.sender} // 'user' or 'bot'
                            text={msg.text}
                            thinking={msg.thinking}
                            references={msg.references}
                            timestamp={msg.timestamp}
                            sourcePipeline={msg.source_pipeline}
                        />
                    </motion.div>
                ))}
            </AnimatePresence>
            {isLoading && ( // Show typing indicator, even if no prior messages for immediate feedback
                 <motion.div 
                    layout
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    className="flex justify-start pl-2 mt-2"
                 >
                    <div className="message-bubble bot-message bg-surface-light dark:bg-surface-dark p-2 inline-flex items-center gap-1 rounded-lg shadow">
                        <span className="animate-pulseDot1 text-text-muted-light dark:text-text-muted-dark text-xs">●</span>
                        <span className="animate-pulseDot2 text-text-muted-light dark:text-text-muted-dark text-xs">●</span>
                        <span className="animate-pulseDot3 text-text-muted-light dark:text-text-muted-dark text-xs">●</span>
                    </div>
                </motion.div>
            )}
        </div>
    );
}
export default ChatHistory;
```

`src/components/chat/ChatHistoryModal.jsx`

```javascript
// src/components/chat/ChatHistoryModal.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api';
import toast from 'react-hot-toast';
import { X, MessageSquareText, Loader2, AlertTriangle, Trash2 } from 'lucide-react'; // Added Trash2
import Modal from '../core/Modal.jsx';
import IconButton from '../core/IconButton.jsx'; // Import IconButton

const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString(undefined, { 
            month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' 
        });
    } catch (e) {
        return 'Invalid Date';
    }
};

function ChatHistoryModal({ isOpen, onClose, onSelectSession }) {
    const [sessions, setSessions] = useState([]);
    const [selectedSessionId, setSelectedSessionId] = useState(null);
    const [sessionMessages, setSessionMessages] = useState([]);
    const [loadingSessions, setLoadingSessions] = useState(false);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState('');

    const fetchSessions = useCallback(async () => {
        if (!isOpen) return; 
        setLoadingSessions(true);
        setError('');
        try {
            const data = await api.getChatSessions(); // Fetches { sessionId, preview, updatedAt, ... }
            setSessions(Array.isArray(data) ? data : []);
            if (data.length === 0) {
                toast.info("No past chat sessions found.");
            }
        } catch (err) {
            toast.error("Failed to load chat sessions.");
            setError(err.message || "Could not fetch sessions.");
        } finally {
            setLoadingSessions(false);
        }
    }, [isOpen]);

    useEffect(() => {
        if (isOpen) {
            fetchSessions();
            setSelectedSessionId(null); 
            setSessionMessages([]);
        }
    }, [isOpen, fetchSessions]); 

    const handleSessionSelectForPreview = async (sessionId) => {
        if (selectedSessionId === sessionId && sessionMessages.length > 0) return; 

        setSelectedSessionId(sessionId);
        setLoadingMessages(true);
        setSessionMessages([]); // Clear previous preview
        setError(''); 
        try {
            // api.getChatHistory returns the array of messages directly
            const messagesArray = await api.getChatHistory(sessionId); 
            // Map to the structure expected by the modal's display loop
            setSessionMessages(messagesArray.map(msg => ({
                id: msg.id || msg._id || `hist-${Date.now()}-${Math.random()}`,
                sender: msg.sender, // 'user' or 'bot'
                text: msg.text, // Main text content
                timestamp: msg.timestamp
                // No need for thinking/references in this preview
            })));
        } catch (err) {
            toast.error("Failed to load messages for this session.");
            setError(`Error loading messages: ${err.message}`);
        } finally {
            setLoadingMessages(false);
        }
    };

    const handleLoadSessionAndClose = () => {
        if (selectedSessionId) {
            onSelectSession(selectedSessionId); 
            onClose();
        } else {
            toast.error("Please select a session to load.");
        }
    };
    
    // Placeholder for delete functionality (implement with backend support later)
    const handleDeleteSession = async (sessionIdToDelete, e) => {
        e.stopPropagation(); // Prevent selecting the session
        if (!window.confirm(`Are you sure you want to delete session ${sessionIdToDelete.substring(0,8)}...? This action cannot be undone.`)) return;
        
        const toastId = toast.loading(`Deleting session ${sessionIdToDelete.substring(0,8)}... (mock)`);
        // try {
        //     await api.deleteChatSession(sessionIdToDelete); // You'll need to create this API endpoint
        //     toast.success("Session deleted.", { id: toastId });
        //     fetchSessions(); // Refresh list
        //     if (selectedSessionId === sessionIdToDelete) {
        //         setSelectedSessionId(null);
        //         setSessionMessages([]);
        //     }
        // } catch (err) {
        //     toast.error(`Failed to delete session: ${err.message}`, { id: toastId });
        // }
        setTimeout(() => { // Simulate API call
            toast.success(`Mock: Session ${sessionIdToDelete.substring(0,8)} would be deleted.`, { id: toastId });
            // setSessions(prev => prev.filter(s => s.sessionId !== sessionIdToDelete)); // Optimistic UI update
        }, 1000);

    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title="Chat History" size="2xl">
            <div className="flex flex-col md:flex-row gap-4 max-h-[70vh] h-[70vh]">
                <div className="w-full md:w-1/3 border-r border-border-light dark:border-border-dark pr-0 md:pr-2 overflow-y-auto custom-scrollbar">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark px-1">Your Sessions</h3>
                    {loadingSessions && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24}/></div>}
                    {!loadingSessions && error && !sessions.length && <div className="text-red-500 text-xs p-2">{error}</div>}
                    {!loadingSessions && !error && sessions.length === 0 && <p className="text-xs text-text-muted-light dark:text-text-muted-dark p-2">No past sessions found.</p>}
                    
                    <ul className="space-y-1">
                        {sessions.map(session => (
                            <li key={session.sessionId}
                                onClick={() => handleSessionSelectForPreview(session.sessionId)}
                                className={`p-2.5 rounded-md cursor-pointer text-xs transition-colors group relative hover:shadow-md
                                            ${selectedSessionId === session.sessionId 
                                                ? 'bg-primary text-white dark:bg-primary-dark shadow-lg ring-2 ring-primary-dark' 
                                                : 'bg-surface-light dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 border border-transparent hover:border-primary-light'}`}
                            >
                                <div className="font-medium truncate" title={session.preview}>{session.preview || `Session ${session.sessionId.substring(0,8)}`}</div>
                                <div className={`text-[0.7rem] ${selectedSessionId === session.sessionId ? 'text-blue-100 dark:text-blue-200' : 'text-text-muted-light dark:text-text-muted-dark'}`}>
                                    {formatDate(session.updatedAt)} - {session.messageCount} msgs
                                </div>
                                <IconButton
                                    icon={Trash2}
                                    size="sm"
                                    variant="ghost"
                                    title="Delete session (Mock)"
                                    className="absolute top-1 right-1 p-1 text-red-400 hover:text-red-600 opacity-0 group-hover:opacity-100 transition-opacity !rounded-full hover:bg-red-500/10"
                                    onClick={(e) => handleDeleteSession(session.sessionId, e)}
                                />
                            </li>
                        ))}
                    </ul>
                </div>

                <div className="w-full md:w-2/3 flex flex-col overflow-hidden mt-4 md:mt-0">
                    <h3 className="text-sm font-semibold mb-2 text-text-light dark:text-text-dark">
                        {selectedSessionId ? `Preview: ${selectedSessionId.substring(0,8)}...` : "Session Preview"}
                    </h3>
                    <div className="flex-grow bg-gray-50 dark:bg-gray-800/50 p-3 rounded-md overflow-y-auto custom-scrollbar border border-border-light dark:border-border-dark">
                        {loadingMessages && <div className="flex justify-center p-4"><Loader2 className="animate-spin text-primary" size={24} /></div>}
                        {!selectedSessionId && !loadingMessages && (
                            <div className="flex flex-col items-center justify-center h-full text-text-muted-light dark:text-text-muted-dark text-sm">
                                <MessageSquareText size={40} className="mb-3 opacity-50" />
                                <p>Select a session from the left to view its messages.</p>
                            </div>
                        )}
                        {selectedSessionId && !loadingMessages && !error && sessionMessages.length === 0 && 
                            <p className="text-center text-sm text-text-muted-light dark:text-text-muted-dark p-4">No messages in this session.</p>
                        }
                        {selectedSessionId && !loadingMessages && error && 
                             <div className="flex flex-col items-center justify-center h-full text-red-500 dark:text-red-400 text-sm p-2">
                                <AlertTriangle size={30} className="mb-2"/> {error}
                            </div>
                        }
                        <div className="space-y-3">
                            {sessionMessages.map(msg => (
                                <div key={msg.id} 
                                     className={`p-2.5 rounded-lg shadow-sm w-fit max-w-[90%] text-xs
                                                ${msg.sender === 'user' 
                                                    ? 'bg-blue-500 text-white ml-auto' 
                                                    : 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100'}`}>
                                    <p className="font-semibold text-[0.7rem] mb-0.5">{msg.sender === 'user' ? 'You' : 'AI Tutor'}</p>
                                    <p className="whitespace-pre-wrap break-words">{msg.text}</p>
                                    <p className="text-[0.65rem] opacity-70 mt-1 text-right">{formatDate(msg.timestamp)}</p>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className="mt-6 pt-4 border-t border-border-light dark:border-border-dark flex justify-end gap-3">
                <button 
                    onClick={onClose} 
                    className="btn-secondary !text-xs !py-1.5 !px-3" // Use your button classes
                >
                    Close
                </button>
                <button 
                    onClick={handleLoadSessionAndClose} 
                    className="btn-primary !text-xs !py-1.5 !px-3" // Use your button classes
                    disabled={!selectedSessionId || loadingMessages || loadingSessions}
                >
                    Load Selected Session
                </button>
            </div>
        </Modal>
    );
}
export default ChatHistoryModal;
```

`src/components/chat/ChatInput.jsx`

```javascript
// src/components/chat/ChatInput.jsx
import React, { useState, useEffect, useRef } from 'react';
import { Send, Mic, PlusCircle, Loader2, SearchCheck, SearchSlash, Brain } from 'lucide-react'; // Added Brain  
import { useWebSpeech } from '../../hooks/useWebSpeech';
import Button from '../core/Button.jsx'; 
import IconButton from '../core/IconButton.jsx';
import toast from 'react-hot-toast'; // Added toast import
import blueBrain from "./../../assets/blueBrain.svg"

function ChatInput({ 
    onSendMessage, 
    isLoading, 
    currentStatus, 
    useRag, 
    setUseRag,
    criticalThinkingEnabled, // New prop
    setCriticalThinkingEnabled // New prop
}) {
    const [inputValue, setInputValue] = useState('');
    const { transcript, listening, isSpeechSupported, startListening, stopListening, resetTranscript } = useWebSpeech();
    const textareaRef = useRef(null);

    useEffect(() => {
        if (transcript) {
            setInputValue(prev => prev + (prev ? " " : "") + transcript);
            resetTranscript(); 
        }
    }, [transcript, resetTranscript]);
    
    useEffect(() => {
        if (textareaRef.current) {
            textareaRef.current.style.height = 'auto';
            textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 128)}px`; // Max height 128px (max-h-32)
        }
    }, [inputValue]);

    const handleSubmit = (e) => {
        e.preventDefault();
        if (inputValue.trim() && !isLoading) {
            // MODIFIED: Explicitly pass criticalThinkingEnabled
            // The onSendMessage function (defined in parent) will need to handle this additional argument.
            onSendMessage(inputValue.trim(), criticalThinkingEnabled); 
            setInputValue('');
        }
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !isLoading) {
            e.preventDefault(); // Prevent newline in textarea
            handleSubmit(e);
        }
    };

    const icon = criticalThinkingEnabled
    ? () => <img src={blueBrain} alt="Blue Brain" className="w-5 h-5" />
    : Brain;


    return (
        <div className="p-2 sm:p-3 border-t border-border-light dark:border-border-dark bg-surface-light dark:bg-surface-dark">
            <div className="text-xs text-text-muted-light dark:text-text-muted-dark mb-1.5 h-4 transition-opacity duration-300">
                {isLoading ? (
                    <span className="flex items-center gap-1"> 
                        <Loader2 size={12} className="animate-spin" /> {currentStatus || "Processing..."}
                    </span>
                ) : (
                    currentStatus || "Ready"
                )}
            </div>

            <form onSubmit={handleSubmit} className="flex items-end gap-2">
                <IconButton
                    icon={PlusCircle}
                    title="Attach file (Coming Soon)"
                    onClick={() => toast.info("Attachment feature coming soon!")}
                    variant="ghost"
                    size="md" 
                    className="p-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                    disabled={isLoading}
                />

                <textarea
                    ref={textareaRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={handleKeyDown}
                    placeholder="Type your message or ask a question..."
                    className="input-field flex-1 p-2.5 resize-none min-h-[44px] max-h-32 custom-scrollbar text-sm" 
                    rows="1"
                    disabled={isLoading}
                />

                {isSpeechSupported && (
                    <IconButton
                        icon={Mic}
                        onClick={() => listening ? stopListening() : startListening()}
                        title={listening ? "Stop listening" : "Start voice input"}
                        variant={listening ? "danger" : "ghost"} 
                        size="md"
                        className={`p-2 ${listening ? 'text-red-500 dark:text-red-400 animate-pulse' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                        disabled={isLoading}
                    />
                )}
                
                <IconButton
                    icon={useRag ? SearchCheck : SearchSlash}
                    onClick={() => setUseRag(!useRag)}
                    title={useRag ? "Disable RAG (Chat with LLM directly)" : "Enable RAG (Use your documents)"}
                    variant="ghost"
                    size="md"
                    className={`p-2 ${useRag ? 'text-green-500 dark:text-green-400' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                    disabled={isLoading}
                />

                {/* New Critical Thinking Toggle */}
               <IconButton
                    icon={icon}
                    onClick={() => setCriticalThinkingEnabled(!criticalThinkingEnabled)}
                    title={criticalThinkingEnabled ? "Disable Critical Thinking (KG)" : "Enable Critical Thinking (KG)"}
                    variant="ghost"
                    size="md"
                    className={`p-2 ${criticalThinkingEnabled ? 'text-purple-500 dark:text-purple-400' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
                    disabled={isLoading}
                />


                <Button 
                    type="submit"
                    variant="primary"
                    size="md" 
                    className="!p-2.5" 
                    disabled={isLoading || !inputValue.trim()}
                    isLoading={isLoading && inputValue.trim()} 
                    title="Send message"
                >
                    {!isLoading || !inputValue.trim() ? <Send size={20} /> : null}
                </Button>
            </form>
        </div>
    );
}
export default ChatInput;
```

`src/components/chat/MessageBubble.jsx`

```javascript
import React, { useEffect, useRef } from 'react';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import Prism from 'prismjs';
import { renderMathInHtml } from '../../utils/markdownUtils';
import { ChevronDown, Brain, Link as LinkIcon, Zap, Server, Volume2, StopCircle, ServerCrash } from 'lucide-react';
import { useTextToSpeech } from '../../hooks/useTextToSpeech.js';
import IconButton from '../core/IconButton.jsx';

marked.setOptions({
  breaks: true,
  gfm: true,
});

const createMarkup = (markdownText) => {
  if (!markdownText) return { __html: '' };
  let html = marked.parse(markdownText);
  html = renderMathInHtml(html);
  const cleanHtml = DOMPurify.sanitize(html, {
    USE_PROFILES: { html: true, mathMl: true, svg: true },
  });
  return { __html: cleanHtml };
};

const escapeHtml = (unsafe) => {
  if (typeof unsafe !== 'string') return '';
  return unsafe.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, `"`).replace(/'/g, `'`);
};

function MessageBubble({ sender, text, thinking, references, timestamp, sourcePipeline, id: messageId }) {
  const isUser = sender === 'user';
  const messageContentRef = useRef(null);
  const thinkingContentRef = useRef(null);
  const { speak, cancel, isSpeaking: isCurrentlySpeakingThisBubble, isSupported: ttsIsSupported } = useTextToSpeech();

  const formatTimestamp = (ts) => {
    if (!ts) return '';
    try {
      return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    } catch {
      return 'Invalid Time';
    }
  };

  const getPipelineIcon = () => {
    if (!sourcePipeline) return null;
    const lower = sourcePipeline.toLowerCase();
    if (lower.includes('ollama')) return <Zap size={12} className="text-green-400" title="Ollama Powered" />;
    if (lower.includes('gemini')) return <Server size={12} className="text-blue-400" title="Gemini Powered" />;
    if (lower.includes('rag')) return <Zap size={12} className="text-purple-400" title="RAG Enhanced" />;
    if (lower.includes('error')) return <ServerCrash size={12} className="text-red-400" title="Error" />;
    return null;
  };

  const handleToggleSpeech = () => {
    if (!ttsIsSupported || !text) return;
    isCurrentlySpeakingThisBubble ? cancel() : speak({ text });
  };

  useEffect(() => {
    if (messageContentRef.current) {
      Prism.highlightAllUnder(messageContentRef.current);
    }
  }, [text]);

  useEffect(() => {
    if (thinkingContentRef.current && thinking) {
      Prism.highlightAllUnder(thinkingContentRef.current);
    }
  }, [thinking]);

  return (
    <div className={`flex flex-col ${isUser ? 'items-end' : 'items-start'} w-full group`}>
      <div className={`message-bubble max-w-[85%] md:max-w-[75%] p-3 rounded-2xl shadow-md break-words ${
        isUser
          ? 'bg-primary dark:bg-primary-dark text-white rounded-br-lg'
          : 'bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark rounded-bl-lg border border-border-light dark:border-border-dark'
      }`}>
        <div
          ref={messageContentRef}
          className="prose prose-sm dark:prose-invert max-w-none message-content leading-relaxed"
          dangerouslySetInnerHTML={createMarkup(text || '')}
        />

        <div className="flex items-center justify-end mt-1.5 text-xs opacity-70 gap-2">
          {!isUser && getPipelineIcon()}
          <span>{formatTimestamp(timestamp)}</span>
          {!isUser && ttsIsSupported && text && (
            <IconButton
              icon={isCurrentlySpeakingThisBubble ? StopCircle : Volume2}
              onClick={handleToggleSpeech}
              title={isCurrentlySpeakingThisBubble ? 'Stop reading' : 'Read aloud'}
              size="sm"
              variant="ghost"
              className={`p-0.5 ${isCurrentlySpeakingThisBubble ? 'text-red-500' : 'text-text-muted-light dark:text-text-muted-dark hover:text-primary'}`}
            />
          )}
        </div>
      </div>

      {!isUser && (thinking || (references && references.length > 0)) && (
        <div className="message-metadata-container max-w-[85%] md:max-w-[75%] mt-1.5 pl-2 space-y-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
          {thinking && thinking.trim() && (
            <details className="group/details text-xs">
              <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                <Brain size={14} /> AI Reasoning
                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
              </summary>
              <pre
                ref={thinkingContentRef}
                className="mt-1 p-2 bg-gray-100 dark:bg-gray-800 rounded-md text-text-light dark:text-text-dark whitespace-pre-wrap break-all text-[0.7rem] max-h-32 overflow-y-auto custom-scrollbar"
              >
                <code className="language-text">{escapeHtml(thinking)}</code>
              </pre>
            </details>
          )}

          {references && references.length > 0 && (
            <details className="group/details text-xs" open>
              <summary className="flex items-center gap-1 cursor-pointer text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light transition-colors">
                <LinkIcon size={14} /> References
                <ChevronDown size={14} className="group-open/details:rotate-180 transition-transform" />
              </summary>
              <ul className="mt-1 pl-1 space-y-0.5 text-[0.7rem]">
                {references.map((ref, index) => (
                  <li
                    key={index}
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors truncate"
                    title={`Preview: ${escapeHtml(ref.content_preview || '')}\nSource: ${escapeHtml(ref.source || '')}`}
                  >
                    <span className="font-semibold text-accent">[{ref.number}]</span> {escapeHtml(ref.source)}
                  </li>
                ))}
              </ul>
            </details>
          )}
        </div>
      )}
    </div>
  );
}

export default MessageBubble;

```

`src/components/common/ThemeToggle.jsx`

```javascript
import React from 'react';
import { Sun, Moon } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        <button
            onClick={toggleTheme}
            className="p-2 rounded-full text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors focus:outline-none focus:ring-2 focus:ring-primary"
            aria-label={theme === 'light' ? 'Switch to dark theme' : 'Switch to light theme'}
        >
            {theme === 'light' ? <Moon size={20} /> : <Sun size={20} />}
        </button>
    );
}

export default ThemeToggle;
```

`src/components/core/Button.jsx`

```javascript
// src/components/core/Button.jsx
import React from 'react';
import { Loader2 } from 'lucide-react'; // For loading spinner

const Button = ({
    children,
    onClick,
    type = 'button',
    variant = 'primary', // 'primary', 'secondary', 'danger', 'outline', 'ghost'
    size = 'md', // 'sm', 'md', 'lg'
    leftIcon,
    rightIcon,
    isLoading = false,
    disabled = false,
    fullWidth = false,
    className = '',
    ...props
}) => {
    const baseStyles = "font-semibold rounded-lg focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2";

    const variantStyles = {
        primary: "bg-primary hover:bg-primary-dark text-white focus:ring-primary",
        secondary: "bg-secondary hover:bg-secondary-dark text-white focus:ring-secondary",
        danger: "bg-red-500 hover:bg-red-600 text-white focus:ring-red-500",
        outline: "border border-primary text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
        ghost: "text-primary hover:bg-primary-light dark:hover:bg-opacity-10 focus:ring-primary",
    };

    const sizeStyles = {
        sm: "px-3 py-1.5 text-xs",
        md: "px-4 py-2 text-sm",
        lg: "px-6 py-3 text-base",
    };

    const widthStyle = fullWidth ? "w-full" : "";
    const isDisabled = disabled || isLoading;
    const finalDisabledStyle = isDisabled ? "opacity-60 cursor-not-allowed" : "cursor-pointer";

    const spinnerSize = size === 'sm' ? 14 : (size === 'lg' ? 20 : 16);
    
    return (
        <button
            type={type}
            onClick={onClick}
            disabled={isDisabled} // Use the corrected variable
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${widthStyle} ${finalDisabledStyle} ${className}`}
            {...props}
        >
            {isLoading && (
                <Loader2 size={spinnerSize} className="animate-spin" />
            )}
            {!isLoading && leftIcon && <span className="icon-left">{leftIcon}</span>}

            <span className={isLoading ? 'ml-2' : ''}>{children}</span>

            {!isLoading && rightIcon && <span className="icon-right">{rightIcon}</span>}
        </button>
    );
};

export default Button;
```

`src/components/core/IconButton.jsx`

```javascript
import React from 'react';
import { Loader2 } from 'lucide-react';

const IconButton = ({
    icon: Icon, // Pass the Lucide icon component directly
    onClick,
    variant = 'ghost', // 'ghost', 'outline', 'subtle'
    size = 'md', // 'sm', 'md', 'lg'
    isLoading = false,
    disabled = false,
    className = '',
    title, // For accessibility and tooltips
    ariaLabel,
    ...props
}) => {
    const baseStyles = "rounded-md focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-colors duration-150 flex items-center justify-center";

    const variantStyles = {
        ghost: "text-text-muted-light dark:text-text-muted-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:ring-primary",
        outline: "border border-gray-300 dark:border-gray-600 text-text-muted-light dark:text-text-muted-dark hover:border-primary hover:text-primary focus:ring-primary",
        subtle: "bg-gray-100 dark:bg-gray-700 text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-600 focus:ring-primary",
        danger: "text-red-500 hover:bg-red-100 dark:hover:bg-red-900 focus:ring-red-500"
    };

    const sizeStyles = {
        sm: "p-1.5", // Icon size typically 14-16px
        md: "p-2",   // Icon size typically 18-20px
        lg: "p-2.5", // Icon size typically 22-24px
    };
    
    const iconSizeMap = {
        sm: 16,
        md: 20,
        lg: 24,
    };

    const disabledStyle = (disabled || isLoading) ? "opacity-50 cursor-not-allowed" : "cursor-pointer";

    return (
        <button
            type="button"
            onClick={onClick}
            disabled={disabled || isLoading}
            className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${disabledStyle} ${className}`}
            title={title}
            aria-label={ariaLabel || title}
            {...props}
        >
            {isLoading ? (
                <Loader2 size={iconSizeMap[size]} className="animate-spin" />
            ) : (
                Icon && <Icon size={iconSizeMap[size]} />
            )}
        </button>
    );
};

export default IconButton;
```

`src/components/core/Modal.jsx`

```javascript
// src/components/core/Modal.jsx
import React, { useEffect, useRef } from 'react';
import { X } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const Modal = ({
    isOpen,
    onClose,
    title,
    children,
    footerContent,
    size = 'md', // 'sm', 'md', 'lg', 'xl', '2xl', '3xl', '4xl', '5xl', 'full'
    closeOnOverlayClick = true,
    initialFocusRef, // Optional ref for focusing an element inside the modal on open
}) => {
    const modalRef = useRef(null);

    // Handle Escape key for closing
    useEffect(() => {
        const handleEscapeKey = (event) => {
            if (event.key === 'Escape' && isOpen) {
                onClose();
            }
        };
        if (isOpen) {
            document.addEventListener('keydown', handleEscapeKey);
        }
        return () => {
            document.removeEventListener('keydown', handleEscapeKey);
        };
    }, [isOpen, onClose]);

    // Handle focus trapping and initial focus
    useEffect(() => {
        if (isOpen) {
            // Set focus to the initialFocusRef or the modal itself
            if (initialFocusRef && initialFocusRef.current) {
                initialFocusRef.current.focus();
            } else if (modalRef.current) {
                modalRef.current.focus(); // Fallback to modal itself
            }

            // Basic focus trapping (can be made more robust with a library)
            const focusableElements = modalRef.current?.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            if (focusableElements && focusableElements.length > 0) {
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                const onKeyDown = (e) => {
                    if (e.key === 'Tab') {
                        if (e.shiftKey) { // Shift + Tab
                            if (document.activeElement === firstElement) {
                                lastElement.focus();
                                e.preventDefault();
                            }
                        } else { // Tab
                            if (document.activeElement === lastElement) {
                                firstElement.focus();
                                e.preventDefault();
                            }
                        }
                    }
                };
                modalRef.current?.addEventListener('keydown', onKeyDown);
                return () => modalRef.current?.removeEventListener('keydown', onKeyDown);
            }
        }
    }, [isOpen, initialFocusRef]);


    const sizeClasses = {
        sm: 'max-w-sm',
        md: 'max-w-md',
        lg: 'max-w-lg',
        xl: 'max-w-xl',
        '2xl': 'max-w-2xl',
        '3xl': 'max-w-3xl',
        '4xl': 'max-w-4xl',
        '5xl': 'max-w-5xl',
        full: 'max-w-full h-full rounded-none sm:rounded-lg sm:max-h-[95vh]', // Special case for full screen like
    };

    const backdropVariants = {
        visible: { opacity: 1, transition: { duration: 0.2, ease: "easeOut" } },
        hidden: { opacity: 0, transition: { duration: 0.15, ease: "easeIn" } },
    };

    const modalVariants = {
        hidden: { y: "-30px", opacity: 0, scale: 0.98, transition: { duration: 0.15, ease: "easeIn" } },
        visible: { y: "0", opacity: 1, scale: 1, transition: { type: "spring", stiffness: 400, damping: 30, duration: 0.3 } },
        exit: { y: "30px", opacity: 0, scale: 0.98, transition: { duration: 0.2, ease: "easeIn" } }
    };

    if (!isOpen) return null;

    return (
        <AnimatePresence mode="wait">
            {isOpen && (
                <motion.div
                    key="modal-backdrop"
                    className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/70 dark:bg-black/80 backdrop-blur-sm"
                    initial="hidden"
                    animate="visible"
                    exit="hidden"
                    variants={backdropVariants}
                    onClick={closeOnOverlayClick ? onClose : undefined}
                    aria-labelledby="modal-title" // For screen readers
                    role="dialog" // Role for the backdrop itself, more specific roles on content
                    aria-modal="true" // Indicate it's a modal overlaying other content
                >
                    <motion.div
                        key="modal-content-wrapper" // Changed key for potential AnimatePresence behavior
                        ref={modalRef}
                        tabIndex={-1} // Make the modal itself focusable for fallback
                        className={`bg-surface-light dark:bg-surface-dark rounded-lg shadow-xl w-full ${sizeClasses[size]} flex flex-col overflow-hidden
                                    ${size === 'full' ? '' : 'max-h-[90vh] sm:max-h-[85vh]'}`} 
                                    // Apply max-h unless it's 'full' size
                        role="document" // The actual dialog content
                        aria-modal="true"
                        aria-labelledby={title ? "modal-title-text" : undefined} // Point to title if exists
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        variants={modalVariants}
                        onClick={(e) => e.stopPropagation()} // Prevent closing when clicking inside modal
                    >
                        {/* Modal Header */}
                        <div className="flex items-center justify-between px-5 py-3.5 border-b border-border-light dark:border-border-dark sticky top-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                            {title && (
                                <h2 id="modal-title-text" className="text-lg font-semibold text-text-light dark:text-text-dark truncate pr-4">
                                    {title}
                                </h2>
                            )}
                            <button
                                onClick={onClose}
                                className="p-1.5 rounded-full text-text-muted-light dark:text-text-muted-dark 
                                           hover:bg-gray-200/80 dark:hover:bg-gray-700/80 
                                           hover:text-red-500 dark:hover:text-red-400 
                                           focus:outline-none focus:ring-2 focus:ring-primary dark:focus:ring-primary-light focus:ring-offset-1 dark:focus:ring-offset-surface-dark"
                                aria-label="Close modal"
                            >
                                <X size={20} />
                            </button>
                        </div>

                        {/* Modal Body */}
                        <div className="px-5 py-4 overflow-y-auto flex-grow custom-scrollbar">
                            {children}
                        </div>

                        {/* Modal Footer */}
                        {footerContent && (
                            <div className="px-5 py-3.5 border-t border-border-light dark:border-border-dark flex justify-end gap-3 sticky bottom-0 bg-surface-light dark:bg-surface-dark z-10 flex-shrink-0">
                                {footerContent}
                            </div>
                        )}
                    </motion.div>
                </motion.div>
            )}
        </AnimatePresence>
    );
};

export default Modal;
```

`src/components/documents/DocumentList.jsx`

```javascript


// frontend/src/components/documents/DocumentList.jsx
import React, { useState, useEffect, useCallback } from 'react';
import api from '../../services/api.js'; // Mocked for V1
import toast from 'react-hot-toast';
import { FileText, Edit3, Trash2, Loader2, AlertTriangle, CheckCircle } from 'lucide-react';
import IconButton from '../core/IconButton.jsx'; // Make sure IconButton is imported
import { useAuth } from '../../hooks/useAuth.jsx';

// Props from LeftPanel: onSelectDocument is selectDocumentForAnalysis from AppStateContext
// selectedDocument is selectedDocumentForAnalysis from AppStateContext
function DocumentList({ onSelectDocument, selectedDocument }) {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  const fetchFiles = useCallback(async () => {
    setLoading(true);
    setError('');
    try {
      
      const response = await api.getFiles(); // Returns { filenames: ["A.txt", "B.pdf"] }
      const filenames = Array.isArray(response.filenames) ? response.filenames : [];
      setFiles(filenames);
      
    } catch (err) {
      console.error("Failed to fetch files:", err);
      setError(err.message || "Failed to fetch files.");
      toast.error("Could not load documents.");
    } finally {
      setLoading(false);
    }
  }, []);



  useEffect(() => {
    fetchFiles();
  }, [fetchFiles]);

  const handleDelete = async (filename) => {
    if (!window.confirm(`Are you sure you want to delete "${filename}"?`)) return;
    const toastId = toast.loading(`Deleting ${filename}...`);
    try {
      await api.deleteFile(filename); // Assumes this works with filename
      toast.success(`${filename} deleted.`, { id: toastId });
      fetchFiles();
      if (selectedDocument === filename) {
        onSelectDocument(null);
      }
    } catch (err) {
      toast.error(`Delete failed: ${err.message}`, { id: toastId });
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center p-4 text-text-muted-light dark:text-text-muted-dark">
        <Loader2 size={20} className="animate-spin mr-2" /> Loading documents...
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2">
        <AlertTriangle size={18} /> {error}
        <button onClick={fetchFiles} className="ml-auto text-xs underline hover:text-red-400">Retry</button>
      </div>
    );
  }

  if (files.length === 0) {
    return <p className="text-center text-xs text-text-muted-light dark:text-text-muted-dark p-4">No documents uploaded.</p>;
  }

  return (
    <div className="space-y-1.5 text-xs custom-scrollbar pr-1">
      {files.map(filename => {
        const isSelected = selectedDocument === filename;

        return (
          <div
            key={filename}
            onClick={() => onSelectDocument(isSelected ? null : filename)}
            className={`p-2.5 bg-surface-light dark:bg-gray-800 border rounded-md flex items-center justify-between hover:shadow-md transition-all duration-150 cursor-pointer
                        ${isSelected
                          ? 'ring-2 ring-primary dark:ring-primary-light shadow-lg border-primary dark:border-primary-light'
                          : 'border-border-light dark:border-border-dark hover:border-gray-400 dark:hover:border-gray-500'}`}
            title={`Select ${filename}`}
          >
            <div className="flex items-center gap-2 truncate">
              {isSelected ? (
                <CheckCircle size={16} className="text-green-500 flex-shrink-0" />
              ) : (
                <FileText size={16} className="text-primary dark:text-primary-light flex-shrink-0" />
              )}
              <span className={`truncate ${isSelected ? 'font-semibold text-primary dark:text-primary-light' : 'text-text-light dark:text-text-dark'}`}>
                {filename}
              </span>
            </div>
            <div className="flex-shrink-0 flex items-center gap-0.5">
              <IconButton
                icon={Trash2}
                size="sm"
                variant="ghost"
                title="Delete"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete(filename);
                }}
                className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 p-1"
              />
            </div>
          </div>
        );
      })}
    </div>
  );
}


export default DocumentList;
```

`src/components/documents/DocumentUpload.jsx`

```javascript
// frontend/src/components/documents/DocumentUpload.jsx
import React, { useState, useRef, useEffect } from 'react';
import api from '../../services/api.js';
import toast from 'react-hot-toast';
import { UploadCloud, FileText, XCircle, Loader2, CheckCircle, AlertTriangle, Paperclip } from 'lucide-react';
import Button from '../core/Button.jsx'; // Your custom Button

// Define the states and corresponding button texts
const BUTTON_TEXT_STATES = {
    IDLE_NO_FILE: "Select a File",
    IDLE_FILE_SELECTED: "Upload Document",
    UPLOADING_BYTES: "Uploading file...", // Static text during byte transfer phase
    // Cycling messages after byte upload, while Node.js waits for Python
    EXTRACTING_CONTENT: "Extracting content...",
    CLEANING_TEXT: "Cleaning text...",
    ANALYZING_DOCUMENT: "Analyzing document...",
    // After Node.js 202 response (Python call finished from Node's perspective)
    FINALIZING_SUBMISSION: "Finalizing...",
    ERROR: "Upload Failed - Retry?", // Or simply "Upload Failed"
};

// Order for the first cycle of detailed processing messages on the button
const firstCycleButtonMessages = [
    BUTTON_TEXT_STATES.EXTRACTING_CONTENT,
    BUTTON_TEXT_STATES.CLEANING_TEXT,
    BUTTON_TEXT_STATES.ANALYZING_DOCUMENT,
];

// Order for subsequent looping cycles on the button
const loopCycleButtonMessages = [
    BUTTON_TEXT_STATES.CLEANING_TEXT, // Loop starts from "Cleaning..."
    BUTTON_TEXT_STATES.ANALYZING_DOCUMENT,
];

const MESSAGE_BUTTON_DISPLAY_DURATION_MS = 3000; // 3 seconds per message

function DocumentUpload({ onUploadSuccess }) {
    const [selectedFile, setSelectedFile] = useState(null);
    const [isProcessing, setIsProcessing] = useState(false);
    const [buttonText, setButtonText] = useState(BUTTON_TEXT_STATES.IDLE_NO_FILE);
    const [errorMessage, setErrorMessage] = useState('');
    const [dragActive, setDragActive] = useState(false); // For dropzone visual feedback

    const fileInputRef = useRef(null);
    const intervalRef = useRef(null);       // Stores the setInterval ID
    const messageIndexRef = useRef(0);    // Current index in the message array
    const currentMessageArrayRef = useRef(firstCycleButtonMessages); // Which array to use (first or loop)
    const isMountedRef = useRef(true);      // Track if component is mounted

    console.log(`[UploadFinalUX] Component Render/Re-render. isProcessing: ${isProcessing}, buttonText: "${buttonText}"`);

    // Effect for component mount and unmount
    useEffect(() => {
        isMountedRef.current = true;
        console.log("[UploadFinalUX] Component Mounted.");
        return () => {
            isMountedRef.current = false;
            if (intervalRef.current) {
                clearInterval(intervalRef.current);
                console.log("[UploadFinalUX] Component Unmounting - Cleared interval:", intervalRef.current);
            }
            console.log("[UploadFinalUX] Component Unmounted.");
        };
    }, []);

    // Effect to manage the cycling of button text messages
    useEffect(() => {
        const clearLocalInterval = (reason = "unspecified") => {
            if (intervalRef.current) {
                console.log(`[UploadFinalUX CycleEffect] Clearing interval (Reason: ${reason}). ID: ${intervalRef.current}`);
                clearInterval(intervalRef.current);
                intervalRef.current = null;
            }
        };

        console.log(`[UploadFinalUX CycleEffect] Evaluating. isProcessing: ${isProcessing}, buttonText: "${buttonText}"`);

        const isCurrentlyInCyclingState =
            buttonText === BUTTON_TEXT_STATES.EXTRACTING_CONTENT ||
            buttonText === BUTTON_TEXT_STATES.CLEANING_TEXT ||
            buttonText === BUTTON_TEXT_STATES.ANALYZING_DOCUMENT;

        if (isProcessing && isCurrentlyInCyclingState) {
            if (!intervalRef.current) { // Only start a new interval if one isn't already running
                console.log(`[UploadFinalUX CycleEffect] Starting new interval. Initial buttonText for cycle: "${buttonText}"`);

                // Determine which array and index to start/resume from
                if (buttonText === BUTTON_TEXT_STATES.EXTRACTING_CONTENT) {
                    currentMessageArrayRef.current = firstCycleButtonMessages;
                    messageIndexRef.current = 0; // Start from the beginning of the first cycle
                } else { // Resuming or starting mid-loop (e.g., if state was restored)
                    const loopIdx = loopCycleButtonMessages.indexOf(buttonText);
                    currentMessageArrayRef.current = loopCycleButtonMessages;
                    messageIndexRef.current = (loopIdx !== -1) ? loopIdx : 0;
                }
                // No need to setButtonText here, as it's already in a cycling state which triggered this.

                intervalRef.current = setInterval(() => {
                    if (!isMountedRef.current || !isProcessing) {
                        clearLocalInterval("component unmounted or no longer processing in interval");
                        return;
                    }

                    messageIndexRef.current++; // Advance to the next message in the current array
                    if (messageIndexRef.current >= currentMessageArrayRef.current.length) {
                        // Reached the end of the current message array, switch to loopCycleMessages
                        currentMessageArrayRef.current = loopCycleButtonMessages;
                        messageIndexRef.current = 0; // Reset index for the loop array
                        console.log("[UploadFinalUX Interval] Switched/Reset to loopCycleMessages. Next message index: 0");
                    }
                    
                    const nextButtonText = currentMessageArrayRef.current[messageIndexRef.current];
                    console.log(`[UploadFinalUX Interval] Setting buttonText to: "${nextButtonText}" (Index: ${messageIndexRef.current} in [${currentMessageArrayRef.current.join(', ')}])`);
                    if (isMountedRef.current) setButtonText(nextButtonText);

                }, MESSAGE_BUTTON_DISPLAY_DURATION_MS);
                console.log(`[UploadFinalUX CycleEffect] Interval started. ID: ${intervalRef.current}. Initial array: [${currentMessageArrayRef.current.join(', ')}]`);
            } else {
                console.log(`[UploadFinalUX CycleEffect] Interval already running for a cycling state. ID: ${intervalRef.current}`);
            }
        } else {
            // If not processing, or if buttonText is not one of the cycling states, clear any existing interval.
            if (intervalRef.current) {
                clearLocalInterval(`not processing or not in cycling state (Text: ${buttonText})`);
            } else {
                // console.log(`[UploadFinalUX CycleEffect] Conditions for cycling NOT met, and no active interval to clear.`);
            }
        }

        return () => { // Cleanup function for this useEffect
            // console.log(`[UploadFinalUX CycleEffect] Cleanup on dep change (isProcessing/buttonText). Current interval ID: ${intervalRef.current}`);
            clearLocalInterval("effect dependency change cleanup");
        };
    }, [isProcessing, buttonText]); // Key dependencies for managing the interval


    const handleFileChange = (e) => {
        console.log("[UploadFinalUX] handleFileChange triggered.");
        if (isProcessing) {
            console.log("[UploadFinalUX] handleFileChange: Currently processing, ignoring file change.");
            return;
        }
        const file = e.target.files && e.target.files[0];
        if (file) {
            setSelectedFile(file);
            setButtonText(BUTTON_TEXT_STATES.IDLE_FILE_SELECTED);
            setErrorMessage('');
            console.log("[UploadFinalUX] handleFileChange: File selected:", file.name);
        } else {
            console.log("[UploadFinalUX] handleFileChange: No file selected or selection cancelled.");
            resetState(); // Resets to IDLE_NO_FILE
        }
    };

    const handleDrag = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; if (e.type === "dragenter" || e.type === "dragover") setDragActive(true); else if (e.type === "dragleave") setDragActive(false); };
    const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); if (isProcessing) return; setDragActive(false); const file = e.dataTransfer.files && e.dataTransfer.files[0]; if (file) { setSelectedFile(file); setButtonText(BUTTON_TEXT_STATES.IDLE_FILE_SELECTED); setErrorMessage(''); console.log("[UploadFinalUX] handleDrop: File dropped:", file.name); } };

    const handleUpload = async () => {
    if (!selectedFile) {
        toast.error("Please select a file first.");
        return;
    }

    console.log("[UploadFinalUX] handleUpload: Starting upload for", selectedFile.name);
    setIsProcessing(true);
    setButtonText(BUTTON_TEXT_STATES.UPLOADING_BYTES);
    setErrorMessage("");

    // Reset cycling refs
    messageIndexRef.current = 0;
    currentMessageArrayRef.current = firstCycleButtonMessages;

    const formData = new FormData();
    formData.append("file", selectedFile);

    // ─── Fallback: if onUploadProgress never reaches 100%, force EXTRACTING_CONTENT after 500ms ───
    const fallbackTimer = setTimeout(() => {
        if (
        isMountedRef.current &&
        isProcessing &&
        buttonText === BUTTON_TEXT_STATES.UPLOADING_BYTES
        ) {
        console.log(
            "[UploadFinalUX] handleUpload: Forcing EXTRACTING_CONTENT (fallback)."
        );
        setButtonText(BUTTON_TEXT_STATES.EXTRACTING_CONTENT);
        }
    }, 500);
    // ───────────────────────────────────────────────────────────────────────────────────────────

    try {
        console.log("[UploadFinalUX] handleUpload: Calling api.uploadFile");
        await api.uploadFile(formData, (event) => {
        if (isMountedRef.current && isProcessing) {
            if (event.lengthComputable) {
            if (event.loaded === event.total) {
                if (buttonText !== BUTTON_TEXT_STATES.EXTRACTING_CONTENT) {
                console.log(
                    "[UploadFinalUX] onUploadProgress: 100% bytes sent. Setting EXTRACTING_CONTENT."
                );
                setButtonText(BUTTON_TEXT_STATES.EXTRACTING_CONTENT);
                }
                clearTimeout(fallbackTimer);
            }
            } else if (buttonText === BUTTON_TEXT_STATES.UPLOADING_BYTES) {
            console.log(
                "[UploadFinalUX] onUploadProgress: Not computable & still UPLOADING_BYTES. Setting EXTRACTING_CONTENT."
            );
            setButtonText(BUTTON_TEXT_STATES.EXTRACTING_CONTENT);
            clearTimeout(fallbackTimer);
            }
        }
        });

        console.log(
        "[UploadFinalUX] handleUpload: api.uploadFile resolved (Node.js 202 received)."
        );
        clearTimeout(fallbackTimer);

        if (isMountedRef.current && isProcessing) {
        console.log(
            "[UploadFinalUX] handleUpload: Setting buttonText to FINALIZING_SUBMISSION."
        );
        setButtonText(BUTTON_TEXT_STATES.FINALIZING_SUBMISSION);
        }

        if (onUploadSuccess) {
        onUploadSuccess({ originalname: selectedFile.name });
        }
        toast.success(`"${selectedFile.name}" submitted. Background tasks initiated.`);

        setTimeout(() => {
        if (isMountedRef.current) {
            console.log(
            "[UploadFinalUX] handleUpload: Timeout for resetState after FINALIZING_SUBMISSION."
            );
            resetState();
        }
        }, 1500);
    } catch (error) {
        clearTimeout(fallbackTimer);
        console.error("[UploadFinalUX] Upload failed in catch:", error);
        if (isMountedRef.current) {
        const msg =
            error.response?.data?.message || error.message || "Upload processing failed.";
        setErrorMessage(msg);
        setButtonText(BUTTON_TEXT_STATES.ERROR);
        setIsProcessing(false);
        toast.error(`Upload of "${selectedFile.name}" failed.`);
        }
    }
    };



    const resetState = () => {
        console.log("[UploadFinalUX] resetState called.");
        setSelectedFile(null);
        setButtonText(BUTTON_TEXT_STATES.IDLE_NO_FILE);
        setErrorMessage('');
        setIsProcessing(false); // This will trigger CycleEffect to clear interval
        if (fileInputRef.current) {
            fileInputRef.current.value = null;
        }
        setDragActive(false);
        messageIndexRef.current = 0;
        currentMessageArrayRef.current = firstCycleButtonMessages; // Reset for next cycle
        console.log("[UploadFinalUX] resetState: State reset complete.");
    };

    const isButtonUploadActuallyDisabled = !selectedFile || isProcessing;
    const UploadAreaIcon = Paperclip;

    return (
        <div className="mb-4 p-1">
            <label
                htmlFor="file-upload-input"
                onDragEnter={handleDrag}
                onDragLeave={handleDrag}
                onDragOver={handleDrag}
                onDrop={handleDrop}
                className={`flex flex-col items-center justify-center w-full h-36 px-4 transition-colors duration-200 ease-in-out
                            bg-surface-light dark:bg-gray-800
                            border-2 border-dashed rounded-lg cursor-pointer
                            border-border-light dark:border-border-dark
                            hover:border-primary dark:hover:border-primary-light
                            ${isProcessing ? "opacity-60 cursor-not-allowed" : ""}
                            ${dragActive ? "border-primary dark:border-primary-light ring-2 ring-primary dark:ring-primary-light bg-primary/10 dark:bg-primary-dark/20" : ""}`}
            >
                <div className="flex flex-col items-center justify-center text-center">
                    <UploadAreaIcon size={36} className={`mb-2 transition-colors ${dragActive ? 'text-primary dark:text-primary-light' : 'text-text-muted-light dark:text-text-muted-dark'}`} />
                    <p className="mb-1 text-xs sm:text-sm text-text-muted-light dark:text-text-muted-dark">
                        <span className="font-semibold text-primary dark:text-primary-light">Click to upload</span> or drag and drop
                    </p>
                    <p className="text-[0.7rem] sm:text-xs text-text-muted-light dark:text-text-muted-dark">PDF, DOCX, TXT, PPTX, code files</p>
                </div>
                <input ref={fileInputRef} id="file-upload-input" type="file" className="hidden" onChange={handleFileChange}
                       disabled={isProcessing}
                       accept=".pdf,.doc,.docx,.ppt,.pptx,.txt,.py,.js,.md,.html,.xml,.json,.csv,.log,.c,.cpp,.java" />
            </label>

            {selectedFile && (
                <div className="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded-md flex items-center justify-between text-sm animate-fadeIn">
                    <div className="flex items-center gap-2 truncate">
                        {buttonText === BUTTON_TEXT_STATES.ERROR && errorMessage ?
                            <AlertTriangle size={18} className="text-red-500 flex-shrink-0" /> :
                            <FileText size={18} className="text-primary flex-shrink-0" />
                        }
                        <span className="truncate text-text-light dark:text-text-dark" title={selectedFile.name}>{selectedFile.name}</span>
                        <span className="text-text-muted-light dark:text-text-muted-dark text-xs whitespace-nowrap">
                            ({(selectedFile.size / 1024).toFixed(1)} KB)
                        </span>
                    </div>
                    {!isProcessing && buttonText !== BUTTON_TEXT_STATES.ERROR && (
                        <button onClick={resetState} className="text-red-500 hover:text-red-700 dark:hover:text-red-400 transition-colors p-1 rounded-full hover:bg-red-500/10">
                            <XCircle size={18} />
                        </button>
                    )}
                </div>
            )}

            {/* Error message display area (if any) */}
            {errorMessage && buttonText === BUTTON_TEXT_STATES.ERROR && (
                 <div className="mt-2 text-xs text-red-600 dark:text-red-400 p-2 bg-red-500/10 rounded-md flex justify-center items-center h-auto">
                    <AlertTriangle size={14} className="mr-1.5 flex-shrink-0" />
                    <span className="flex-grow text-center">{errorMessage.substring(0,100)}</span>
                 </div>
            )}

            <Button
                onClick={handleUpload}
                fullWidth
                className="mt-3 text-sm min-h-[38px]" // min-height to prevent button size jumping due to text length
                variant="primary"
                isLoading={isProcessing} // Button component shows its spinner when true
                disabled={isButtonUploadActuallyDisabled}
                leftIcon={!isProcessing && buttonText !== BUTTON_TEXT_STATES.ERROR ? <UploadCloud size={16} /> : null}
            >
                {/* The button's text is now directly from the buttonText state */}
                {buttonText}
            </Button>
        </div>
    );
}
export default DocumentUpload;
```

`src/components/layout/CenterPanel.jsx`

```javascript
// src/components/layout/CenterPanel.jsx
import React, { useState, useEffect } from 'react';
import ChatHistory from '../chat/ChatHistory';
import ChatInput from '../chat/ChatInput';
import api from '../../services/api';
import { useAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import toast from 'react-hot-toast';

function CenterPanel({ messages, setMessages, currentSessionId, chatStatus, setChatStatus }) {
    const { token, user } = useAuth();
    const { selectedLLM, systemPrompt, selectedDocumentForAnalysis } = useAppState(); 
    const [useRag, setUseRag] = useState(false); 
    const [isSending, setIsSending] = useState(false);
    const [criticalThinkingEnabled, setCriticalThinkingEnabled] = useState(false); // State for CT

    // MODIFIED: Accept isCtEnabledFromInput as the second argument
    const handleSendMessage = async (inputText, isCtEnabledFromInput) => { 
        if (!inputText.trim() || !token || !currentSessionId || isSending) {
            if (!currentSessionId) toast.error("No active session. Try 'New Chat'.");
            return;
        }

        const clientSideId = `user-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        const userMessage = {
            id: clientSideId, 
            sender: 'user',
            role: 'user', 
            text: inputText.trim(),
            parts: [{ text: inputText.trim() }], 
            timestamp: new Date().toISOString()
        };
        
        setMessages(prev => [...prev, userMessage]);
        
        setIsSending(true);
        let currentThinkingStatus = "Connecting to AI...";
        // MODIFIED: Use isCtEnabledFromInput for status message
        if (useRag && isCtEnabledFromInput) {
            currentThinkingStatus = `Searching docs, retrieving KG & Contacting ${selectedLLM.toUpperCase()} (RAG + CT)...`;
        } else if (useRag) {
            currentThinkingStatus = `Searching documents & Contacting ${selectedLLM.toUpperCase()} (RAG)...`;
        } else if (isCtEnabledFromInput) {
            currentThinkingStatus = `Retrieving KG & Contacting ${selectedLLM.toUpperCase()} (CT)...`;
        } else {
            currentThinkingStatus = `Contacting ${selectedLLM.toUpperCase()}...`;
        }
        setChatStatus(currentThinkingStatus);

        const historyForBackend = messages.map(m => ({
            role: m.sender === 'bot' ? 'model' : 'user',
            parts: m.parts || [{ text: m.text }], 
            timestamp: m.timestamp,
            ...(m.sender === 'bot' && { 
                thinking: m.thinking,
                references: m.references,
                source_pipeline: m.source_pipeline
            })
        }));
        
        const payload = {
            query: inputText.trim(), 
            history: historyForBackend,
            sessionId: currentSessionId,
            useRag: useRag,
            llmProvider: selectedLLM, 
            systemPrompt: systemPrompt,
            // MODIFIED: Use the parameter and match backend key
            criticalThinkingEnabled: isCtEnabledFromInput, 
            documentContextName: selectedDocumentForAnalysis || null, 
        };
            
        try {
            console.log("CenterPanel: Sending payload to /api/chat/message:", payload);
            const response = await api.sendMessage(payload); 
            
            if (response && response.reply) {
                const aiReply = {
                    ...response.reply, 
                    id: `bot-${Date.now()}-${Math.random().toString(16).slice(2)}` 
                };
                setMessages(prev => [...prev, aiReply]);
                setChatStatus(`Responded via ${aiReply.source_pipeline || selectedLLM.toUpperCase()}.`);
            } else {
                throw new Error("Invalid or empty response structure from AI service.");
            }

        } catch (error) {
            console.error("Error sending message:", error);
            const errorText = error.response?.data?.message || error.message || 'Failed to get response from AI.';
            
            let errorReplyMessage;
            if (error.response?.data?.reply) {
                errorReplyMessage = {
                    ...error.response.data.reply,
                    id: `error-${Date.now()}-${Math.random().toString(16).slice(2)}`
                };
            } else {
                errorReplyMessage = { 
                    id: `error-${Date.now()}-${Math.random().toString(16).slice(2)}`, 
                    sender: 'bot', 
                    text: `Error: ${errorText}`,
                    parts: [{ text: `Error: ${errorText}` }],
                    timestamp: new Date().toISOString(),
                    thinking: "Error processing request.",
                    source_pipeline: "error"
                };
            }
            setMessages(prev => [...prev, errorReplyMessage]);
            setChatStatus(`Error: ${errorText.substring(0,70)}...`);
            toast.error(errorText);
        } finally {
            setIsSending(false);
        }
    };
    
    useEffect(() => {
        if (!currentSessionId) {
            setChatStatus("Please login or start a new chat.");
        } else if (messages.length === 0 && !isSending) {
            setChatStatus("Ready. Send a message to start!");
        }
    }, [currentSessionId, messages, isSending, setChatStatus]); // Added setChatStatus to dependency array


    return (
        <div className="flex flex-col h-full bg-background-light dark:bg-background-dark rounded-lg shadow-inner">
            {messages.length === 0 && !isSending && currentSessionId && (
                 <div className="p-6 sm:p-8 text-center text-text-muted-light dark:text-text-muted-dark animate-fadeIn">
                    <h2 className="text-xl sm:text-2xl font-semibold mb-2 text-text-light dark:text-text-dark">
                        AI Engineering Tutor
                    </h2>
                    <p className="text-base sm:text-lg mb-3">Session ID: {currentSessionId.substring(0,8)}...</p>
                    <div className="text-xs sm:text-sm space-y-1">
                        <p>Current LLM: <span className="font-semibold text-accent">{selectedLLM.toUpperCase()}</span>.</p>
                        <p className="max-w-md mx-auto">
                            Assistant Mode: <span className="italic">"{systemPrompt.length > 60 ? systemPrompt.substring(0,60)+'...' : systemPrompt}"</span>
                        </p>
                        {selectedDocumentForAnalysis && (
                            <p className="mt-1">
                                Analysis Target: <span className="font-medium text-primary dark:text-primary-light">{selectedDocumentForAnalysis}</span>
                            </p>
                        )}
                        <p className="mt-1">
                            {useRag ? <span>RAG is <span className="text-green-500 font-semibold">ON</span>. Using document context.</span> 
                                  : <span>RAG is <span className="text-red-500 font-semibold">OFF</span>. Chatting directly.</span>}
                        </p>
                        <p> {/* New status for Critical Thinking (uses the component's state for display) */}
                            {criticalThinkingEnabled ? <span>Critical Thinking (KG) is <span className="text-purple-500 font-semibold">ON</span>.</span> 
                                  : <span>Critical Thinking (KG) is <span className="text-gray-500 font-semibold">OFF</span>.</span>}
                        </p>
                    </div>
                </div>
            )}

            <ChatHistory messages={messages} isLoading={isSending} />
            <ChatInput 
                onSendMessage={handleSendMessage} 
                isLoading={isSending} 
                currentStatus={chatStatus}
                useRag={useRag}
                setUseRag={setUseRag}
                criticalThinkingEnabled={criticalThinkingEnabled} // Pass state
                setCriticalThinkingEnabled={setCriticalThinkingEnabled} // Pass setter
            />
        </div>
    );
}
export default CenterPanel;
```

`src/components/layout/LeftCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/LeftCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { Edit3, UploadCloud, FileText, ChevronRight, Settings2 } from 'lucide-react'; // Settings2 for fallback
import IconButton from '../core/IconButton.jsx'; 
import { motion } from 'framer-motion';

// Mapping icon names (or IDs) to Lucide components
const iconMap = {
    prompt: Edit3,       // Icon for "Custom Prompt"
    upload: UploadCloud, // Icon for "Upload Document"
    docs: FileText,      // Icon for "Document List"
};

function LeftCollapsedNav() {
    const { setIsLeftPanelOpen } = useAppState();

    // Define the items for the collapsed navigation bar
    const navItems = [
        { 
            id: 'prompt', 
            label: 'Custom Prompt', 
            iconName: 'prompt', // Matches key in iconMap
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, also scroll to/focus the prompt section in LeftPanel
            } 
        },
        { 
            id: 'upload', 
            label: 'Upload Document', 
            iconName: 'upload', 
            action: () => { 
                setIsLeftPanelOpen(true);
                // TODO: Optionally, open LeftPanel and focus/highlight upload area
            } 
        },
        { 
            id: 'docs', 
            label: 'Document List', 
            iconName: 'docs', 
            action: () => { 
                setIsLeftPanelOpen(true); 
                // TODO: Optionally, open LeftPanel scrolled to document list
            } 
        },
    ];

    return (
        <motion.aside
            key="left-collapsed-nav" // Unique key for AnimatePresence
            initial={{ x: '-100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '-100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            // Styling for the thin vertical bar
            className="fixed left-0 top-16 bottom-0 z-30 w-14 sm:w-16 
                       bg-surface-light dark:bg-surface-dark 
                       border-r border-border-light dark:border-border-dark 
                       shadow-lg flex flex-col items-center py-3 space-y-2 custom-scrollbar"
        >
            {/* Button to open the full LeftPanel - Placed at the top */}
            <IconButton 
                icon={ChevronRight} 
                onClick={() => setIsLeftPanelOpen(true)} 
                title="Open Assistant Panel"
                ariaLabel="Open Assistant Panel"
                variant="ghost" 
                size="lg" // Make it prominent
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />

            {/* Icons for different sections of LeftPanel */}
            {navItems.map(item => {
                const IconComponent = iconMap[item.iconName] || Settings2; // Fallback icon
                return (
                    <IconButton 
                        key={item.id}
                        icon={IconComponent}
                        onClick={item.action} // Action currently just opens the panel
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md" 
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
            {/* Add a flexible spacer if you want the open button pushed further down from items */}
            {/* <div className="flex-grow"></div> */}
        </motion.aside>
    );
}
export default LeftCollapsedNav;
```

`src/components/layout/LeftPanel.jsx`

```javascript
// frontend/src/components/layout/LeftPanel.jsx
import React, { useState, useEffect } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import DocumentUpload from '../documents/DocumentUpload.jsx';
import DocumentList from '../documents/DocumentList.jsx';   
import { PanelLeftClose, ChevronDown, ChevronUp, FilePlus, Settings2, Bot, BookOpen, Lightbulb } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion, AnimatePresence } from 'framer-motion'; // Added AnimatePresence here
import toast from 'react-hot-toast'; // For toast notifications

const PROMPT_PRESETS = [
    { id: 'friendly_tutor', name: 'Friendly Tutor', icon: Bot, text: "You are a friendly, patient, and encouraging tutor specializing in engineering and scientific topics for PhD students. Explain concepts clearly, break down complex ideas, use analogies, and offer positive reinforcement. Ask follow-up questions to ensure understanding." },
    { id: 'concept_explorer', name: 'Concept Explorer', icon: BookOpen, text: "You are an expert academic lecturer introducing a new, complex engineering or scientific concept. Your goal is to provide a deep, structured explanation. Define terms rigorously, outline the theory, provide relevant mathematical formulations (using Markdown), illustrative examples, and discuss applications or limitations pertinent to PhD-level research." },
    { id: 'knowledge_check', name: 'Knowledge Check', icon: Lightbulb, text: "You are assessing understanding of engineering/scientific topics. Ask targeted questions to test knowledge, identify misconceptions, and provide feedback on the answers. Start by asking the user what topic they want to be quizzed on." },
    { id: 'custom', name: 'Custom Prompt', icon: Settings2, text: "You are a helpful AI engineering tutor." }
];

function LeftPanel() {
    const { 
        setIsLeftPanelOpen, 
        systemPrompt, setSystemPrompt, 
        selectDocumentForAnalysis, selectedDocumentForAnalysis // Get these from AppStateContext
    } = useAppState();
    
    const [isPromptSectionOpen, setIsPromptSectionOpen] = useState(true);
    const [isDocManagementOpen, setIsDocManagementOpen] = useState(true);
    const [selectedPresetId, setSelectedPresetId] = useState('custom');

    useEffect(() => {
        const matchedPreset = PROMPT_PRESETS.find(p => p.text === systemPrompt);
        setSelectedPresetId(matchedPreset ? matchedPreset.id : 'custom');
    }, [systemPrompt]);

    const handlePresetChange = (event) => {
        const presetId = event.target.value;
        setSelectedPresetId(presetId);
        const selectedPreset = PROMPT_PRESETS.find(p => p.id === presetId);
        if (selectedPreset) {
            setSystemPrompt(selectedPreset.text);
        }
    };
    
    const [docListKey, setDocListKey] = useState(Date.now()); 
    const handleUploadSuccess = () => { 
        setDocListKey(Date.now()); 
        toast.success("Document list refreshed after upload.");
    };
    

    const SelectedPresetIcon = PROMPT_PRESETS.find(p => p.id === selectedPresetId)?.icon || Settings2;

    return (
        <div className="flex flex-col h-full">
            <div className="flex items-center justify-between mb-3 px-1 pt-1">
                <h2 className="text-sm font-semibold text-text-light dark:text-text-dark">Assistant Controls</h2>
                <IconButton 
                    icon={PanelLeftClose} 
                    onClick={() => setIsLeftPanelOpen(false)} 
                    title="Close Assistant Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary"
                />
            </div>

            {/* Custom Prompt Section */}
            <div className="mb-4">
                <button 
                    onClick={() => setIsPromptSectionOpen(!isPromptSectionOpen)}
                    className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark"
                    aria-expanded={isPromptSectionOpen}
                >
                    <span className="flex items-center gap-2">
                        <SelectedPresetIcon size={16} className="text-primary dark:text-primary-light" />
                        Custom Prompt
                    </span>
                    {isPromptSectionOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isPromptSectionOpen && (
                        <motion.div 
                            key="prompt-section-content"
                            initial={{ height: 0, opacity: 0 }} 
                            animate={{ height: 'auto', opacity: 1 }} 
                            exit={{ height: 0, opacity: 0 }}
                            transition={{ duration: 0.2, ease: "easeInOut" }}
                            className="mt-2 p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner overflow-hidden"
                        >
                            <label htmlFor="prompt-preset-select" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">
                                Prompt Mode:
                            </label>
                            <select
                                id="prompt-preset-select"
                                value={selectedPresetId}
                                onChange={handlePresetChange}
                                className="input-field mb-2 text-xs py-1.5"
                            >
                                {PROMPT_PRESETS.map(preset => (
                                    <option key={preset.id} value={preset.id}>{preset.name}</option>
                                ))}
                            </select>
                            
                            <label htmlFor="system-prompt-area" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">
                                System Prompt (Editable):
                            </label>
                            <textarea
                                id="system-prompt-area"
                                value={systemPrompt}
                                onChange={(e) => {
                                    setSystemPrompt(e.target.value);
                                    setSelectedPresetId('custom');
                                }}
                                rows="5"
                                className="input-field text-xs custom-scrollbar"
                                placeholder="Enter system prompt..."
                            />
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>

            {/* Document Management Section */}
            <div className="flex-grow flex flex-col overflow-hidden">
                 <button 
                    onClick={() => setIsDocManagementOpen(!isDocManagementOpen)}
                    className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left text-text-light dark:text-text-dark bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-2"
                    aria-expanded={isDocManagementOpen}
                >
                    <span className="flex items-center gap-2"><FilePlus size={16} className="text-primary dark:text-primary-light" /> Document Management</span>
                    {isDocManagementOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                </button>
                <AnimatePresence>
                    {isDocManagementOpen && (
                        <motion.div 
                            key="doc-management-content"
                            initial={{ height: 0, opacity: 0 }} 
                            animate={{ height: 'auto', opacity: 1 }} 
                            exit={{ height: 0, opacity: 0 }}
                            transition={{ duration: 0.2, ease: "easeInOut" }}
                            className="flex-grow flex flex-col overflow-hidden p-3 bg-surface-light dark:bg-surface-dark border border-border-light dark:border-border-dark rounded-md shadow-inner"
                        >
                            <DocumentUpload onUploadSuccess={handleUploadSuccess} />
                            <div className="mt-3 flex-grow overflow-y-auto custom-scrollbar">
                                <label htmlFor="doc-filter" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">Filter documents:</label>
                                 <select id="doc-filter" className="input-field text-xs mt-1 mb-2 py-1.5">
                                    <option value="all">All Documents</option>
                                    <option value="pdf">PDFs</option>
                                    {/* More filter options */}
                                </select>
                                <DocumentList 
                                    key={docListKey} // To re-fetch files on upload
                                    onSelectDocument={selectDocumentForAnalysis} // Pass setter from context
                                    selectedDocument={selectedDocumentForAnalysis} // Pass current selection from context
                                />
                            </div>
                        </motion.div>
                    )}
                </AnimatePresence>
            </div>
        </div>
    );
}
export default LeftPanel;
```

`src/components/layout/LLMSelectionModal.jsx`

```javascript
// frontend/src/components/layout/LLMSelectionModal.jsx
import React, { useState, useEffect } from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import api from '../../services/api.js'; // For V1, this is mocked
import toast from 'react-hot-toast';
import { X, Save, KeyRound, Link2, AlertCircle } from 'lucide-react';
import Modal from '../core/Modal.jsx'; // Using the generic Modal component
import Button from '../core/Button.jsx';
import LLMSelection from '../auth/LLMSelection.jsx';
import { motion } from 'framer-motion';

function LLMSelectionModal({ isOpen, onClose, currentLLM, onSelectLLM }) {
    // This component now acts as the content provider for the generic Modal
    const { switchLLM: setGlobalLLMPreference } = useAppState();
    
    const [locallySelectedLLM, setLocallySelectedLLM] = useState(currentLLM);
    const [geminiApiKeyInput, setGeminiApiKeyInput] = useState('');
    const [ollamaApiUrlInput, setOllamaApiUrlInput] = useState('');
    
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        if (isOpen) {
            setLocallySelectedLLM(currentLLM); // Sync with global when modal opens
            setGeminiApiKeyInput(''); 
            setOllamaApiUrlInput(''); 
            setError('');
        }
    }, [isOpen, currentLLM]);

    const handleSavePreference = async () => {
        setLoading(true); 
        setError('');
        const toastId = toast.loading('Saving LLM preference...');
        try {
            const configData = { llmProvider: locallySelectedLLM };
            if (locallySelectedLLM === 'gemini' && geminiApiKeyInput.trim()) {
                configData.apiKey = geminiApiKeyInput.trim();
            }
            if (locallySelectedLLM === 'ollama' && ollamaApiUrlInput.trim()) {
                configData.ollamaUrl = ollamaApiUrlInput.trim();
            }
            
            await api.updateUserLLMConfig(configData); // Mocked in V1
            
            setGlobalLLMPreference(locallySelectedLLM); // Update global AppStateContext
            if(onSelectLLM) onSelectLLM(locallySelectedLLM); // Inform parent (TopNav) if needed

            toast.dismiss(toastId);
            toast.success(`LLM preference updated to ${locallySelectedLLM.toUpperCase()} (mocked).`);
            onClose(); // Close the modal
        } catch (err) {
            toast.dismiss(toastId);
            const errorMessage = err.response?.data?.message || err.message || 'Failed to update LLM preference.';
            setError(errorMessage);
            toast.error(errorMessage);
        } finally {
            setLoading(false);
        }
    };
    
    const inputWrapperClass = "relative";
    const inputIconClass = "absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-text-muted-light dark:text-text-muted-dark pointer-events-none";
    const inputFieldStyledClass = "input-field pl-10 py-2 text-sm";

    return (
         <Modal 
            isOpen={isOpen} 
            onClose={onClose} 
            title="Switch LLM Provider" 
            size="lg"
            footerContent={ // Pass footer buttons to the generic Modal
                <>
                    <Button variant="ghost" onClick={onClose} disabled={loading} className="text-sm">Cancel</Button>
                    <Button onClick={handleSavePreference} isLoading={loading} className="text-sm" leftIcon={<Save size={16}/>}>
                        Save Preference
                    </Button>
                </>
            }
        >
            {/* This is the children prop for the generic Modal */}
            <div className="space-y-5"> 
                <p className="text-sm text-text-muted-light dark:text-text-muted-dark">
                    Select your preferred Large Language Model. Your choice will be saved for future sessions. (V1 uses mock data regardless).
                </p>
                <LLMSelection 
                    selectedLLM={locallySelectedLLM} 
                    onLlmChange={setLocallySelectedLLM}
                    disabled={loading}
                />
                {locallySelectedLLM === 'gemini' && (
                    <motion.div 
                        key="gemini-config-modal" 
                        initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}
                        className="mt-4 space-y-1 overflow-hidden"
                    >
                        <label htmlFor="modalGeminiApiKey" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">
                            Gemini API Key (Optional - Enter to update)
                        </label>
                        <div className={inputWrapperClass}>
                            <KeyRound className={inputIconClass} />
                            <input
                                type="password"
                                id="modalGeminiApiKey"
                                className={inputFieldStyledClass}
                                placeholder="Leave blank to use existing/default"
                                value={geminiApiKeyInput}
                                onChange={(e) => setGeminiApiKeyInput(e.target.value)}
                                disabled={loading}
                            />
                        </div>
                    </motion.div>
                )}
                {locallySelectedLLM === 'ollama' && (
                    <motion.div 
                        key="ollama-config-modal" 
                        initial={{ opacity: 0, height: 0 }} animate={{ opacity: 1, height: 'auto' }} exit={{ opacity: 0, height: 0 }}
                        className="mt-4 space-y-1 overflow-hidden"
                    >
                        <label htmlFor="modalOllamaUrl" className="block text-xs font-medium text-text-muted-light dark:text-text-muted-dark mb-1">
                            Ollama API URL (Optional - Enter to update)
                        </label>
                         <div className={inputWrapperClass}>
                            <Link2 className={inputIconClass} />
                            <input
                                type="text"
                                id="modalOllamaUrl"
                                className={inputFieldStyledClass}
                                placeholder="Default (usually http://localhost:11434)"
                                value={ollamaApiUrlInput}
                                onChange={(e) => setOllamaApiUrlInput(e.target.value)}
                                disabled={loading}
                            />
                        </div>
                    </motion.div>
                )}
                {/* Corrected error display */}
                {error && (
                    <div className="p-3 mt-3 bg-red-500/10 border border-red-500/30 text-red-600 dark:text-red-300 rounded-md text-sm flex items-center gap-2 animate-fadeIn">
                        <AlertCircle size={18}/> {error}
                    </div>
                )}
            </div>
        </Modal>
    );
}

export default LLMSelectionModal;
```

`src/components/layout/RightCollapsedNav.jsx`

```javascript
// frontend/src/components/layout/RightCollapsedNav.jsx
import React from 'react';
import { useAppState } from '../../contexts/AppStateContext.jsx';
import { HelpCircle, GitFork, Tags, ChevronLeft } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

const iconMap = {
    HelpCircle: HelpCircle,
    Tags: Tags,
    GitFork: GitFork,
};

function RightCollapsedNav() {
    const { setIsRightPanelOpen } = useAppState();

    const navItems = [
        { id: 'faq', label: 'FAQ Generator', iconName: 'HelpCircle', action: () => { setIsRightPanelOpen(true); /* TODO: set analysis type contextually */ } },
        { id: 'topics', label: 'Key Topics Extractor', iconName: 'Tags', action: () => { setIsRightPanelOpen(true); } },
        { id: 'mindmap', label: 'Mind Map Creator', iconName: 'GitFork', action: () => { setIsRightPanelOpen(true); } },
    ];

    return (
        <motion.aside
            key="right-collapsed-nav"
            initial={{ x: '100%', opacity: 0 }}
            animate={{ x: '0%', opacity: 1 }}
            exit={{ x: '100%', opacity: 0 }}
            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
            className="fixed right-0 top-16 bottom-0 z-30 w-14 sm:w-16 bg-surface-light dark:bg-surface-dark border-l border-border-light dark:border-border-dark shadow-lg flex-col items-center py-3 space-y-2 hidden md:flex"
        >
            {/* Open Panel Button AT THE TOP */}
            <IconButton 
                icon={ChevronLeft} 
                onClick={() => setIsRightPanelOpen(true)} 
                title="Open Analyzer Panel"
                ariaLabel="Open Analyzer Panel"
                variant="ghost" 
                size="lg"
                className="mb-2 text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
            />
            {navItems.map(item => {
                 const Icon = iconMap[item.iconName] || HelpCircle;
                return (
                    <IconButton 
                        key={item.id}
                        icon={Icon}
                        onClick={item.action}
                        title={item.label}
                        ariaLabel={item.label}
                        variant="ghost"
                        size="md"
                        className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                    />
                );
            })}
        </motion.aside>
    );
}
export default RightCollapsedNav;
```

`src/components/layout/RightPanel.jsx`

```javascript
// src/components/layout/RightPanel.jsx
import React, { useState } from 'react'; // Removed useEffect if not used
import { useAppState } from '../../contexts/AppStateContext';
// import AnalysisTool from '../analysis/AnalysisTool.jsx'; // Comment out or remove old import
import AnalysisToolRunner from '../analysis/AnalysisToolRunner.jsx'; // <-- NEW IMPORT
import { PanelRightClose, ChevronDown, ChevronUp, Telescope } from 'lucide-react';
import IconButton from '../core/IconButton.jsx';
import { motion } from 'framer-motion';

function RightPanel() {
    const { setIsRightPanelOpen, selectedDocumentForAnalysis } = useAppState();
    const [isAnalyzerOpen, setIsAnalyzerOpen] = useState(true);

    const currentSelectedDocFilename = selectedDocumentForAnalysis || null;

    return (
        <div className="flex flex-col h-full p-3 sm:p-4 bg-surface-light dark:bg-surface-dark text-text-light dark:text-text-dark custom-scrollbar">
            <div className="flex items-center justify-between mb-4 pb-2 border-b border-border-light dark:border-border-dark">
                <h2 className="text-base font-semibold">Advanced Analyzer</h2>
                <IconButton 
                    icon={PanelRightClose} 
                    onClick={() => setIsRightPanelOpen(false)} 
                    title="Close Analyzer Panel"
                    variant="ghost"
                    size="sm"
                    className="text-text-muted-light dark:text-text-muted-dark hover:text-primary dark:hover:text-primary-light"
                />
            </div>
            
            <button 
                onClick={() => setIsAnalyzerOpen(!isAnalyzerOpen)}
                className="w-full flex items-center justify-between px-3 py-2.5 text-sm font-medium text-left bg-gray-50 dark:bg-gray-800 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-md focus:outline-none shadow-sm border border-border-light dark:border-border-dark mb-3"
            >
                <span className="flex items-center gap-2"><Telescope size={16} /> Analysis Tools</span>
                {isAnalyzerOpen ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
            </button>

            {isAnalyzerOpen && (
                <motion.div 
                    initial={{ height: 0, opacity: 0 }} 
                    animate={{ height: 'auto', opacity: 1 }} 
                    exit={{ height: 0, opacity: 0 }}
                    transition={{ duration: 0.2, ease: "easeInOut" }}
                    className="flex-grow space-y-3 overflow-y-auto custom-scrollbar pr-1"
                >
                    {!currentSelectedDocFilename && (
                        <div className="p-4 text-xs text-center text-text-muted-light dark:text-text-muted-dark bg-gray-50 dark:bg-gray-800 rounded-md border border-dashed border-border-light dark:border-border-dark">
                            <p>Select a document from the left panel to enable analysis tools.</p>
                        </div>
                    )}
                    {/* Replace AnalysisTool with AnalysisToolRunner */}
                    <AnalysisToolRunner toolType="faq" title="FAQ Generator" iconName="HelpCircle" selectedDocumentFilename={currentSelectedDocFilename} />
                    <AnalysisToolRunner toolType="topics" title="Key Topics Extractor" iconName="Tags" selectedDocumentFilename={currentSelectedDocFilename} />
                    <AnalysisToolRunner toolType="mindmap" title="Mind Map Creator" iconName="GitFork" selectedDocumentFilename={currentSelectedDocFilename} />
                </motion.div>
            )}
        </div>
    );
}
export default RightPanel;
```

`src/components/layout/TopNav.jsx`

```javascript
// frontend/src/components/layout/TopNav.jsx
import React, { useState } from 'react';
import { useAuth } from '../../hooks/useAuth';
import { useAppState } from '../../contexts/AppStateContext';
import ThemeToggle from '../common/ThemeToggle.jsx';
import LLMSelectionModal from './LLMSelectionModal.jsx';
import { 
    LogOut, User, MessageSquare, History as HistoryIcon, Settings, Cpu, Zap, ServerCrash, Server 
} from 'lucide-react';
import toast from 'react-hot-toast';

function TopNav({ user: authUser, onLogout, onNewChat, onHistoryClick, orchestratorStatus }) { // Renamed user to authUser to avoid conflict
    const { selectedLLM, switchLLM } = useAppState();
    const [isLLMModalOpen, setIsLLMModalOpen] = useState(false);
    
    const getStatusIndicator = () => {
        if (!orchestratorStatus) return <div title="Status unavailable" className="w-4 h-4 bg-gray-400 rounded-full"></div>;
        if (orchestratorStatus.status === "ok") {
            return <Zap size={18} className="text-green-400 animate-pulse" title={`Backend Online: ${orchestratorStatus.message}`} />;
        } else if (orchestratorStatus.status === "loading") {
            return <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-yellow-400" title="Connecting..."></div>;
        } else {
            return <ServerCrash size={18} className="text-red-400" title={`Backend Offline: ${orchestratorStatus.message}`} />;
        }
    };
    
    return (
        <>
            <nav className="fixed top-0 left-0 right-0 z-40 bg-surface-light dark:bg-surface-dark border-b border-border-light dark:border-border-dark shadow-sm h-16 flex items-center justify-between px-2 sm:px-4">
                <div className="flex items-center gap-2">
                    <a href="/" className="flex items-center gap-1.5 sm:gap-2 text-lg sm:text-xl font-semibold text-text-light dark:text-text-dark">
                        <Server size={24} className="text-primary dark:text-primary-light" />
                        <span className="hidden sm:inline">AI Tutor</span>
                    </a>
                </div>

                <div className="flex-1 flex justify-center px-2">
                    <div className="flex items-center gap-1 sm:gap-2">
                         <button
                            onClick={onNewChat} // Connected to App.jsx handleNewChat
                            className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                            title="Start a new chat session"
                        >
                            <MessageSquare size={14} /> <span className="hidden sm:inline">New Chat</span>
                        </button>
                        <button
                            onClick={onHistoryClick} // Connected to App.jsx setIsHistoryModalOpen(true)
                            className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                            title="View chat history"
                        >
                            <HistoryIcon size={14} /> <span className="hidden sm:inline">History</span>
                        </button>
                        <button
                            onClick={() => setIsLLMModalOpen(true)}
                            className="flex items-center gap-1 px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700 hover:bg-gray-200 dark:hover:bg-gray-600 transition-colors"
                            title={`Switch LLM (Current: ${selectedLLM.toUpperCase()})`}
                        >
                            <Cpu size={14} /> <span className="hidden xs:inline">{selectedLLM.toUpperCase()}</span>
                        </button>
                    </div>
                </div>

                <div className="flex items-center gap-1.5 sm:gap-2">
                    {getStatusIndicator()}
                    <ThemeToggle />
                    <div className="relative group">
                        <button className="p-1.5 bg-primary-light dark:bg-primary-dark text-white rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-surface-light dark:focus:ring-offset-surface-dark focus:ring-primary">
                            <User size={18} />
                        </button>
                        <div className="absolute right-0 mt-2 w-48 bg-surface-light dark:bg-surface-dark rounded-md shadow-lg py-1 opacity-0 group-hover:opacity-100 focus-within:opacity-100 transition-opacity duration-150 ease-in-out transform scale-95 group-hover:scale-100 focus-within:scale-100 origin-top-right invisible group-hover:visible focus-within:visible z-50">
                            <div className="px-4 py-2 text-sm text-text-light dark:text-text-dark border-b border-border-light dark:border-border-dark">
                                Signed in as <br/><strong>{authUser?.username || 'User'}</strong>
                            </div>
                            <button
                                onClick={() => toast.info("Profile settings coming soon!")}
                                className="w-full text-left px-4 py-2 text-sm text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
                            >
                                <Settings size={16} /> Profile
                            </button>
                            <button
                                onClick={onLogout} // Connected to App.jsx handleLogoutAndShowModal
                                className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900 flex items-center gap-2"
                            >
                                <LogOut size={16} /> Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
            <LLMSelectionModal 
                isOpen={isLLMModalOpen} 
                onClose={() => setIsLLMModalOpen(false)} 
                currentLLM={selectedLLM}
                onSelectLLM={(llm) => {
                    switchLLM(llm); // From AppStateContext
                    setIsLLMModalOpen(false);
                }}
            />
        </>
    );
}
export default TopNav;
```

`src/contexts/AppStateContext.jsx`

```javascript
// frontend/src/contexts/AppStateContext.jsx
import React, { createContext, useState, useContext, useEffect } from 'react';

export const AppStateContext = createContext(null);

export const useAppState = () => {
    const context = useContext(AppStateContext);
    if (!context) throw new Error('useAppState must be used within an AppStateProvider');
    return context;
};

const defaultSystemPromptText = "You are a helpful AI engineering tutor.";

export const AppStateProvider = ({ children }) => {
    const [theme, setThemeState] = useState(() => {
        const storedTheme = localStorage.getItem('theme') || 'dark'; // Default to dark
        // Apply theme to HTML element on initial load
        if (typeof window !== 'undefined') {
            document.documentElement.classList.remove('light', 'dark');
            document.documentElement.classList.add(storedTheme);
        }
        return storedTheme;
    });

    const [selectedLLM, setSelectedLLM] = useState(localStorage.getItem('selectedLLM') || 'gemini'); // Default to gemini
    const [isLeftPanelOpen, setIsLeftPanelOpen] = useState(true);
    const [isRightPanelOpen, setIsRightPanelOpen] = useState(true);
    
    const [currentSessionId, setCurrentSessionIdState] = useState(() => {
        return localStorage.getItem('aiTutorSessionId') || null;
    });
    
    const [systemPrompt, setSystemPromptState] = useState(
        localStorage.getItem('aiTutorSystemPrompt') || defaultSystemPromptText
    );
    const [selectedDocumentForAnalysis, setSelectedDocumentForAnalysisState] = useState(null);

    // <<< NEW STATE FOR ADMIN SESSION >>>
    const [isAdminSessionActive, setIsAdminSessionActiveState] = useState(() => {
        // Check sessionStorage on initial load
        return sessionStorage.getItem('isAdminSessionActive') === 'true';
    });

    const toggleTheme = () => {
        setThemeState(prevTheme => {
            const newTheme = prevTheme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            // Side effect for HTML class managed by useEffect below
            return newTheme;
        });
    };
    
    const switchLLM = (llm) => {
         setSelectedLLM(llm); 
         localStorage.setItem('selectedLLM', llm);
         console.log("AppStateContext: Switched LLM to:", llm);
    };
    
    const setSessionId = (sessionId) => { // This is the global setter for session ID
        if (sessionId) {
            localStorage.setItem('aiTutorSessionId', sessionId);
        } else {
            localStorage.removeItem('aiTutorSessionId');
        }
        setCurrentSessionIdState(sessionId); 
        console.log("AppStateContext: Global session ID updated to:", sessionId);
    };

    const setSystemPrompt = (promptText) => {
        setSystemPromptState(promptText);
        localStorage.setItem('aiTutorSystemPrompt', promptText);
    };

    const selectDocumentForAnalysis = (documentFile) => { // documentFile is expected to be the filename string
        setSelectedDocumentForAnalysisState(documentFile); 
        console.log("AppStateContext: Document selected for analysis:", documentFile || "None");
    };

    // <<< NEW SETTER FOR ADMIN SESSION FLAG >>>
    const setIsAdminSessionActive = (isActive) => {
        if (isActive) {
            sessionStorage.setItem('isAdminSessionActive', 'true');
            // When admin becomes active, we should clear any regular user's session ID
            // to prevent conflicts or carrying over state.
            // The regular user auth token remains in localStorage but won't be used
            // while isAdminSessionActive is true (as per App.jsx logic).
            // If you want to fully log out the regular user when admin logs in,
            // you'd call the logout function from AuthContext here.
            // For now, just making admin session dominant.
            // setSessionId(null); // Optional: clear regular user session ID
        } else {
            sessionStorage.removeItem('isAdminSessionActive');
        }
        setIsAdminSessionActiveState(isActive);
        console.log("AppStateContext: Admin session active status set to:", isActive);
    };

    // Effect to apply theme to HTML element and body
    useEffect(() => {
        const rootHtmlElement = document.documentElement;
        rootHtmlElement.classList.remove('light', 'dark');
        rootHtmlElement.classList.add(theme);
        
        // Also manage body background for non-Tailwind elements if necessary
        document.body.className = ''; // Clear existing body classes
        document.body.classList.add(theme === 'dark' ? 'bg-background-dark' : 'bg-background-light');
        console.log("AppStateContext: Theme effect, theme is:", theme);
    }, [theme]);

    return (
        <AppStateContext.Provider value={{
            theme, toggleTheme,
            selectedLLM, switchLLM,
            isLeftPanelOpen, setIsLeftPanelOpen,
            isRightPanelOpen, setIsRightPanelOpen,
            currentSessionId, setSessionId, // Exposing the setter
            systemPrompt, setSystemPrompt,
            selectedDocumentForAnalysis, selectDocumentForAnalysis,
            isAdminSessionActive, setIsAdminSessionActive // <<< EXPOSE NEW STATE & SETTER
        }}>
            {children}
        </AppStateContext.Provider>
    );
};
```

`src/contexts/AuthContext.jsx`

```javascript
// frontend/src/contexts/AuthContext.jsx
import React, { createContext, useState, useEffect, useCallback } from 'react';
import api from '../services/api.js'; 
import toast from 'react-hot-toast';
// No need for jwt-decode here if backend sends user details or /me provides them.

export const AuthContext = createContext(null);

// --- DEVELOPMENT FLAGS ---
export const DEV_MODE_ALLOW_DEV_LOGIN = false; // <-- SET TO false
const MOCK_DEV_USERNAME = 'DevUser'; 
const MOCK_DEV_PASSWORD = 'devpassword';   
// --- END DEVELOPMENT FLAGS ---

export const AuthProvider = ({ children }) => {
    const [token, setTokenState] = useState(localStorage.getItem('authToken'));
    const [user, setUserState] = useState(null);
    const [loading, setLoading] = useState(true);

    const setToken = (newToken) => {
        if (newToken) {
            localStorage.setItem('authToken', newToken);
        } else {
            localStorage.removeItem('authToken');
        }
        setTokenState(newToken);
    };

    const setUser = (newUser) => {
        setUserState(newUser);
    };
    
    const processAuthData = useCallback((authApiResponse) => {
        // Expects authApiResponse to be: { token, _id, username, sessionId?, message? }
        if (authApiResponse && authApiResponse.token && authApiResponse._id && authApiResponse.username) {
            setToken(authApiResponse.token);
            setUser({ id: authApiResponse._id, username: authApiResponse.username });
            console.log("AuthContext: User and Token set.", { username: authApiResponse.username });
            // Session ID from authApiResponse (like authApiResponse.sessionId)
            // will be passed to App.jsx through the onClose callback of AuthModal
            return authApiResponse; 
        } else {
            console.error("AuthContext: processAuthData received incomplete data from API", authApiResponse);
            // Clear any partial auth state
            setToken(null);
            setUser(null);
            throw new Error("Authentication response from server was incomplete.");
        }
    }, []); // No dependencies needed as setToken and setUser are stable

    useEffect(() => {
        const verifyTokenAndLoadUser = async () => {
            const storedToken = localStorage.getItem('authToken');
            if (storedToken) {
                setTokenState(storedToken); // Set token for api.getMe() to use Authorization header
                try {
                    console.log("AuthContext: Found stored token. Verifying with /me...");
                    const userDataFromMe = await api.getMe(); // api.js will include the token
                    if (userDataFromMe && userDataFromMe._id && userDataFromMe.username) {
                        setUser({ id: userDataFromMe._id, username: userDataFromMe.username });
                        // Token is already set from localStorage and has been confirmed valid by /me
                        console.log("AuthContext: Token verified, user loaded via /me.", userDataFromMe);
                    } else {
                        console.warn("AuthContext: /me endpoint did not return valid user data.", userDataFromMe);
                        setToken(null); // Clear invalid token from state and localStorage
                        setUser(null);
                    }
                } catch (error) {
                    console.warn("AuthContext: Auto-login via /me failed. Token might be invalid or expired.", error.message);
                    setToken(null); // Clear invalid token
                    setUser(null);
                }
            } else {
                console.log("AuthContext: No stored token found.");
            }
            setLoading(false);
        };
        verifyTokenAndLoadUser();
    }, []);

    const login = async (credentials) => {
        setLoading(true);
        try {
            const data = await api.login(credentials); // data = { token, _id, username, sessionId, message }
            return processAuthData(data);
        } catch (error) {
            setToken(null); 
            setUser(null);
            console.error("AuthContext login error:", error.response?.data?.message || error.message);
            throw error; 
        } finally {
            setLoading(false);
        }
    };
    
    const signup = async (signupData) => {
        setLoading(true);
        try {
            const data = await api.signup(signupData); // data = { token, _id, username, sessionId, message }
            return processAuthData(data);
        } catch (error) {
            setToken(null);
            setUser(null);
            console.error("AuthContext signup error:", error.response?.data?.message || error.message);
            throw error;
        } finally {
            setLoading(false);
        }
    };

    const logout = () => {
        console.log("AuthContext: Logging out user.");
        setToken(null); 
        setUser(null);
        // Other contexts (like AppStateContext for sessionId) should react to token/user becoming null.
        toast.success("You have been logged out.");
    };

    // Dev login will attempt to use MOCK_DEV_USERNAME/PASSWORD against the REAL backend if DEV_MODE_MOCK_API in api.js is false.
    // This will likely fail unless that user exists on the backend.
    const devLogin = async () => {
        if (!DEV_MODE_ALLOW_DEV_LOGIN) {
            const msg = "Dev Quick Login is disabled in AuthContext.";
            toast.error(msg);
            return Promise.reject(new Error(msg));
        }
        console.warn("AuthContext: devLogin initiated. This attempts to log in with MOCK credentials against the configured API endpoint.");
        setLoading(true);
        try {
            const data = await api.login({ username: MOCK_DEV_USERNAME, password: MOCK_DEV_PASSWORD });
            return processAuthData(data);
        } catch (error) {
            setToken(null);
            setUser(null);
            const errorMsg = error.response?.data?.message || error.message || "Dev login attempt failed.";
            console.error("AuthContext: Dev Quick Login via API failed:", errorMsg);
            toast.error(`Dev Login Error: ${errorMsg}`);
            throw error; 
        } finally {
            setLoading(false);
        }
    };

    return (
        <AuthContext.Provider value={{ 
            token, 
            user, 
            loading, 
            login, 
            signup, 
            logout, 
            devLogin: DEV_MODE_ALLOW_DEV_LOGIN ? devLogin : undefined,
            setUser, // Allow App.jsx or other components to potentially set user details if needed
            // setToken, // Exposing setToken directly is usually not needed by consumers
            DEV_MODE_ALLOW_DEV_LOGIN,
            MOCK_DEV_USERNAME,
            MOCK_DEV_PASSWORD
        }}>
            {children}
        </AuthContext.Provider>
    );
};
```

`src/hooks/useAuth.jsx`

```javascript
import { useContext } from 'react';
import { AuthContext } from '../contexts/AuthContext';

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
};
```

`src/hooks/useTextToSpeech.js`

```javascript
// src/hooks/useTextToSpeech.js
import { useState, useEffect, useCallback, useRef } from 'react';
import { marked } from 'marked'; // To parse markdown for plain text

// Configure marked (if not already globally configured for this specific use)
// It's generally better if marked is configured once, e.g. in MessageBubble or a central place.
// Assuming marked is available and configured.

const getPlainTextFromMarkdown = (markdown) => {
  if (!markdown) return '';
  try {
    // A simpler approach for plain text extraction for TTS:
    // Render to a temporary element and get its text content.
    // This handles complex markdown structures reasonably well for speech.
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = marked.parse(markdown); // marked.parse() is synchronous
    let text = tempDiv.textContent || tempDiv.innerText || '';
    
    // Basic cleanup: remove excessive newlines/spaces that might make speech awkward
    text = text.replace(/\n+/g, ' '); // Replace newlines with spaces
    text = text.replace(/\s\s+/g, ' '); // Replace multiple spaces with single
    return text.trim();
  } catch (error) {
    console.error("Error parsing markdown for TTS:", error);
    return markdown; // Fallback to raw markdown if parsing fails
  }
};


export const useTextToSpeech = () => {
    const [isSpeaking, setIsSpeaking] = useState(false);
    const [isSupported, setIsSupported] = useState(false);
    const utteranceRef = useRef(null);

    useEffect(() => {
        if (typeof window !== 'undefined' && window.speechSynthesis) {
            setIsSupported(true);
        }

        const handleEnd = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        
        const synth = window.speechSynthesis;
        if (synth) {
            // Add event listeners if needed, but onend on utterance is usually sufficient
        }

        return () => {
            if (synth) {
                synth.cancel(); // Cancel any speech on component unmount or hook cleanup
            }
        };
    }, []);

    const speak = useCallback(({ text, lang = 'en-US', voiceURI = null, rate = 1, pitch = 1, volume = 1 }) => {
        if (!isSupported || !text) return;

        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel(); // Stop any currently playing speech
        }
        
        const plainText = getPlainTextFromMarkdown(text);
        if (!plainText) {
            console.warn("TTS: No text content to speak after parsing markdown.");
            return;
        }

        const newUtterance = new SpeechSynthesisUtterance(plainText);
        newUtterance.lang = lang;
        newUtterance.rate = rate;
        newUtterance.pitch = pitch;
        newUtterance.volume = volume;

        if (voiceURI) {
            const voices = synth.getVoices();
            const selectedVoice = voices.find(voice => voice.voiceURI === voiceURI);
            if (selectedVoice) {
                newUtterance.voice = selectedVoice;
            }
        }
        
        newUtterance.onstart = () => {
            setIsSpeaking(true);
        };
        newUtterance.onend = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
        };
        newUtterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            setIsSpeaking(false);
            utteranceRef.current = null;
        };

        utteranceRef.current = newUtterance;
        synth.speak(newUtterance);
    }, [isSupported]);

    const cancel = useCallback(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        if (synth.speaking) {
            synth.cancel();
        }
        // onend should fire and set isSpeaking to false.
        // If it doesn't (e.g. cancel is abrupt), manually reset:
        if (isSpeaking) {
            setIsSpeaking(false);
            utteranceRef.current = null;
        }
    }, [isSupported, isSpeaking]);

    // Optional: Get available voices
    const getVoices = useCallback(() => {
        if (!isSupported) return [];
        return window.speechSynthesis.getVoices();
    }, [isSupported]);

    // Voices might load asynchronously. Listen for 'voiceschanged' event.
    useEffect(() => {
        if (!isSupported) return;
        const synth = window.speechSynthesis;
        const loadVoices = () => {
            // You might want to store voices in state if your UI allows voice selection
            // console.log("Voices loaded:", synth.getVoices());
        };
        synth.addEventListener('voiceschanged', loadVoices);
        // Initial load if voices are already available
        if (synth.getVoices().length > 0) {
            loadVoices();
        }
        return () => synth.removeEventListener('voiceschanged', loadVoices);
    }, [isSupported]);


    return {
        speak,
        cancel,
        isSpeaking,
        isSupported,
        getVoices,
        currentlySpeakingUtterance: utteranceRef.current
    };
};
```

`src/hooks/useTheme.js`

```javascript
// import { useContext } from 'react';
// import { AppStateContext } from '../contexts/AppStateContext'; // Assuming theme is in AppStateContext

// export const useTheme = () => {
//     const context = useContext(AppStateContext);
//     if (!context) {
//         throw new Error('useTheme must be used within an AppStateProvider');
//     }
//     return { theme: context.theme, toggleTheme: context.toggleTheme };
// };


import { useContext } from 'react';
import { AppStateContext } from '../contexts/AppStateContext.jsx'; // Correct named import for the context object

export const useTheme = () => {
    const context = useContext(AppStateContext); // Use the imported context object
    if (!context) {
        throw new Error('useTheme must be used within an AppStateProvider');
    }
    return { theme: context.theme, toggleTheme: context.toggleTheme };
};
```

`src/hooks/useWebSpeech.js`

```javascript
// src/hooks/useWebSpeech.js
import { useState, useEffect, useCallback } from 'react';

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

export const useWebSpeech = () => {
    const [transcript, setTranscript] = useState('');
    const [listening, setListening] = useState(false);
    const [recognitionInstance, setRecognitionInstance] = useState(null);
    const [error, setError] = useState(null); // Added error state
    const isSpeechSupported = !!SpeechRecognition;

    useEffect(() => {
        if (!isSpeechSupported) {
            console.warn("Web Speech API is not supported by this browser.");
            return;
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = false; // Set to true if you want it to keep listening
        recognition.interimResults = false; // Set to true for live results
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
            const currentTranscript = Array.from(event.results)
                .map(result => result[0])
                .map(result => result.transcript)
                .join('');
            setTranscript(currentTranscript);
            setError(null); // Clear error on successful result
            // console.log("Voice input result:", currentTranscript);
        };

        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            let errorMessage = event.error;
            if (event.error === 'no-speech') errorMessage = "No speech detected. Please try again.";
            else if (event.error === 'audio-capture') errorMessage = "Audio capture failed. Check microphone.";
            else if (event.error === 'not-allowed') errorMessage = "Microphone permission denied.";
            else if (event.error === 'network') errorMessage = "Network error during speech recognition.";
            // Add more specific error messages as needed
            
            setError(errorMessage);
            setListening(false);
        };

        recognition.onend = () => {
            setListening(false);
            // console.log("Speech recognition ended.");
        };
        
        setRecognitionInstance(recognition);

        // Cleanup
        return () => {
            if (recognition) {
                recognition.abort(); // Use abort to stop and discard results if component unmounts
            }
        };
    }, [isSpeechSupported]);

    const startListening = useCallback(() => {
        if (recognitionInstance && !listening) {
            try {
                setTranscript(''); // Clear previous transcript
                setError(null); // Clear previous errors
                recognitionInstance.start();
                setListening(true);
                // console.log("Speech recognition started.");
            } catch (e) {
                // This catch might be for synchronous errors during .start() call,
                // most errors are handled by recognition.onerror
                console.error("Error starting speech recognition:", e);
                setError("Could not start voice input.");
                setListening(false); // Ensure listening state is correct
            }
        }
    }, [recognitionInstance, listening]);

    const stopListening = useCallback(() => {
        if (recognitionInstance && listening) {
            recognitionInstance.stop(); // Stop and process any captured audio
            // setListening(false) will be called by onend event
            // console.log("Speech recognition stopped manually.");
        }
    }, [recognitionInstance, listening]);

    const resetTranscript = useCallback(() => {
        setTranscript('');
    }, []);


    return {
        transcript,
        listening,
        isSpeechSupported,
        startListening,
        stopListening,
        resetTranscript,
        error // Expose error state
    };
};
```

`src/index.css`

```css
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  html, body, #root { /* Apply to html, body, AND your React root div */
    @apply h-full overflow-hidden; /* Force full height and no scroll on these */
  }

  html {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    scroll-behavior: smooth; /* This is fine, affects internal scrolls */
  }

  body {
    @apply bg-background-light text-text-light transition-colors duration-300;
    font-family: theme('fontFamily.sans');
    /* overflow-hidden is now applied via the html, body, #root rule above */
  }

  html.dark body {
    @apply bg-background-dark text-text-dark;
  }
  html.light body {
    @apply bg-background-light text-text-light;
  }

  .custom-scrollbar {
     @apply scrollbar-thin scrollbar-thumb-secondary dark:scrollbar-thumb-secondary-dark scrollbar-track-surface-light dark:scrollbar-track-gray-800 scrollbar-thumb-rounded-full scrollbar-track-rounded-full;
  }

  /* --- Enhanced Prose Styles --- */
  .prose {
    @apply max-w-none text-text-light dark:text-text-dark;
  }
  .prose, .prose-sm {
    /* Headings */
    h1 { @apply text-2xl sm:text-3xl font-extrabold mb-6 mt-2 text-text-light dark:text-text-dark; }
    h2 { @apply text-xl sm:text-2xl font-bold mb-4 mt-8 border-b border-border-light dark:border-border-dark pb-2; }
    h3 { @apply text-lg sm:text-xl font-semibold mb-3 mt-6; }
    h4 { @apply text-base sm:text-lg font-semibold mb-2 mt-4; }

    /* Paragraphs */
    p { @apply mb-4 leading-relaxed; }

    /* Links */
    a { @apply text-primary dark:text-primary-light hover:underline font-medium; }
    pre a, pre code a { @apply text-inherit no-underline hover:text-inherit; }

    /* Lists */
    ul, ol { @apply pl-5 mb-4 space-y-1; }
    ul { @apply list-disc; }
    ol { @apply list-decimal; }
    li { @apply mb-1; }
    ul ul, ol ol, ul ol, ol ul { @apply pl-5 mt-1 mb-1; }
    li::marker { @apply text-text-muted-light dark:text-text-muted-dark; }

    /* --- GFM Task List Checkboxes - Custom GREEN Styling --- */
    li:has(> input[type="checkbox"]) {
      @apply flex items-center;
      list-style-type: none;
      margin-left: -1.25rem; /* Adjust as needed for alignment */
      padding-left: 0;
    }

    li > input[type="checkbox"] {
      @apply opacity-0 w-0 h-0 absolute;
    }

    li:has(> input[type="checkbox"])::before {
      content: "";
      @apply inline-block w-4 h-4 border-2 rounded-sm mr-2 align-middle flex-shrink-0;
      @apply bg-surface-light dark:bg-gray-700;
      @apply border-border-light dark:border-border-dark;
      transition: all 0.15s ease-in-out;
    }

    li:has(> input[type="checkbox"]:checked)::before {
      @apply bg-green-500 dark:bg-green-600 border-green-500 dark:border-green-600;
      background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
      background-size: 70% 70%;
      background-position: center;
      background-repeat: no-repeat;
    }

    li:has(> input[type="checkbox"]:disabled:not(:checked))::before {
      @apply opacity-60 cursor-not-allowed;
      @apply bg-gray-100 dark:bg-gray-600 border-gray-300 dark:border-gray-500;
    }

    li:has(> input[type="checkbox"]:checked:disabled)::before {
      @apply bg-green-500/70 dark:bg-green-600/70 border-green-500/70 dark:border-green-600/70;
      opacity: 0.75;
      cursor: not-allowed;
    }


    /* Blockquotes */
    blockquote {
      @apply border-l-4 border-primary dark:border-primary-light pl-4 py-2 my-4 italic text-text-muted-light dark:text-text-muted-dark bg-surface-light dark:bg-gray-800/30 rounded-r-md;
    }
    blockquote p { @apply mb-0; }

    /* Horizontal Rules */
    hr { @apply my-8 border-t border-border-light dark:border-border-dark; }

    /* Tables */
    table { @apply w-full my-6 text-sm border-collapse; }
    thead { @apply border-b-2 border-border-light dark:border-border-dark; }
    th {
      @apply px-4 py-2.5 text-left font-semibold text-text-light dark:text-text-dark bg-gray-100 dark:bg-gray-700/50;
      @apply border border-border-light dark:border-border-dark;
    }
    tbody tr { @apply border-b border-border-light dark:border-border-dark; }
    tbody tr:last-child { @apply border-b-0; }
    tbody tr:nth-child(even) { @apply bg-gray-50 dark:bg-gray-800/20; }
    td { @apply px-4 py-2.5 text-left border-x border-border-light dark:border-border-dark; }
    td code { @apply text-xs; }
    td strong { @apply font-semibold; }

    /* --- Code Styling --- */
    code:not(pre code) {
      @apply px-1.5 py-0.5 bg-primary/10 dark:bg-primary-dark/20 text-primary dark:text-primary-light rounded-md text-xs font-mono break-words;
    }
    code:not(pre code)::before, code:not(pre code)::after { content: ''; }

    pre {
      @apply bg-[#282c34] dark:bg-[#21252b] p-4 rounded-lg shadow-md overflow-x-auto custom-scrollbar my-5;
    }
    pre code {
      @apply bg-transparent p-0 font-mono text-sm leading-relaxed;
      color: #abb2bf;
      white-space: pre-wrap;
      word-break: break-all;
    }

    strong { @apply font-semibold text-text-light dark:text-text-dark; }
  }
}

@layer components {
  /* ... your existing btn, input-field, form-checkbox, card styles ... */
  /* The li:has(> input[type="checkbox"]) from your paste was misplaced, it should be within .prose */

  /* I will keep your existing .form-checkbox rules here as they might be used by other non-prose forms */
  .btn {
    @apply font-semibold py-2 px-4 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-opacity-75 transition-all duration-150 ease-in-out flex items-center justify-center gap-2 disabled:opacity-60 disabled:cursor-not-allowed;
  }
  html.dark .btn { @apply focus:ring-offset-background-dark; }
  html:not(.dark) .btn { @apply focus:ring-offset-background-light; }

  .btn-primary { @apply btn bg-primary text-white hover:bg-primary-dark focus:ring-primary; }
  .btn-secondary { @apply btn bg-secondary text-white hover:bg-secondary-dark focus:ring-secondary; }
  .btn-ghost { @apply btn text-text-muted-light dark:text-text-muted-dark hover:bg-gray-500 hover:bg-opacity-10 focus:ring-primary; }

  .input-field {
    @apply block w-full px-3 py-2 bg-surface-light dark:bg-gray-700 border border-border-light dark:border-border-dark rounded-md text-sm shadow-sm placeholder-text-muted-light dark:placeholder-text-muted-dark
           focus:outline-none focus:border-primary dark:focus:border-primary-light focus:ring-1 focus:ring-primary dark:focus:ring-primary-light;
  }
  .form-input, .form-textarea, .form-select, .form-multiselect { @apply input-field; }

  .form-checkbox, .form-radio {
    @apply rounded shadow-sm border-border-light dark:border-border-dark text-primary focus:ring-primary dark:focus:ring-primary-light;
    @apply bg-surface-light dark:bg-gray-600;
  }
  .form-checkbox:disabled, .form-radio:disabled {
    @apply opacity-70 bg-gray-200 dark:bg-gray-700 border-gray-300 dark:border-gray-600;
  }

  .card-base {
    @apply border rounded-panel shadow-panel;
    @apply bg-surface-light dark:bg-surface-dark border-border-light dark:border-border-dark;
  }
  .card-header-base {
    @apply px-4 py-3 text-sm font-semibold border-b;
    @apply text-text-light dark:text-text-dark border-border-light dark:border-border-dark;
  }
}
```

`src/main.jsx`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import { AuthProvider } from './contexts/AuthContext.jsx'; // For regular users
import { AppStateProvider } from './contexts/AppStateContext.jsx';
import { Toaster } from 'react-hot-toast';
import './index.css';

import 'prismjs/themes/prism-okaidia.css';
import 'katex/dist/katex.min.css';
import Prism from 'prismjs'; 
import 'prismjs/components/prism-python';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-jsx';
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-markup'; 
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-bash';
import 'prismjs/components/prism-csharp';
import 'prismjs/components/prism-java';


ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <AppStateProvider>
        <AppWrapper />
      </AppStateProvider>
    </AuthProvider>
  </React.StrictMode>,
);
```

`src/services/adminApi.js`

```javascript
// frontend/src/services/adminApi.js
import axios from 'axios';

// Get base URL for admin document endpoints
const ADMIN_DOCS_API_BASE_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:5001/api'}/admin/documents`;

// Get fixed admin credentials from .env (prefixed with VITE_ for frontend access)
const ADMIN_USERNAME_FRONTEND = import.meta.env.VITE_ADMIN_USERNAME || 'admin';
const ADMIN_PASSWORD_FRONTEND = import.meta.env.VITE_ADMIN_PASSWORD || 'admin123';

const adminApiClient = axios.create({
    baseURL: ADMIN_DOCS_API_BASE_URL,
});

// Helper function to generate the Basic Authentication header for the fixed admin
export const getFixedAdminAuthHeaders = () => {
    if (!ADMIN_USERNAME_FRONTEND || !ADMIN_PASSWORD_FRONTEND) {
        console.error("Admin credentials not found in VITE_ADMIN_USERNAME or VITE_ADMIN_PASSWORD .env variables for frontend.");
        // Fallback or throw error - for now, return empty, API call will likely fail 401
        return {}; 
    }
    const basicAuthToken = btoa(`${ADMIN_USERNAME_FRONTEND}:${ADMIN_PASSWORD_FRONTEND}`);
    return { 'Authorization': `Basic ${basicAuthToken}` };
};

// Generic function to make an authenticated admin API request
const makeAdminApiRequest = async (method, endpoint, data = null, authHeaders = {}) => {
    // `authHeaders` here is expected to be the output of `getFixedAdminAuthHeaders()`
    if (!authHeaders.Authorization) {
        // This check is important if getFixedAdminAuthHeaders might return empty due to missing .env vars
        const errorMsg = "Admin authentication headers are missing. Cannot make admin API request.";
        console.error(errorMsg);
        throw new Error(errorMsg);
    }
    try {
        const config = {
            method,
            url: endpoint, // endpoint is relative to ADMIN_DOCS_API_BASE_URL
            headers: {
                ...authHeaders, // Contains 'Authorization: Basic ...'
                'Content-Type': data instanceof FormData ? 'multipart/form-data' : 'application/json',
            },
        };
        if (data) {
            config.data = data;
        }
        const response = await adminApiClient(config);
        return response.data;
    } catch (error) {
        // Construct a more informative error message
        let errorMessage = 'Admin API request failed.';
        if (error.response) {
            // The request was made and the server responded with a status code
            // that falls out of the range of 2xx
            errorMessage = error.response.data?.message || error.response.statusText || `Server error: ${error.response.status}`;
            console.error(`Admin API Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}): Status ${error.response.status}`, error.response.data);
        } else if (error.request) {
            // The request was made but no response was received
            errorMessage = 'No response from admin API server. Check network or server status.';
            console.error(`Admin API Network Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}):`, error.request);
        } else {
            // Something happened in setting up the request that triggered an Error
            errorMessage = error.message || 'Error setting up admin API request.';
            console.error(`Admin API Setup Error (${method.toUpperCase()} ${ADMIN_DOCS_API_BASE_URL}${endpoint}):`, error.message);
        }
        throw new Error(errorMessage); // Throw a new error with the processed message
    }
};

// Specific API functions
export const uploadAdminDocument = async (formData, adminAuthHeaders) => {
    // Backend expects: { message, filename, originalname } on 202 Accepted
    return makeAdminApiRequest('post', '/upload', formData, adminAuthHeaders);
};

export const getAdminDocuments = async (adminAuthHeaders) => {
    // Backend expects: { documents: [{ originalName, serverFilename, uploadedAt, ... }] }
    return makeAdminApiRequest('get', '/', null, adminAuthHeaders);
};

export const deleteAdminDocument = async (serverFilename, adminAuthHeaders) => {
    // Backend expects: { message }
    return makeAdminApiRequest('delete', `/${serverFilename}`, null, adminAuthHeaders);
};

export const getAdminDocumentAnalysis = async (serverFilename, adminAuthHeaders) => {
    // Backend expects: { originalName, analysis: {faq, topics, mindmap}, analysisUpdatedAt }
    return makeAdminApiRequest('get', `/${serverFilename}/analysis`, null, adminAuthHeaders);
};
```

`src/services/api.js`

```javascript
// frontend/src/services/api.js
import axios from "axios";
import toast from "react-hot-toast";

// --- CENTRAL CONTROL FLAG FOR MOCKING ---
const DEV_MODE_MOCK_API = false; // <--- SET THIS TO false

// --- Axios API Client (for real backend calls) ---
const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || "http://localhost:5001/api",
});





// Axios Request Interceptor to add JWT token
apiClient.interceptors.request.use( 
  (config) => {
    const token = localStorage.getItem("authToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Axios Response Interceptor to handle common errors (e.g., 401)
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      console.error("API Interceptor: Received 401 Unauthorized. Token might be invalid or expired.");
      // The AuthContext will handle the actual logout logic and UI update.
      // We can dispatch a custom event that AuthContext can listen for,
      // or AuthContext can catch the error from the API call directly.
      // For simplicity, AuthContext will catch the error from the API call.
      // localStorage.removeItem('authToken'); // AuthContext will handle this.
    }
    return Promise.reject(error);
  }
);


  // Helper function to parse thinking tags from content
function parseAnalysisOutput(rawOutput) {
    if (!rawOutput || typeof rawOutput !== 'string') {
        return { content: '', thinking: '' };
    }
    const thinkingMatch = rawOutput.match(/<thinking>([\s\S]*?)<\/thinking>/i);
    let thinkingText = '';
    let mainContent = rawOutput;

    if (thinkingMatch && thinkingMatch[1]) {
        thinkingText = thinkingMatch[1].trim();
        // Remove the thinking block (and any leading/trailing newlines around it) from the main content
        mainContent = rawOutput.replace(/<thinking>[\s\S]*?<\/thinking>\s*/i, '').trim();
    }
    return { content: mainContent, thinking: thinkingText };
}

// --- API Definition Object ---
const api = {

  // --- Helper to fetch stored analysis (can be internal to this module) ---
  _getStoredDocumentAnalysis: async (documentFilename) => {
    try {
      // This GET request fetches the whole analysis object { faq, topics, mindmap }
      const response = await apiClient.get(`/analysis/${encodeURIComponent(documentFilename)}`);
      return response.data;
    } catch (error) {
      if (error.response && error.response.status === 404) {
        console.info(`No stored analysis found for document: ${documentFilename}`);
        return null; // Return null if no analysis record exists for the document
      }
      console.error(`Error fetching stored analysis for ${documentFilename}:`, error);
      throw error; // Re-throw other errors to be handled by the caller
    }
  },

  // --- Unified and Intelligent requestAnalysis function ---
  // This function is called by AnalysisTool.jsx's "Run" button.
  requestAnalysis: async (payload) => {
    const { filename, analysis_type } = payload;

    if (!filename || !analysis_type) {
      toast.error("Filename and analysis type are required.");
      throw new Error("Filename and analysis_type are required for requestAnalysis.");
    }

    const toastId = toast.loading(`Checking for stored ${analysis_type} for "${filename}"...`);

    try {
      const storedAnalysisData = await api._getStoredDocumentAnalysis(filename);

      if (storedAnalysisData &&
          storedAnalysisData[analysis_type] &&
          typeof storedAnalysisData[analysis_type] === 'string' &&
          storedAnalysisData[analysis_type].trim() !== "") {
        
        const { content: parsedContent, thinking: parsedThinking } = parseAnalysisOutput(storedAnalysisData[analysis_type]);
        
        toast.success(`Displaying stored ${analysis_type} for "${filename}".`, { id: toastId });
        return {
          content: parsedContent,
          thinking: parsedThinking || `Retrieved stored ${analysis_type} data. No specific thinking process recorded in content.`
        };
      } else {
        toast.dismiss(toastId);
        const generationToastId = toast.loading(`No stored ${analysis_type}. Generating new analysis for "${filename}"... (Mock V1)`);
        console.warn(`No valid stored ${analysis_type} found for "${filename}". Falling back to mock generation.`);

        // --- MOCK GENERATION LOGIC ---
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));

        let fullMockOutput = ""; // This will be the string as if LLM returned it, including <thinking> tags

        switch (analysis_type) {
          case 'faq':
            fullMockOutput = `<thinking>I will identify key details from the provided text about ${filename} to formulate 5-7 FAQs with concise answers directly from the text. My plan is to scan for questions, key statements, and rephrase them appropriately.</thinking>\n\nQ: What is this document about?\nA: This is mock FAQ content for ${filename}.\n\nQ: How is this generated?\nA: Through a mock API call when no stored data is found.`;
            break;
          case 'topics':
            fullMockOutput = `<thinking>I will identify the key topics in the provided biography of ${filename}. I will focus on the major events and themes highlighted in the narrative, ensuring each topic is explained concisely using only information from the text. I'll then list them with brief explanations.</thinking>\n\n### Mock Key Topics for ${filename}\n\n- Topic A: Mock Data Integration\n- Topic B: Placeholder Information\n- Topic C: ${analysis_type.toUpperCase()} specific to ${filename}`;
            break;
          case 'mindmap':
            fullMockOutput = `<thinking>Planning to generate a mind map structure for ${filename}. Will use Markdown list format focusing on hierarchical relationships found in the text.</thinking>\n\nmindmap\n  root((${filename} - Mock Mindmap))\n    Overview\n      Key Point 1\n      Key Point 2\n    Details\n      Specific Detail A\n      Specific Detail B`;
            break;
          default:
            fullMockOutput = `<thinking>No specific thinking process for unknown analysis type '${analysis_type}'.</thinking>\n\nMock content for an unknown analysis type '${analysis_type}' on ${filename}.`;
        }

        const { content: parsedMockContent, thinking: parsedMockThinking } = parseAnalysisOutput(fullMockOutput);

        toast.success(`${analysis_type} generated (mock data) for "${filename}".`, { id: generationToastId });
        return {
          content: parsedMockContent,
          thinking: parsedMockThinking || `Mock generation for ${analysis_type} on "${filename}".`
        };
        // --- END MOCK GENERATION LOGIC ---
      }
    } catch (error) {
      toast.error(`Error processing ${analysis_type} for "${filename}": ${error.message || 'Unknown error'}`, { id: toastId });
      console.error(`Error in requestAnalysis for ${filename} (${analysis_type}):`, error);
      return {
        content: `Error: Could not retrieve or generate ${analysis_type} for "${filename}".\n${error.message}`,
        thinking: "An error occurred during the analysis process."
      };
    }
  },

  
  // ------------------------------------------------- Auth --------------------------------------------------
 
  // Completed✅
  login: async (credentials) => {
    const response = await apiClient.post("/auth/signin", credentials);
    return response.data; // Expects { token, _id, username, sessionId, message }
  },

  // Completed✅
  signup: async (userData) => {
    const response = await apiClient.post("/auth/signup", userData);
    return response.data; // Expects { token, _id, username, sessionId, message }
  },

  // Completed✅
  getMe: async () => {
    const response = await apiClient.get("/auth/me");
    return response.data; // Expects { _id, username, ... }
  },

  // ------------------------------------------------ Chat -----------------------------------------------
  
  // Not completed yet❌
  sendMessage: async (payload) => {
    const response = await apiClient.post("/chat/message", payload);
    return response.data; // Expects { reply: { role, parts, timestamp, ... } }
  },

  // Not completed yet❌
  getChatHistory: async (sessionId) => {
    const response = await apiClient.get(`/chat/session/${sessionId}`);
    // Backend returns the full session object which includes { messages: [...] }
    return response.data.messages || []; 
  },

  // Not completed yet❌
  getChatSessions: async () => {
    const response = await apiClient.get("/chat/sessions");
    return response.data; // Expects array of session summaries
  },

  // Not completed yet❌
  startNewSession: async () => {
    // This call is to the backend's /api/chat/history to get a new session ID
    // when the user explicitly clicks "New Chat" and is already logged in.
    // The backend creates a new session placeholder if needed and returns a new UUID.
    const response = await apiClient.post("/chat/history", { 
        sessionId: `client-initiate-${Date.now()}`, // Temporary ID, backend replaces it
        messages: [] 
    });
    // Expects { message, savedSessionId (can be null), newSessionId }
    return { sessionId: response.data.newSessionId };
  },

  // Not completed yet❌
  saveChatHistory: async (sessionId, messages) => {
    const response = await apiClient.post("/chat/history", { sessionId, messages });
    return response.data; // Expects { message, savedSessionId, newSessionId }
  },

 
  // -------------------------------------------------- Files ------------------------------------------------------
  
  // Completed✅
  uploadFile: async (formData, onUploadProgress) => {
    const response = await apiClient.post("/upload", formData, {
      headers: { "Content-Type": "multipart/form-data" },
      onUploadProgress,
    });
    return response.data; // Expects { message, filename (serverFilename), originalname }
  },
  
  // Completed✅
  getFiles: async () => {
     
    const response = await apiClient.get("/files");
    console.log("Response from /files ; ", response.data);
    
    return response.data; // Expects array of file objects
  },

  // Completed✅
  deleteFile: async (serverFilename) => {
    const response = await apiClient.delete(`/files/${serverFilename}`);
    return response.data;
  },
  
  // -------------------------------------------- User LLM Config ---------------------------------------------------
  
  // Not completed yet❌-
  updateUserLLMConfig: async (configData) => {
    // For V2, if backend stores user LLM preferences:
    // const response = await apiClient.post('/user/config/llm', configData);
    // return response.data;
    console.warn("api.updateUserLLMConfig (frontend): Node.js backend doesn't have a dedicated user config endpoint yet. This is a local mock via api.js.");
    return new Promise(resolve => setTimeout(() => {
        localStorage.setItem("selectedLLM", configData.llmProvider); // Still update local for UI
        if (configData.apiKey) localStorage.setItem("mockGeminiApiKeyStatus", "set");
        if (configData.ollamaUrl) localStorage.setItem("mockOllamaUrl", configData.ollamaUrl);
        resolve({ message: `LLM preference for ${configData.llmProvider} noted (local mock via API layer).` });
    }, 100));
  },

  // Not completed yet❌
  getUserLLMConfig: async () => {
    // For V2, if backend stores user LLM preferences:
    // const response = await apiClient.get('/user/config/llm');
    // return response.data; // expects { llmProvider }
    console.warn("api.getUserLLMConfig (frontend): Node.js backend doesn't have a dedicated user config endpoint yet. Returning local default via api.js.");
    return new Promise(resolve => setTimeout(() => {
        resolve({ llmProvider: localStorage.getItem("selectedLLM") || "ollama" });
    }, 50));
  },


  // ----------------------------------------------- Status & Syllabus -------------------------------------------
  
  // Not completed yet❌
  getOrchestratorStatus: async () => {
    // For V2, Node.js backend could have its own /api/status endpoint.
    // For now, this simulates a status.
    console.warn("api.getOrchestratorStatus (frontend): Using a local mock via API layer for backend status.");
    return new Promise(resolve => setTimeout(() => {
        resolve({
            status: "ok",
            message: "Backend (Node.js - Mocked Status via Frontend API)",
            database_status: "Connected (Mock)",
        });
    }, 50));
    // Example real call:
    // const response = await apiClient.get('/status'); // Assuming /api/status on Node.js backend
    // return response.data;
  },

  // Not completed yet❌
  getSyllabus: async (subjectId) => {
    const response = await apiClient.get(`/syllabus/${subjectId}`);
    return response.data.syllabus; // Backend returns { syllabus: "markdown_content" }
  },

  // Not completed yet❌
  getMindmap: async () => {
    const response = await apiClient.get('/mindmap'); // Assumes /api/mindmap on backend
    return response.data; // Expects { mermaidCode: "...", source: "..." }
  }
};

export default api;


```

`src/utils/helpers.js`

```javascript
// Debounce function: Limits the rate at which a function can fire.

export const debounce = (func, delay) => {
    let timeoutId;
    return function(...args) {
        const context = this;
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(context, args), delay);
    };
};

// Throttle function: Ensures a function is called at most once in a specified time period.
export const throttle = (func, limit) => {
    let inThrottle;
    let lastFunc;
    let lastRan;
    return function(...args) {
        const context = this;
        if (!inThrottle) {
            func.apply(context, args);
            lastRan = Date.now();
            inThrottle = true;
            setTimeout(() => {
                inThrottle = false;
                if (lastFunc) {
                    lastFunc.apply(context, args); // Call with latest args if throttled
                    lastRan = Date.now();
                }
            }, limit);
        } else {
            lastFunc = func; // Store the latest call
        }
    };
};

// Simple function to format file size
export const formatFileSize = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

// Function to generate a simple unique ID (for client-side list keys, etc.)
export const generateUniqueId = (prefix = 'id') => {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

// Function to safely get nested property
export const getNestedValue = (obj, path, defaultValue = undefined) => {
    const value = path.split('.').reduce((acc, part) => acc && acc[part], obj);
    return value === undefined ? defaultValue : value;
};

// Basic HTML escape (can be more comprehensive)
export const escapeHtml = (unsafe) => {
    if (typeof unsafe !== 'string') return '';
    return unsafe
         .replace(/&/g, "&")
         .replace(/</g, "<")
         .replace(/>/g, ">")
         .replace(/"/g, '"')
         .replace(/'/g, "'");
};

// You can add more utility functions here as your project grows.
// For example, date formatting, string manipulation, etc.

// Example: Truncate text
export const truncateText = (text, maxLength = 100) => {
    if (!text || text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
};
```

`src/utils/markdownUtils.jsx`

```javascript
// src/utils/markdownUtils.jsx
import katex from 'katex';
import DOMPurify from 'dompurify';

const decodeHtmlEntities = (encodedString) => {
  if (typeof encodedString !== 'string') return encodedString;

  const textarea = document.createElement('textarea');
  textarea.innerHTML = encodedString;
  return textarea.value;
};

export const renderMathInHtml = (htmlString) => {
  if (!htmlString || typeof htmlString !== 'string') return htmlString;

  let processedString = htmlString;
  processedString = processedString.replace(/(?<!\\)\$\$([\s\S]+?)(?<!\\)\$\$/g, (match, rawExpression) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: true, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"} 
      });
      return DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } });
    } catch (e) { 
      console.warn(`KaTeX (display) error: ${e.message} for expression: ${expression}`); 
      return match; 
    }
  });

  processedString = processedString.replace(/(^|[^$\\])\$(?![\s$])([^$\n]+?)(?<![\s\\])\$([^\$]|$)/g, (fullMatch, prefix, rawExpression, suffix) => {
    const expression = decodeHtmlEntities(rawExpression.trim());
    if (!expression) return fullMatch; 
    try {
      const rendered = katex.renderToString(expression, { 
        displayMode: false, 
        throwOnError: false,
        macros: {"\\RR": "\\mathbb{R}"}
      });
      return prefix + DOMPurify.sanitize(rendered, { USE_PROFILES: { mathMl: true, svg: true, html: true } }) + suffix;
    } catch (e) { 
      console.warn(`KaTeX (inline) error: ${e.message} for expression: ${expression}`);
      return fullMatch; 
    }
  });
  
  return processedString;
};
```

`tailwind.config.js`

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        'primary': { light: '#60a5fa', DEFAULT: '#3b82f6', dark: '#2563eb' },
        'secondary': { light: '#9ca3af', DEFAULT: '#6b7280', dark: '#4b5563' },
        'accent': '#2dd4bf',
        'background-dark': '#0F172A', 'surface-dark': '#1E293B', 'border-dark': '#334155', 'text-dark': '#E2E8F0', 'text-muted-dark': '#94A3B8',
        'background-light': '#F8FAFC', 'surface-light': '#FFFFFF', 'border-light': '#E2E8F0', 'text-light': '#0F172A', 'text-muted-light': '#64748B',
      },
      fontFamily: {
        sans: ['"Inter var"', 'Inter', 'system-ui', 'sans-serif'],
      },
      boxShadow: {
        'main': '0 4px 15px -5px rgba(0,0,0,0.07), 0 2px 8px -6px rgba(0,0,0,0.07)',
        'panel': '0 8px 20px -5px rgba(0,0,0,0.1), 0 4px 10px -6px rgba(0,0,0,0.08)',
        'card-hover': '0 6px 18px -4px rgba(0,0,0,0.1), 0 3px 10px -5px rgba(0,0,0,0.1)',
      },
      borderRadius: { 'xl': '0.75rem', '2xl': '1rem', 'panel': '0.75rem' },
      keyframes: {
        fadeIn: { '0%': { opacity: '0', transform: 'translateY(5px)' }, '100%': { opacity: '1', transform: 'translateY(0px)' } },
        slideUp: { '0%': { transform: 'translateY(10px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } },
        pulseDots: {
          '0%, 100%': { opacity: '0.3', transform: 'scale(0.8)' },
          '50%': { opacity: '1', transform: 'scale(1)' },
        }
      },
      animation: {
        fadeIn: 'fadeIn 0.3s ease-out forwards',
        slideUp: 'slideUp 0.4s ease-out forwards',
        pulseDot1: 'pulseDots 1.4s infinite 0s ease-in-out',
        pulseDot2: 'pulseDots 1.4s infinite 0.2s ease-in-out',
        pulseDot3: 'pulseDots 1.4s infinite 0.4s ease-in-out',
      }
    },
  },
  plugins: [
    require('@tailwindcss/forms')({ strategy: 'class' }),
    require('tailwind-scrollbar')({ nocompatible: true }),
    require('@tailwindcss/typography'),
  ],
}
```

`vite.config.js`

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

```

